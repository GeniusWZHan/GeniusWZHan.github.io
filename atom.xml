<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戒修-沉迷技术的小沙弥</title>
  <subtitle>我喜欢GO</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leokongwq.github.io/"/>
  <updated>2018-03-07T16:04:30.000Z</updated>
  <id>https://leokongwq.github.io/</id>
  
  <author>
    <name>kongwenqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring扩展点及springboot自动配置总结</title>
    <link href="https://leokongwq.github.io/2018/03/06/spring-extension-point-autoconfig-summary.html"/>
    <id>https://leokongwq.github.io/2018/03/06/spring-extension-point-autoconfig-summary.html</id>
    <published>2018-03-06T14:57:35.000Z</published>
    <updated>2018-03-07T16:04:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring扩展点和自动配置"><a href="#spring扩展点和自动配置" class="headerlink" title="spring扩展点和自动配置"></a>spring扩展点和自动配置</h2><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span>
<span class="line">  </span>
<span class="line">    <span class="comment">/** </span>
<span class="line">     * Modify the application context's internal bean factory after its standard </span>
<span class="line">     * initialization. All bean definitions will have been loaded, but no beans </span>
<span class="line">     * will have been instantiated yet. This allows for overriding or adding </span>
<span class="line">     * properties even to eager-initializing beans. </span>
<span class="line">     * <span class="doctag">@param</span> beanFactory the bean factory used by the application context </span>
<span class="line">     * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors </span>
<span class="line">     */</span>  </span>
<span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;  </span>
<span class="line">  </span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>通过该扩展点，我们修改，新增<code>BeanDefinition</code>。因为此时所有的<code>BeanDefinition</code>已经加载，但是没有Bean被创建。一般用在需要覆盖或替换Bean的属性时。</p>
<a id="more"></a>
<p>spring中，有内置的一些BeanFactoryPostProcessor实现类，常用的有：</p>
<ul>
<li>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</li>
<li>org.springframework.beans.factory.config.PropertyOverrideConfigurer</li>
<li>org.springframework.beans.factory.config.CustomEditorConfigurer：用来注册自定义的属性编辑器</li>
</ul>
<h3 id="BeanFactoryPostProcessor-1"><a href="#BeanFactoryPostProcessor-1" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span>
<span class="line"> * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span>
<span class="line"> * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span>
<span class="line"> * or a custom init-method). The bean will already be populated with property values.</span>
<span class="line"> * The returned bean instance may be a wrapper around the original.</span>
<span class="line"> * <span class="doctag">@param</span> bean the new bean instance</span>
<span class="line"> * <span class="doctag">@param</span> beanName the name of the bean</span>
<span class="line"> * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span>
<span class="line"> * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span>
<span class="line"> * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span>
<span class="line"> * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span>
<span class="line"> */</span></span>
<span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span>
<span class="line"> * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span>
<span class="line"> * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span>
<span class="line"> * or a custom init-method). The bean will already be populated with property values.</span>
<span class="line"> * The returned bean instance may be a wrapper around the original.</span>
<span class="line"> * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span>
<span class="line"> * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span>
<span class="line"> * post-processor can decide whether to apply to either the FactoryBean or created</span>
<span class="line"> * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span>
<span class="line"> * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span>
<span class="line"> * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span>
<span class="line"> * in contrast to all other BeanPostProcessor callbacks.</span>
<span class="line"> * <span class="doctag">@param</span> bean the new bean instance</span>
<span class="line"> * <span class="doctag">@param</span> beanName the name of the bean</span>
<span class="line"> * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span>
<span class="line"> * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span>
<span class="line"> * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span>
<span class="line"> * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span>
<span class="line"> * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span>
<span class="line"> */</span></span>
<span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>该扩展点提供了两个方法：</p>
<ol>
<li>是在Bean新创建后，未初始化前调用的。例如在<code>InitializingBean</code>的<code>afterPropertiesSet</code>前，或则自定义的<code>init-method</code>前。</li>
<li>在Bean初始化后，调用方法<code>postProcessAfterInitialization</code>。</li>
</ol>
<p>spring中，有内置的一些BeanPostProcessor实现类，例如：</p>
<ul>
<li>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor：支持@Resource注解的注入</li>
<li>org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor：支持@Required注解的注入</li>
<li>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor：支持@Autowired注解的注入</li>
<li>org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor：支持@PersistenceUnit和@PersistenceContext注解的注入</li>
<li>org.springframework.context.support.ApplicationContextAwareProcessor：用来为bean注入ApplicationContext等容器对象</li>
</ul>
<p>spring提供的这些Bean都可以通过<code>&lt;context:annotation-config/&gt;</code> 来自动进行配置。</p>
<p>不过我们一般都会配置包扫描：<code>&lt;context:component-scan base-package=”xx.yy.zz”/&gt;</code>，该配置已经包含了:<code>&lt;context:annotation-config/&gt;</code>。</p>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><blockquote>
<p>Indicates that a class declares one or more {@link Bean @Bean} methods and<br>  may be processed by the Spring container to generate bean definitions and<br>  service requests for those beans at runtime, for example:</p>
</blockquote>
<p><code>@Configuration</code>是spring3.0引入的新注解。该注解主要用来为spring容器提供<code>BeanDefinition</code>和在运行时提供其它Bean所需要的Bean。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Inject</span></span>
<span class="line">    <span class="keyword">private</span> DataSource dataSource;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Bean</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">myBean</span><span class="params">()</span> </span>&#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean(dataSource);</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Configuration</span></span>
<span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfig</span> </span>&#123;</span>
<span class="line">        <span class="meta">@Bean</span></span>
<span class="line">        <span class="function">DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder().build();</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h2 id="springboot自动配置"><a href="#springboot自动配置" class="headerlink" title="springboot自动配置"></a>springboot自动配置</h2><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>要想使用springboot提供的自动配置功能，必须在你工程的启动主类上添加注解<code>@EnableAutoConfiguration</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="meta">@Inherited</span></span>
<span class="line"><span class="meta">@AutoConfigurationPackage</span></span>
<span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span>
<span class="line"></span>
<span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Exclude specific auto-configuration classes such that they will never be applied.</span>
<span class="line">	 * <span class="doctag">@return</span> the classes to exclude</span>
<span class="line">	 */</span></span>
<span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Exclude specific auto-configuration class names such that they will never be</span>
<span class="line">	 * applied.</span>
<span class="line">	 * <span class="doctag">@return</span> the class names to exclude</span>
<span class="line">	 * <span class="doctag">@since</span> 1.3.0</span>
<span class="line">	 */</span></span>
<span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>这个注解的功能概况如下：</p>
<ol>
<li>自动配置基于应用的<code>classpath</code>以及你定义了什么Beans</li>
<li>可以通过设置注解的<code>excludeName</code>属性或者通过<code>spring.autoconfigure.exclude</code>配置项来指定不需要自动配置的项目。</li>
<li>自动配置的发生时机在用户定义的Beans被注册之后</li>
<li>最好将<code>@EnableAutoConfiguration</code>注解放在<code>root package</code>的类上，这样就能够搜索到所有子<code>packages</code>中的类了</li>
<li>自动配置类就是普通的Spring <code>@Configuration</code>类，通过<code>SpringFactoriesLoader</code>机制完成加载，实现上通常使用@Conditional(比如<code>@ConditionalOnClass</code>或者<code>@ConditionalOnMissingBean</code>)</li>
</ol>
<p>不过在较新的springboot版本，可以直接使用注解<code>@SpringBootApplication</code>，原因如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="meta">@Inherited</span></span>
<span class="line"><span class="meta">@SpringBootConfiguration</span></span>
<span class="line"><span class="meta">@EnableAutoConfiguration</span></span>
<span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class))</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p><code>@SpringBootApplication</code>已经包含了<code>@EnableAutoConfiguration</code>。</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * <span class="doctag">@author</span> Chris Beams</span>
<span class="line"> * <span class="doctag">@author</span> Juergen Hoeller</span>
<span class="line"> * <span class="doctag">@since</span> 3.0</span>
<span class="line"> * <span class="doctag">@see</span> Configuration</span>
<span class="line"> * <span class="doctag">@see</span> ImportSelector</span>
<span class="line"> * <span class="doctag">@see</span> ImportResource</span>
<span class="line"> */</span></span>
<span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Import &#123;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span>
<span class="line">	 * or regular component classes to import.</span>
<span class="line">	 */</span></span>
<span class="line">	Class&lt;?&gt;[] value();</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p><code>@Import</code>注解的功能如下：</p>
<ol>
<li>该注解的功能和spring xml配置文件中的<code>&lt;import/&gt;</code>标签相同。</li>
<li>可以用来导入的类有<code>@Configuration</code>,<code>@ImportSelector</code>,<code>@ImportBeanDefinitionRegistrar</code></li>
<li>要访问通过<code>@Import</code>导入的，定义在<code>@Configuration</code>中的类，应该通过<code>@Autowired</code>进行注入。</li>
</ol>
<h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * <span class="doctag">@author</span> Chris Beams</span>
<span class="line"> * <span class="doctag">@author</span> Juergen Hoeller</span>
<span class="line"> * <span class="doctag">@author</span> Sam Brannen</span>
<span class="line"> * <span class="doctag">@since</span> 3.0</span>
<span class="line"> * <span class="doctag">@see</span> Configuration</span>
<span class="line"> * <span class="doctag">@see</span> Import</span>
<span class="line"> */</span></span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ImportResource &#123;</span>
<span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"locations"</span>)</span>
<span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line">    </span>
<span class="line">    <span class="comment">/**</span>
<span class="line">	 * Resource locations from which to import.</span>
<span class="line">	 * &lt;p&gt;Supports resource-loading prefixes such as &#123;<span class="doctag">@code</span> classpath:&#125;,</span>
<span class="line">	 * &#123;<span class="doctag">@code</span> file:&#125;, etc.</span>
<span class="line">	 * &lt;p&gt;Consult the Javadoc for &#123;<span class="doctag">@link</span> #reader&#125; for details on how resources</span>
<span class="line">	 * will be processed.</span>
<span class="line">	 * <span class="doctag">@since</span> 4.2</span>
<span class="line">	 * <span class="doctag">@see</span> #value</span>
<span class="line">	 * <span class="doctag">@see</span> #reader</span>
<span class="line">	 */</span></span>
<span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span>
<span class="line"> 	 String[] locations() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line"> 	 </span>
<span class="line"> 	 Class&lt;? extends BeanDefinitionReader&gt; reader() <span class="keyword">default</span> BeanDefinitionReader.class;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>用来导入资源一个或多个包含<code>bean definitions</code>的资源文件。如果资源文件以<code>.groovy</code>结尾，那么就使用<code>GroovyBeanDefinitionReader</code>，否则使用<code>XmlBeanDefinitionReader</code>进行解析。</p>
<h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="meta">@Inherited</span></span>
<span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar.class)</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span>
<span class="line">    <span class="comment">/**</span>
<span class="line">	 * &#123;<span class="doctag">@link</span> Configuration&#125;, &#123;<span class="doctag">@link</span> ImportSelector&#125;, &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125;</span>
<span class="line">	 * or regular component classes to import.</span>
<span class="line">	 */</span></span>
<span class="line">	Class&lt;?&gt;[] value();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>该注解类的作用就是告诉spring:打了该注解类所在的包下面的被注解类，需要被<code>AutoConfigurationPackages</code>类进行注册。具体的实现原理可以参考第四小节提到的Bean动态注册，关于<code>ImportBeanDefinitionRegistrar</code>的解释。</p>
<h4 id="Import-EnableAutoConfigurationImportSelector-class"><a href="#Import-EnableAutoConfigurationImportSelector-class" class="headerlink" title="@Import(EnableAutoConfigurationImportSelector.class)"></a>@Import(EnableAutoConfigurationImportSelector.class)</h4><p><code>@EnableAutoConfiguration</code>注解的另外一个作用就是引入了<code>EnableAutoConfigurationImportSelector</code></p>
<p>它的类图如下所示：</p>
<img src="/2018/03/06/spring-extension-point-autoconfig-summary/EnableAutoConfigurationImportSelector.png" alt="EnableAutoConfigurationImportSelector.png" title="">
<p>可以发现它除了实现几个Aware类接口外，最关键的就是实现了<code>DeferredImportSelector</code>(继承自<code>ImportSelector</code>)接口。</p>
<p>所以我们先来看看<code>ImportSelector</code>以及<code>DeferredImportSelector</code>接口的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span>
<span class="line">     * 基于被引入的Configuration类的AnnotationMetadata信息选择并返回需要引入的类名列表</span>
<span class="line">     */</span></span>
<span class="line">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>这个接口的Javadoc比较长，还是捡重点说明一下：</p>
<ol>
<li>功能通过<code>selectImports</code>方法实现，用于筛选可以<code>@Import</code>进的<code>@Configuration</code>配置类。</li>
<li>实现了<code>ImportSelector</code>接口的类也可以实现一系列<code>Aware</code>接口，这些<code>Aware</code>接口中的相应方法会在<code>selectImports</code>方法之前被调用(这一点通过上面的类图也可以佐证，<code>EnableAutoConfigurationImportSelector</code>确实实现了四个Aware类型的接口)</li>
<li><code>ImportSelector</code>的实现和通常的<code>@Import</code>在处理方式上是一致的，然而还是可以在所有<code>@Configuration</code>类都被处理后再进行引入筛选(具体看下面即将介绍的<code>@DeferredImportSelector</code>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line">* A variation of &#123;<span class="doctag">@link</span> ImportSelector&#125; that runs after all &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; beans</span>
<span class="line">* have been processed. This type of selector can be particularly useful when the selected</span>
<span class="line">* imports are &#123;<span class="doctag">@code</span> <span class="doctag">@Conditional</span>&#125;.</span>
<span class="line">/</span>
<span class="line">public interface DeferredImportSelector extends ImportSelector &#123;</span>
<span class="line">&#125;</span></span>
</pre></td></tr></table></figure>
<p>这个接口是一个标记接口，它本身没有定义任何方法。那么这个接口的含义是什么呢：</p>
<p>它是<code>ImportSelector</code>接口的一个变体，在所有的<code>@Configuration</code>被处理之后才会执行。在需要筛选的引入类型具备<code>@Conditional</code>注解的时候非常有用实现类同样也可以实现<code>Ordered</code>接口，来定义多个<code>DeferredImportSelector</code>的优先级别(当然了，也可以使用注解<code>@Order</code>)</p>
<p>下面来看看是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span>
<span class="line">    <span class="comment">//可以通过配置`spring.boot.enableautoconfiguration`来关闭该功能，默认是true</span></span>
<span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span>
<span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">      <span class="comment">// Step1: 得到注解信息</span></span>
<span class="line">        AutoConfigurationMetadata autoConfigurationMetadata =   AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span>
<span class="line">        <span class="comment">// Step2: 得到注解中的所有属性信息</span></span>
<span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span>
<span class="line">        <span class="comment">// Step3: 得到候选配置列表</span></span>
<span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span>
<span class="line">                attributes);</span>
<span class="line">        <span class="comment">// Step4: 去重</span></span>
<span class="line">        configurations = removeDuplicates(configurations);</span>
<span class="line">        <span class="comment">// Step5: 排序</span></span>
<span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span>
<span class="line">        <span class="comment">// Step6: 根据注解中的exclude信息去除不需要的</span></span>
<span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span>
<span class="line">        checkExcludedClasses(configurations, exclusions);</span>
<span class="line">        configurations.removeAll(exclusions);</span>
<span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span>
<span class="line">        <span class="comment">// Step7: 派发事件</span></span>
<span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span>
<span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span>
<span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>注解<code>@EnableAutoConfiguration</code>一般加在应用的启动主类上，并且提供了两个配置属性:<code>exclude</code>和<code>excludeName</code>来指定排除那些配置类。</p>
<p>所以上面代码中的<code>attributes</code>变量的值其实就是注解<code>@EnableAutoConfiguration</code>的配置属性</p>
<p>核心就在于上面的步骤3：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span>
<span class="line">        AnnotationAttributes attributes)</span> </span>&#123;</span>
<span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span>
<span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span>
<span class="line">    Assert.notEmpty(configurations,</span>
<span class="line">            <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span>
<span class="line">                    + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span>
<span class="line">    <span class="keyword">return</span> configurations;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>它将实现委托给了<code>SpringFactoriesLoader</code>的<code>loadFactoryNames</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入的factoryClass：org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span>
<span class="line">    String factoryClassName = factoryClass.getName();</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span>
<span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span>
<span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span>
<span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span>
<span class="line">            URL url = urls.nextElement();</span>
<span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span>
<span class="line">            String factoryClassNames = properties.getProperty(factoryClassName);</span>
<span class="line">            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span>
<span class="line">        &#125;</span>
<span class="line">        <span class="keyword">return</span> result;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span>
<span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() +</span>
<span class="line">                <span class="string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="comment">// 相关常量</span></span>
<span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span>
</pre></td></tr></table></figure>
<p>这段代码的意图很明确，它会从类路径中拿到所有名为<code>META-INF/spring.factories</code>的配置文件，然后按照<code>factoryClass</code>的名称取到对应的值。那么我们就来找一个<code>META-INF/spring.factories</code>配置文件看看.</p>
<h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p>比如spring-boot-autoconfigure包：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line"># Auto Configure</span>
<span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span>
<span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span>
<span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span>
<span class="line"># 省略了很多</span>
</pre></td></tr></table></figure>
<blockquote>
<p>如果需要禁用某些自动配置功能， 可以通过配置<code>@EnableAutoConfiguration</code>的<code>exclude</code>属性。</p>
</blockquote>
<p>上面的文件列举了非常多的自动配置候选项，挑一个AOP相关的<code>AopAutoConfiguration</code>看看究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果设置了spring.aop.auto=false，那么AOP不会被配置</span></span>
<span class="line"><span class="comment">// 需要检测到@EnableAspectJAutoProxy注解存在才会生效</span></span>
<span class="line"><span class="comment">// 默认使用JdkDynamicAutoProxyConfiguration，如果设置了spring.aop.proxy-target-class=true，那么使用CglibAutoProxyConfiguration</span></span>
<span class="line"><span class="meta">@Configuration</span></span>
<span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; EnableAspectJAutoProxy.class, Aspect.class, Advice.class &#125;)</span>
<span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Configuration</span></span>
<span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span>
<span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>, matchIfMissing = <span class="keyword">true</span>)</span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line"></span>
<span class="line">    <span class="meta">@Configuration</span></span>
<span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span>
<span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">false</span>)</span>
<span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>这个自动配置类的作用是判断是否存在配置项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">spring.aop.proxy-target-class=true</span>
</pre></td></tr></table></figure>
<p>如果存在并且值为<code>true</code>的话使用基于<code>CGLIB</code>字节码操作的动态代理方案，否则使用JDK自带的动态代理机制。</p>
<p>在这个配置类中，使用到了两个全新的注解：</p>
<ul>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnProperty</li>
</ul>
<p>从这两个注解的名称，就大概能够猜出它们的功能了：</p>
<h3 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h3><p>当类路径上存在指定的类时，满足条件。</p>
<h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h3><p>当配置中存在指定的属性时，满足条件。</p>
<p>其实除了这两个注解之外，还有几个类似的，它们都在<code>org.springframework.boot.autoconfigure.condition</code>这个包下，在具体介绍实现之前，下面先来看看Spring Boot对于<code>@Conditional</code>的扩展。</p>
<h3 id="Spring-Boot对于-Conditional的扩展"><a href="#Spring-Boot对于-Conditional的扩展" class="headerlink" title="Spring Boot对于@Conditional的扩展"></a>Spring Boot对于@Conditional的扩展</h3><p>Spring Boot提供了一个实现了<code>Condition</code>接口的抽象类<code>SpringBootCondition</code>。</p>
<p>这个类的主要作用是打印一些用于诊断的日志，告诉用户哪些类型被自动配置了。</p>
<p>它实现<code>Condition</code>接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span>
<span class="line">        AnnotatedTypeMetadata metadata)</span> </span>&#123;</span>
<span class="line">    String classOrMethodName = getClassOrMethodName(metadata);</span>
<span class="line">    <span class="keyword">try</span> &#123;</span>
<span class="line">        ConditionOutcome outcome = getMatchOutcome(context, metadata);</span>
<span class="line">        logOutcome(classOrMethodName, outcome);</span>
<span class="line">        recordEvaluation(context, classOrMethodName, outcome);</span>
<span class="line">        <span class="keyword">return</span> outcome.isMatch();</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">catch</span> (NoClassDefFoundError ex) &#123;</span>
<span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span>
<span class="line">                <span class="string">"Could not evaluate condition on "</span> + classOrMethodName + <span class="string">" due to "</span></span>
<span class="line">                        + ex.getMessage() + <span class="string">" not "</span></span>
<span class="line">                        + <span class="string">"found. Make sure your own configuration does not rely on "</span></span>
<span class="line">                        + <span class="string">"that class. This can also happen if you are "</span></span>
<span class="line">                        + <span class="string">"@ComponentScanning a springframework package (e.g. if you "</span></span>
<span class="line">                        + <span class="string">"put a @ComponentScan in the default package by mistake)"</span>,</span>
<span class="line">                ex);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span>
<span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span>
<span class="line">                <span class="string">"Error processing condition on "</span> + getName(metadata), ex);</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
<span class="line"><span class="comment">/**</span>
<span class="line"> * Determine the outcome of the match along with suitable log output.</span>
<span class="line"> * <span class="doctag">@param</span> context the condition context</span>
<span class="line"> * <span class="doctag">@param</span> metadata the annotation metadata</span>
<span class="line"> * <span class="doctag">@return</span> the condition outcome</span>
<span class="line"> */</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span>
<span class="line">        AnnotatedTypeMetadata metadata)</span></span>;</span>
</pre></td></tr></table></figure>
<p>SpringBootCondition已经提供了基本的实现，将内部的匹配细节定义成抽象方法getMatchOutcome，交给其子类去完成。</p>
<p>另外，还提供了两个可能会被子类使用到的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * 如果指定的conditions中有任意一个匹配，那么就返回true</span>
<span class="line"> * <span class="doctag">@param</span> context the context</span>
<span class="line"> * <span class="doctag">@param</span> metadata the annotation meta-data</span>
<span class="line"> * <span class="doctag">@param</span> conditions conditions to test</span>
<span class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if any condition matches.</span>
<span class="line"> */</span></span>
<span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">anyMatches</span><span class="params">(ConditionContext context,</span>
<span class="line">        AnnotatedTypeMetadata metadata, Condition... conditions)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">for</span> (Condition condition : conditions) &#123;</span>
<span class="line">        <span class="keyword">if</span> (matches(context, metadata, condition)) &#123;</span>
<span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span>
<span class="line"> * 检查指定的condition是否匹配</span>
<span class="line"> * <span class="doctag">@param</span> context the context</span>
<span class="line"> * <span class="doctag">@param</span> metadata the annotation meta-data</span>
<span class="line"> * <span class="doctag">@param</span> condition condition to test</span>
<span class="line"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the condition matches.</span>
<span class="line"> */</span></span>
<span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context,</span>
<span class="line">        AnnotatedTypeMetadata metadata, Condition condition)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">if</span> (condition <span class="keyword">instanceof</span> SpringBootCondition) &#123;</span>
<span class="line">        <span class="keyword">return</span> ((SpringBootCondition) condition).getMatchOutcome(context, metadata)</span>
<span class="line">                .isMatch();</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">return</span> condition.matches(context, metadata);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="org-springframework-boot-autoconfigure-condition包"><a href="#org-springframework-boot-autoconfigure-condition包" class="headerlink" title="org.springframework.boot.autoconfigure.condition包"></a>org.springframework.boot.autoconfigure.condition包</h3><p>除了上面已经遇到的<code>@ConditionalOnClass</code>和<code>@ConditionalOnProperty</code>，这个包中还定义了很多条件实现类，下面简单列举几个：</p>
<h3 id="ConditionalOnExpression-基于SpEL的条件判断"><a href="#ConditionalOnExpression-基于SpEL的条件判断" class="headerlink" title="@ConditionalOnExpression - 基于SpEL的条件判断"></a>@ConditionalOnExpression - 基于SpEL的条件判断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * Configuration annotation for a conditional element that depends on the value of a SpEL</span>
<span class="line"> * expression.</span>
<span class="line"> *</span>
<span class="line"> * <span class="doctag">@author</span> Dave Syer</span>
<span class="line"> */</span></span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="meta">@Conditional</span>(OnExpressionCondition.class)</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnExpression &#123;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span>
<span class="line">     * The SpEL expression to evaluate. Expression should return &#123;<span class="doctag">@code</span> true&#125; if the</span>
<span class="line">     * condition passes or &#123;<span class="doctag">@code</span> false&#125; if it fails.</span>
<span class="line">     * <span class="doctag">@return</span> the SpEL expression</span>
<span class="line">     */</span></span>
<span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">true</span>"</span>;</span>
</pre></td></tr></table></figure>
<p>然后相应的实现类是<code>OnExpressionCondition</code>，它继承自<code>SpringBootCondition</code>。</p>
<h3 id="ConditionalOnMissingClass-基于类不存在与classpath的条件判断"><a href="#ConditionalOnMissingClass-基于类不存在与classpath的条件判断" class="headerlink" title="@ConditionalOnMissingClass - 基于类不存在与classpath的条件判断"></a>@ConditionalOnMissingClass - 基于类不存在与classpath的条件判断</h3><p>这一个条件实现正好和<code>@ConditionalOnClass</code>条件相反</p>
<p>下面列举所有由Spring Boot提供的条件注解：</p>
<ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnClass</li>
<li>@ConditionalOnCloudPlatform</li>
<li>@ConditionalOnExpression</li>
<li>@ConditionalOnJava</li>
<li>@ConditionalOnJndi</li>
<li>@ConditionalOnMissingBean</li>
<li>@ConditionalOnMissingClass</li>
<li>@ConditionalOnNotWebApplication</li>
<li>@ConditionalOnProperty</li>
<li>@ConditionalOnResource</li>
<li>@ConditionalOnSingleCandidate</li>
<li>@ConditionalOnWebApplication</li>
</ul>
<p>一般的模式，就是一个条件注解对应一个继承自SpringBootCondition的具体实现类。</p>
<h2 id="动态注册Bean"><a href="#动态注册Bean" class="headerlink" title="动态注册Bean"></a>动态注册Bean</h2><p>在某些特殊的场景下，我们需要动态的向spring的容器注册Bean。spring框架本身提供了一些机制来帮助我们来实现这些特殊的需求。</p>
<h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span>
<span class="line">    </span>
<span class="line">    <span class="comment">/**</span>
<span class="line">	 * Register a new bean definition with this registry.</span>
<span class="line">	 * Must support RootBeanDefinition and ChildBeanDefinition.</span>
<span class="line">	 * <span class="doctag">@param</span> beanName the name of the bean instance to register</span>
<span class="line">	 * <span class="doctag">@param</span> beanDefinition definition of the bean instance to register</span>
<span class="line">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException if the BeanDefinition is invalid</span>
<span class="line">	 * or if there is already a BeanDefinition for the specified bean name</span>
<span class="line">	 * (and we are not allowed to override it)</span>
<span class="line">	 * <span class="doctag">@see</span> RootBeanDefinition</span>
<span class="line">	 * <span class="doctag">@see</span> ChildBeanDefinition</span>
<span class="line">	 */</span></span>
<span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span>
<span class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>BeanDefinitionRegistry 扩展点允许我们来动态的想spring容器注册<code>BeanDefinition</code>。</p>
<h3 id="SingletonBeanRegistry"><a href="#SingletonBeanRegistry" class="headerlink" title="SingletonBeanRegistry"></a>SingletonBeanRegistry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span>
<span class="line">    <span class="comment">/**</span>
<span class="line">	 * Register the given existing object as singleton in the bean registry,</span>
<span class="line">	 * under the given bean name.</span>
<span class="line">	 * &lt;p&gt;The given instance is supposed to be fully initialized; the registry</span>
<span class="line">	 * will not perform any initialization callbacks (in particular, it won't</span>
<span class="line">	 * call InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125; method).</span>
<span class="line">	 * The given instance will not receive any destruction callbacks</span>
<span class="line">	 * (like DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125; method) either.</span>
<span class="line">	 * &lt;p&gt;When running within a full BeanFactory: &lt;b&gt;Register a bean definition</span>
<span class="line">	 * instead of an existing instance if your bean is supposed to receive</span>
<span class="line">	 * initialization and/or destruction callbacks.&lt;/b&gt;</span>
<span class="line">	 * &lt;p&gt;Typically invoked during registry configuration, but can also be used</span>
<span class="line">	 * for runtime registration of singletons. As a consequence, a registry</span>
<span class="line">	 * implementation should synchronize singleton access; it will have to do</span>
<span class="line">	 * this anyway if it supports a BeanFactory's lazy initialization of singletons.</span>
<span class="line">	 * <span class="doctag">@param</span> beanName the name of the bean</span>
<span class="line">	 * <span class="doctag">@param</span> singletonObject the existing singleton object</span>
<span class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span>
<span class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.DisposableBean#destroy</span>
<span class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.BeanDefinitionRegistry#registerBeanDefinition</span>
<span class="line">	 */</span></span>
<span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerSingleton</span><span class="params">(String beanName, Object singletonObject)</span></span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p><code>SingletonBeanRegistry</code>允许我们来直接向Spring容器注册Singleton的Bean实例。</p>
<p>两者区别在于使用前者时，Spring容器会根据BeanDefinition实例化bean实例，而使用后者时，bean实例就是传递给registerSingleton方法的对象。</p>
<p>DefaultListableBeanFactory接口同时实现了这两个接口，在实践中通常会使用这个接口。</p>
<h4 id="在普通bean中进行动态注册"><a href="#在普通bean中进行动态注册" class="headerlink" title="在普通bean中进行动态注册"></a>在普通bean中进行动态注册</h4><p>可以在任何获得了<code>BeanDefinitionRegistry</code>或者<code>SingletonBeanRegistry</code>实例的地方进行动态注册。</p>
<p>但是如果bean不是在<code>BeanFactoryPostProcessor</code>中被注册，那么该bean则无法被<strong>BeanPostProcessor</strong>处理，即无法对其应用aop、Bean Validation等功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
</pre></td><td class="code"><pre><span class="line">RestController</span>
<span class="line"><span class="meta">@Slf</span>4j</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonManagerRegisterController</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span>
<span class="line">     * The Application context.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="meta">@Autowired</span></span>
<span class="line">    GenericApplicationContext applicationContext;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span>
<span class="line">     * The Bean factory.</span>
<span class="line">     */</span></span>
<span class="line">    <span class="meta">@Autowired</span></span>
<span class="line">    ConfigurableBeanFactory beanFactory;</span>
<span class="line"></span>
<span class="line">    <span class="comment">/**</span>
<span class="line">     * 动态注册bean，此处注册的bean没有AOP的支持</span>
<span class="line">     * curl http://localhost:8080/registerPersonManager</span>
<span class="line">     */</span></span>
<span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/registerPersonManager"</span>)</span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerPersonManager</span><span class="params">()</span> </span>&#123;</span>
<span class="line">        PersonDao personDao = applicationContext.getBean(PersonDao.class);</span>
<span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span>
<span class="line">        personManager.setPersonDao(personDao);</span>
<span class="line">        beanFactory.registerSingleton(<span class="string">"personManager3"</span>, personManager);</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h4 id="在BeanFactoryPostProcessor中进行动态注册"><a href="#在BeanFactoryPostProcessor中进行动态注册" class="headerlink" title="在BeanFactoryPostProcessor中进行动态注册"></a>在<code>BeanFactoryPostProcessor</code>中进行动态注册</h4><p>在Spring容器的启动过程中，<code>BeanFactory</code>载入bean的定义后会立刻执行<code>BeanFactoryPostProcessor</code>，此时动态注册bean，则可以保证动态注册的bean被<code>BeanPostProcessor</code>处理，并且可以保证其的实例化和初始化总是先于依赖它的bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="meta">@Slf</span>4j</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span>
<span class="line">    </span>
<span class="line">    <span class="meta">@Override</span></span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span>
<span class="line">        DefaultListableBeanFactory defaultListableBeanFactory</span>
<span class="line">                = (DefaultListableBeanFactory) beanFactory;</span>
<span class="line"></span>
<span class="line">        <span class="comment">//注册Bean定义，容器根据定义返回bean</span></span>
<span class="line">        log.info(<span class="string">"register personManager1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span>
<span class="line">        BeanDefinitionBuilder beanDefinitionBuilder =</span>
<span class="line">                BeanDefinitionBuilder.genericBeanDefinition(PersonManager.class);</span>
<span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span>
<span class="line">        BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span>
<span class="line">        defaultListableBeanFactory.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span>
<span class="line"></span>
<span class="line">        <span class="comment">//注册bean实例</span></span>
<span class="line">        log.info(<span class="string">"register personManager2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span>
<span class="line">        PersonDao personDao = beanFactory.getBean(PersonDao.class);</span>
<span class="line">        PersonManager personManager = <span class="keyword">new</span> PersonManager();</span>
<span class="line">        personManager.setPersonDao(personDao);</span>
<span class="line">        beanFactory.registerSingleton(<span class="string">"personManager2"</span>, personManager);</span>
<span class="line"></span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="BeanDefinitionRegistryPostProcessor"><a href="#BeanDefinitionRegistryPostProcessor" class="headerlink" title="BeanDefinitionRegistryPostProcessor"></a>BeanDefinitionRegistryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Modify the application context's internal bean definition registry after its</span>
<span class="line">	 * standard initialization. All regular bean definitions will have been loaded,</span>
<span class="line">	 * but no beans will have been instantiated yet. This allows for adding further</span>
<span class="line">	 * bean definitions before the next post-processing phase kicks in.</span>
<span class="line">	 * <span class="doctag">@param</span> registry the bean definition registry used by the application context</span>
<span class="line">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span>
<span class="line">	 */</span></span>
<span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException</span>;</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p><code>BeanDefinitionRegistryPostProcessor</code> 这个类也可以提供<code>BeanDefinition</code>注册的扩展点。</p>
<h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * &#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125; used for bootstrapping processing of</span>
<span class="line"> * &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes.</span>
<span class="line"> *</span>
<span class="line"> * &lt;p&gt;Registered by default when using &#123;<span class="doctag">@code</span> &lt;context:annotation-config/&gt;&#125; or</span>
<span class="line"> * &#123;<span class="doctag">@code</span> &lt;context:component-scan/&gt;&#125;. Otherwise, may be declared manually as</span>
<span class="line"> * with any other BeanFactoryPostProcessor.</span>
<span class="line"> *</span>
<span class="line"> * &lt;p&gt;This post processor is &#123;<span class="doctag">@link</span> Ordered#HIGHEST_PRECEDENCE&#125; as it is important</span>
<span class="line"> * that any &#123;<span class="doctag">@link</span> Bean&#125; methods declared in Configuration classes have their</span>
<span class="line"> * respective bean definitions registered before any other BeanFactoryPostProcessor</span>
<span class="line"> * executes.</span>
<span class="line"> *</span>
<span class="line"> * <span class="doctag">@author</span> Chris Beams</span>
<span class="line"> * <span class="doctag">@author</span> Juergen Hoeller</span>
<span class="line"> * <span class="doctag">@author</span> Phillip Webb</span>
<span class="line"> * <span class="doctag">@since</span> 3.0</span>
<span class="line"> */</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>,</span>
<span class="line">		<span class="title">PriorityOrdered</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span>
</pre></td></tr></table></figure>
<p>这个类的主要功能就是用来处理打了<code>@Configuration</code>注解的Java配置类。解析配置类，并注册<code>BeanDefinition</code>到<code>BeanDefinitionRegistry</code></p>
<p>最重要的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line">* Derive further bean definitions from the configuration classes in the registry.</span>
<span class="line">*/</span></span>
<span class="line"><span class="meta">@Override</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span>
<span class="line">    <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span>
<span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span>
<span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span>
<span class="line">    			<span class="string">"postProcessBeanDefinitionRegistry already called on this post-processor against "</span> + registry);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span>
<span class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span>
<span class="line">    			<span class="string">"postProcessBeanFactory already called on this post-processor against "</span> + registry);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span>
<span class="line">    </span>
<span class="line">    processConfigBeanDefinitions(registry);</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="comment">/**</span>
<span class="line"> * Build and validate a configuration model based on the registry of</span>
<span class="line"> * &#123;<span class="doctag">@link</span> Configuration&#125; classes.</span>
<span class="line"> */</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span>
<span class="line">    <span class="comment">//代码太多了。</span></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line">* Interface to be implemented by types that register additional bean definitions when</span>
<span class="line">* processing @&#123;<span class="doctag">@link</span> Configuration&#125; classes. Useful when operating at the bean definition</span>
<span class="line">* level (as opposed to &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method/instance level) is desired or necessary.</span>
<span class="line">*/</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Register bean definitions as necessary based on the given annotation metadata of</span>
<span class="line">	 * the importing &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span>
<span class="line">	 * &lt;p&gt;Note that &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be</span>
<span class="line">	 * registered here, due to lifecycle constraints related to &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125;</span>
<span class="line">	 * class processing.</span>
<span class="line">	 * <span class="doctag">@param</span> importingClassMetadata annotation metadata of the importing class</span>
<span class="line">	 * <span class="doctag">@param</span> registry current bean definition registry</span>
<span class="line">	 */</span></span>
<span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,     BeanDefinitionRegistry registry)</span></span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>Spring官方在动态注册bean时，大部分套路其实是使用ImportBeanDefinitionRegistrar接口。</p>
<p>所有实现了该接口的类的都会被<code>ConfigurationClassPostProcessor</code>处理，<code>ConfigurationClassPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口，所以<code>ImportBeanDefinitionRegistrar</code>中动态注册的bean是优先与依赖其的bean初始化的，也能被aop、validator等机制处理。</p>
<p>使用方法</p>
<p><code>ImportBeanDefinitionRegistrar</code>需要配合<code>@Configuration</code>和<code>@Import</code>注解，<code>@Configuration</code>定义Java格式的Spring配置文件，<code>@Import</code>注解导入实现了<code>ImportBeanDefinitionRegistrar</code>接口的类。</p>
<p>例子：</p>
<p>首先编写一个实现了接口<code>ImportBeanDefinitionRegistrar</code>的类，来实现我们自定义的Bean注册功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UranusConfigRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">  <span class="meta">@Override</span></span>
<span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span>
<span class="line">      System.out.println(registry.getClass());</span>
<span class="line">      System.out.println(importingClassMetadata.getClassName());</span>
<span class="line">  &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>随后我们定义两个配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span>
<span class="line"><span class="meta">@Import</span>(UranusConfigRegistrar.class)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConfig</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="meta">@Configuration</span></span>
<span class="line"><span class="meta">@Import</span>(UranusConfigRegistrar.class)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>启动springboot应用，我们能再控制台看到如下的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">DefaultListableBeanFactory</span></span>
<span class="line"><span class="title">com</span>.<span class="title">leokongwq</span>.<span class="title">springcloud</span>.<span class="title">bookservice</span>.<span class="title">config</span>.<span class="title">DatabaseConfig</span></span>
<span class="line"></span>
<span class="line"><span class="title">class</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">DefaultListableBeanFactory</span></span>
<span class="line"><span class="title">com</span>.<span class="title">leokongwq</span>.<span class="title">springcloud</span>.<span class="title">bookservice</span>.<span class="title">config</span>.<span class="title">WebConfig</span></span></span>
</pre></td></tr></table></figure>
<p>从输出我们可以知道，方法<code>registerBeanDefinitions</code>的参数<code>AnnotationMetadata</code>里面包含<code>@Configuration</code>配置类的注解原信息。<code>registry</code>参数其实就是spring容器。</p>
<p>通过<code>AnnotationMetadata</code>我们能获取到<code>@Configuration</code>配置类上的所有注解信息，包括配置类里面加了注解的方法配置信息。</p>
<p>通过该机制，我们可以在<code>@Configuration</code>配置类上添加配置原元数据注解，以此来实现动态注册Bean的功能。</p>
<p>例如:</p>
<p>配置注解类：<code>EnableRedisCache</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Import</span>(UranusConfigRegistrar.class)</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRedisCache &#123;</span>
<span class="line"></span>
<span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> <span class="keyword">default</span> "127.0.0.1"</span>;</span>
<span class="line"></span>
<span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">port</span><span class="params">()</span> <span class="keyword">default</span> 9527</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>启用注解<code>EnableRedisCache</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span>
<span class="line"><span class="meta">@EnableRedisCache</span></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationBootstrap</span> </span>&#123;</span>
<span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line">        SpringApplication.run(ApplicationBootstrap.class, args); </span>
<span class="line">	&#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>启动应用，可以在控制台看到如下的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">DefaultListableBeanFactory</span></span>
<span class="line"><span class="title">com</span>.<span class="title">leokongwq</span>.<span class="title">springcloud</span>.<span class="title">bookservice</span>.<span class="title">config</span>.<span class="title">WebConfig</span></span>
<span class="line"><span class="title">host</span></span>=<span class="number">127.0</span>.0.1</span>
<span class="line">port=<span class="number">9527</span></span>
</pre></td></tr></table></figure>
<p>有了配置的元数据，我们就可以自由发挥，动态的生成一些Bean。</p>
<p>举一个springboot中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span>
<span class="line"> * &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; used by &#123;<span class="doctag">@link</span> ServletComponentScan&#125;.</span>
<span class="line"> *</span>
<span class="line"> * <span class="doctag">@author</span> Andy Wilkinson</span>
<span class="line"> * <span class="doctag">@author</span> Stephane Nicoll</span>
<span class="line"> */</span></span>
<span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServletComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span>
<span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"servletComponentRegisteringPostProcessor"</span>;</span>
<span class="line"></span>
<span class="line">	<span class="meta">@Override</span></span>
<span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span>
<span class="line">			BeanDefinitionRegistry registry)</span> </span>&#123;</span>
<span class="line">		Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span>
<span class="line">		<span class="keyword">if</span> (registry.containsBeanDefinition(BEAN_NAME)) &#123;</span>
<span class="line">			updatePostProcessor(registry, packagesToScan);</span>
<span class="line">		&#125;</span>
<span class="line">		<span class="keyword">else</span> &#123;</span>
<span class="line">			addPostProcessor(registry, packagesToScan);</span>
<span class="line">		&#125;</span>
<span class="line">	&#125;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span>
<span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span>
<span class="line"><span class="meta">@Documented</span></span>
<span class="line"><span class="meta">@Import</span>(ServletComponentScanRegistrar.class)</span>
<span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServletComponentScan &#123;</span>
<span class="line">    <span class="comment">/**</span>
<span class="line">	 * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span>
<span class="line">	 * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@ServletComponentScan</span>("org.my.pkg")&#125; instead of</span>
<span class="line">	 * &#123;<span class="doctag">@code</span> <span class="doctag">@ServletComponentScan</span>(basePackages="org.my.pkg")&#125;.</span>
<span class="line">	 * <span class="doctag">@return</span> the base packages to scan</span>
<span class="line">	 */</span></span>
<span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"basePackages"</span>)</span>
<span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Base packages to scan for annotated servlet components. &#123;<span class="doctag">@link</span> #value()&#125; is an</span>
<span class="line">	 * alias for (and mutually exclusive with) this attribute.</span>
<span class="line">	 * &lt;p&gt;</span>
<span class="line">	 * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span>
<span class="line">	 * package names.</span>
<span class="line">	 * <span class="doctag">@return</span> the base packages to scan</span>
<span class="line">	 */</span></span>
<span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span>
<span class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line"></span>
<span class="line">	<span class="comment">/**</span>
<span class="line">	 * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span>
<span class="line">	 * scan for annotated servlet components. The package of each class specified will be</span>
<span class="line">	 * scanned.</span>
<span class="line">	 * <span class="doctag">@return</span> classes from the base packages to scan</span>
<span class="line">	 */</span></span>
<span class="line">	Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p><code>ServletComponentScanRegistrar</code>实现了接口：<code>ImportBeanDefinitionRegistrar</code>。 同时注解<code>@ServletComponentScan</code>上也打了注解<code>@Import(ServletComponentScanRegistrar.class)</code>。</p>
<p>这样我们就可以在使用注解<code>ServletComponentScan</code>时，指定<code>basePackages</code>和<code>basePackageClasses</code>属性来配置Servlet规范里面的组件。Filter，Listener， Servlet等。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span>
<span class="line"><span class="meta">@ServletComponentScan</span>(basePackages = <span class="string">"com.leokongwq.springcloud.bookservice.web"</span>)</span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceApplication</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span>
<span class="line">		SpringApplication.run(BookServiceApplication.class, args);</span>
<span class="line">	&#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h2 id="SpringFactoriesLoader-机制"><a href="#SpringFactoriesLoader-机制" class="headerlink" title="SpringFactoriesLoader 机制"></a>SpringFactoriesLoader 机制</h2><p>SpringFactoriesLoader 的主要目的是在Spring框架内部完成工厂的加载机制。</p>
<p>主要的方法有2个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span>
<span class="line">		Assert.notNull(factoryClass, <span class="string">"'factoryClass' must not be null"</span>);</span>
<span class="line">		ClassLoader classLoaderToUse = classLoader;</span>
<span class="line">		<span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span>
<span class="line">			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span>
<span class="line">		&#125;</span>
<span class="line">		List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span>
<span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span>
<span class="line">			logger.trace(<span class="string">"Loaded ["</span> + factoryClass.getName() + <span class="string">"] names: "</span> + factoryNames);</span>
<span class="line">		&#125;</span>
<span class="line">		List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;(factoryNames.size());</span>
<span class="line">		<span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span>
<span class="line">			result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span>
<span class="line">		&#125;</span>
<span class="line">		AnnotationAwareOrderComparator.sort(result);</span>
<span class="line">		<span class="keyword">return</span> result;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span>
<span class="line">		String factoryClassName = factoryClass.getName();</span>
<span class="line">		<span class="keyword">try</span> &#123;</span>
<span class="line">			Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span>
<span class="line">					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span>
<span class="line">			List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span>
<span class="line">			<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span>
<span class="line">				URL url = urls.nextElement();</span>
<span class="line">				Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span>
<span class="line">				String factoryClassNames = properties.getProperty(factoryClassName);</span>
<span class="line">				result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span>
<span class="line">			&#125;</span>
<span class="line">			<span class="keyword">return</span> result;</span>
<span class="line">		&#125;</span>
<span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span>
<span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() +</span>
<span class="line">					<span class="string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span>
<span class="line">		&#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>这两个方法都是从classpath的指定文件中获取需要加载的类。这个文件就是classpath下面的：<code>META-INF/spring.factories</code>。在签名的小节已经看到过这个文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;spring扩展点和自动配置&quot;&gt;&lt;a href=&quot;#spring扩展点和自动配置&quot; class=&quot;headerlink&quot; title=&quot;spring扩展点和自动配置&quot;&gt;&lt;/a&gt;spring扩展点和自动配置&lt;/h2&gt;&lt;h3 id=&quot;BeanFactoryPostProcessor&quot;&gt;&lt;a href=&quot;#BeanFactoryPostProcessor&quot; class=&quot;headerlink&quot; title=&quot;BeanFactoryPostProcessor&quot;&gt;&lt;/a&gt;BeanFactoryPostProcessor&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/** &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * Modify the application context&#39;s internal bean factory after its standard &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * initialization. All bean definitions will have been loaded, but no beans &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * will have been instantiated yet. This allows for overriding or adding &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * properties even to eager-initializing beans. &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; beanFactory the bean factory used by the application context &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@throws&lt;/span&gt; org.springframework.beans.BeansException in case of errors &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;  &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;  &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过该扩展点，我们修改，新增&lt;code&gt;BeanDefinition&lt;/code&gt;。因为此时所有的&lt;code&gt;BeanDefinition&lt;/code&gt;已经加载，但是没有Bean被创建。一般用在需要覆盖或替换Bean的属性时。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>基于Openresy的图片服务</title>
    <link href="https://leokongwq.github.io/2018/02/12/openresy-lua-image-server.html"/>
    <id>https://leokongwq.github.io/2018/02/12/openresy-lua-image-server.html</id>
    <published>2018-02-12T06:43:12.000Z</published>
    <updated>2018-02-12T07:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>有个项目的需要是：用户通过给好友分享带有二维码的图片，好友扫码或在微信中识别二维码来领取分享的礼物。要实现这个需要，能想到的解决方案有两个：</p>
<a id="more"></a>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>客户端实现。背景图片存在客户端，客户端动态生成二维码，并完成图片的合成（包括给背景图添加二维码，文字水印，用户头像等信息）。</p>
<p>优点：图片和合成处理分布在每个用户的手机上，图片合成的计算压力进行了分散。用户体验更好。服务端只需要存储合成后的图片，并进行图片的加速访问。</p>
<p>缺点：这个方案的可行的前提是客户端当前需要具备这样的能力，而且需要需要访问用户手机的相册（也可以不访问）。现实问题是：1.马上开发上线，开发，审核，推广，用户下载都需要时间。2.用户版本不一致，不能保证覆盖面。</p>
<!-- more -->
<p>由于以上的问题，才有了方案二。</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>服务端实现。背景图片存在服务端，服务端通过图片库来完成图片的合成（二维码，水印等）。</p>
<p>优点：不依赖客户端。更好的动态控制能力</p>
<p>缺点：图片处理的压力全部在服务端。</p>
<h4 id="Java-实现"><a href="#Java-实现" class="headerlink" title="Java 实现"></a>Java 实现</h4><p>一开始的方案是通过Java开发一个图片服务，通过Java库<a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing</a>来生成二维码。<a href="https://github.com/coobird/thumbnailator" target="_blank" rel="external">Thumbnails</a> 来进行图片的合成，水印等功能。</p>
<p>马上开发并进行压测后发现效率一般。决定这个方案作为备选方案，抗不住就加机器。</p>
<h4 id="Openresty-Lua-ImageMagic"><a href="#Openresty-Lua-ImageMagic" class="headerlink" title="Openresty + Lua + ImageMagic"></a>Openresty + Lua + ImageMagic</h4><p>Openresty，Lua，ImageMagic 的作用就不解释了。下面直接上配置和代码。</p>
<p>Openresty 配置</p>
<figure class="highlight nginx"><figcaption><span>main block</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment"># 二维码文件名缓存</span></span>
<span class="line"><span class="attribute">lua_shared_dict</span> qr_cache <span class="number">10m</span>;</span>
<span class="line"><span class="comment"># 合成后的图片缓存，生产环境可以调大</span></span>
<span class="line"><span class="attribute">lua_shared_dict</span> share_img_file_cache <span class="number">10m</span>;</span>
</pre></td></tr></table></figure>
<figure class="highlight nginx"><figcaption><span>server</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
</pre></td><td class="code"><pre><span class="line"></span>
<span class="line"><span class="section">server</span> &#123;</span>
<span class="line">    <span class="attribute">listen</span>    <span class="number">80</span>;</span>
<span class="line">    <span class="attribute">server_name</span> localhost;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">access_log</span>  /data/logs/nginx/image.access.log  main;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">location</span> /images &#123;</span>
<span class="line">       <span class="attribute">set</span> <span class="variable">$image_root</span> <span class="string">"/data/static"</span>;</span>
<span class="line">       <span class="attribute">set</span> <span class="variable">$file</span> <span class="string">"<span class="variable">$image_root</span><span class="variable">$uri</span>"</span>;</span>
<span class="line">       <span class="attribute">set</span> <span class="variable">$convert_bin</span> <span class="string">"/usr/local/bin/convert"</span>;</span>
<span class="line">       <span class="attribute">rewrite_by_lua_file</span> <span class="string">"/Users/leo/workspace/lua/nginx-imagemagick.lua"</span>;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>Lua合成图片代码</p>
<figure class="highlight lua"><figcaption><span>nginx-imagemagick.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
<span class="line">101</span>
<span class="line">102</span>
<span class="line">103</span>
<span class="line">104</span>
<span class="line">105</span>
<span class="line">106</span>
<span class="line">107</span>
<span class="line">108</span>
<span class="line">109</span>
<span class="line">110</span>
<span class="line">111</span>
<span class="line">112</span>
<span class="line">113</span>
<span class="line">114</span>
<span class="line">115</span>
<span class="line">116</span>
<span class="line">117</span>
<span class="line">118</span>
<span class="line">119</span>
<span class="line">120</span>
<span class="line">121</span>
<span class="line">122</span>
<span class="line">123</span>
<span class="line">124</span>
<span class="line">125</span>
<span class="line">126</span>
<span class="line">127</span>
<span class="line">128</span>
<span class="line">129</span>
<span class="line">130</span>
<span class="line">131</span>
<span class="line">132</span>
<span class="line">133</span>
<span class="line">134</span>
<span class="line">135</span>
<span class="line">136</span>
<span class="line">137</span>
<span class="line">138</span>
<span class="line">139</span>
<span class="line">140</span>
<span class="line">141</span>
<span class="line">142</span>
<span class="line">143</span>
<span class="line">144</span>
<span class="line">145</span>
<span class="line">146</span>
<span class="line">147</span>
<span class="line">148</span>
<span class="line">149</span>
<span class="line">150</span>
<span class="line">151</span>
<span class="line">152</span>
<span class="line">153</span>
<span class="line">154</span>
<span class="line">155</span>
<span class="line">156</span>
<span class="line">157</span>
<span class="line">158</span>
<span class="line">159</span>
<span class="line">160</span>
<span class="line">161</span>
<span class="line">162</span>
<span class="line">163</span>
<span class="line">164</span>
<span class="line">165</span>
<span class="line">166</span>
<span class="line">167</span>
<span class="line">168</span>
<span class="line">169</span>
<span class="line">170</span>
<span class="line">171</span>
<span class="line">172</span>
<span class="line">173</span>
<span class="line">174</span>
<span class="line">175</span>
<span class="line">176</span>
<span class="line">177</span>
<span class="line">178</span>
<span class="line">179</span>
<span class="line">180</span>
<span class="line">181</span>
<span class="line">182</span>
<span class="line">183</span>
<span class="line">184</span>
<span class="line">185</span>
<span class="line">186</span>
<span class="line">187</span>
<span class="line">188</span>
<span class="line">189</span>
<span class="line">190</span>
<span class="line">191</span>
<span class="line">192</span>
<span class="line">193</span>
<span class="line">194</span>
<span class="line">195</span>
<span class="line">196</span>
<span class="line">197</span>
<span class="line">198</span>
<span class="line">199</span>
<span class="line">200</span>
<span class="line">201</span>
<span class="line">202</span>
<span class="line">203</span>
<span class="line">204</span>
<span class="line">205</span>
<span class="line">206</span>
<span class="line">207</span>
<span class="line">208</span>
<span class="line">209</span>
<span class="line">210</span>
<span class="line">211</span>
<span class="line">212</span>
<span class="line">213</span>
<span class="line">214</span>
<span class="line">215</span>
<span class="line">216</span>
<span class="line">217</span>
<span class="line">218</span>
<span class="line">219</span>
<span class="line">220</span>
<span class="line">221</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> qr = <span class="built_in">require</span>(<span class="string">"qrencode"</span>)</span>
<span class="line"><span class="keyword">local</span> qr_cache = ngx.shared.qr_cache;</span>
<span class="line"><span class="keyword">local</span> share_img_file_cache = ngx.shared.share_img_file_cache</span>
<span class="line"><span class="keyword">local</span> imgages_root_dir = ngx.var.image_root .. <span class="string">"/images/"</span></span>
<span class="line"><span class="keyword">local</span> img_file_suffix = <span class="string">".png"</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- config</span></span>
<span class="line"><span class="keyword">local</span> image_sizes = &#123; <span class="string">"640x640"</span>, <span class="string">"320x320"</span>, <span class="string">"124x124"</span>, <span class="string">"140x140"</span>, <span class="string">"64x64"</span>, <span class="string">"60x60"</span>, <span class="string">"32x32"</span>, <span class="string">"0x0"</span> &#125;</span>
<span class="line"></span>
<span class="line"><span class="comment">-- 字符串分隔方法</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">string:split</span><span class="params">(sep)</span></span></span>
<span class="line">	<span class="keyword">local</span> sep, fields = sep <span class="keyword">or</span> <span class="string">":"</span>, &#123;&#125;</span>
<span class="line">	<span class="keyword">local</span> pattern = <span class="built_in">string</span>.format(<span class="string">"([^%s]+)"</span>, sep)</span>
<span class="line">	self:gsub(pattern, <span class="function"><span class="keyword">function</span> <span class="params">(c)</span></span> fields[#fields + <span class="number">1</span>] = c <span class="keyword">end</span>)</span>
<span class="line">	<span class="keyword">return</span> fields</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- parse uri</span></span>
<span class="line"></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseUri</span><span class="params">(uri)</span></span></span>
<span class="line"></span>
<span class="line">	<span class="keyword">local</span> _, _, name, ext, size = <span class="built_in">string</span>.find(uri, <span class="string">"(.+)(%..+)!(%d+x%d+)"</span>)</span>
<span class="line"></span>
<span class="line">	<span class="comment">--ngx.header.content_type = "text/plain";</span></span>
<span class="line"></span>
<span class="line">	<span class="comment">--ngx.say(name,size);</span></span>
<span class="line"></span>
<span class="line">	<span class="keyword">if</span> name <span class="keyword">and</span> size <span class="keyword">and</span> ext <span class="keyword">then</span></span>
<span class="line">		<span class="keyword">return</span> ngx.var.image_root .. name .. ext, size</span>
<span class="line">	<span class="keyword">else</span></span>
<span class="line">		<span class="keyword">return</span> <span class="string">""</span>, <span class="string">""</span></span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fileExists</span><span class="params">(name)</span></span></span>
<span class="line">	<span class="keyword">local</span> f, msg = <span class="built_in">io</span>.open(name, <span class="string">"r"</span>)</span>
<span class="line">	<span class="keyword">if</span> f ~= <span class="keyword">nil</span> <span class="keyword">then</span></span>
<span class="line">		<span class="built_in">io</span>.close(f)</span>
<span class="line">		<span class="keyword">return</span> <span class="keyword">true</span></span>
<span class="line">	<span class="keyword">else</span></span>
<span class="line">		ngx.log(ngx.ERR, msg)</span>
<span class="line">		<span class="keyword">return</span> <span class="keyword">false</span></span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sizeExists</span><span class="params">(size)</span></span></span>
<span class="line">	<span class="keyword">for</span> _, value <span class="keyword">in</span> <span class="built_in">pairs</span>(image_sizes) <span class="keyword">do</span></span>
<span class="line">		<span class="keyword">if</span> value == size <span class="keyword">then</span></span>
<span class="line">			<span class="keyword">return</span> <span class="keyword">true</span></span>
<span class="line">		<span class="keyword">end</span></span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line">	<span class="keyword">return</span> <span class="keyword">false</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 返回图片</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response_image</span><span class="params">(img_file_path)</span></span></span>
<span class="line">	ngx.header.content_type = <span class="string">"image/jpg"</span>;</span>
<span class="line"></span>
<span class="line">	<span class="keyword">local</span> f = <span class="built_in">io</span>.open(img_file_path, <span class="string">"rb"</span>)</span>
<span class="line">	<span class="keyword">local</span> content = f:read(<span class="string">"*all"</span>)</span>
<span class="line">	ngx.<span class="built_in">print</span>(content)</span>
<span class="line">	f:close()</span>
<span class="line">	<span class="keyword">return</span> ngx.exit(ngx.OK)</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 返回图片, 是二进制</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">response_image_bin</span><span class="params">(img_bin)</span></span></span>
<span class="line">	ngx.header.content_type = <span class="string">"image/jpg"</span>;</span>
<span class="line">	ngx.<span class="built_in">print</span>(img_bin)</span>
<span class="line">	<span class="comment">-- ngx.flush()</span></span>
<span class="line">	<span class="keyword">return</span> ngx.exit(ngx.HTTP_OK)</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 缓存生成的图片</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cache_img_bin</span><span class="params">(cache_key, img_file_path)</span></span></span>
<span class="line">	<span class="keyword">local</span> f = <span class="built_in">io</span>.open(img_file_path, <span class="string">"rb"</span>)</span>
<span class="line">	<span class="keyword">local</span> content = f:read(<span class="string">"*all"</span>)</span>
<span class="line">	share_img_file_cache[cache_key] = content</span>
<span class="line">	f:close()</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 图片大小转化</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resize_imgage</span><span class="params">(image_file, width_height)</span></span></span>
<span class="line">	<span class="keyword">local</span> src_image_path = imgages_root_dir .. image_file</span>
<span class="line">	<span class="keyword">local</span> target_image_path = imgages_root_dir .. image_file:split(<span class="string">"."</span>)[<span class="number">1</span>] .. <span class="string">"_"</span> .. img_file_suffix</span>
<span class="line">	<span class="keyword">local</span> command = <span class="built_in">table</span>.concat(</span>
<span class="line">		&#123;</span>
<span class="line">			ngx.var.convert_bin,</span>
<span class="line">			<span class="string">"-resize"</span>,</span>
<span class="line">			width_height,</span>
<span class="line">			src_image_path,</span>
<span class="line">			target_image_path</span>
<span class="line">		&#125;,</span>
<span class="line">		<span class="string">" "</span></span>
<span class="line">	)</span>
<span class="line">	<span class="comment">-- 进行图片处理</span></span>
<span class="line">	<span class="built_in">os</span>.execute(command)</span>
<span class="line">	<span class="keyword">return</span> target_image_path</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 生成二维码图片 - 二进制流</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen_qr_code_bin</span><span class="params">(content)</span></span></span>
<span class="line">	<span class="keyword">local</span> qr_code_bin = qr &#123;</span>
<span class="line">		text=content,</span>
<span class="line">		level=<span class="string">"L"</span>,</span>
<span class="line">		kanji=<span class="keyword">false</span>,</span>
<span class="line">		ansi=<span class="keyword">false</span>,</span>
<span class="line">		size=<span class="number">4</span>,</span>
<span class="line">		margin=<span class="number">2</span>,</span>
<span class="line">		symversion=<span class="number">0</span>,</span>
<span class="line">		dpi=<span class="number">78</span>,</span>
<span class="line">		casesensitive=<span class="keyword">true</span>,</span>
<span class="line">		foreground=<span class="string">"000000"</span>,</span>
<span class="line">		background=<span class="string">"FFFFFF"</span></span>
<span class="line">	&#125;</span>
<span class="line">	<span class="keyword">return</span> qr_code_bin</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 生成二维码图片文件</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen_qr_code_file</span><span class="params">(qr_file_name, qr_code_bin)</span></span></span>
<span class="line">	<span class="keyword">local</span> full_qr_file_path = imgages_root_dir .. qr_file_name</span>
<span class="line">	file = <span class="built_in">io</span>.open(full_qr_file_path, <span class="string">"wb"</span>)</span>
<span class="line">	<span class="built_in">io</span>.output(file)</span>
<span class="line">	<span class="built_in">io</span>.write(qr_code_bin)</span>
<span class="line">	<span class="built_in">io</span>.close(file)</span>
<span class="line">	<span class="comment">-- 缩放到固定大小</span></span>
<span class="line">	<span class="comment">-- resize_imgage(qr_file_name, "120x120")</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 返回指定内容的二维码文件</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_qr_file</span><span class="params">(content)</span></span></span>
<span class="line">	<span class="keyword">local</span> qr_md5 = ngx.md5(content)</span>
<span class="line"></span>
<span class="line">	<span class="keyword">if</span> qr_cache[qr_md5] ~= <span class="keyword">nil</span></span>
<span class="line">	<span class="keyword">then</span></span>
<span class="line">		<span class="keyword">return</span> qr_cache[qr_md5]</span>
<span class="line">	<span class="keyword">else</span></span>
<span class="line">		<span class="keyword">local</span> qr_file_name = qr_md5 .. img_file_suffix</span>
<span class="line">		<span class="keyword">local</span> qr_code_bin = gen_qr_code_bin(content)</span>
<span class="line">		gen_qr_code_file(qr_file_name, qr_code_bin)</span>
<span class="line"></span>
<span class="line">		qr_cache[qr_md5] = qr_file_name</span>
<span class="line">		<span class="keyword">return</span> qr_file_name</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 获取生成二维码的内容</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_qr_code_content</span><span class="params">()</span></span></span>
<span class="line">	<span class="comment">-- 解析 body 参数之前一定要先读取 body</span></span>
<span class="line">	<span class="comment">--	ngx.req.read_body()</span></span>
<span class="line">	<span class="comment">--	local arg = ngx.req.get_post_args()</span></span>
<span class="line">	<span class="comment">--	for k,v in pairs(arg) do</span></span>
<span class="line">	<span class="comment">--		ngx.say("[POST] key:", k, " v:", v)</span></span>
<span class="line">	<span class="comment">--	end</span></span>
<span class="line"></span>
<span class="line">	<span class="keyword">local</span> args = ngx.req.get_uri_args()</span>
<span class="line">	<span class="keyword">local</span> text = args[<span class="string">'url'</span>]</span>
<span class="line">	<span class="keyword">return</span> text</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">--图片合成</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose_img</span><span class="params">(bg_img, fg_img, result_img)</span></span></span>
<span class="line">	<span class="keyword">local</span> command = <span class="built_in">table</span>.concat(</span>
<span class="line">		&#123;</span>
<span class="line">			ngx.var.convert_bin,</span>
<span class="line">			bg_img,</span>
<span class="line">			<span class="string">"+profile '*'"</span>,</span>
<span class="line">			<span class="string">"-quality 75%"</span>,</span>
<span class="line">			<span class="string">"-strip"</span>,</span>
<span class="line">			<span class="string">"-gravity northwest"</span>,</span>
<span class="line">			<span class="string">"-compose over "</span> .. fg_img,</span>
<span class="line">			<span class="string">"-geometry +500+525"</span>,</span>
<span class="line">			<span class="string">"-composite -compress BZip"</span>,</span>
<span class="line">			result_img</span>
<span class="line">		&#125;,</span>
<span class="line">		<span class="string">" "</span></span>
<span class="line">	)</span>
<span class="line">	<span class="comment">-- ngx.log(ngx.ERR, command)</span></span>
<span class="line">	<span class="comment">-- 进行图片处理</span></span>
<span class="line">	<span class="built_in">os</span>.execute(command)</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 图片添加二维码，文字水印</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose_img</span><span class="params">()</span></span></span>
<span class="line">	<span class="keyword">local</span> text = get_qr_code_content()</span>
<span class="line">	<span class="keyword">if</span> text == <span class="keyword">nil</span> <span class="keyword">or</span> text == <span class="string">""</span> <span class="keyword">then</span></span>
<span class="line">		ngx.header.content_type = <span class="string">"text/plain"</span></span>
<span class="line">		ngx.say(<span class="string">'need a text param'</span>)</span>
<span class="line">		<span class="keyword">return</span> ngx.exit(ngx.OK)</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line">	<span class="comment">--ngx.log(ngx.ERR, text)</span></span>
<span class="line"></span>
<span class="line">	<span class="keyword">local</span> sub_uris = ngx.var.uri:split(<span class="string">"/"</span>)</span>
<span class="line">	<span class="keyword">local</span> file_name = sub_uris[<span class="built_in">table</span>.getn(sub_uris)]</span>
<span class="line"></span>
<span class="line">	ori_filename = ngx.var.image_root .. ngx.var.uri</span>
<span class="line">	<span class="keyword">if</span> fileExists(ori_filename) == <span class="keyword">false</span> <span class="keyword">then</span></span>
<span class="line">		<span class="keyword">return</span> ngx.exit(<span class="number">404</span>)</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"></span>
<span class="line">	ngx.header.content_type = <span class="string">"image/png"</span></span>
<span class="line"></span>
<span class="line">	<span class="comment">-- 生成二维码</span></span>
<span class="line">	<span class="keyword">local</span> qr_code_file = imgages_root_dir .. get_qr_file(text)</span>
<span class="line">	<span class="keyword">local</span> result_img = ngx.md5(text) .. <span class="string">"_res_"</span> .. img_file_suffix</span>
<span class="line">	<span class="keyword">local</span> result_file = imgages_root_dir .. result_img</span>
<span class="line"></span>
<span class="line">	<span class="keyword">if</span> share_img_file_cache[result_img] ~= <span class="keyword">nil</span></span>
<span class="line">	<span class="keyword">then</span></span>
<span class="line">			<span class="comment">-- ngx.log(ngx.ERR, "from cache")</span></span>
<span class="line">			<span class="keyword">return</span> response_image_bin(share_img_file_cache[result_img])</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"></span>
<span class="line">	<span class="comment">-- ngx.exit(ngx.OK)</span></span>
<span class="line">	compose_img(ori_filename, qr_code_file, result_file)</span>
<span class="line">	cache_img_bin(result_img, result_file)</span>
<span class="line"></span>
<span class="line">	response_image(result_file)</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line">compose_img()</span>
</pre></td></tr></table></figure>
<h3 id="方案二的优化和扩展"><a href="#方案二的优化和扩展" class="headerlink" title="方案二的优化和扩展"></a>方案二的优化和扩展</h3><p>1.生成图片的缓存可以通过在openresty前面添加专门的缓存服务器(Openresty，varnish)。<br>2.生成的分析图片可以通过CDN进行分发，这样用户访问的速度更快。<br>3.合成图片的大小可以进一步压缩。目前合成的图片偏大。<br>4.通过这个demo，我们可以进一步丰富功能，只要是ImageMagic支持的功能，理论上都可以实现。</p>
<h3 id="环境的安装配置"><a href="#环境的安装配置" class="headerlink" title="环境的安装配置"></a>环境的安装配置</h3><h4 id="Openresy安装"><a href="#Openresy安装" class="headerlink" title="Openresy安装"></a>Openresy安装</h4><p>请参考:<a href="http://openresty.org/en/installation.html" target="_blank" rel="external">http://openresty.org/en/installation.html</a></p>
<h4 id="二维码生成库libqrencode安装"><a href="#二维码生成库libqrencode安装" class="headerlink" title="二维码生成库libqrencode安装"></a>二维码生成库libqrencode安装</h4><p>ubuntu： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">sudo apt-get install libqrencode-dev libpng12-dev</span>
</pre></td></tr></table></figure>
<p>CentOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">yum install libpng-devel</span>
<span class="line">wget http://ftp.riken.jp/Linux/centos/7/os/x86_64/Packages/qrencode-devel-3.4.1-3.el7.x86_64.rpm</span>
<span class="line">rpm -ivh qrencode-devel-3.4.1-3.el7.x86_64.rpm</span>
</pre></td></tr></table></figure>
<p>MacOS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">brew install libqrencode</span>
</pre></td></tr></table></figure>
<p>安装Lua扩展库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">git clone https://github.com/vincascm/qrencode</span>
<span class="line">make &amp;&amp; make install</span>
</pre></td></tr></table></figure>
<p><code>make test</code>如果能成功，控制台会显示一个二维码。</p>
<p>下面是一个生成二维码的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
</pre></td><td class="code"><pre><span class="line">server &#123;</span>
<span class="line"></span>
<span class="line">   listen 8080;</span>
<span class="line">   server_name img.papa.com.cn;</span>
<span class="line"></span>
<span class="line">   location / &#123;</span>
<span class="line">        default_type image/png;</span>
<span class="line">        content_by_lua_block &#123;</span>
<span class="line">              local qr = require(&quot;qrencode&quot;)</span>
<span class="line">              local args = ngx.req.get_uri_args()</span>
<span class="line">              local text = args.text</span>
<span class="line"></span>
<span class="line">              if text == nil or text== &quot;&quot; then</span>
<span class="line">                      ngx.say(&apos;need a text param&apos;)</span>
<span class="line">                      ngx.exit(404)</span>
<span class="line">              end</span>
<span class="line"></span>
<span class="line">              ngx.say(qr &#123;</span>
<span class="line">                      text=text,</span>
<span class="line">                      level=&quot;L&quot;,</span>
<span class="line">                      kanji=false,</span>
<span class="line">                      ansi=false,</span>
<span class="line">                      size=4,</span>
<span class="line">                      margin=2,</span>
<span class="line">                      symversion=0,</span>
<span class="line">                      dpi=78,</span>
<span class="line">                      casesensitive=true,</span>
<span class="line">                      foreground=&quot;000000&quot;,</span>
<span class="line">                      background=&quot;FFFFFF&quot;</span>
<span class="line">              &#125;)</span>
<span class="line">           &#125;</span>
<span class="line">           add_header Expires &quot;Fri, 01 Jan 1980 00:00:00 GMT&quot;;    </span>
<span class="line">           add_header Pragma &quot;no-cache&quot;;    </span>
<span class="line">           add_header Cache-Control &quot;no-cache, max-age=0, must-revalidate&quot;;</span>
<span class="line">           #add_header Content-Type image/png;</span>
<span class="line">  &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在配置真个环境的过程中，有一下几点需要注意：</p>
<p>1.lua的版本最好使用5.1，否则会有各种问题。<br>2.二维码生成的配置中<code>ansi=false</code>，否则在浏览器不能显示。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/vincascm/qrencode" target="_blank" rel="external">https://github.com/vincascm/qrencode</a></p>
<p><a href="http://blog.csdn.net/orangleliu/article/details/64912578" target="_blank" rel="external">基于 OpenResty 的二维码生成方案</a></p>
<p><a href="https://www.jianshu.com/p/62dc0b601e91" target="_blank" rel="external">Lua包管理工具Luarocks详解</a></p>
<p><a href="http://www.hopesoft.org/blog/?p=1188" target="_blank" rel="external">OpenResty(Nginx)+Lua+GraphicsMagick实现缩略图功能</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;有个项目的需要是：用户通过给好友分享带有二维码的图片，好友扫码或在微信中识别二维码来领取分享的礼物。要实现这个需要，能想到的解决方案有两个：&lt;/p&gt;
    
    </summary>
    
      <category term="架构" scheme="https://leokongwq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Openresy" scheme="https://leokongwq.github.io/tags/Openresy/"/>
    
      <category term="Nginx" scheme="https://leokongwq.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统调用算法</title>
    <link href="https://leokongwq.github.io/2018/02/06/linux-file-system-schedule.html"/>
    <id>https://leokongwq.github.io/2018/02/06/linux-file-system-schedule.html</id>
    <published>2018-02-06T12:41:43.000Z</published>
    <updated>2018-02-08T13:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html" target="_blank" rel="external">调整 Linux I/O 调度器优化系统性能</a></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>查看RocketMQ文档的过程中，提到了通过修改IO调度算法来提高RocketMQ的性能。网上找了一些文章，感觉IBM这个文章不错。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前言<br>Linux I/O 调度器是Linux内核中的一个组成部分，用户可以通过调整这个调度器来优化系统性能。本文首先介绍Linux I/O 调度器的结构，然后介绍如何根据不同的存储器来设置Linux I/O 调度器从而达到优化系统性能。</p>
<a id="more"></a>
<h3 id="Linux-I-O-系统简介"><a href="#Linux-I-O-系统简介" class="headerlink" title="Linux I/O 系统简介"></a>Linux I/O 系统简介</h3><p>Linux I/O调度器（Linux I/O Scheduler）是LinuxI/O体系的一个组件，它介于通用块层和块设备驱动程序之间。如图 1 所示。</p>
<p>图1 Linux I/O调度器介于通用块层和块设备驱动程序之间</p>
<img src="/2018/02/06/linux-file-system-schedule/image001.png" alt="image001.png" title="">
<p>当Linux内核组件要读写一些数据时，并不是请求一发出，内核便立即执行该请求，而是将其推迟执行。当传输一个新数据块时，内核需要检查它能否通过。Linux IO调度程序是介于通用块层和块设备驱动程序之间，所以它接收来自通用块层的请求，试图合并请求，并找到最合适的请求下发到块设备驱动程序中。之后块设备驱动程序会调用一个函数来响应这个请求。</p>
<p>Linux整体I/O体系可以分为七层，它们分别是：</p>
<ol>
<li>VFS虚拟文件系统：内核要跟多种文件系统打交道，内核抽象了这VFS，专门用来适配各种文件系统，并对外提供统一操作接口。</li>
<li>磁盘缓存：磁盘缓存是一种将磁盘上的一些数据保留着RAM中的软件机制，这使得对这部分数据的访问可以得到更快的响应。磁盘缓存在Linux中有三种类型：Dentry cache ，Page cache ， Buffer cache。</li>
<li>映射层：内核从块设备上读取数据，这样内核就必须确定数据在物理设备上的位置，这由映射层（Mapping Layer）来完成。</li>
<li>通用块层：由于绝大多数情况的I/O操作是跟块设备打交道，所以Linux在此提供了一个类似vfs层的块设备操作抽象层。下层对接各种不同属性的块设备，对上提供统一的Block IO请求标准。</li>
<li>I/O调度层：大多数的块设备都是磁盘设备，所以有必要根据这类设备的特点以及应用特点来设置一些不同的调度器。</li>
<li>块设备驱动：块设备驱动对外提供高级的设备操作接口。</li>
<li>物理硬盘：这层就是具体的物理设备。</li>
</ol>
<h3 id="调度算法有哪些？"><a href="#调度算法有哪些？" class="headerlink" title="调度算法有哪些？"></a>调度算法有哪些？</h3><p>Linux 从2.4内核开始支持I/O调度器,到目前为止有5种类型：Linux 2.4内核的 Linus Elevator、Linux 2.6内核的 Deadline、 Anticipatory、 CFQ、 Noop，其中Anticipatory从Linux 2.6.33版本后被删除了。目前主流的Linux发行版本使用Deadline、 CFQ、 Noop三种I/O调度器。下面依次简单介绍：</p>
<h4 id="1-Linus-Elevator"><a href="#1-Linus-Elevator" class="headerlink" title="1 Linus Elevator"></a>1 Linus Elevator</h4><p>在2.4 内核中它是第一种I/O调度器。它的主要作用是为每个设备维护一个查询请求，当内核收到一个新请求时，如果能合并就合并。如果不能合并，就会尝试排序。如果既不能合并，也没有合适的位置插入，就放到请求队列的最后。</p>
<h4 id="2-NOOP"><a href="#2-NOOP" class="headerlink" title="2 NOOP"></a>2 NOOP</h4><p>NOOP全称<code>No Operation</code>,中文名称电梯式调度器，该算法实现了最简单的FIFO队列，所有I/O请求大致按照先来后到的顺序进行操作。NOOP实现了一个简单的FIFO队列,它像电梯的工作主法一样对I/O请求进行组织。它是基于先入先出（FIFO）队列概念的 Linux 内核里最简单的I/O 调度器。此调度程序最适合于固态硬盘。NOOP的工作流程如图4 所示。</p>
<p>图4 NOOP的工作流程</p>

<h4 id="3-CFQ"><a href="#3-CFQ" class="headerlink" title="3 CFQ"></a>3 CFQ</h4><p>CFQ全称Completely Fair Scheduler ，中文名称完全公平调度器，它是现在许多 Linux 发行版的默认调度器，CFQ是内核默认选择的I/O调度器。它将由进程提交的同步请求放到多个进程队列中，然后为每个队列分配时间片以访问磁盘。对于通用的服务器是最好的选择,CFQ均匀地分布对I/O带宽的访问。CFQ为每个进程和线程,单独创建一个队列来管理该进程所产生的请求,以此来保证每个进程都能被很好的分配到I/O带宽，I/O调度器每次执行一个进程的4次请求。该算法的特点是按照I/O请求的地址进行排序，而不是按照先来后到的顺序来进行响应。简单来说就是给所有同步进程分配时间片，然后才排队访问磁盘，CFQ的工作流程如图 3 所示 。</p>
<p>图3 CFQ的工作流程</p>

<p>Anticipatory的中文含义是”预料的，预想的”，顾名思义有个I/O发生的时候，如果又有进程请求I/O操作，则将产生一个默认的6毫秒猜测时间，猜测下一个进程请求I/O是要干什么的。这个I/O调度器对读操作优化服务时间，在提供一个I/O的时候进行短时间等待，使进程能够提交到另外的I/O。Anticipatory算法从Linux 2.6.33版本后被删除了，因为使用CFQ通过配置也能达到Anticipatory的效果。</p>
<h4 id="4-DeadLine"><a href="#4-DeadLine" class="headerlink" title="4 DeadLine"></a>4 DeadLine</h4><p>Deadline翻译成中文是截止时间调度器，是对Linus Elevator的一种改进，它避免有些请求太长时间不能被处理。另外可以区分对待读操作和写操作。DEADLINE额外分别为读I/O和写I/O提供了FIFO队列。Deadline的工作流程如图 2 所示。</p>
<p>图2 Deadline的工作流程</p>
<img src="/2018/02/06/linux-file-system-schedule/image002.jpg" alt="image002.jpg" title="">
<h4 id="5-ANTICIPATORY"><a href="#5-ANTICIPATORY" class="headerlink" title="5 ANTICIPATORY"></a>5 ANTICIPATORY</h4><p>CFQ和DEADLINE考虑的焦点在于满足零散IO请求上。对于连续的IO请求，比如顺序读，并没有做优化。为了满足随机IO和顺序IO混合的场景，Linux还支持ANTICIPATORY调度算法。ANTICIPATORY的在DEADLINE的基础上，为每个读IO都设置了6ms的等待时间窗口。如果在这6ms内OS收到了相邻位置的读IO请求，就可以立即满足。</p>
<p>本质上与Deadline一样，但在最后一次读操作后，要等待6ms，才能继续进行对其它I/O请求进行调度。可以从应用程序中预订一个新的读请求，改进读操作的执行，但以一些写操作为代价。它会在每个6ms中插入新的I/O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。AS适合于写入较多的环境，比如文件服务器，但对对数据库环境表现很差。</p>
<h3 id="I-O调度器的选择"><a href="#I-O调度器的选择" class="headerlink" title="I/O调度器的选择"></a>I/O调度器的选择</h3><p>目前主流Linux发行版本使用三种I/O调度器：DeadLine、CFQ、NOOP，通常来说Deadline适用于大多数环境,特别是写入较多的文件服务器，从原理上看，DeadLine是一种以提高机械硬盘吞吐量为思考出发点的调度算法，尽量保证在有I/O请求达到最终期限的时候进行调度，非常适合业务比较单一并且I/O压力比较重的业务，比如Web服务器，数据库应用等。CFQ 为所有进程分配等量的带宽,适用于有大量进程的多用户系统，CFQ是一种比较通用的调度算法，它是一种以进程为出发点考虑的调度算法，保证大家尽量公平,为所有进程分配等量的带宽,适合于桌面多任务及多媒体应用。NOOP 对于闪存设备和嵌入式系统是最好的选择。对于固态硬盘来说使用NOOP是最好的，DeadLine次之，而CFQ效率最低。</p>
<p>查看Linux系统的 I/O调度器<br>查看Linux系统的I/O调度器一般分成两个部分，一个是查看Linux系统整体使用的I/O调度器，另一个是查看某磁盘使用的I/O调度器。</p>
<p>查看当前系统支持的I/O调度器，使用如下命令：</p>
<p>清单 1. 查看当前系统支持的I/O调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"># dmesg | grep -i scheduler</span>
<span class="line">[    1.508820] io scheduler noop registered</span>
<span class="line">[    1.508827] io scheduler deadline registered</span>
<span class="line">[    1.508850] io scheduler cfq registered (default)</span>
</pre></td></tr></table></figure>
<p>清单1的代码显示cfq是目前的I/O调度器。</p>
<p>查看某块硬盘的IO调度算法I/O调度器，使用如下命令：</p>
<p>清单2. 查看一个硬盘使用的I/O调度器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"># cat /sys/block/sda/queue/scheduler</span>
<span class="line">noop deadline [cfq]</span>
</pre></td></tr></table></figure>
<p>清单2显示当前使用的调度器是cfq，就是括号括起来的那一个。</p>
<h3 id="修改Linux系统的-I-O调度器"><a href="#修改Linux系统的-I-O调度器" class="headerlink" title="修改Linux系统的 I/O调度器"></a>修改Linux系统的 I/O调度器</h3><p>修改Linux系统的 I/O调度器有三种方法，分别是使用shell命令、使用grubby命令或者修改grub配置文件。下面依次介绍：</p>
<h4 id="使用shell命令"><a href="#使用shell命令" class="headerlink" title="使用shell命令"></a>使用shell命令</h4><p>Linux下更改的I/O调度器很简单。不需要更新内核，可以使用shell命令修改：</p>
<p>清单3. 查使用shell命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">#echo noop &gt; /sys/block/sdb/queue/scheduler</span>
</pre></td></tr></table></figure>
<p>清单3的命令把noop设置为一个磁盘的I/O调度器，你可以随时更改而无需重启计算机。</p>
<h4 id="永久修改默认的I-O调度器"><a href="#永久修改默认的I-O调度器" class="headerlink" title="永久修改默认的I/O调度器"></a>永久修改默认的I/O调度器</h4><p>使用shell命令修改I/O调度器，只是临时修改，系统重启后，修改的调度器就会失效，要想修改默认的调度器，有两种方法使用grubby命令或者直接编辑grub配置文件。</p>
<p>使用grubby命令</p>
<p>例如需要把I/O调度器从cfq调整成 DeadLine ，命令如下：</p>
<p>清单4.使用grubby命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"># grubby --grub --update-kernel=ALL --args=&quot;elevator=deadline&quot;</span>
</pre></td></tr></table></figure>
<p>清单4的命令，通过设置内核加载参数, 这样当机器重启的时候，系统自动把所有设备的 I/O调度器变成 DeadLine 。</p>
<h4 id="使用编辑器修改配置文件"><a href="#使用编辑器修改配置文件" class="headerlink" title="使用编辑器修改配置文件"></a>使用编辑器修改配置文件</h4><p>也可以直接编辑grub的配置文件 ，通过修改grub配置文件，系统自动把所有设备的 I/O调度器变成cfq。操作过程如下：</p>
<p>清单5 使用vi编辑器修改grub配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line">#vi cat /etc/default/grub</span>
<span class="line">#修改第五行，在行尾添加#</span>
<span class="line">elevator= cfq</span>
<span class="line"> </span>
<span class="line">然后保存文件，重新编译配置文件，</span>
<span class="line">#grub2-mkconfig -o /boot/grub2/grub.cfg</span>
</pre></td></tr></table></figure>
<p>重新启动计算机系统即可。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux I/O调度器是 Linux 内核中的一个组成部分，用户可以通过根据不同的存储器来设置 Linux I/O 调度器从而达到优化系统性能。 一般来说 NOOP 调度器最适合于固态硬盘，DeadLine 调度器适用于写入较多的文件服务器，比如Web服务器，数据库应用等，而CFQ 调度器适合于桌面多任务及媒体应用。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://access.redhat.com/solutions/109223" target="_blank" rel="external">红帽子知识库文章：How to use the Noop I/O Scheduler</a></p>
<p><a href="http://product.china-pub.com/36767" target="_blank" rel="external">深入理解Linux内核(第三版) 原名: Understanding the Linux Kernel</a></p>
<p><a href="http://www.361way.com/linux-iosched/4800.html" target="_blank" rel="external">RH442之linux IO调度（电梯算法）</a></p>
<p><a href="http://www.cnblogs.com/cobbliu/p/5389556.html" target="_blank" rel="external">Linux IO Scheduler（Linux IO 调度器）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-lo-io-scheduler-optimize-performance/index.html&quot;&gt;调整 Linux I/O 调度器优化系统性能&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;查看RocketMQ文档的过程中，提到了通过修改IO调度算法来提高RocketMQ的性能。网上找了一些文章，感觉IBM这个文章不错。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前言&lt;br&gt;Linux I/O 调度器是Linux内核中的一个组成部分，用户可以通过调整这个调度器来优化系统性能。本文首先介绍Linux I/O 调度器的结构，然后介绍如何根据不同的存储器来设置Linux I/O 调度器从而达到优化系统性能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://leokongwq.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>基于openresty的后端应用健康检查-动态上下线</title>
    <link href="https://leokongwq.github.io/2018/01/31/openresty-health-check-dynamic-up-down.html"/>
    <id>https://leokongwq.github.io/2018/01/31/openresty-health-check-dynamic-up-down.html</id>
    <published>2018-01-31T12:18:25.000Z</published>
    <updated>2018-02-01T01:49:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了保证在应用发布期间不间断用户的请求，我们需要实现后端服务的动态上下线。同时为了在OPS管理台能看到某个应用各个Server结点的健康状态，我们需要后端节点的健康检查功能。基于openresty，这些功能都可以实现。</p>
<a id="more"></a>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>实现健康检查，可以通过<code>lua-resty-upstream-healthcheck</code>来实现。</p>
<p>具体配置如下：</p>
<figure class="highlight"><figcaption><span>nginx.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
</pre></td><td class="code"><pre><span class="line">## 指定共享内存</span>
<span class="line">lua_shared_dict healthcheck 1m;</span>
<span class="line"></span>
<span class="line">## 在worker初始化过程中，启动定时器，进行后端结点的检查</span>
<span class="line">init_worker_by_lua_block &#123;</span>
<span class="line">   local hc = require "resty.upstream.healthcheck"</span>
<span class="line">   local ok, err = hc.spawn_checker &#123;</span>
<span class="line">       -- shm 表示共享内存区的名称，</span>
<span class="line">       shm = "healthcheck",</span>
<span class="line">       -- type 表示健康检查的类型， HTTP or TCP （目前只支持http）</span>
<span class="line">       type = "http",    </span>
<span class="line">       -- upstream 指定 upstream 配置的名称   </span>
<span class="line">       upstream = "tomcat",</span>
<span class="line">       -- 如果是http类型，指定健康检查发送的请求的URL</span>
<span class="line">       http_req = "GET /health.txt HTTP/1.0\r\nHost: tomcat\r\n\r\n",</span>
<span class="line">       -- 请求间隔时间，默认是 1 秒。最小值为 2毫秒</span>
<span class="line">       interval = 2000,</span>
<span class="line">       -- 请求的超时时间。 默认值为：1000 毫秒</span>
<span class="line">       timeout = 5000,</span>
<span class="line">       -- 失败多少次后，将节点标记为down。 默认值为 5</span>
<span class="line">       fall = 3, </span>
<span class="line">       -- 成功多少次后，将节点标记为up。默认值为 2</span>
<span class="line">       rise = 2,</span>
<span class="line">       -- 返回的http状态码，表示应用正常</span>
<span class="line">       valid_statuses = &#123;200, 302&#125;,</span>
<span class="line">       -- 并发度， 默认值为 1</span>
<span class="line">       concurrency = 1,</span>
<span class="line">   &#125;</span>
<span class="line"> </span>
<span class="line">   if not ok then</span>
<span class="line">       ngx.log(ngx.ERR, "=======&gt; failed to spawn health checker: ", err)</span>
<span class="line">       return</span>
<span class="line">   end</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"># 配置监控检查访问页面</span>
<span class="line">location /server/status &#123;</span>
<span class="line">  access_log off;</span>
<span class="line">  default_type text/plain;</span>
<span class="line">  content_by_lua_block &#123;</span>
<span class="line">      local hc = require "resty.upstream.healthcheck"</span>
<span class="line">      ngx.say("Nginx Worker PID: ", ngx.worker.pid())</span>
<span class="line">      ngx.print(hc.status_page())</span>
<span class="line">  &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="节点上下线"><a href="#节点上下线" class="headerlink" title="节点上下线"></a>节点上下线</h3><p>该功能利用了<code>lua-upstream-nginx-module</code>模块来实现，提供REST分割API来获取upstream的信息，上下线指定upstream下的server。具体看下面的代码：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置 upstream管理地址</span></span>
<span class="line"><span class="attribute">location</span> /upstreams &#123;</span>
<span class="line">  <span class="attribute">default_type</span> text/plain;</span>
<span class="line">  <span class="attribute">content_by_lua_file</span> /Users/leo/workspace/lua/upstream.lua;</span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>upstreams http API lua 代码:</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
<span class="line">51</span>
<span class="line">52</span>
<span class="line">53</span>
<span class="line">54</span>
<span class="line">55</span>
<span class="line">56</span>
<span class="line">57</span>
<span class="line">58</span>
<span class="line">59</span>
<span class="line">60</span>
<span class="line">61</span>
<span class="line">62</span>
<span class="line">63</span>
<span class="line">64</span>
<span class="line">65</span>
<span class="line">66</span>
<span class="line">67</span>
<span class="line">68</span>
<span class="line">69</span>
<span class="line">70</span>
<span class="line">71</span>
<span class="line">72</span>
<span class="line">73</span>
<span class="line">74</span>
<span class="line">75</span>
<span class="line">76</span>
<span class="line">77</span>
<span class="line">78</span>
<span class="line">79</span>
<span class="line">80</span>
<span class="line">81</span>
<span class="line">82</span>
<span class="line">83</span>
<span class="line">84</span>
<span class="line">85</span>
<span class="line">86</span>
<span class="line">87</span>
<span class="line">88</span>
<span class="line">89</span>
<span class="line">90</span>
<span class="line">91</span>
<span class="line">92</span>
<span class="line">93</span>
<span class="line">94</span>
<span class="line">95</span>
<span class="line">96</span>
<span class="line">97</span>
<span class="line">98</span>
<span class="line">99</span>
<span class="line">100</span>
<span class="line">101</span>
<span class="line">102</span>
<span class="line">103</span>
<span class="line">104</span>
<span class="line">105</span>
<span class="line">106</span>
<span class="line">107</span>
<span class="line">108</span>
<span class="line">109</span>
<span class="line">110</span>
<span class="line">111</span>
<span class="line">112</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span></span>
<span class="line"><span class="keyword">local</span> hc = <span class="built_in">require</span> <span class="string">"resty.upstream.healthcheck"</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">local</span> concat = <span class="built_in">table</span>.concat</span>
<span class="line"><span class="keyword">local</span> upstream = <span class="built_in">require</span> <span class="string">"ngx.upstream"</span></span>
<span class="line"><span class="keyword">local</span> get_servers = upstream.get_servers</span>
<span class="line"><span class="keyword">local</span> get_upstreams = upstream.get_upstreams</span>
<span class="line"><span class="keyword">local</span> get_primary_peers = upstream.get_primary_peers</span>
<span class="line"><span class="keyword">local</span> get_backup_peers = upstream.get_backup_peers</span>
<span class="line"><span class="keyword">local</span> set_peer_down = upstream.set_peer_down</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 字符串分隔方法</span></span>
<span class="line"><span class="function"><span class="keyword">function</span> <span class="title">string:split</span><span class="params">(sep)</span></span>  </span>
<span class="line">	<span class="keyword">local</span> sep, fields = sep <span class="keyword">or</span> <span class="string">":"</span>, &#123;&#125;  </span>
<span class="line">	<span class="keyword">local</span> pattern = <span class="built_in">string</span>.format(<span class="string">"([^%s]+)"</span>, sep)  </span>
<span class="line">	self:gsub(pattern, <span class="function"><span class="keyword">function</span> <span class="params">(c)</span></span> fields[#fields + <span class="number">1</span>] = c <span class="keyword">end</span>)  </span>
<span class="line">	<span class="keyword">return</span> fields  </span>
<span class="line"><span class="keyword">end</span> </span>
<span class="line"></span>
<span class="line"><span class="comment">-- get all upstream config block </span></span>
<span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_all_upstream</span><span class="params">()</span></span></span>
<span class="line">	<span class="keyword">local</span> us = get_upstreams()</span>
<span class="line">	<span class="keyword">local</span> upstreams = &#123;&#125;</span>
<span class="line">	</span>
<span class="line">	<span class="keyword">for</span> _, u <span class="keyword">in</span> <span class="built_in">ipairs</span>(us) <span class="keyword">do</span></span>
<span class="line">		<span class="keyword">local</span> srvs = get_servers(u)</span>
<span class="line">		upstreams[u] = srvs</span>
<span class="line">	<span class="keyword">end</span>		</span>
<span class="line">	</span>
<span class="line">	<span class="keyword">return</span> upstreams	</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 获取某个upstream下的所有Server</span></span>
<span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_servers_by_upstream_name</span><span class="params">(upstream_name)</span></span></span>
<span class="line">	<span class="keyword">local</span> up = get_all_upstream()[upstream_name]</span>
<span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> up <span class="keyword">then</span></span>
<span class="line">		<span class="keyword">return</span> &#123;&#125;</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"></span>
<span class="line">	<span class="keyword">return</span> up	</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 获取所有的 peer</span></span>
<span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">get_all_peers</span><span class="params">(upstream_name)</span></span></span>
<span class="line">	<span class="keyword">local</span> primary_peers = get_primary_peers(upstream_name)</span>
<span class="line"><span class="comment">--	local backup_peers = get_backup_peers(upstream_name)</span></span>
<span class="line"><span class="comment">--	</span></span>
<span class="line"><span class="comment">--	local primary_cnt = table.getn(primary_peers)</span></span>
<span class="line"><span class="comment">--	local backup_cnt = table.getn(backup_peers)</span></span>
<span class="line"><span class="comment">--		</span></span>
<span class="line"><span class="comment">--	local total = table.getn(primary_peers) + table.getn(backup_peers)</span></span>
<span class="line"><span class="comment">--	local all_peers = &#123;&#125;</span></span>
<span class="line"><span class="comment">--	</span></span>
<span class="line"><span class="comment">--	for i = primary_cnt + 1, total do</span></span>
<span class="line"><span class="comment">--		backup_peers[i - primary_cnt]["backup"] = true</span></span>
<span class="line"><span class="comment">--		table.insert(primary_peers, i, backup_peers[i - primary_cnt])</span></span>
<span class="line"><span class="comment">--	end</span></span>
<span class="line"><span class="comment">--	</span></span>
<span class="line">	<span class="keyword">return</span> primary_peers</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 操作Server节点上下线</span></span>
<span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">op_server</span><span class="params">(upstream_name, server_name, op)</span></span></span>
<span class="line">	<span class="comment">-- ngx.say(cjson.encode(get_all_peers(upstream_name)))</span></span>
<span class="line">	<span class="keyword">local</span> all_peers = get_all_peers(upstream_name)</span>
<span class="line">	<span class="keyword">for</span> i, peer <span class="keyword">in</span> <span class="built_in">ipairs</span>(all_peers) <span class="keyword">do</span> </span>
<span class="line">		<span class="keyword">if</span> peer[<span class="string">"name"</span>] == server_name <span class="keyword">then</span></span>
<span class="line">			target_peer = peer</span>
<span class="line">			<span class="keyword">break</span></span>
<span class="line">		<span class="keyword">end</span></span>
<span class="line">	<span class="keyword">end</span> </span>
<span class="line">	</span>
<span class="line">	<span class="keyword">if</span> target_peer == <span class="keyword">nil</span> <span class="keyword">then</span></span>
<span class="line">		ngx.say(cjson.encode(&#123;code = <span class="string">"E00001"</span>, msg = <span class="string">"error peer name"</span>&#125;))	</span>
<span class="line">	<span class="keyword">else</span></span>
<span class="line">		<span class="keyword">if</span> op == <span class="string">"down"</span> <span class="keyword">then</span></span>
<span class="line">			down_value = <span class="keyword">true</span></span>
<span class="line">		<span class="keyword">else</span></span>
<span class="line">			down_value = <span class="keyword">false</span></span>
<span class="line">		<span class="keyword">end</span></span>
<span class="line">		</span>
<span class="line">		<span class="keyword">local</span> is_back_up = target_peer[<span class="string">"backup"</span>] <span class="keyword">or</span> <span class="keyword">false</span></span>
<span class="line">		set_peer_down(upstream_name, is_back_up, target_peer[<span class="string">"id"</span>], down_value)		</span>
<span class="line">		ngx.say(cjson.encode(&#123;code = <span class="string">"A00000"</span>, msg = <span class="string">"Success"</span>&#125;))	</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">local</span> http_method = ngx.req.get_method()</span>
<span class="line"><span class="keyword">local</span> sub_uris = ngx.var.uri:split(<span class="string">"/"</span>)</span>
<span class="line"></span>
<span class="line"><span class="comment">-- 节点上下线</span></span>
<span class="line"><span class="keyword">if</span> <span class="built_in">table</span>.getn(sub_uris) == <span class="number">4</span> <span class="keyword">then</span></span>
<span class="line">	op_server(sub_uris[<span class="number">2</span>], sub_uris[<span class="number">3</span>], sub_uris[<span class="number">4</span>])</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 获取master or backup nodes</span></span>
<span class="line"><span class="keyword">if</span> <span class="built_in">table</span>.getn(sub_uris) == <span class="number">3</span> <span class="keyword">then</span></span>
<span class="line">	<span class="keyword">if</span> sub_uris[<span class="number">3</span>] == <span class="string">"primary"</span> <span class="keyword">then</span></span>
<span class="line">		ngx.say(cjson.encode(get_primary_peers(sub_uris[<span class="number">2</span>])))</span>
<span class="line">	<span class="keyword">else</span></span>
<span class="line">		ngx.say(cjson.encode(get_backup_peers(sub_uris[<span class="number">2</span>])))</span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line">	ngx.exit(ngx.HTTP_OK)</span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 获取所有upstream or 指定名称的upstream</span></span>
<span class="line"><span class="keyword">if</span> sub_uris[<span class="number">2</span>] <span class="keyword">then</span></span>
<span class="line">	ngx.say(cjson.encode(get_all_peers(sub_uris[<span class="number">2</span>])))	</span>
<span class="line"><span class="keyword">else</span></span>
<span class="line">	ngx.say(cjson.encode(get_all_upstream()))</span>
<span class="line"><span class="keyword">end</span></span>
</pre></td></tr></table></figure>
<p>提供的API有：</p>
<h4 id="获取所有的upstream的信息"><a href="#获取所有的upstream的信息" class="headerlink" title="获取所有的upstream的信息"></a>获取所有的upstream的信息</h4><p><a href="http://localhost/upstreams" target="_blank" rel="external">http://localhost/upstreams</a> </p>
<h4 id="获取指定upstream的信息"><a href="#获取指定upstream的信息" class="headerlink" title="获取指定upstream的信息"></a>获取指定upstream的信息</h4><p><a href="http://localhost/upstreams/{upstream_name}" target="_blank" rel="external">http://localhost/upstreams/{upstream_name}</a></p>
<h4 id="获取指定upstream下指定server-name的节点信息"><a href="#获取指定upstream下指定server-name的节点信息" class="headerlink" title="获取指定upstream下指定server_name的节点信息"></a>获取指定upstream下指定server_name的节点信息</h4><p><a href="http://localhost/upstreams/{upstream_name}/{server_name}" target="_blank" rel="external">http://localhost/upstreams/{upstream_name}/{server_name}</a></p>
<h4 id="指定upstream下指定server-name节点上下线"><a href="#指定upstream下指定server-name节点上下线" class="headerlink" title="指定upstream下指定server_name节点上下线"></a>指定upstream下指定server_name节点上下线</h4><p><a href="http://localhost/upstreams/{upstream_name}/{server_name}/down" target="_blank" rel="external">http://localhost/upstreams/{upstream_name}/{server_name}/down</a></p>
<p><a href="http://localhost/upstreams/{upstream_name}/{server_name}/up" target="_blank" rel="external">http://localhost/upstreams/{upstream_name}/{server_name}/up</a></p>
<p>有了这些个API，就有了在OPS控制台远程控制节点上下线的能力。通过和发布系统的配合，在节点发布时，先进行下线操作，指定时间间隔（处理完目前的请求，无流量后进行发布）后再发布。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>能不能实现节点平滑的上下线， 一定要用测试结果说话。 下面是一段<a href="http://gatling.io" target="_blank" rel="external">gatling</a>的压测脚本。</p>
<p>以<code>50req/s</code>的速率发送请求，持续时间为30秒。如果整个压测过程中，在动态下线某个节点后，没有出现失败的请求，那就可以说明平滑的上下线是成功的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> qiyueorder</span>
<span class="line"></span>
<span class="line"><span class="keyword">import</span> io.gatling.core.<span class="type">Predef</span>._</span>
<span class="line"><span class="keyword">import</span> io.gatling.http.<span class="type">Predef</span>._</span>
<span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span>
<span class="line"></span>
<span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessLimit</span> <span class="keyword">extends</span> <span class="title">Simulation</span> </span>&#123;</span>
<span class="line"></span>
<span class="line">	<span class="keyword">val</span> httpConf = http</span>
<span class="line">		.baseURL(<span class="string">"http://i.vip.iqiyi.com/"</span>)</span>
<span class="line">		.acceptHeader(<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>)</span>
<span class="line">		.doNotTrackHeader(<span class="string">"1"</span>)</span>
<span class="line">		.acceptLanguageHeader(<span class="string">"zh-CN,en;q=0.5"</span>)</span>
<span class="line">		.acceptEncodingHeader(<span class="string">"gzip, deflate"</span>)</span>
<span class="line">		.userAgentHeader(<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:16.0) Gecko/20100101 Firefox/16.0"</span>)</span>
<span class="line"></span>
<span class="line">	 <span class="keyword">val</span> uri = <span class="string">"/pay/h5/paytype.action"</span></span>
<span class="line">	 <span class="keyword">val</span> scn = scenario(<span class="string">"qiyue-api限流组件压测"</span>).exec(http(<span class="string">"queryOrderStat"</span>).get(uri))</span>
<span class="line"></span>
<span class="line">	setUp(</span>
<span class="line">		scn.inject(constantUsersPerSec(<span class="number">50</span>) during(<span class="number">30</span> seconds))</span>
<span class="line">		<span class="comment">//scn.inject(atOnceUsers(50))</span></span>
<span class="line">	).protocols(httpConf)</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/cubicdaiya/ngx_dynamic_upstream" target="_blank" rel="external">https://github.com/cubicdaiya/ngx_dynamic_upstream</a><br><a href="https://github.com/openresty/lua-upstream-nginx-module" target="_blank" rel="external">https://github.com/openresty/lua-upstream-nginx-module</a><br><a href="https://github.com/openresty/lua-resty-upstream-healthcheck" target="_blank" rel="external">https://github.com/openresty/lua-resty-upstream-healthcheck</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;为了保证在应用发布期间不间断用户的请求，我们需要实现后端服务的动态上下线。同时为了在OPS管理台能看到某个应用各个Server结点的健康状态，我们需要后端节点的健康检查功能。基于openresty，这些功能都可以实现。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://leokongwq.github.io/categories/web/"/>
    
    
      <category term="openresty" scheme="https://leokongwq.github.io/tags/openresty/"/>
    
  </entry>
  
  <entry>
    <title>TCP状态转化总结</title>
    <link href="https://leokongwq.github.io/2018/01/30/tcp-state-transfer-diagram.html"/>
    <id>https://leokongwq.github.io/2018/01/30/tcp-state-transfer-diagram.html</id>
    <published>2018-01-30T14:30:24.000Z</published>
    <updated>2018-02-06T05:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自：<a href="http://blog.csdn.net/wenqian1991/article/details/39667131" target="_blank" rel="external">TCP的三次握手和四次挥手</a></p>
<h3 id="TCP连接建立过程——三次握手"><a href="#TCP连接建立过程——三次握手" class="headerlink" title="TCP连接建立过程——三次握手"></a>TCP连接建立过程——三次握手</h3><ul>
<li>第一次握手：客户端发送位码为 SYN = 1（SYN 标志位置位），随机产生初始序列号 Seq = J 的数据包到服务器。服务器由 SYN = 1（置位）知道，客户端要求建立联机。</li>
<li>第二次握手：服务器收到请求后要确认联机信息，向客户端发送确认号Ack = （客户端的Seq +1，J+1），SYN = 1，ACK = 1（SYN，ACK 标志位置位），随机产生的序列号 Seq = K 的数据包。</li>
<li>第三次握手：客户端收到后检查 Ack 是否正确，即第一次发送的 Seq +1（J+1），以及位码ACK是否为1。若正确，客户端会再发送 Ack = （服务器端的Seq+1，K+1），ACK = 1，以及序号Seq为服务器确认号J 的确认包。服务器收到后确认之前发送的 Seq（K+1） 值与 ACK= 1 （ACK置位）则连接建立成功。</li>
</ul>
<a id="more"></a>
<p>经过了这三步之后，客户端与服务器端就成功建立起一个 TCP连接。这三个步骤统称为三次握手。</p>
<p>（上面Seq表示序列号，Ack表示确认号，SYN和ACK以及FIN等都是标志位。ACK 被设置为 1表示确认号字段是有效的，如果 ACK为 0，则该段不包含确认信息。SYN 被用于建立连接过程，在连接请求中，SYN = 1 和 ACK = 0 表示该段没有捎带确认字段。连接应答会捎带一个确认，所以应答时会有 SYN= 1 和 ACK= 1。另外发送ACK无需任何代价，所以我们会看到一旦一个连接建立起来，ACK标志总是被置为1）</p>
<img src="/2018/01/30/tcp-state-transfer-diagram/20141003170103720.bmp" alt="20141003170103720.bmp" title="">
<p>从上图可以看出，当客户端调用connect 时，触发了连接请求，向服务器发送了 SYN J包，这时 connect 进入阻塞状态；服务器监听到连接请求，即收到 SYN J包，调用 accept函数接收请求向客户端发送 SYN K，ACK J+1，这时 accept 进入阻塞状态，客户端收到服务器的 SYN K，ACK J+1之后，这时 connect 返回，并对 SYN K 进行确认，服务器收到 ACK K+1时，accept返回，至此三次握手完毕，连接建立。可以得知：<strong>客户端的 connect在三次握手的第二次返回，而服务器端的 accept在三次握手的第三次返回。</strong></p>
<h3 id="为什么是三次握手："><a href="#为什么是三次握手：" class="headerlink" title="为什么是三次握手："></a>为什么是三次握手：</h3><p>有讲到“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。<br>这样说明“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p>下面用抓包工具 Wireshark 实际分析下三次握手的过程，这里是登陆一个网址，然后Wireshark 过滤http 找到与浏览器打开该网站相关的数据包。</p>
<p>连接的是 HTTP 服务器，可以看到其端口号正是80，客户端的端口号则是随机的。红色框框标记的则是三次握手过程，下面具体来看</p>
<img src="/2018/01/30/tcp-state-transfer-diagram/20141015150458984.bmp" alt="20141015150458984.bmp" title="">
<h4 id="第一次握手数据包："><a href="#第一次握手数据包：" class="headerlink" title="第一次握手数据包："></a>第一次握手数据包：</h4><img src="/2018/01/30/tcp-state-transfer-diagram/first_shake_hand.bmp" alt="first_shake_hand.bmp" title="">
<p>客户端发送一个TCP，标志位SYN置位，序列号为4225926656（默认是相对序列号，可以在Wireshark中protocol preference 设置Absolute Number，显示真正的序列号）。表示客户端请求建立连接。</p>
<h4 id="第二次握手数据包："><a href="#第二次握手数据包：" class="headerlink" title="第二次握手数据包："></a>第二次握手数据包：</h4><img src="/2018/01/30/tcp-state-transfer-diagram/secend-hand-shake.bmp" alt="secend-hand-shake.bmp" title="">
<p>看源端口和目的端口。服务器发回确认包，标志位SYN和ACK置位，将确认序号Ack设置为客户的ISN（初始序号）+1，为4225926657，同时发送序列号为3022381253。</p>
<h4 id="第三次握手数据包"><a href="#第三次握手数据包" class="headerlink" title="第三次握手数据包"></a>第三次握手数据包</h4><img src="/2018/01/30/tcp-state-transfer-diagram/third-hand-shake.bmp" alt="third-hand-shake.bmp" title="">
<p>客户端再次发送确认包，其中ACK置位，确认序号Ack设置为服务器发过来的序号Seq+1，为3022381254，并发送序号=服务器发过来的确认号。</p>
<p>对于建连接的三次握手，主要是初始化Seq的值。通信的双方要互相通知对方自己的初始化的Seq（ISN），这个号（上面的K，J）作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输问题而乱序，TCP会用这个序号来拼接数据。</p>
<h3 id="TCP连接终止过程——四次挥手"><a href="#TCP连接终止过程——四次挥手" class="headerlink" title="TCP连接终止过程——四次挥手"></a>TCP连接终止过程——四次挥手</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，也就是发送方和接收方都需要Fin和Ack。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接，收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>这里我们假定客户端主动关闭（实际上谁先执行主动关闭没本质区别，通话结束了，谁先挂断没啥区别）</p>
<p>客户端发送一个FIN Seq = M（FIN置位，序号为M）包，用来关闭客户端到服务器端的数据传送。<br>服务器端收到这个FIN，它发回一个ACK，确认序号Ack 为收到的序号M+1。<br>服务器端关闭与客户端的连接，发送一个FIN Seq = N 给客户端。<br>客户端发回ACK 报文确认，确认序号Ack 为收到的序号N+1。</p>
<img src="/2018/01/30/tcp-state-transfer-diagram/tcp_close_state_transfer.bmp" alt="tcp_close_state_transfer.bmp" title="">
<p>对于四次挥手，其实仔细看是两次，因为TCP是全双工的，必须双方都关闭才可以，单方会有两次，共有四次。终止的时候，有一方是被动的，所以看上去就成了四次挥手。</p>
<p>前面有说道，一旦连接建立起来，ACK标志位总是被置为1。所以我们在下图可以看到TCP建立连接之后，ACK总是被置为1的。</p>
<img src="/2018/01/30/tcp-state-transfer-diagram/tcp_close_four_wireshark.bmp" alt="tcp_close_four_wireshark.bmp" title="">
<p>关闭连接过程主要看FIN标志位是否置位，ACK在连接建立成功之后都是置为1的。</p>
<p>上面Wireshark抓包是服务器端先执行主动关闭。</p>
<p>第一次挥手：服务器端发起主动关闭，FIN置位，Seq = 3022381791；</p>
<p>第二次挥手：客户端收到FIN后，发回ACK，Ack = Seq + 1 = 3022381792；至此服务器端的连接关闭了，接下来还需要关闭客户端的。</p>
<p>第三次挥手：客户端发送FIN，Seq = 4225929031；</p>
<p>第四次挥手：服务器端收到FIN后，发回ACK，Ack = Seq + 1 = 4225929032.这样客户端的连接也关闭了。至此全双工的TCP连接关闭。</p>
<p>另外通过下面的截图可以发现：数据传输中的 Sequence Number 的增加是和传输字节数相关的。</p>
<img src="/2018/01/30/tcp-state-transfer-diagram/20141015152915479.bmp" alt="20141015152915479.bmp" title="">
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转载自：&lt;a href=&quot;http://blog.csdn.net/wenqian1991/article/details/39667131&quot;&gt;TCP的三次握手和四次挥手&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;TCP连接建立过程——三次握手&quot;&gt;&lt;a href=&quot;#TCP连接建立过程——三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP连接建立过程——三次握手&quot;&gt;&lt;/a&gt;TCP连接建立过程——三次握手&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一次握手：客户端发送位码为 SYN = 1（SYN 标志位置位），随机产生初始序列号 Seq = J 的数据包到服务器。服务器由 SYN = 1（置位）知道，客户端要求建立联机。&lt;/li&gt;
&lt;li&gt;第二次握手：服务器收到请求后要确认联机信息，向客户端发送确认号Ack = （客户端的Seq +1，J+1），SYN = 1，ACK = 1（SYN，ACK 标志位置位），随机产生的序列号 Seq = K 的数据包。&lt;/li&gt;
&lt;li&gt;第三次握手：客户端收到后检查 Ack 是否正确，即第一次发送的 Seq +1（J+1），以及位码ACK是否为1。若正确，客户端会再发送 Ack = （服务器端的Seq+1，K+1），ACK = 1，以及序号Seq为服务器确认号J 的确认包。服务器收到后确认之前发送的 Seq（K+1） 值与 ACK= 1 （ACK置位）则连接建立成功。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="网络编程" scheme="https://leokongwq.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="TCP" scheme="https://leokongwq.github.io/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>openresty动态upstream实现</title>
    <link href="https://leokongwq.github.io/2018/01/27/openresty-dynamic-upstream.html"/>
    <id>https://leokongwq.github.io/2018/01/27/openresty-dynamic-upstream.html</id>
    <published>2018-01-27T12:38:12.000Z</published>
    <updated>2018-01-27T13:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>公司现有应用的部署方式是所有的请求通过一个外网域名进行访问，在<code>openresty</code>内部通过<code>location</code>匹配来分离请求到不同的<code>upstream</code>。这样的配置方式带来的最大问题至少有两个：</p>
<ol>
<li>配置膨胀。随着子应用接口的增加，<code>location</code>的配置会很复杂，不易阅读和新增配置。</li>
<li>每次新增和删除接口都需要修改所有<code>openresty</code>配置。这会带来额外的运维负担，而且会影响部分接口的稳定性。</li>
</ol>
<p>那有没有一种方式可以动态的新增和删除需要跳转的<code>uri</code>呢？ 这个就是下面我要提供的解决方案。</p>
<a id="more"></a>
<p>先来看一个示例配置，如下所示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
<span class="line">49</span>
<span class="line">50</span>
</pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> www.a.com &#123;</span>
<span class="line">   <span class="attribute">server</span> <span class="number">127.0.0.1:7001</span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="attribute">upstream</span> www.b.com &#123;</span>
<span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:7002</span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="attribute">upstream</span> www.abc.com &#123;</span>
<span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:7003</span>;</span>
<span class="line">&#125;</span>
<span class="line"></span>
<span class="line"><span class="section">server</span> &#123;</span>
<span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span>
<span class="line">    <span class="attribute">server_name</span> www.abc.com;</span>
<span class="line"></span>
<span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span>
<span class="line"></span>
<span class="line">    <span class="attribute">access_log</span>  /data/logs/nginx/abc.access.log  main;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">location</span> <span class="regexp">~ (/a/hello.html)|(/a/world.html)</span> &#123;</span>
<span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span>
<span class="line">        <span class="attribute">proxy_pass</span>   http://www.a.com;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">location</span> <span class="regexp">~ (/b/hello.html)|(/b/world.html)</span> &#123;</span>
<span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span>
<span class="line">        <span class="attribute">proxy_pass</span>   http://www.b.com;</span>
<span class="line">    &#125;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">location</span> / &#123;</span>
<span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span>
<span class="line">        <span class="attribute">proxy_pass</span> http://www.abc.com;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h3 id="set-by-lua-file"><a href="#set-by-lua-file" class="headerlink" title="set_by_lua_file"></a>set_by_lua_file</h3><p>该解决方案的原理是通过<code>set_by_lua_file</code>指令计算需要动态upstream的名称，然后在<code>proxy_pass</code>中引用该变量。具体请看如下的配置和lua代码：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">### 生产环境需要开启：on.</span></span>
<span class="line"><span class="attribute">lua_code_cache</span> <span class="literal">off</span>;</span>
<span class="line"><span class="attribute">lua_package_path</span> <span class="string">'/path/to/lua/module/search/path'</span>;</span>
<span class="line"><span class="attribute">lua_shared_dict</span> rewrite_conf <span class="number">10m</span>;</span>
<span class="line"><span class="attribute">init_by_lua_file</span> init.lua;</span>
</pre></td></tr></table></figure>
<p>init.lua 用来初始化全局配置。在这里我们用来读取动态配置的<code>uri</code></p>
<figure class="highlight lua"><figcaption><span>init.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span></span>
<span class="line"><span class="keyword">local</span> rewrite_conf = ngx.shared.rewrite_conf;</span>
<span class="line"></span>
<span class="line">file = <span class="built_in">io</span>.input(<span class="string">"rewrite.json"</span>)    <span class="comment">-- 使用 io.input() 函数打开文件</span></span>
<span class="line"></span>
<span class="line"><span class="keyword">local</span> jsonCfg = <span class="string">""</span></span>
<span class="line"><span class="keyword">repeat</span></span>
<span class="line">	line = <span class="built_in">io</span>.read()            <span class="comment">-- 逐行读取内容，文件结束时返回nil</span></span>
<span class="line">	<span class="keyword">if</span> <span class="keyword">nil</span> == line <span class="keyword">then</span></span>
<span class="line">		<span class="keyword">break</span></span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line">	jsonCfg = jsonCfg..line</span>
<span class="line"><span class="keyword">until</span> (<span class="keyword">false</span>)</span>
<span class="line"></span>
<span class="line"><span class="built_in">io</span>.close(file)                  <span class="comment">-- 关闭文件</span></span>
<span class="line"></span>
<span class="line">rewrite_json = cjson.decode(jsonCfg)</span>
<span class="line"></span>
<span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(rewrite_json) <span class="keyword">do</span> </span>
<span class="line">	rewrite_conf[k] = v </span>
<span class="line"><span class="keyword">end</span></span>
</pre></td></tr></table></figure>
<p>rewrite.json文件的内容如下所示：</p>
<figure class="highlight json"><figcaption><span>rewrite.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
</pre></td><td class="code"><pre><span class="line">&#123;</span>
<span class="line">	<span class="attr">"www.abc.com"</span> : &#123;</span>
<span class="line">		<span class="attr">"rewrite_urls"</span> : [</span>
<span class="line">			&#123;</span>
<span class="line">				<span class="attr">"uri"</span> : <span class="string">"/a/hello.html"</span>,</span>
<span class="line">				<span class="attr">"rewrite_upstream"</span> : <span class="string">"www.a.com"</span></span>
<span class="line">			&#125;,</span>
<span class="line">			&#123;</span>
<span class="line">				<span class="attr">"uri"</span> : <span class="string">"/b/hello.html"</span>,</span>
<span class="line">				<span class="attr">"rewrite_upstream"</span> : <span class="string">"www.b.com"</span></span>
<span class="line">			&#125;</span>
<span class="line">		]	</span>
<span class="line">	&#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>下面就是我们简化后的location配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
</pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span>
<span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span>
<span class="line">    <span class="attribute">server_name</span> www.abc.com;</span>
<span class="line"></span>
<span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span>
<span class="line"></span>
<span class="line">    <span class="attribute">access_log</span>  /data/logs/nginx/abc.access.log  main;</span>
<span class="line">    </span>
<span class="line">    <span class="attribute">location</span> / &#123;</span>
<span class="line">        <span class="comment">## 动态计算upsteam的名字</span></span>
<span class="line">        <span class="attribute">set_by_lua_file</span> <span class="variable">$my_upstream</span> set.lua;</span>
<span class="line">    </span>
<span class="line">        <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Connection <span class="string">""</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span>
<span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span>
<span class="line">        <span class="attribute">proxy_pass</span> http://<span class="variable">$my_upstream</span>;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<figure class="highlight lua"><figcaption><span>set.lua</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态设置				</span></span>
<span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span></span>
<span class="line"></span>
<span class="line"><span class="comment">-- 执行 rewrite 判断</span></span>
<span class="line"><span class="keyword">local</span> rewrite_conf = ngx.shared.rewrite_conf</span>
<span class="line"><span class="keyword">local</span> host = ngx.var.http_host</span>
<span class="line"><span class="keyword">local</span> uri = ngx.var.uri</span>
<span class="line"></span>
<span class="line"><span class="keyword">local</span> default_upstream = host</span>
<span class="line"></span>
<span class="line"><span class="keyword">if</span> rewrite_conf[host] ~= <span class="keyword">nil</span> <span class="keyword">then</span></span>
<span class="line">	<span class="keyword">for</span> i, elem <span class="keyword">in</span> <span class="built_in">ipairs</span>(rewrite_conf[host][<span class="string">'rewrite_urls'</span>]) <span class="keyword">do</span></span>
<span class="line">		<span class="keyword">if</span> uri == elem[<span class="string">'uri'</span>] <span class="keyword">then</span></span>
<span class="line">			default_upstream = elem[<span class="string">'rewrite_upstream'</span>]</span>
<span class="line">			<span class="keyword">break</span></span>
<span class="line">		<span class="keyword">end</span></span>
<span class="line">	<span class="keyword">end</span></span>
<span class="line"><span class="keyword">end</span></span>
<span class="line"></span>
<span class="line">ngx.log(ngx.INFO, <span class="string">"default_upstream="</span>..default_upstream)</span>
<span class="line"><span class="keyword">return</span> default_upstream</span>
</pre></td></tr></table></figure>
<p>到此，整个方案就算完成了。但是还不够完美。因为没有实现动态的效果。</p>
<p>要实现动态的效果其实很简单，我这里有个建议：</p>
<ol>
<li>通过将动态配置的<code>uri</code>信息，也就是<code>rewrite.json</code>的内容放置的Redis中。</li>
<li>提供一个管理API接口，用来读取Redis中的最新配置并更新<code>ngx.shared.rewrite_conf</code>的值。</li>
</ol>
<p>当然了，如果配置更新了，但你不想主动调用该管理API接口。你也可以通过<code>ngx.timer.at</code>来设置定时任务来主动获取Redis的配置。</p>
<h3 id="方案二-ngx-location-capture"><a href="#方案二-ngx-location-capture" class="headerlink" title="方案二 ngx.location.capture"></a>方案二 ngx.location.capture</h3><p>先介绍一下指令<code>ngx.location.capture</code>的作用：</p>
<blockquote>
<p>语法: res = ngx.location.capture(uri, options?)<br>上下文: rewrite_by_lua<em>, access_by_lua</em>, content_by_lua*<br>向 uri 发起一个同步非阻塞 Nginx 子请求。</p>
</blockquote>
<p>Nginx 子请求是一种非常强有力的方式，它可以发起非阻塞的内部请求来访问目标<code>location</code>。目标 <code>location</code> 可以是配置文件中其它文件目录，或任何其它 <code>nginx C</code> 模块，包括 <code>ngx_proxy</code>、<code>ngx_fastcgi</code>、<code>ngx_memc</code>、<code>ngx_postgres</code>、<code>ngx_drizzle</code>，甚至 <code>ngx_lua</code> 自身等等 。</p>
<p>需要注意的是，子请求只是模拟 HTTP 接口的形式，没有额外的 <code>HTTP/TCP</code> 流量，也没有 <code>IPC</code> (进程间通信) 调用。所有工作在内部高效地在 C 语言级别完成。</p>
<p>子请求与 <code>HTTP 301/302</code> 重定向指令 (通过 <code>ngx.redirect</code>) 完全不同，也与内部重定向 ((通过 <code>ngx.exec</code>) 完全不同。</p>
<p>在发起子请求前，用户程序应总是读取完整的 HTTP 请求体 (通过调用 <code>ngx.req.read_body</code> 或设置 <code>lua_need_request_body</code> 指令为 on).</p>
<p>该 API 方法（<code>ngx.location.capture_multi</code> 也一样）总是缓冲整个请求体到内存中。因此，当需要处理一个大的子请求响应，用户程序应使用 <code>cosockets</code> 进行流式处理，</p>
<h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p>参考 <a href="http://blog.csdn.net/daiyudong2020/article/details/53027934" target="_blank" rel="external">用openresty实现动态upstream</a></p>
<p>该方法的实现可以做的灵活，功能也可以更强大。当然缺点是你需要做非常多的工作。例如：获取元素请求的参数，请求的HTTP方法类型，然后设置请求的URI请求参数，请求体（可以通过<code>always_forward_body</code>避免）等。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="external">lua-nginx-module</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;公司现有应用的部署方式是所有的请求通过一个外网域名进行访问，在&lt;code&gt;openresty&lt;/code&gt;内部通过&lt;code&gt;location&lt;/code&gt;匹配来分离请求到不同的&lt;code&gt;upstream&lt;/code&gt;。这样的配置方式带来的最大问题至少有两个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置膨胀。随着子应用接口的增加，&lt;code&gt;location&lt;/code&gt;的配置会很复杂，不易阅读和新增配置。&lt;/li&gt;
&lt;li&gt;每次新增和删除接口都需要修改所有&lt;code&gt;openresty&lt;/code&gt;配置。这会带来额外的运维负担，而且会影响部分接口的稳定性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那有没有一种方式可以动态的新增和删除需要跳转的&lt;code&gt;uri&lt;/code&gt;呢？ 这个就是下面我要提供的解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="openresty" scheme="https://leokongwq.github.io/tags/openresty/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁的几种实现方式</title>
    <link href="https://leokongwq.github.io/2018/01/19/distribute-lock-some-way.html"/>
    <id>https://leokongwq.github.io/2018/01/19/distribute-lock-some-way.html</id>
    <published>2018-01-19T06:02:59.000Z</published>
    <updated>2018-01-19T12:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进程内的对共享资源的互斥访问可以通过各个语言提供的Lock来实现。在分布式环境下对共享资源的访问就需要分布式锁的支持。分布式是锁的本质是都是找一个共同可以访问的资源，可以是分布式文件系统中的文件，某个固定结点的一块内存，等等。共享资源所在机器的进程来协调分布式的加锁和解锁请求。分布式的锁比进程内的锁需要考虑的问题还要多。下面就总结一下常用的分布式锁解决方案。</p>
<p>但是：能不用分布式锁就不要用了。性能，可扩展性，容错都很难处理。</p>
<a id="more"></a>
<h3 id="分布式锁需要实现的功能"><a href="#分布式锁需要实现的功能" class="headerlink" title="分布式锁需要实现的功能"></a>分布式锁需要实现的功能</h3><ul>
<li><p>互斥性 统一时刻只能被集群中某个应用的单个线程访问</p>
</li>
<li><p>可重入</p>
</li>
<li><p>阻塞式</p>
</li>
<li><p>高可用</p>
</li>
<li><p>高性能</p>
</li>
</ul>
<h3 id="数据库实现"><a href="#数据库实现" class="headerlink" title="数据库实现"></a>数据库实现</h3><h4 id="基于table的实现"><a href="#基于table的实现" class="headerlink" title="基于table的实现"></a>基于table的实现</h4><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁记录表，然后通过操作该表中的数据来实现了。</p>
<p>当我们要锁住某个方法或资源时，我们就在该表中增加一条带有唯一索引的记录，想要释放锁的时候就删除这条记录。</p>
<p>创建这样一张数据库表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`distLock`</span> (</span>
<span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span>
<span class="line">  <span class="string">`lock_name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'锁名称'</span>,</span>
<span class="line">  <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span>
<span class="line">  <span class="string">`update_time`</span> <span class="keyword">timestamp</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间，自动生成'</span>,</span>
<span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span>
<span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uniq_lock_name`</span> (<span class="string">`lock_name`</span>) <span class="keyword">USING</span> BTREE</span>
<span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'分布式锁'</span>;</span>
</pre></td></tr></table></figure>
<p>加锁：insert一条记录<br>解锁：删除该记录</p>
<p>存在的问题：</p>
<ol>
<li>严重依赖数据库的可用性，存在单点风险</li>
<li>没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>需要客户端实现自旋，阻塞，超时控制等。</li>
<li>锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中锁</li>
<li>性能依赖数据的写入性能力，扩展性差。记录已经存在了。</li>
</ol>
<p>优化方式：</p>
<ol>
<li>数据库双写。消除单点</li>
<li>记录锁获取时间和失效时间。定时任务删除释放失败的锁。</li>
<li>客户端封装自旋逻辑，锁超时和进程内的线程互斥逻辑。</li>
<li>记录获取锁的客户端唯一标志。insert前进行查询判断。</li>
<li>搭建多个高可用集群，锁的名称进行哈希处理</li>
</ol>
<h4 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h4><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</p>
<p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span>
<span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span>
<span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span>
<span class="line">        <span class="keyword">try</span>&#123;</span>
<span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span>
<span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span>
<span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span>
<span class="line">            &#125;</span>
<span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span>
<span class="line"></span>
<span class="line">        &#125;</span>
<span class="line">        sleep(<span class="number">100</span>);</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给<code>lock_name</code>添加索引，值得注意的是，这个索引一定要创建成<code>唯一索引</code>。</p>
<p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span>
<span class="line">    connection.commit();</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>这种方法可以有效的解决上面提到的无法释放锁(事务有自己的超时时间)和阻塞锁（MySQL帮你阻塞）的问题。</p>
<p>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。<br>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。<br>但是还是无法直接解决数据库单点和可重入问题。</p>
<p>这里还可能存在另外一个问题，虽然我们对<code>lock_name</code>使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</p>
<p>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p>
<p>数据库实现分布式锁的优点：</p>
<p>直接借助数据库，容易理解。</p>
<p>数据库实现分布式锁的缺点</p>
<p>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p>
<p>操作数据库需要一定的开销，性能问题需要考虑。</p>
<p>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p>
<h3 id="基于缓存实现分布式锁"><a href="#基于缓存实现分布式锁" class="headerlink" title="基于缓存实现分布式锁"></a>基于缓存实现分布式锁</h3><p>redis 的实现可以参考下面的文章:</p>
<p><a href="http://blog.csdn.net/u010359884/article/details/50310387" target="_blank" rel="external">基于redis分布式锁实现“秒杀”</a><br><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="external">jedisLock—redis分布式锁实现</a><br><a href="http://ifeve.com/redis-lock/" target="_blank" rel="external">《Redis官方文档》用Redis构建分布式锁</a></p>
<h3 id="基于zooKeeper实现分布式锁"><a href="#基于zooKeeper实现分布式锁" class="headerlink" title="基于zooKeeper实现分布式锁"></a>基于zooKeeper实现分布式锁</h3><p><a href="http://ifeve.com/zookeeper-lock/" target="_blank" rel="external">ZooKeeper的用法： 分布式锁</a><br><a href="http://blog.csdn.net/sqh201030412/article/details/51456143" target="_blank" rel="external">zookeeper入门之curator框架–几种锁的操作</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="external">分布式锁实现</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;进程内的对共享资源的互斥访问可以通过各个语言提供的Lock来实现。在分布式环境下对共享资源的访问就需要分布式锁的支持。分布式是锁的本质是都是找一个共同可以访问的资源，可以是分布式文件系统中的文件，某个固定结点的一块内存，等等。共享资源所在机器的进程来协调分布式的加锁和解锁请求。分布式的锁比进程内的锁需要考虑的问题还要多。下面就总结一下常用的分布式锁解决方案。&lt;/p&gt;
&lt;p&gt;但是：能不用分布式锁就不要用了。性能，可扩展性，容错都很难处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://leokongwq.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统一致性</title>
    <link href="https://leokongwq.github.io/2018/01/19/distribute-system-consistent.html"/>
    <id>https://leokongwq.github.io/2018/01/19/distribute-system-consistent.html</id>
    <published>2018-01-19T02:08:35.000Z</published>
    <updated>2018-01-27T12:16:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p>在理论计算机科学中，<code>CAP定理</code>（CAP theorem），又被称作<code>布鲁尔定理</code>（Brewer’s theorem），它指出对于一个<code>分布式存储系统</code>来说，不可能同时满足以下三点:</p>
<ul>
<li>一致性（Consistence） 每次读取都能获取最新的写入或一个<code>ERROR</code></li>
<li>可用性（Availability）（每次请求都能获取到非<code>ERROR</code>的响应 – 但是不保证获取的数据为最新数据）</li>
<li>分区容错性（Network partitioning）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li>
</ul>
<p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致(<code>全部不更新能保证一致性</code>)，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p>
<a id="more"></a>
<h4 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h4><ul>
<li>一致性: 指一旦数据写入成功，随后所有的读取请求都能获取写入结果。单节点系统，如：一个节点的DBMS能保证一致性，因为没有副本。<code>这里的一致性指的是强一致性</code>。</li>
<li>可用性: 每次请求都能获取到的响应（合理的时间内，超时不可以），但是不保证获取的数据为最新数据。</li>
<li>分区容错性（Network partitioning）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[3]。）</li>
</ul>
<p>一个节点的存储系统一致性能保证，但是可用性不能保证。为什么？ 原因是：网络不总是可靠的，在发生网络分区或大量丢包，大量延迟的情况下，请求不能在合理的时间内结束，如此可用性是不能保证的（单点故障）。要消灭单点故障，就需要对数据做备份。数据多副本的情况下就有不一致的风险。 因此在设计系统时，首先要考虑的就是：在网络故障的前提下如何对可用性和一致性做取舍。通常情况下我们都会选择可用性，舍弃强一致性。</p>
<p>CAP是针对分布式系统的，对集中式系统不起作用。例如：应用和数据存储（DBMS）在一台机器上，没有副本就没有一致性的问题，没有网络就没有网络分区的问题。只要DBMS进程存在就是可用的。</p>
<p>CAP 同时是针对分布式存储状态或数据的系统的，如果分布式系统的每个节点都是纯粹的计算节点，那么根本就存在上述的各种问题。</p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p><code>BASE</code>是<code>Basically Available</code>（基本可用）、<code>Soft state</code>（软状态）和<code>Eventually consistent</code>（最终一致性）三个短语的简写，是由来自eBay的架构师<code>Dan Pritchett</code>在其文章<a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="external">BASE: An Acid Alternative</a> 中第一次明确提出的。BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性(Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。以下两个就是“基本可用”的典型例子。</p>
<p>响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1～2秒。</p>
<p>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</p>
<h4 id="弱状态"><a href="#弱状态" class="headerlink" title="弱状态"></a>弱状态</h4><p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><ul>
<li>强一致性  ：系统任何的数据写入成功后，随后在所有结点所有读取操作都能获取到该写入结果。</li>
<li>弱一致性  ：系统在数据写入成功后，不能保证随后立即可以读取到该写入结果，但是会保证一段时间窗口后肯定能读取到该结果。</li>
<li>最终一致性 ：最终一致性是一种特殊的弱一致性，它是指在上线数据写入成功后，如果没有再对该数据有写入操作，那么在一段时间窗口后所有客户端端都能读取到一致的数据。</li>
</ul>
<h3 id="最终一致性分类"><a href="#最终一致性分类" class="headerlink" title="最终一致性分类"></a>最终一致性分类</h3><p>亚马逊首席技术官Werner Vogels在于2008年发表的一篇经典文章 <a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html" target="_blank" rel="external">Eventually Consistent-Revisited</a>中，对最终一致性进行了非常详细的介绍。他认为最终一致性是一种特殊的弱一致性：系统能够保证在没有其它新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够获取到最新的值。同时，在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟、系统负载和数据复制方案设计等因素。</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种。 </p>
<h4 id="因果一致性（Causal-consistency）"><a href="#因果一致性（Causal-consistency）" class="headerlink" title="因果一致性（Causal consistency）"></a>因果一致性（Causal consistency）</h4><p>因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，即不能发生丢失更新情况。与此同时，与进程A无因果关系的进程C的数据访问则没有这样的限制。</p>
<h4 id="读己之所写（Read-your-writes）"><a href="#读己之所写（Read-your-writes）" class="headerlink" title="读己之所写（Read your writes）"></a>读己之所写（Read your writes）</h4><p>读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值，而不会看到旧值。也就是说，对于单个数据获取者来说，其读取到的数据，一定不会比自己上次写入的值旧。因此，读己之所写也可以看作是一种特殊的因果一致性。</p>
<h4 id="会话一致性（Session-consistency）"><a href="#会话一致性（Session-consistency）" class="headerlink" title="会话一致性（Session consistency）"></a>会话一致性（Session consistency）</h4><p>会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现“读己之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p>
<h4 id="单调读一致性（Monotonic-read-consistency）"><a href="#单调读一致性（Monotonic-read-consistency）" class="headerlink" title="单调读一致性（Monotonic read consistency）"></a>单调读一致性（Monotonic read consistency）</h4><p>单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</p>
<h4 id="单调写一致性（Monotonic-write-consistency）"><a href="#单调写一致性（Monotonic-write-consistency）" class="headerlink" title="单调写一致性（Monotonic write consistency）"></a>单调写一致性（Monotonic write consistency）</h4><p>单调写一致性是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</p>
<h3 id="一致性实现方式"><a href="#一致性实现方式" class="headerlink" title="一致性实现方式"></a>一致性实现方式</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="external">CAP定理</a><br><a href="https://dzone.com/articles/better-explaining-cap-theorem" target="_blank" rel="external">better-explaining-cap-theorem</a><br><a href="https://dzone.com/articles/understanding-the-cap-theorem" target="_blank" rel="external">understanding-the-cap-theorem</a><br><a href="https://www.allthingsdistributed.com/2008/12/eventually_consistent.html" target="_blank" rel="external">eventually_consistent</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CAP定理&quot;&gt;&lt;a href=&quot;#CAP定理&quot; class=&quot;headerlink&quot; title=&quot;CAP定理&quot;&gt;&lt;/a&gt;CAP定理&lt;/h3&gt;&lt;p&gt;在理论计算机科学中，&lt;code&gt;CAP定理&lt;/code&gt;（CAP theorem），又被称作&lt;code&gt;布鲁尔定理&lt;/code&gt;（Brewer’s theorem），它指出对于一个&lt;code&gt;分布式存储系统&lt;/code&gt;来说，不可能同时满足以下三点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性（Consistence） 每次读取都能获取最新的写入或一个&lt;code&gt;ERROR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可用性（Availability）（每次请求都能获取到非&lt;code&gt;ERROR&lt;/code&gt;的响应 – 但是不保证获取的数据为最新数据）&lt;/li&gt;
&lt;li&gt;分区容错性（Network partitioning）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致(&lt;code&gt;全部不更新能保证一致性&lt;/code&gt;)，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://leokongwq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>kotlin之coroutine学习笔记</title>
    <link href="https://leokongwq.github.io/2018/01/10/kotlin-coroutine-learn.html"/>
    <id>https://leokongwq.github.io/2018/01/10/kotlin-coroutine-learn.html</id>
    <published>2018-01-10T11:17:15.000Z</published>
    <updated>2018-01-27T12:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line">@Throws(InterruptedException::class)</span>
<span class="line">public fun &lt;T&gt; runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123;</span>
<span class="line">    val currentThread = Thread.currentThread()</span>
<span class="line">    val eventLoop = if (context[ContinuationInterceptor] == null) BlockingEventLoop(currentThread) else null</span>
<span class="line">    val newContext = newCoroutineContext(context + (eventLoop ?: EmptyCoroutineContext))</span>
<span class="line">    val coroutine = BlockingCoroutine&lt;T&gt;(newContext, currentThread, privateEventLoop = eventLoop != null)</span>
<span class="line">    coroutine.initParentJob(context[Job])</span>
<span class="line">    block.startCoroutine(coroutine, coroutine)</span>
<span class="line">    return coroutine.joinBlocking()</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建一个<code>coroutine</code>并且阻塞当前线程直到区块执行完毕，这个一般是用于桥接一般的阻塞式编程方式到<code>coroutine</code>编程方式的，不应该在已经是<code>coroutine</code>的地方使用。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><h4 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> suspend fun &lt;T&gt; run(</span>
<span class="line">    context: CoroutineContext,</span>
<span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span>
<span class="line">    block: suspend () -&gt; T</span>
<span class="line">): T = suspendCoroutineOrReturn sc@ &#123; cont -&gt;</span>
<span class="line">    val oldContext = cont.context</span>
<span class="line">    <span class="comment">// fast path #1 if there is no change in the actual context:</span></span>
<span class="line">    <span class="keyword">if</span> (context === oldContext || context is CoroutineContext.Element &amp;&amp; oldContext[context.key] === context)</span>
<span class="line">        <span class="keyword">return</span><span class="meta">@sc</span> block.startCoroutineUninterceptedOrReturn(cont)</span>
<span class="line">    <span class="comment">// compute new context</span></span>
<span class="line">    val newContext = oldContext + context</span>
<span class="line">    <span class="comment">// fast path #2 if the result is actually the same</span></span>
<span class="line">    <span class="keyword">if</span> (newContext === oldContext)</span>
<span class="line">        <span class="keyword">return</span><span class="meta">@sc</span> block.startCoroutineUninterceptedOrReturn(cont)</span>
<span class="line">    <span class="comment">// fast path #3 if the new dispatcher is the same as the old one.</span></span>
<span class="line">    <span class="comment">// `equals` is used by design (see equals implementation is wrapper context like ExecutorCoroutineDispatcher)</span></span>
<span class="line">    <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span>
<span class="line">        val newContinuation = RunContinuationDirect(newContext, cont)</span>
<span class="line">        <span class="keyword">return</span><span class="meta">@sc</span> block.startCoroutineUninterceptedOrReturn(newContinuation)</span>
<span class="line">    &#125;</span>
<span class="line">    <span class="comment">// slowest path otherwise -- use new interceptor, sync to its result via a full-blown instance of RunCompletion</span></span>
<span class="line">    require(!start.isLazy) &#123; <span class="string">"$start start is not supported"</span> &#125;</span>
<span class="line">    val completion = RunCompletion(</span>
<span class="line">        context = newContext,</span>
<span class="line">        delegate = cont,</span>
<span class="line">        resumeMode = <span class="keyword">if</span> (start == CoroutineStart.ATOMIC) MODE_ATOMIC_DEFAULT <span class="keyword">else</span> MODE_CANCELLABLE)</span>
<span class="line">    completion.initParentJob(newContext[Job]) <span class="comment">// attach to job</span></span>
<span class="line">    start(block, completion)</span>
<span class="line">    completion.getResult()</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>在指定的<code>CoroutineContext</code>中调用指定的<code>suspend</code>区块。 该方法会导致当前<code>CoroutineContext</code>中的<code>coroutine</code>挂起并等待该代码块执行完毕。</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><h4 id="声明-2"><a href="#声明-2" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> fun <span class="title">launch</span><span class="params">(</span>
<span class="line">    context: CoroutineContext = DefaultDispatcher,</span>
<span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span>
<span class="line">    block: suspend CoroutineScope.()</span> -&gt; Unit</span>
<span class="line">): Job </span>&#123;</span>
<span class="line">    val newContext = newCoroutineContext(context)</span>
<span class="line">    val coroutine = <span class="keyword">if</span> (start.isLazy)</span>
<span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span>
<span class="line">        StandaloneCoroutine(newContext, active = <span class="keyword">true</span>)</span>
<span class="line">    coroutine.initParentJob(context[Job])</span>
<span class="line">    start(block, coroutine, coroutine)</span>
<span class="line">    <span class="keyword">return</span> coroutine</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>创建运行在<code>CoroutineContext</code>中的<code>coroutine</code>，返回的<code>Job</code>支持取消、启动等操作，不会挂起父<code>coroutine</code>上下文；可以在非<code>coroutine</code>中调用。</p>
<p>参数<code>context</code>可以显示指定。默认为<code>DefaultDispatcher</code>。<br>参数<code>start</code>表示<code>coroutine</code>的启动选项。默认为<code>CoroutineStart.DEFAULT</code><br>参数<code>block</code>表示<code>coroutine</code>里面执行的代码。</p>
<p>默认请情况下，coroutine是会被立即调度执行的。如果参数<code>start</code>的值为<code>CoroutineStart.LAZY</code>，那么会返回一个新建状态的<code>coroutine</code>。 可以通过显示调用<code>Job.start()</code>方法来启动该<code>coroutine</code>。</p>
<p>如果在该<code>coroutine</code>里面有未捕获的异常，那么会导致该<code>coroutine</code>的父<code>coroutine</code>取消。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><h4 id="声明-3"><a href="#声明-3" class="headerlink" title="声明"></a>声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> fun &lt;T&gt; async(</span>
<span class="line">    context: CoroutineContext = DefaultDispatcher,</span>
<span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span>
<span class="line">    block: suspend CoroutineScope.() -&gt; T</span>
<span class="line">): Deferred&lt;T&gt; &#123;</span>
<span class="line">    val newContext = newCoroutineContext(context)</span>
<span class="line">    val coroutine = <span class="keyword">if</span> (start.isLazy)</span>
<span class="line">        LazyDeferredCoroutine(newContext, block) <span class="keyword">else</span></span>
<span class="line">        DeferredCoroutine&lt;T&gt;(newContext, active = <span class="keyword">true</span>)</span>
<span class="line">    coroutine.initParentJob(context[Job])</span>
<span class="line">    start(block, coroutine, coroutine)</span>
<span class="line">    <span class="keyword">return</span> coroutine</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>创建运行在CoroutineContext中的coroutine，并且带回返回值(返回的是Deferred，我们可以通过await等方式获得返回值)</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.dreamtobe.cn/kotlin-coroutines/" target="_blank" rel="external">Kotlin Coroutines(协程)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;runBlocking&quot;&gt;&lt;a href=&quot;#runBlocking&quot; class=&quot;headerlink&quot; title=&quot;runBlocking&quot;&gt;&lt;/a&gt;runBlocking&lt;/h3&gt;&lt;h4 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h4&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Throws(InterruptedException::class)&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;public fun &amp;lt;T&amp;gt; runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -&amp;gt; T): T &amp;#123;&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    val currentThread = Thread.currentThread()&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    val eventLoop = if (context[ContinuationInterceptor] == null) BlockingEventLoop(currentThread) else null&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    val newContext = newCoroutineContext(context + (eventLoop ?: EmptyCoroutineContext))&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    val coroutine = BlockingCoroutine&amp;lt;T&amp;gt;(newContext, currentThread, privateEventLoop = eventLoop != null)&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    coroutine.initParentJob(context[Job])&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    block.startCoroutine(coroutine, coroutine)&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;    return coroutine.joinBlocking()&lt;/span&gt;
&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="kotlin" scheme="https://leokongwq.github.io/categories/kotlin/"/>
    
    
  </entry>
  
  <entry>
    <title>mac上禁止jenkins自启动</title>
    <link href="https://leokongwq.github.io/2018/01/10/mac-autostart.html"/>
    <id>https://leokongwq.github.io/2018/01/10/mac-autostart.html</id>
    <published>2018-01-10T07:43:30.000Z</published>
    <updated>2018-01-15T07:19:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本机安装了Jenkins后，每次开机都会自启动。浪费资源不说，主要是占用了<code>8080</code>这个人见人爱的端口。 通过下面的办法可以禁止它的自启动。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">launchctl unload -w /Library/LaunchDaemons/org.jenkins-ci.plist</span>
</pre></td></tr></table></figure>
<p>通过这个例子指定，OSX上启动的的脚本都是放在目录<code>/Library/LaunchDaemons</code>下。该目录下的每个文件都是有特殊格式的。</p>
<p>如果想要制作自启动脚本，可以参考这个目录下的脚本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;本机安装了Jenkins后，每次开机都会自启动。浪费资源不说，主要是占用了&lt;code&gt;8080&lt;/code&gt;这个人见人爱的端口。 通过下面的
    
    </summary>
    
    
      <category term="osx" scheme="https://leokongwq.github.io/tags/osx/"/>
    
  </entry>
  
  <entry>
    <title>Gossip算法介绍</title>
    <link href="https://leokongwq.github.io/2018/01/01/gossip-intro.html"/>
    <id>https://leokongwq.github.io/2018/01/01/gossip-intro.html</id>
    <published>2018-01-01T06:31:59.000Z</published>
    <updated>2018-01-01T06:53:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自：<a href="http://blog.csdn.net/chen77716/article/details/6275762" target="_blank" rel="external">Gossip算法</a></p>
<p>Gossip算法因为Cassandra而名声大噪，Gossip看似简单，但要真正弄清楚其本质远没看起来那么容易。为了寻求Gossip的本质，下面的内容主要参考Gossip的原始论文：&lt;<efficient reconciliation="" and="" flow="" control="" for="" anti-entropy="" protocols="">&gt;。</efficient></p>
<h3 id="Gossip背景"><a href="#Gossip背景" class="headerlink" title="Gossip背景"></a>Gossip背景</h3><p>Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。</p>
<p>但Gossip并不是一个新东西，之前的泛洪查找、路由算法都归属于这个范畴，不同的是Gossip给这类算法提供了明确的语义、具体实施方法及收敛性证明。</p>
<a id="more"></a>
<h3 id="Gossip特点"><a href="#Gossip特点" class="headerlink" title="Gossip特点"></a>Gossip特点</h3><p>Gossip算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致，这充分说明了Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p>
<p>要注意到的一点是，即使有的节点因宕机而重启，有新节点加入，但经过一段时间后，这些节点的状态也会与其他节点达成一致，也就是说，Gossip天然具有分布式容错的优点。</p>
<h3 id="Gossip本质"><a href="#Gossip本质" class="headerlink" title="Gossip本质"></a>Gossip本质</h3><p>Gossip是一个带冗余的容错算法，更进一步，Gossip是一个最终一致性算法。虽然无法保证在某个时刻所有节点状态一致，但可以保证在”最终“所有节点一致，”最终“是一个现实中存在，但理论上无法证明的时间点。</p>
<p>因为Gossip不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，不需要任何的中心节点。实际上Gossip可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。</p>
<p>但Gossip的缺点也很明显，冗余通信会对网路带宽、CUP资源造成很大的负载，而这些负载又受限于通信频率，该频率又影响着算法收敛的速度，后面我们会讲在各种场合下的优化方法。</p>
<h3 id="Gossip节点的通信方式及收敛性"><a href="#Gossip节点的通信方式及收敛性" class="headerlink" title="Gossip节点的通信方式及收敛性"></a>Gossip节点的通信方式及收敛性</h3><p>根据原论文，两个节点（A、B）之间存在三种通信方式:</p>
<ul>
<li>push: A节点将数据(key,value,version)及对应的版本号推送给B节点，B节点更新A中比自己新的数据</li>
<li>pull：A仅将数据key,version推送给B，B将本地比A新的数据（Key,value,version）推送给A，A更新本地</li>
<li>push/pull：与pull类似，只是多了一步，A再将本地比B新的数据推送给B，B更新本地<br>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push需通信1次，pull需2次，push/pull则需3次，从效果上来讲，push/pull最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull的收敛速度是最快的。</li>
</ul>
<p>假设每个节点通信周期都能选择（感染）一个新节点，则Gossip算法退化为一个二分查找过程，每个周期构成一个平衡二叉树，收敛速度为$O(n^2)$，对应的时间开销则为$O(logN)$。这也是Gossip理论上最优的收敛速度。但在实际情况中最优收敛速度是很难达到的，假设某个节点在第<code>i</code>个周期被感染的概率为$p_i$ ,第<code>i+1</code>个周期被感染的概率为$p_i+1$ ，则pull的方式:</p>
<p>$p_i+1=p_i^2$</p>
<p>而push为：</p>
<p>$p_i+1=p_i(1-\frac{1}{n})^{n(1-p_i)}$</p>
<p>显然pull的收敛速度大于push，而每个节点在每个周期被感染的概率都是固定的p(0&lt;p&lt;1)，因此Gossip算法是基于p的平方收敛，也成为概率收敛，这在众多的一致性算法中是非常独特的。</p>
<p>每个Gossip的节点的工作方式又分两种：</p>
<ul>
<li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li>
<li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li>
</ul>
<p>Anti-Entropy模式有完全的容错性，但有较大的网络、CPU负载；Rumor-Mongering模式有较小的网络、CPU负载，但必须为数据定义”最新“的边界，并且难以保证完全容错，对失败重启且超过”最新“期限的节点，无法保证最终一致性，或需要引入额外的机制处理不一致性。我们后续着重讨论Anti-Entropy模式的优化。</p>
<h3 id="Anti-Entropy的协调机制"><a href="#Anti-Entropy的协调机制" class="headerlink" title="Anti-Entropy的协调机制"></a>Anti-Entropy的协调机制</h3><p>协调机制是讨论在每次2个节点通信时，如何交换数据能达到最快的一致性，也即消除两个节点的不一致性。上面所讲的push、pull等是通信方式，协调是在通信方式下的数据交换机制。协调所面临的最大问题是，因为受限于网络负载，不可能每次都把一个节点上的数据发送给另外一个节点，也即每个Gossip的消息大小都有上限。在有限的空间上有效率地交换所有的消息是协调要解决的主要问题。</p>
<p>在讨论之前先声明几个概念：</p>
<ul>
<li>令N = {p,q,s,…}为需要gossip通信的server集合，有界大小</li>
<li>令(p1,p2,…)是宿主在节点p上的数据，其中数据有(key,value,version)构成，q的规则与p类似。</li>
</ul>
<p>为了保证一致性，规定数据的value及version只有宿主节点才能修改，其他节点只能间接通过Gossip协议来请求数据对应的宿主节点修改。</p>
<h4 id="精确协调（Precise-Reconciliation）"><a href="#精确协调（Precise-Reconciliation）" class="headerlink" title="精确协调（Precise Reconciliation）"></a>精确协调（Precise Reconciliation）</h4><p>精确协调希望在每次通信周期内都非常准确地消除双方的不一致性，具体表现为相互发送对方需要更新的数据，因为每个节点都在并发与多个节点通信，理论上精确协调很难做到。精确协调需要给每个数据项独立地维护自己的version，在每次交互是把所有的(key,value,version)发送到目标进行比对，从而找出双方不同之处从而更新。但因为Gossip消息存在大小限制，因此每次选择发送哪些数据就成了问题。当然可以随机选择一部分数据，也可确定性的选择数据。对确定性的选择而言，可以有最老优先（根据版本）和最新优先两种，最老优先会优先更新版本最新的数据，而最新更新正好相反，这样会造成老数据始终得不到机会更新，也即饥饿。</p>
<p>当然，开发这也可根据业务场景构造自己的选择算法，但始终都无法避免消息量过多的问题。</p>
<h4 id="整体协调（Scuttlebutt-Reconciliation）"><a href="#整体协调（Scuttlebutt-Reconciliation）" class="headerlink" title="整体协调（Scuttlebutt Reconciliation）"></a>整体协调（Scuttlebutt Reconciliation）</h4><p>整体协调与精确协调不同之处是，整体协调不是为每个数据都维护单独的版本号，而是为每个节点上的宿主数据维护统一的version。比如节点P会为(p1,p2,…)维护一个一致的全局version，相当于把所有的宿主数据看作一个整体，当与其他节点进行比较时，只需必须这些宿主数据的最高version，如果最高version相同说明这部分数据全部一致，否则再进行精确协调。</p>
<p>整体协调对数据的选择也有两种方法：</p>
<ul>
<li>广度优先：根据整体version大小排序，也称为公平选择</li>
<li>深度优先：根据包含数据多少的排序，也称为非公平选择。因为后者更有实用价值，所以原论文更鼓励后者</li>
</ul>
<h3 id="Cassandra中的实现"><a href="#Cassandra中的实现" class="headerlink" title="Cassandra中的实现"></a>Cassandra中的实现</h3><p>经过验证，Cassandra实现了基于整体协调的push/push模式，有几个组件：</p>
<p>三条消息分别对应push/pull的三个阶段：</p>
<ul>
<li>GossipDigitsMessage</li>
<li>GossipDigitsAckMessage</li>
<li>GossipDigitsAck2Message</li>
</ul>
<p>还有三种状态：</p>
<ul>
<li>EndpointState：维护宿主数据的全局version，并封装了HeartBeat和ApplicationState</li>
<li>HeartBeat：心跳信息</li>
<li>ApplicationState：系统负载信息（磁盘使用率）</li>
</ul>
<p>Cassandra主要是使用Gossip完成三方面的功能：</p>
<ul>
<li>失败检测</li>
<li>动态负载均衡</li>
<li>去中心化的弹性扩展</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Gossip是一种去中心化、容错而又最终一致性的绝妙算法，其收敛性不但得到证明还具有指数级的收敛速度。使用Gossip的系统可以很容易的把Server扩展到更多的节点，满足弹性扩展轻而易举。</p>
<p>唯一的缺点是收敛是最终一致性，不使用那些强一致性的场景，比如2pc。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自：&lt;a href=&quot;http://blog.csdn.net/chen77716/article/details/6275762&quot;&gt;Gossip算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gossip算法因为Cassandra而名声大噪，Gossip看似简单，但要真正弄清楚其本质远没看起来那么容易。为了寻求Gossip的本质，下面的内容主要参考Gossip的原始论文：&amp;lt;&lt;Efficient Reconciliation and Flow Control for Anti-Entropy Protocols&gt;&amp;gt;。&lt;/p&gt;
&lt;h3 id=&quot;Gossip背景&quot;&gt;&lt;a href=&quot;#Gossip背景&quot; class=&quot;headerlink&quot; title=&quot;Gossip背景&quot;&gt;&lt;/a&gt;Gossip背景&lt;/h3&gt;&lt;p&gt;Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。&lt;/p&gt;
&lt;p&gt;但Gossip并不是一个新东西，之前的泛洪查找、路由算法都归属于这个范畴，不同的是Gossip给这类算法提供了明确的语义、具体实施方法及收敛性证明。&lt;/p&gt;
    
    </summary>
    
    
      <category term="gossip" scheme="https://leokongwq.github.io/tags/gossip/"/>
    
  </entry>
  
  <entry>
    <title>consul和其它软件的比较</title>
    <link href="https://leokongwq.github.io/2018/01/01/consul-vs-other-software.html"/>
    <id>https://leokongwq.github.io/2018/01/01/consul-vs-other-software.html</id>
    <published>2018-01-01T00:10:17.000Z</published>
    <updated>2018-01-01T00:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Consul-vs-ZooKeeper-doozerd-etcd"><a href="#Consul-vs-ZooKeeper-doozerd-etcd" class="headerlink" title="Consul vs. ZooKeeper, doozerd, etcd"></a>Consul vs. ZooKeeper, doozerd, etcd</h3><p>ZooKeeper、Doozerd、Etcd在架构上都非常相似，它们都有服务节点（server node），而这些服务节点的操作都要求达到节点的仲裁数（通常，节点的仲裁数遵循的是简单多数原则）。此外，它们都是强一致性的，并且提供各种原语。通过应用程序内部的客户端lib库，这些原语可以用来构建复杂的分布式系统。</p>
<p>在一个单一的数据中心内部，Consul同样使用多个服务节点。在每个数据中心中，为了Consule能够运行，并且保持强一致性，Consul服务端需要仲裁。然而，Consul原生支持多数据中心，就像一个丰富gossip系统连接服务器节点和客户端一样。</p>
<p>当提供K/V存储的时候，这些系统具有大致相同的语义，读操作是强一致性的，并且在面对网络分区的时候，为了保证读操作的强一致性，牺牲了可用性。然而，当系统应用于复杂情况时，这种差异会变得更加明显。</p>
<p>这些系统提供的语义对构建服务发现系统的开发人员很有吸引力，但更重要的是，它们强制开发人员自己构建这些特性。ZooKeeper只提供一个原始的K/V存储，并要求开发人员构建他们自己的系统来提供服务发现功能。相反的是，Consul提供了一个坚固的框架，这不仅仅是为了提供服务发现功能，也是为了减少推测工作和开发工作量。客户端只需简单地完成服务注册工作，然后使用一个DNS接口或者HTTP接口就可以执行工作了，而其他系统则需要你定制自己的解决方案。</p>
<p>一个令人信服的服务发现框架必须包含健康检测功能，并且考虑失败的可能性。要是节点失败或者服务故障了，即使开发人员知道节点A提供Foo服务也是没用的。Navie系统利用心跳检测，周期性的更新服务或结点的TTL值。这种模式会导致检测工作随着结点的数目的增加而线性增加，并且限制了服务器的数量。此外，故障检测窗口的存活时间至少要和TTL一样长。</p>
<p>ZooKeeper提供了临时节点，这些临时节点就是K/V条目，当客户端断开连接时，这些条目会被删除。虽然这些临时节点比一个心跳系统更高级，但仍存在固有的扩展性问题，并且会增加客户端的复杂性。与ZooKeeper服务器端连接时，客户端必须保持活跃，并且去做持续性连接。此外，ZooKeeper还需要胖客户端，而胖客户端是很难编写，并且胖客户端会经常导致调试质询。</p>
<p>Consul使用一个完全不同的架构进行结点的健康检测。这个架构中不仅仅只有Consul服务结点，集群中的每一个节点上都会运行一个Consul客户端。这些Consul客户端属于一个gossip pool，gossip pool提供了一些功能，包括分布式健康检测。gossip协议提供了一个高效的故障检测工具，这个故障检测工具可以应用到任意规模的集群，而不仅仅是作用于特定的服务器组。同时，这个故障检测工具也支持在本地进行多种健康检测。与此相反，ZooKeeper的临时节点只是一个非常原始的活跃度检测。因为有了Consul，客户端可以检测web服务器是否正在返回200状态码，内存利用率是否达到临界点，是否有足够的数据存储盘等。此外，ZooKeeper会暴露系统的复杂性给客户端，为了避免ZooKeeper出现的这种情况，Consul只提供一个简单HTTP接口。</p>
<p>Consul为服务发现、健康检测、K/V存储和多数据中心提供了一流的支持。为了支持任意存储，而不仅仅是简单的K/V存储，其它系统都要求工具和lib库要率先建立。然而，通过使用客户端节点，Consul提供了一个简单的API，这个API的开发只需要瘦客户端就可以了， 而且通过使用配置文件和DNS接口，开发人员可以建立完整的服务发现解决方案，最终，达到避免开发API的目的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Consul-vs-ZooKeeper-doozerd-etcd&quot;&gt;&lt;a href=&quot;#Consul-vs-ZooKeeper-doozerd-etcd&quot; class=&quot;headerlink&quot; title=&quot;Consul vs. ZooKeeper, doozer
    
    </summary>
    
    
      <category term="consul" scheme="https://leokongwq.github.io/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>consul快速启动</title>
    <link href="https://leokongwq.github.io/2017/12/31/consul-quick-start.html"/>
    <id>https://leokongwq.github.io/2017/12/31/consul-quick-start.html</id>
    <published>2017-12-31T01:25:12.000Z</published>
    <updated>2017-12-31T12:50:31.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>该文章翻译自 <a href="https://www.consul.io/intro/index.html" target="_blank" rel="external">https://www.consul.io/intro/index.html</a></p>
<p>这篇文章的目标是对Consul进行一个简单的介绍。包括Consul是什么，它解决了什么问题，它有哪些功能。通过这篇文章能让你对Consul能有一个大致的了解，和基本的使用。</p>
<h3 id="What-is-Consul"><a href="#What-is-Consul" class="headerlink" title="What is Consul?"></a>What is Consul?</h3><hr>
<p>Consul 有许多组件，但是作为一个整理来看，它为你的基础设施提供了服务发现和统一配置功能。它提供如下的主要的功能：</p>
<a id="more"></a>
<ul>
<li>服务发现: Consul 的客户端可以在Consul上注册服务，如 API 或 mysql。并且其它的客户端可以通过Consul来发现这些服务。通过 DNS 或 HTTP接口，应用程序可以很容易的发现它们依赖的服务。</li>
<li>健康检查: Consul客户端可以提供任何数量的健康检查，或者与给定的服务相关联（“Web服务器返回200 OK”），或者与本地节点（“内存利用率低于90％”）相关联。 操作员可以使用此信息来监视群集运行状况，服务发现组件使用此信息将流量从不健康的主机中引导出去。</li>
<li>KV 存储: 应用可以通过使用Consul提供的具有继承结构的 <code>Key/Value</code> 存储来实现任何需要的功能，包括动态配置， 特征标记，协调，领导选举等等。 Consul提供了简单的HTTP API是该功能非常容易使用。</li>
<li>多数据中心: Consul支持多个数据中心。 这意味着Consul的用户不必担心构建额外的抽象层以扩展到多个区域。</li>
</ul>
<p>Consul设计的目标是对DevOps社区和应用程序开发人员友好，使其成为现代化，弹性基础架构的完美选择。</p>
<h3 id="Basic-Architecture-of-Consul"><a href="#Basic-Architecture-of-Consul" class="headerlink" title="Basic Architecture of Consul"></a>Basic Architecture of Consul</h3><hr>
<p>Consul是一个分布式，高可用的系统。本节将介绍基础知识，故意省略一些不必要的细节，以便你快速了解Consul的工作原理。有关更多详细信息，请参阅<a href="https://www.consul.io/docs/internals/architecture.html" target="_blank" rel="external">深入了解Consul架构细节</a>。</p>
<p>向Consul提供服务的每个节点都运行一个Consul Agent。运行一个Consul代理不是用来发现其他服务或操作键值对数据。不需要运行代理。该代理的目的是负责对该结点提供的服务和其本身进行健康检查。</p>
<p>该Consul Agent与一个或多个Consul Server进行通信。Consul Server是数据存储和复制的地方。服务器自己选出一位Leader。虽然Consul可以在一台服务器上运行，但建议部署3个或5个结点，以避免数据丢失故障的发生。每个数据中心都建议使用一组Consul服务器。</p>
<p>需要发现其它服务或节点的基础架构组件可以查询任何Consul服务器或任何Consul代理。代理自动将查询转发到服务器。</p>
<p>每个数据中心都运行Consul服务器集群。当发生跨数据中心服务发现或配置请求时，本地Consul服务器将请求转发到远程数据中心并返回结果。</p>
<h3 id="Installing-Consul"><a href="#Installing-Consul" class="headerlink" title="Installing Consul"></a>Installing Consul</h3><hr>
<p>安装Consul非常简单。<a href="https://www.consul.io/downloads.html" target="_blank" rel="external">下载</a>目标平台的安装文件，解压或安装到指定目录，并添加到系统PATH中就可以了。</p>
<h4 id="Verifying-the-Installation"><a href="#Verifying-the-Installation" class="headerlink" title="Verifying the Installation"></a>Verifying the Installation</h4><p>安装完Consul收，在命令行执行<code>consul</code>，如果有如下的输出，则表示consul安装成功了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">$ consul</span>
<span class="line">usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]</span>
<span class="line"></span>
<span class="line">Available commands are:</span>
<span class="line">    agent          Runs a Consul agent</span>
<span class="line">    event          Fire a new event</span>
<span class="line"></span>
<span class="line"># ...</span>
</pre></td></tr></table></figure>
<h3 id="Run-the-Consul-Agent"><a href="#Run-the-Consul-Agent" class="headerlink" title="Run the Consul Agent"></a>Run the Consul Agent</h3><p>For more detail on bootstrapping a datacenter, see this guide.</p>
<p>Consul安装完成后，必须启动Consul Agent。该agent可以允许在<code>Server</code>模式和<code>Client</code>模式。 每一个数据中心至少需要一个Server，但是推荐一个Consul集群至少包含3个或5个Consul Server结点。只有一个Consul Server结点是不推荐的，因为很可能丢失数据，在开发环境可以这么做。</p>
<p>所有其它的agent运行在client模式。 一个client模式的agent是一个非常轻量级的进程，它会注册服务，执行监控检测，并将请求转发到Server。组成集群的每个结点都必须运行一个agent。</p>
<p>在一个数据中心搭建Consul集群可以参考<a href="https://www.consul.io/docs/guides/bootstrapping.html" target="_blank" rel="external">https://www.consul.io/docs/guides/bootstrapping.html</a></p>
<h4 id="Starting-the-Agent"><a href="#Starting-the-Agent" class="headerlink" title="Starting the Agent"></a>Starting the Agent</h4><hr>
<p>为了简单起见，我们现在将以开发模式启动Consul agent。 这种模式对于快速简单地启动单节点Consul环境非常有用。 它并不打算在生产中使用，因为它不会持续任何状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
</pre></td><td class="code"><pre><span class="line">-$ consul agent -dev</span>
<span class="line">==&gt; Starting Consul agent...</span>
<span class="line">==&gt; Starting Consul agent RPC...</span>
<span class="line">==&gt; Consul agent running!</span>
<span class="line">           Version: &apos;v0.7.0&apos;</span>
<span class="line">         Node name: &apos;Armons-MacBook-Air&apos;</span>
<span class="line">        Datacenter: &apos;dc1&apos;</span>
<span class="line">            Server: true (bootstrap: false)</span>
<span class="line">       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)</span>
<span class="line">      Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302)</span>
<span class="line">    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false</span>
<span class="line">             Atlas: &lt;disabled&gt;</span>
<span class="line"></span>
<span class="line">==&gt; Log data will now stream in as it occurs:</span>
<span class="line"></span>
<span class="line">2016/09/15 10:21:10 [INFO] raft: Initial configuration (index=1): [&#123;Suffrage:Voter ID:127.0.0.1:8300 Address:127.0.0.1:8300&#125;]</span>
<span class="line">2016/09/15 10:21:10 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &quot;&quot;)</span>
<span class="line">2016/09/15 10:21:10 [INFO] serf: EventMemberJoin: Armons-MacBook-Air 127.0.0.1</span>
<span class="line">2016/09/15 10:21:10 [INFO] serf: EventMemberJoin: Armons-MacBook-Air.dc1 127.0.0.1</span>
<span class="line">2016/09/15 10:21:10 [INFO] consul: Adding LAN server Armons-MacBook-Air (Addr: tcp/127.0.0.1:8300) (DC: dc1)</span>
<span class="line">2016/09/15 10:21:10 [INFO] consul: Adding WAN server Armons-MacBook-Air.dc1 (Addr: tcp/127.0.0.1:8300) (DC: dc1)</span>
<span class="line">2016/09/15 10:21:13 [DEBUG] http: Request GET /v1/agent/services (180.708µs) from=127.0.0.1:52369</span>
<span class="line">2016/09/15 10:21:13 [DEBUG] http: Request GET /v1/agent/services (15.548µs) from=127.0.0.1:52369</span>
<span class="line">2016/09/15 10:21:17 [WARN] raft: Heartbeat timeout from &quot;&quot; reached, starting election</span>
<span class="line">2016/09/15 10:21:17 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2</span>
<span class="line">2016/09/15 10:21:17 [DEBUG] raft: Votes needed: 1</span>
<span class="line">2016/09/15 10:21:17 [DEBUG] raft: Vote granted from 127.0.0.1:8300 in term 2. Tally: 1</span>
<span class="line">2016/09/15 10:21:17 [INFO] raft: Election won. Tally: 1</span>
<span class="line">2016/09/15 10:21:17 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state</span>
<span class="line">2016/09/15 10:21:17 [INFO] consul: cluster leadership acquired</span>
<span class="line">2016/09/15 10:21:17 [DEBUG] consul: reset tombstone GC to index 3</span>
<span class="line">2016/09/15 10:21:17 [INFO] consul: New leader elected: Armons-MacBook-Air</span>
<span class="line">2016/09/15 10:21:17 [INFO] consul: member &apos;Armons-MacBook-Air&apos; joined, marking health alive</span>
<span class="line">2016/09/15 10:21:17 [INFO] agent: Synced service &apos;consul&apos;</span>
<span class="line">```    </span>
<span class="line"></span>
<span class="line">如你所见， Consul agent已经启动了并输出一些日志数据。从日志数据可以知道该agent运行在`Server`模式并且是整个集群的Leader。此外，本地成员被标记为集群中的监控结点。</span>
<span class="line"></span>
<span class="line">&gt; Note for OS X Users: Consul uses your hostname as the default node name. If your hostname contains periods, DNS queries to that node will not work with Consul. To avoid this, explicitly set the name of your node with the -node flag.</span>
<span class="line"></span>
<span class="line">### Cluster Members</span>
<span class="line"></span>
<span class="line">在一个终端窗口执行命令：`consul members`，你可以知道Consul集群的所有成员信息。在后面的章节中我们会介绍如何加入集群，但是现在，你只能看到一个结点，那就是你自己。</span>
<span class="line"></span>
<span class="line">```shell</span>
<span class="line">$ consul members</span>
<span class="line">Node                Address            Status  Type    Build     Protocol  DC</span>
<span class="line">Armons-MacBook-Air  172.20.20.11:8301  alive   server  0.6.1dev  2         dc1</span>
</pre></td></tr></table></figure>
<p>命令<code>consul members</code>的输出显示了我们自己的节点，它正在运行的地址，运行状况，在集群中的角色以及一些版本信息。 额外的元数据可以通过提供<code>-detailed</code>标志来查看。</p>
<p><code>consul members</code>命令的输出基于<a href="https://www.consul.io/docs/internals/gossip.html" target="_blank" rel="external">gossip协议</a>，并且是最终一致的。 也就是说，在任何时候，本地agent所看到的数据可能与服务器上的状态不完全一致。 要获得一致的数据，可以通过HTTP API 查询 Consul Server结点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ curl localhost:8500/v1/catalog/nodes</span>
<span class="line">[&#123;&quot;Node&quot;:&quot;Armons-MacBook-Air&quot;,&quot;Address&quot;:&quot;127.0.0.1&quot;,&quot;TaggedAddresses&quot;:&#123;&quot;lan&quot;:&quot;127.0.0.1&quot;,&quot;wan&quot;:&quot;127.0.0.1&quot;&#125;,&quot;CreateIndex&quot;:4,&quot;ModifyIndex&quot;:110&#125;]</span>
</pre></td></tr></table></figure>
<p>除了HTTP API， 也可以通过DNS接口来查询结点的信息。但需要注意的是你的查询需要指定Consul的DNS服务器信息（默认端口是8600）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 -p 8600 Armons-MacBook-Air.node.consul</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;Armons-MacBook-Air.node.consul.    IN  A</span>
<span class="line"></span>
<span class="line">;; ANSWER SECTION:</span>
<span class="line">Armons-MacBook-Air.node.consul. 0 IN    A   127.0.0.1</span>
<span class="line">»</span>
</pre></td></tr></table></figure>
<h3 id="Stopping-the-Agent"><a href="#Stopping-the-Agent" class="headerlink" title="Stopping the Agent"></a>Stopping the Agent</h3><p>你可以使用<code>Ctrl-C</code>(中断信号)来优雅的关闭agent。在中断agent后，你可以看到该agent已经离开了集群并且处于关闭状态。</p>
<p>通过优雅地离开，Consul通知其它集群成员该节点离开。 如果你强行杀死了代理进程，则群集的其它成员将检测到该节点失败。 成员离开时，它的服务和检查信息将从<code>catalog</code>中删除。 当一个成员失败时，其健康被简单地标记为关键，但不会从目录中删除。 Consul将自动尝试重新连接到失败的节点，使其能够从特定的网络条件恢复，直到该结点再也联系不到。</p>
<p>此外，如果一个agent是作为<code>server</code>模式运行，那么优雅的离开是非常重要的，因为这会导致<a href="https://www.consul.io/docs/internals/consensus.html" target="_blank" rel="external">共识协议</a>潜在的不可用。 有关如何安全地添加和删除服务器的详细信息，请参阅<a href="https://www.consul.io/docs/guides/index.html" target="_blank" rel="external">指南</a>部分。</p>
<h3 id="Registering-Services"><a href="#Registering-Services" class="headerlink" title="Registering Services"></a>Registering Services</h3><h4 id="Defining-a-Service"><a href="#Defining-a-Service" class="headerlink" title="Defining a Service"></a>Defining a Service</h4><hr>
<p>服务的注册既可以通过提供服务定义，也可以通过调用Consul提供的服务注册HTTP API。</p>
<p>服务定义是注册服务最常用的方式，因此我们将在这一步中使用该方法。</p>
<p>首先，为Consul配置创建一个目录。 Consul将所有配置文件加载到配置目录中，因此Unix系统上的一个通用约定是将目录命名为<code>/etc/consul.d</code>（.d后缀意味着“该目录包含一组配置文件”）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/consul.d</span>
</pre></td></tr></table></figure>
<p>下面我们创建一个服务定义文件。我们假设一个名为<code>web</code>的服务运行在<code>80</code>端口。此外我们还给该服务指定了一个标签： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ echo &apos;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;web&quot;, &quot;tags&quot;: [&quot;rails&quot;], &quot;port&quot;: 80&#125;&#125;&apos; | sudo tee /etc/consul.d/web.json</span>
</pre></td></tr></table></figure>
<p>现在，我们重启agent，并指定Consul的配置文件目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">$ consul agent -dev -config-dir=/etc/consul.d</span>
<span class="line">==&gt; Starting Consul agent...</span>
<span class="line">...</span>
<span class="line">    [INFO] agent: Synced service &apos;web&apos;</span>
<span class="line">...</span>
</pre></td></tr></table></figure>
<p>在启动的日志输出中你会看到<code>synced the web service</code>字样。这就意味着该agent从服务定义配置文件中加载了服务定义，并且成功注册到服务的<code>catalog</code>中。</p>
<p>如果你想要注册多个服务，你可以创建多个服务定义文件在Consul的配置目录中。</p>
<h3 id="Querying-Services"><a href="#Querying-Services" class="headerlink" title="Querying Services"></a>Querying Services</h3><hr>
<p>一旦Agent启动并且服务注册成功，我们就可以通过DNS和HTTP API来查询服务信息。</p>
<h4 id="DNS-API"><a href="#DNS-API" class="headerlink" title="DNS API"></a>DNS API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 -p 8600 web.service.consul</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;web.service.consul.        IN  A</span>
<span class="line"></span>
<span class="line">;; ANSWER SECTION:</span>
<span class="line">web.service.consul. 0   IN  A   172.20.20.11</span>
</pre></td></tr></table></figure>
<p>如你所见，返回了一个可以用的，带有结点IP地址的记录。 一条记录只能有一个IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 -p 8600 web.service.consul SRV</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;web.service.consul.        IN  SRV</span>
<span class="line"></span>
<span class="line">;; ANSWER SECTION:</span>
<span class="line">web.service.consul. 0   IN  SRV 1 1 80 Armons-MacBook-Air.node.dc1.consul.</span>
<span class="line"></span>
<span class="line">;; ADDITIONAL SECTION:</span>
<span class="line">Armons-MacBook-Air.node.dc1.consul. 0 IN A  172.20.20.11</span>
</pre></td></tr></table></figure>
<p>也可以通过DNS查询指定标签的服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 -p 8600 rails.web.service.consul</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;rails.web.service.consul.      IN  A</span>
<span class="line"></span>
<span class="line">;; ANSWER SECTION:</span>
<span class="line">rails.web.service.consul.   0   IN  A   172.20.20.11</span>
</pre></td></tr></table></figure>
<p><code>rails</code>就是服务<code>web</code>的标签。</p>
<h4 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ curl http://localhost:8500/v1/catalog/service/web</span>
<span class="line">[&#123;&quot;Node&quot;:&quot;Armons-MacBook-Air&quot;,&quot;Address&quot;:&quot;172.20.20.11&quot;,&quot;ServiceID&quot;:&quot;web&quot;, \</span>
<span class="line">    &quot;ServiceName&quot;:&quot;web&quot;,&quot;ServiceTags&quot;:[&quot;rails&quot;],&quot;ServicePort&quot;:80&#125;]</span>
</pre></td></tr></table></figure>
<p>catalog API 给出了指定服务的所有结点信息。就像我们随后看到的健康检查一样，你通常只想查询健康的服务实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8500/v1/health/service/web?passing&apos;</span>
<span class="line">[&#123;&quot;Node&quot;:&quot;Armons-MacBook-Air&quot;,&quot;Address&quot;:&quot;172.20.20.11&quot;,&quot;Service&quot;:&#123; \</span>
<span class="line">    &quot;ID&quot;:&quot;web&quot;, &quot;Service&quot;:&quot;web&quot;, &quot;Tags&quot;:[&quot;rails&quot;],&quot;Port&quot;:80&#125;, &quot;Checks&quot;: ...&#125;]</span>
</pre></td></tr></table></figure>
<h3 id="Updating-Services"><a href="#Updating-Services" class="headerlink" title="Updating Services"></a>Updating Services</h3><hr>
<p>服务定义的修改可以通过修改服务定义文件，并给agent发送<code>SIGHUP</code>信号即可。这样你可以不停机，同时不影响服务查询的情况下修改服务定义。此外，也可以通过HTTP API 来动态添加，删除，修改服务。</p>
<h3 id="Consul-Cluster"><a href="#Consul-Cluster" class="headerlink" title="Consul Cluster"></a>Consul Cluster</h3><p>我们已经启动了我们第一个agent，并在该agent上进行了服务注册和查询。这表明了Consul的使用是多么的简单，但是没有展示如何基于该agent进行扩展为生产环境级别的服务发现基础设施。该该小节，我们将搭建一个真正的集群。</p>
<p>当一个agent启动后，它是不知道其它agent的存在的：它自己处于一个隔离的只有一个结点的集群。如果要了解其它节点的信息，则该agent必须加入已有的集群。为了加入已有的集群，它只需要知道已有集群中一个结点的信息即可。加入集群后，它会通过<code>gossip</code>协议快速发现集群中的其它结点。一个 Consul agent 可以加入任何其它的agent，而不仅仅运行在server模式。</p>
<h4 id="Starting-the-Agents"><a href="#Starting-the-Agents" class="headerlink" title="Starting the Agents"></a>Starting the Agents</h4><p>分别在两台机器上执行下面的命令</p>
<p>10.13.40.95</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">agent -server -bootstrap-expect=1 -data-dir=/tmp/consul -node=agent-one -bind=10.13.40.95 -enable-script-checks=true -config-dir=/usr/local/consul/conf</span>
</pre></td></tr></table></figure>
<p>10.110.82.169 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">agent -server -bootstrap-expect=1 -data-dir=/tmp/consul -node=agent-two -bind=10.110.82.169 -enable-script-checks=true -config-dir=/usr/local/consul/conf</span>
</pre></td></tr></table></figure>
<p>到目前为止我们拥有了2个集群，每个集群都只有一个结点。相互之间并不知道彼此的存在。</p>
<h4 id="Joining-a-Cluster"><a href="#Joining-a-Cluster" class="headerlink" title="Joining a Cluster"></a>Joining a Cluster</h4><hr>
<p>通过下面的命令来组件集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">/usr/local/consul/bin/consul join 10.110.82.169</span>
<span class="line">Successfully joined cluster by contacting 1 nodes.</span>
</pre></td></tr></table></figure>
<p>通过命令<code>members</code>来检测集群是否搭建成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line">/usr/local/consul/bin/consul members</span>
<span class="line">Node       Address             Status  Type    Build  Protocol  DC   Segment</span>
<span class="line">agent-one  10.13.40.95:8301    alive   server  1.0.2  2         dc1  &lt;all&gt;</span>
<span class="line">agent-two  10.110.82.169:8301  alive   server  1.0.2  2         dc1  &lt;all&gt;</span>
</pre></td></tr></table></figure>
<h4 id="Auto-joining-a-Cluster-on-Start"><a href="#Auto-joining-a-Cluster-on-Start" class="headerlink" title="Auto-joining a Cluster on Start"></a>Auto-joining a Cluster on Start</h4><hr>
<p>Consul facilitates auto-join by enabling the auto-discovery of instances in AWS, Google Cloud or Azure with a given tag key/value. To use the integration, add the retry_join_ec2, retry_join_gce or the retry_join_azure nested object to your Consul configuration file. This will allow a new node to join the cluster without any hardcoded configuration. Alternatively, you can join a cluster at startup using the -join flag or start_join setting with hardcoded addresses of other known Consul agents.</p>
<p>实践中，当在数据中心启动一个新的Consul结点，它应该自动加入Consul集群而不应该通过人工的方式来加入。</p>
<h4 id="Querying-Nodes"><a href="#Querying-Nodes" class="headerlink" title="Querying Nodes"></a>Querying Nodes</h4><hr>
<p>和查询服务一样，Consul提供了API来查询结点的信息，你可以通过DNS和HTTP API来进行查询。</p>
<p>针对DNS API, 结点的查询命令结构为:<code>NAME.node.consul</code> 或 <code>NAME.node.DATACENTER.consul</code>。如果不知道数据中心信息，那么该查询只会查询本数据中心内的结点。</p>
<p>例如，在结点<code>agent-one</code>，我们可以查询结点<code>agent-two</code>的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">dig @127.0.0.1 -p 8600 agent-two.node.consul</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;agent-two.node.consul. IN  A</span>
<span class="line"></span>
<span class="line">;; ANSWER SECTION:</span>
<span class="line">agent-two.node.consul.  0 IN    A   172.20.20.11</span>
</pre></td></tr></table></figure>
<h4 id="Leaving-a-Cluster"><a href="#Leaving-a-Cluster" class="headerlink" title="Leaving a Cluster"></a>Leaving a Cluster</h4><hr>
<p>otherwise, other nodes will detect it as having failed. The difference is covered in more detail here.</p>
<p>退出Consul集群，你可以优雅的退出（<code>Ctrl-C</code>）agent 进程 或 kill agent进程。优雅的退出集群会允许结点慢慢进入离开状态，其它结点也会收到通知信息。虽然其它结点也会检查到离开的结点，但是两者还是有不同的。具体可以参考<a href="https://www.consul.io/intro/getting-started/agent.html#stopping" target="_blank" rel="external">https://www.consul.io/intro/getting-started/agent.html#stopping</a></p>
<h3 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h3><p>我们已经看到了使用Consul时多么的简单，添加集群结点，添加服务，查询结点和服务的信息都很容易。在该小节，我们将继续添加结点和服务的健康检查机制。健康检查是服务发现的关键组件，可以防止使用不健康的服务。</p>
<h4 id="Defining-Checks"><a href="#Defining-Checks" class="headerlink" title="Defining Checks"></a>Defining Checks</h4><p>Similar to a service, a check can be registered either by providing a check definition or by making the appropriate calls to the HTTP API.</p>
<p>We will use the check definition approach because, just like with services, definitions are the most common way to set up checks.</p>
<p>与服务定义类似，可以通过提供<code>检查定义</code>或通过调用对应的HTTP API来注册<code>检查</code>。</p>
<p>我们将使用<code>检查定义</code>方法，因为就像服务一样，定义是设置检查最常用的方法。</p>
<p>在Consul的配置文件目录创建2定义文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
</pre></td><td class="code"><pre><span class="line">~$ echo &apos;&#123;&quot;check&quot;: &#123;&quot;name&quot;: &quot;ping&quot;,</span>
<span class="line">  &quot;script&quot;: &quot;ping -c1 google.com &gt;/dev/null&quot;, &quot;interval&quot;: &quot;30s&quot;&#125;&#125;&apos; \</span>
<span class="line">  &gt;/etc/consul.d/ping.json</span>
<span class="line"></span>
<span class="line">~$ echo &apos;&#123;&quot;service&quot;: &#123;&quot;name&quot;: &quot;web&quot;, &quot;tags&quot;: [&quot;rails&quot;], &quot;port&quot;: 80,</span>
<span class="line">  &quot;check&quot;: &#123;&quot;script&quot;: &quot;curl localhost &gt;/dev/null 2&gt;&amp;1&quot;, &quot;interval&quot;: &quot;10s&quot;&#125;&#125;&#125;&apos; \</span>
<span class="line">  &gt;/etc/consul.d/web.json</span>
</pre></td></tr></table></figure>
<p>第一个定义添加了一个名为<code>ping</code>的主机级别的检查。 此检查运行间隔为30秒，调用<code>ping -c1 google.com</code>。 在基于脚本的运行状况检查上，检查以与启动Consul进程相同的用户身份运行。 如果该命令以非零退出码退出，则该节点将被标记为不健康。 这是任何基于脚本的健康检查的共同约定。</p>
<p>第二个命令修改名为web的服务，添加一个检查，每隔10秒通过curl发送一个请求，以验证Web服务器是否可访问。 与主机级运行状况检查一样，如果脚本以非零退出代码退出，服务将被标记为不健康。</p>
<p>现在重启第二个agent， 可以通过<code>consule reload</code> 或 通过给agent发送<code>SIGHUP</code>信号。你应该看到下面的日志信息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line">==&gt; Starting Consul agent...</span>
<span class="line">...</span>
<span class="line">    [INFO] agent: Synced service &apos;web&apos;</span>
<span class="line">    [INFO] agent: Synced check &apos;service:web&apos;</span>
<span class="line">    [INFO] agent: Synced check &apos;ping&apos;</span>
<span class="line">    [WARN] Check &apos;service:web&apos; is now critical</span>
</pre></td></tr></table></figure>
<p>前几行表示代理已经同步了新的定义。 最后一行表明我们为Web服务添加的检查是至关重要的。 这是因为我们实际上没有运行Web服务器，所以<code>curl</code>测试失败了！</p>
<h4 id="Checking-Health-Status"><a href="#Checking-Health-Status" class="headerlink" title="Checking Health Status"></a>Checking Health Status</h4><p>现在我们已经添加了一些简单的检查，我们可以使用HTTP API来检查它们。 首先，我们可以使用这个命令查找任何失败的检查（注意，这可以在任一节点上运行）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">~$ curl http://localhost:8500/v1/health/state/critical</span>
<span class="line">[&#123;&quot;Node&quot;:&quot;agent-two&quot;,&quot;CheckID&quot;:&quot;service:web&quot;,&quot;Name&quot;:&quot;Service &apos;web&apos; check&quot;,&quot;Status&quot;:&quot;critical&quot;,&quot;Notes&quot;:&quot;&quot;,&quot;ServiceID&quot;:&quot;web&quot;,&quot;ServiceName&quot;:&quot;web&quot;,&quot;ServiceTags&quot;:[&quot;rails&quot;]&#125;]</span>
</pre></td></tr></table></figure>
<p>我们可以看到，只有一个检查，我们的Web服务检查，在临界状态。</p>
<p>另外，我们可以尝试使用DNS查询Web服务。 由于服务不健康，Consul 不会返回任何结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">dig @127.0.0.1 -p 8600 web.service.consul</span>
<span class="line">...</span>
<span class="line"></span>
<span class="line">;; QUESTION SECTION:</span>
<span class="line">;web.service.consul.        IN  A</span>
</pre></td></tr></table></figure>
<h3 id="KV-Data"><a href="#KV-Data" class="headerlink" title="KV Data"></a>KV Data</h3><p>Consul除了提供服务发现和综合健康检查之外，还提供一个易于使用的KV存储。 这可以用来保存动态配置，协助服务协调，建立领导者选举，并使开发人员可以考虑构建的任何东西。</p>
<p>这一步假定您至少有一个Consul代理已经在运行。</p>
<h4 id="Simple-Usage"><a href="#Simple-Usage" class="headerlink" title="Simple Usage"></a>Simple Usage</h4><p>为了演示开始有多简单，我们将操作K / V存储中的几个键。 有两种方式与Consul KV存储进行交互：通过HTTP API和Consul KV CLI。 以下示例显示使用Consul KV CLI，因为它是最容易入门的。 对于更高级的集成，您可能需要使用Consul KV HTTP API</p>
<p>首先让我们探索KV存储。 我们可以向Consul询问名为redis / config / minconns的路径上的密钥的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv get redis/config/minconns</span>
<span class="line">Error! No key exists at: redis/config/minconns</span>
</pre></td></tr></table></figure>
<p>As you can see, we get no result, which makes sense because there is no data in the KV store. Next we can insert or “put” values into the KV store.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv put redis/config/minconns 1</span>
<span class="line">Success! Data written to: redis/config/minconns</span>
<span class="line"></span>
<span class="line">$ consul kv put redis/config/maxconns 25</span>
<span class="line">Success! Data written to: redis/config/maxconns</span>
<span class="line"></span>
<span class="line">$ consul kv put -flags=42 redis/config/users/admin abcd1234</span>
<span class="line">Success! Data written to: redis/config/users/admin</span>
</pre></td></tr></table></figure>
<p>Now that we have keys in the store, we can query for the value of individual keys:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv get redis/config/minconns</span>
<span class="line">1</span>
</pre></td></tr></table></figure>
<p>Consul retains additional metadata about the field, which is retrieved using the -detailed flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv get -detailed redis/config/minconns</span>
<span class="line">CreateIndex      207</span>
<span class="line">Flags            0</span>
<span class="line">Key              redis/config/minconns</span>
<span class="line">LockIndex        0</span>
<span class="line">ModifyIndex      207</span>
<span class="line">Session          -</span>
<span class="line">Value            1</span>
</pre></td></tr></table></figure>
<p>For the key “redis/config/users/admin”, we set a flag value of 42. All keys support setting a 64-bit integer flag value. This is not used internally by Consul, but it can be used by clients to add meaningful metadata to any KV.</p>
<p>It is possible to list all the keys in the store using the recurse options. Results will be returned in lexicographical order:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv get -recurse</span>
<span class="line">redis/config/maxconns:25</span>
<span class="line">redis/config/minconns:1</span>
<span class="line">redis/config/users/admin:abcd1234</span>
</pre></td></tr></table></figure>
<p>To delete a key from the Consul KV store, issue a “delete” call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv delete redis/config/minconns</span>
<span class="line">Success! Deleted key: redis/config/minconns</span>
</pre></td></tr></table></figure>
<p>It is also possible to delete an entire prefix using the recurse option:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv delete -recurse redis</span>
<span class="line">Success! Deleted keys with prefix: redis</span>
</pre></td></tr></table></figure>
<p>To update the value of an existing key, “put” a value at the same path:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv put foo bar</span>
<span class="line"></span>
<span class="line">$ consul kv get foo</span>
<span class="line">bar</span>
<span class="line"></span>
<span class="line">$ consul kv put foo zip</span>
<span class="line"></span>
<span class="line">$ consul kv get foo</span>
<span class="line">zip</span>
</pre></td></tr></table></figure>
<p>Consul can provide atomic key updates using a Check-And-Set operation. To perform a CAS operation, specify the -cas flag:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">$ consul kv put -cas -modify-index=123 foo bar</span>
<span class="line">Success! Data written to: foo</span>
<span class="line"></span>
<span class="line">$ consul kv put -cas -modify-index=123 foo bar</span>
<span class="line">Error! Did not write to foo: CAS failed</span>
</pre></td></tr></table></figure>
<p>In this case, the first CAS update succeeds because the index is 123. The second operation fails because the index is no longer 123.</p>
<h3 id="Consul-Web-UI"><a href="#Consul-Web-UI" class="headerlink" title="Consul Web UI"></a>Consul Web UI</h3><p>Consul comes with support for beautiful, functional web UIs out of the box. UIs can be used for viewing all services and nodes, for viewing all health checks and their current status, and for reading and setting key/value data. The UIs automatically support multi-datacenter.</p>
<img src="/2017/12/31/consul-quick-start/consul_web_ui-3a1e7bf9.png" alt="consul_web_ui-3a1e7bf9.png" title="">
<p>To set up the self-hosted UI, start the Consul agent with the -ui parameter:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ consul agent -ui</span>
<span class="line">...</span>
</pre></td></tr></table></figure>
<p>The UI is available at the /ui path on the same port as the HTTP API. By default this is <a href="http://localhost:8500/ui" target="_blank" rel="external">http://localhost:8500/ui</a>.</p>
<p>You can view a live demo of the Consul Web UI here.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;该文章翻译自 &lt;a href=&quot;https://www.consul.io/intro/index.html&quot;&gt;https://www.consul.io/intro/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章的目标是对Consul进行一个简单的介绍。包括Consul是什么，它解决了什么问题，它有哪些功能。通过这篇文章能让你对Consul能有一个大致的了解，和基本的使用。&lt;/p&gt;
&lt;h3 id=&quot;What-is-Consul&quot;&gt;&lt;a href=&quot;#What-is-Consul&quot; class=&quot;headerlink&quot; title=&quot;What is Consul?&quot;&gt;&lt;/a&gt;What is Consul?&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;Consul 有许多组件，但是作为一个整理来看，它为你的基础设施提供了服务发现和统一配置功能。它提供如下的主要的功能：&lt;/p&gt;
    
    </summary>
    
    
      <category term="consul" scheme="https://leokongwq.github.io/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>CPU总线仲裁</title>
    <link href="https://leokongwq.github.io/2017/12/22/computer-science-bus-arbitration.html"/>
    <id>https://leokongwq.github.io/2017/12/22/computer-science-bus-arbitration.html</id>
    <published>2017-12-22T10:08:12.000Z</published>
    <updated>2017-12-22T10:16:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Java中查询底层CAS实现时，了解到CPU总线仲裁的概念。Google后找到如下的文章。</p>
<p><a href="http://www.ques10.com/p/8794/what-is-bus-arbitration-explain-any-two-techniques/" target="_blank" rel="external">what-is-bus-arbitration-explain-any-two-techniques</a></p>
<a id="more"></a>
<h3 id="CPU总线仲裁实现"><a href="#CPU总线仲裁实现" class="headerlink" title="CPU总线仲裁实现"></a>CPU总线仲裁实现</h3><ul>
<li>The device that is allowed to initiate data transfers on the bus at any given time is called the bus master. In a computer system there may be more than one bus master such as processor, DMA controller etc.</li>
<li>They share the system bus. When current master relinquishes control of the bus, another bus master can acquire the control of the bus.</li>
<li>Bus arbitration is the process by which the next device to become the bus master is selected and bus mastership is transferred to it. The selection of bus master is usually done on the priority basis.</li>
</ul>
<p>There are two approaches to bus arbitration: Centralized and distributed.</p>
<h3 id="Centralized-Arbitration"><a href="#Centralized-Arbitration" class="headerlink" title="Centralized Arbitration"></a>Centralized Arbitration</h3><ul>
<li>In centralized bus arbitration, a single bus arbiter performs the required arbitration. The bus arbiter may be the processor or a separate controller connected to the bus.</li>
<li><p>There are three different arbitration schemes that use the centralized bus arbitration approach. There schemes are:</p>
<p>  a. Daisy chaining<br>  b. Polling method<br>  c. Independent request</p>
</li>
</ul>
<h4 id="Daisy-chaining"><a href="#Daisy-chaining" class="headerlink" title="Daisy chaining"></a>Daisy chaining</h4><p>The system connections for Daisy chaining method are shown in fig below.</p>
<img src="/2017/12/22/computer-science-bus-arbitration/wiYLSHg.png" alt="wiYLSHg.png" title="">
<ul>
<li>It is simple and cheaper method. All masters make use of the same line for bus request.</li>
<li>In response to the bus request the controller sends a bus grant if the bus is free.</li>
<li>The bus grant signal serially propagates through each master until it encounters the first one that is requesting access to the bus. This master blocks the propagation of the bus grant signal, activities the busy line and gains control of the bus.</li>
<li>Therefore any other requesting module will not receive the grant signal and hence cannot get the bus access.</li>
</ul>
<h4 id="Polling-method"><a href="#Polling-method" class="headerlink" title="Polling method"></a>Polling method</h4><img src="/2017/12/22/computer-science-bus-arbitration/q7rcpOB.png" alt="q7rcpOB.png" title="">
<ul>
<li>The system connections for polling method are shown in figure above.</li>
<li>In this the controller is used to generate the addresses for the master. Number of address line required depends on the number of master connected in the system.</li>
<li>For example, if there are 8 masters connected in the system, at least three address lines are required.</li>
<li>In response to the bus request controller generates a sequence of master address. When the requesting master recognizes its address, it activated the busy line ad begins to use the bus.</li>
</ul>
<h4 id="Independent-request"><a href="#Independent-request" class="headerlink" title="Independent request"></a>Independent request</h4><img src="/2017/12/22/computer-science-bus-arbitration/MS8iRFG.png" alt="MS8iRFG.png" title="">  
<ul>
<li>The figure below shows the system connections for the independent request scheme.</li>
<li>In this scheme each master has a separate pair of bus request and bus grant lines and each pair has a priority assigned to it.</li>
<li>The built in priority decoder within the controller selects the highest priority request and asserts the corresponding bus grant signal.</li>
</ul>
<h3 id="Distributed-Arbitration"><a href="#Distributed-Arbitration" class="headerlink" title="Distributed Arbitration"></a>Distributed Arbitration</h3><ul>
<li>In distributed arbitration, all devices participate in the selection of the next bus master.</li>
<li>In this scheme each device on the bus is assigned a4-bit identification number.</li>
<li>The number of devices connected on the bus when one or more devices request for the control of bus, they assert the start-arbitration signal and place their 4-bit ID numbers on arbitration lines, ARB0 through ARB3.</li>
<li>These four arbitration lines are all open-collector. Therefore, more than one device can place their 4-bit ID number to indicate that they need to control of bus. If one device puts 1 on the bus line and another device puts 0 on the same bus line, the bus line status will be 0. Device reads the status of all lines through inverters buffers so device reads bus status 0as logic 1. Scheme the device having highest ID number has highest priority.</li>
<li>When two or more devices place their ID number on bus lines then it is necessary to identify the highest ID number on bus lines then it is necessary to identify the highest ID number from the status of bus line. Consider that two devices A and B, having ID number 1 and 6, respectively are requesting the use of the bus.</li>
<li>Device A puts the bit pattern 0001, and device B puts the bit pattern 0110. With this combination the status of bus-line will be 1000; however because of inverter buffers code seen by both devices is 0111.</li>
<li>Each device compares the code formed on the arbitration line to its own ID, starting from the most significant bit. If it finds the difference at any bit position, it disables its drives at that bit position and for all lower-order bits.</li>
<li>It does so by placing a 0 at the input of their drive. In our example, device detects a different on line ARB2 and hence it disables its drives on line ARB2, ARB1 and ARB0. This causes the code on the arbitration lines to change to 0110. This means that device B has won the race.</li>
<li>The decentralized arbitration offers high reliability because operation of the bus is not dependent on any single device.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在Java中查询底层CAS实现时，了解到CPU总线仲裁的概念。Google后找到如下的文章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ques10.com/p/8794/what-is-bus-arbitration-explain-any-two-techniques/&quot;&gt;what-is-bus-arbitration-explain-any-two-techniques&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CS" scheme="https://leokongwq.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>java Instrumentation 和 Agent</title>
    <link href="https://leokongwq.github.io/2017/12/21/java-agent-instrumentation.html"/>
    <id>https://leokongwq.github.io/2017/12/21/java-agent-instrumentation.html</id>
    <published>2017-12-21T15:10:20.000Z</published>
    <updated>2017-12-22T09:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Java的Instrumentation"><a href="#什么是Java的Instrumentation" class="headerlink" title="什么是Java的Instrumentation ?"></a>什么是Java的Instrumentation ?</h3><p>JDK™5.0中引入包<code>java.lang.instrument</code>。 该包提供了一个Java编程API，可以用来开发增强Java应用程序的工具，例如监视它们或收集性能信息。 使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。</p>
<p>在 Java SE 6 里面，instrumentation 包被赋予了更强大的功能：<code>启动后的 instrument</code>、<code>本地代码（native code）instrument</code>，以及<code>动态改变 classpath</code> 等等。这些改变，意味着 Java 具有了更强的动态控制、解释能力，它使得 Java 语言变得更加灵活多变。</p>
<a id="more"></a>
<p>在 Java SE6 里面，最大的改变是运行时的 Instrumentation 成为可能。在 <code>Java SE 5</code> 中，Instrument 要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation 的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。但是在实践中，有很多的情况，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了 instrument 的应用。而 <code>Java SE 6</code> 的新特性改变了这种情况，通过 Java Tool API 中的 attach 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到 instrumentation 的目的。</p>
<p>另外，对 native 的 Instrumentation 也是 Java SE 6 的一个崭新的功能，这使以前无法完成的功能 —— 对 native 接口的 instrumentation 可以在 Java SE 6 中，通过一个或者一系列的 prefix 添加而得以完成。</p>
<p>最后，Java SE 6 里的 Instrumentation 也增加了动态添加 class path 的功能。所有这些新的功能，都使得 instrument 包的功能更加丰富，从而使 Java 语言本身更加强大</p>
<h3 id="Instrumentation-核心API"><a href="#Instrumentation-核心API" class="headerlink" title="Instrumentation 核心API"></a>Instrumentation 核心API</h3><h4 id="void-addTransformer-ClassFileTransformer-transformer-boolean-canRetransform"><a href="#void-addTransformer-ClassFileTransformer-transformer-boolean-canRetransform" class="headerlink" title="void addTransformer(ClassFileTransformer transformer, boolean canRetransform);"></a>void addTransformer(ClassFileTransformer transformer, boolean canRetransform);</h4><p>该方法从1.6开始引入。功能是注册一个 <code>ClassFileTransformer</code> 类的实例，在类加载的时候被调用。</p>
<h4 id="addTransformer-ClassFileTransformer-transformer"><a href="#addTransformer-ClassFileTransformer-transformer" class="headerlink" title="addTransformer(ClassFileTransformer transformer);"></a>addTransformer(ClassFileTransformer transformer);</h4><p>功能同上。    </p>
<h4 id="boolean-removeTransformer-ClassFileTransformer-transformer"><a href="#boolean-removeTransformer-ClassFileTransformer-transformer" class="headerlink" title="boolean removeTransformer(ClassFileTransformer transformer);"></a>boolean removeTransformer(ClassFileTransformer transformer);</h4><p>注销一个 已经注册的 <code>ClassFileTransformer</code></p>
<h4 id="boolean-isRetransformClassesSupported"><a href="#boolean-isRetransformClassesSupported" class="headerlink" title="boolean isRetransformClassesSupported();"></a>boolean isRetransformClassesSupported();</h4><p>判断当前JVM的配置是否支持类的重新转换。开启该配置需要在 Agent的清单文件中添加<code>Can-Retransform-Classes:true</code> 配置。</p>
<h4 id="retransformClasses-Class-lt-gt-…-classes-throws-UnmodifiableClassException"><a href="#retransformClasses-Class-lt-gt-…-classes-throws-UnmodifiableClassException" class="headerlink" title="retransformClasses(Class&lt;?&gt;… classes) throws UnmodifiableClassException;"></a>retransformClasses(Class&lt;?&gt;… classes) throws UnmodifiableClassException;</h4><p>retransform class 可以简单理解为回滚操作，具体回滚到哪个版本，这个需要看情况而定，下面不管那种情况都有一个前提，那就是javaagent已经要求要有retransform的能力了：</p>
<p>如果类是在第一次加载的的时候就做了transform，那么做retransform的时候会将代码回滚到transform之后的代码<br>如果类是在第一次加载的的时候没有任何变化，那么做retransform的时候会将代码回滚到最原始的类文件里的字节码<br>如果类已经加载了，期间类可能做过多次redefine(比如被另外一个agent做过)，但是接下来加载一个新的agent要求有retransform的能力了，然后对类做redefine的动作，那么retransform的时候会将代码回滚到上一个agent最后一次做redefine后的字节码</p>
<h4 id="boolean-isRedefineClassesSupported"><a href="#boolean-isRedefineClassesSupported" class="headerlink" title="boolean isRedefineClassesSupported();"></a>boolean isRedefineClassesSupported();</h4><p>判断当前JVM的配置是否支持类的重新定义。开启该配置需要在 Agent的清单文件中添加<code>Can-Redefine-Classes:true</code> 配置。</p>
<h4 id="void-redefineClasses-ClassDefinition…-definitions-throws-ClassNotFoundException-UnmodifiableClassException"><a href="#void-redefineClasses-ClassDefinition…-definitions-throws-ClassNotFoundException-UnmodifiableClassException" class="headerlink" title="void redefineClasses(ClassDefinition… definitions) throws  ClassNotFoundException, UnmodifiableClassException;"></a>void redefineClasses(ClassDefinition… definitions) throws  ClassNotFoundException, UnmodifiableClassException;</h4><p>对参数代码的类进行重新定义。针对的是已经加载的类。</p>
<h4 id="boolean-isModifiableClass-Class-lt-gt-theClass"><a href="#boolean-isModifiableClass-Class-lt-gt-theClass" class="headerlink" title="boolean isModifiableClass(Class&lt;?&gt; theClass);"></a>boolean isModifiableClass(Class&lt;?&gt; theClass);</h4><p>判断参数指定的类是否可以被修改。JDK1.6开始。</p>
<h4 id="Class-getAllLoadedClasses"><a href="#Class-getAllLoadedClasses" class="headerlink" title="Class[] getAllLoadedClasses();"></a>Class[] getAllLoadedClasses();</h4><p>返回当前JVM已经加载的所有类。</p>
<h4 id="Class-getInitiatedClasses-ClassLoader-loader"><a href="#Class-getInitiatedClasses-ClassLoader-loader" class="headerlink" title="Class[] getInitiatedClasses(ClassLoader loader);"></a>Class[] getInitiatedClasses(ClassLoader loader);</h4><p>返回当前JVM已经初始化的类。</p>
<h4 id="long-getObjectSize-Object-objectToSize"><a href="#long-getObjectSize-Object-objectToSize" class="headerlink" title="long getObjectSize(Object objectToSize);"></a>long getObjectSize(Object objectToSize);</h4><p>获取参数指定对象的大小。</p>
<h4 id="void-appendToBootstrapClassLoaderSearch-JarFile-jarfile"><a href="#void-appendToBootstrapClassLoaderSearch-JarFile-jarfile" class="headerlink" title="void appendToBootstrapClassLoaderSearch(JarFile jarfile);"></a>void appendToBootstrapClassLoaderSearch(JarFile jarfile);</h4><p>添加参数指定的jar文件到<code>根类加载器</code>的搜索路径中。JDK1.6开始。</p>
<h4 id="void-appendToSystemClassLoaderSearch-JarFile-jarfile"><a href="#void-appendToSystemClassLoaderSearch-JarFile-jarfile" class="headerlink" title="void appendToSystemClassLoaderSearch(JarFile jarfile);"></a>void appendToSystemClassLoaderSearch(JarFile jarfile);</h4><p>添加参数指定的jar文件到<code>系统类加载器</code>的搜索路径中。JDK1.6开始。</p>
<h4 id="boolean-isNativeMethodPrefixSupported"><a href="#boolean-isNativeMethodPrefixSupported" class="headerlink" title="boolean isNativeMethodPrefixSupported();"></a>boolean isNativeMethodPrefixSupported();</h4><p>当前JVM配置是否支持设置本地方法前缀。开启该配置需要在Agent的清单文件中添加<code>Can-Set-Native-Method-Prefix:true</code>配置。JDK1.6开始。</p>
<h4 id="void-setNativeMethodPrefix-ClassFileTransformer-transformer-String-prefix"><a href="#void-setNativeMethodPrefix-ClassFileTransformer-transformer-String-prefix" class="headerlink" title="void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);"></a>void setNativeMethodPrefix(ClassFileTransformer transformer, String prefix);</h4><p>该方法用来处理失败的native方法解析，可以重新尝试带有指定前缀的本地方法。JDK1.6开始。</p>
<h3 id="Instrumentation-的基本功能和用法"><a href="#Instrumentation-的基本功能和用法" class="headerlink" title="Instrumentation 的基本功能和用法"></a>Instrumentation 的基本功能和用法</h3><p><code>java.lang.instrument</code>包的具体实现，依赖于 JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 是从 Java SE 5 开始引入，整合和取代了以前使用的 Java Virtual Machine Profiler Interface (JVMPI) 和 the Java Virtual Machine Debug Interface (JVMDI)，而在 Java SE 6 中，JVMPI 和 JVMDI 已经消失了。JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。事实上，java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。关于 JVMTI 的详细信息，请参考 Java SE 6 文档（请参见 参考资源）当中的介绍</p>
<p>Instrumentation 的最大作用，就是类定义动态改变和操作。在 <code>Java SE 5</code> 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 <code>–javaagent</code>参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p>
<p>在 Java SE 5 当中，开发者可以让 Instrumentation 代理在 main 函数运行前执行。简要说来就是如下几个步骤：</p>
<p>1.编写 premain 函数</p>
<p>编写一个 Java 类，包含如下两个方法当中的任何一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;  [<span class="number">1</span>]</span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>; [<span class="number">2</span>]</span>
</pre></td></tr></table></figure>
<p>其中，[1] 的优先级比 [2] 高，将会被优先执行（[1] 和 [2] 同时存在时，[2] 被忽略）。</p>
<p>在这个<code>premain</code>函数中，开发者可以进行对类的各种操作。</p>
<p><code>agentArgs</code> 是 <code>premain</code> 函数得到的程序参数，随同 <code>–javaagent</code> 一起传入。与 <code>main</code> 函数不同的是，这个参数是一个字符串而不是一个字符串数组，如果程序参数有多个，程序将自行解析这个字符串。</p>
<p><code>Inst</code> 是一个 <code>java.lang.instrument.Instrumentation</code> 的实例，由 JVM 自动传入。<code>java.lang.instrument.Instrumentation</code> 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。</p>
<p>2.jar 文件打包</p>
<p>将这个 Java 类打包成一个 jar 文件，并在其中的 manifest 属性当中加入<code>Premain-Class</code>来指定步骤 1 当中编写的那个带有 <code>premain</code> 的 Java 类。（可能还需要指定其他属性以开启更多功能）</p>
<p>3.运行</p>
<p>用如下方式运行带有 Instrumentation 的 Java 程序：</p>
<p>java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ]</p>
<h3 id="Java-SE-6-的新特性：虚拟机启动后的动态-instrument"><a href="#Java-SE-6-的新特性：虚拟机启动后的动态-instrument" class="headerlink" title="Java SE 6 的新特性：虚拟机启动后的动态 instrument"></a>Java SE 6 的新特性：虚拟机启动后的动态 instrument</h3><p>在 Java SE 5 当中，开发者只能在 premain 当中施展想象力，所作的 Instrumentation 也仅限与 main 函数执行前，这样的方式存在一定的局限性。</p>
<p>在 Java SE 5 的基础上，Java SE 6 针对这种状况做出了改进，开发者可以在 main 函数开始执行以后，再启动自己的 Instrumentation 程序。</p>
<p>在 Java SE 6 的 Instrumentation 当中，有一个跟 premain“并驾齐驱”的“agentmain”方法，可以在 main 函数开始运行之后再运行。</p>
<p>跟 premain 函数一样， 开发者可以编写一个含有“agentmain”函数的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span> <span class="params">(String agentArgs, Instrumentation inst)</span></span>; [<span class="number">1</span>] </span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span> <span class="params">(String agentArgs)</span></span>; [<span class="number">2</span>]</span>
</pre></td></tr></table></figure>
<p>同样，[1] 的优先级比 [2] 高，将会被优先执行。</p>
<p>跟 <code>premain</code> 函数一样，开发者可以在 <code>agentmain</code> 中进行对类的各种操作。其中的 <code>agentArgs</code> 和 <code>Inst</code> 的用法跟 <code>premain</code> 相同。</p>
<p>与<code>Premain-Class</code>类似，开发者必须在 <code>manifest</code> 文件里面设置<code>Agent-Class</code>来指定包含 <code>agentmain</code> 函数的类。</p>
<p>可是，跟 <code>premain</code> 不同的是，<code>agentmain</code> 需要在 <code>main</code> 函数开始运行后才启动，这样的时机应该如何确定呢，这样的功能又如何实现呢？</p>
<p>在 Java SE 6 文档当中，开发者也许无法在 <code>java.lang.instrument</code> 包相关的文档部分看到明确的介绍，更加无法看到具体的应用 <code>agnetmain</code> 的例子。不过，在 <code>Java SE 6</code> 的新特性里面，有一个不太起眼的地方，揭示了 <code>agentmain</code> 的用法。这就是 <code>Java SE 6</code> 当中提供的 <code>Attach API</code>。</p>
<p><code>Attach API</code> 不是 Java 的标准 API，而是 Sun 公司提供的一套扩展 API，用来向目标 JVM ”附着”（Attach）代理工具程序的。有了它，开发者可以方便的监控一个 JVM，运行一个外加的代理程序。</p>
<p><code>Attach API</code> 很简单，只有 2 个主要的类，都在 <code>com.sun.tools.attach</code> 包里面： <code>VirtualMachine</code> 代表一个 Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了 JVM 枚举，<code>Attach</code> 动作和 <code>Detach</code> 动作（Attach 动作的相反行为，从 JVM 上面解除一个代理）等等 ; <code>VirtualMachineDescriptor</code> 则是一个描述虚拟机的容器类，配合 <code>VirtualMachine</code> 类完成各种功能。</p>
<p>为了简单起见，我们举例简化如下：依然用类文件替换的方式，将一个返回 1 的函数替换成返回 2 的函数，<code>Attach API</code> 写在一个线程里面，用睡眠等待的方式，每隔半秒时间检查一次所有的 Java 虚拟机，当发现有新的虚拟机出现的时候，就调用 attach 函数，随后再按照 Attach API 文档里面所说的方式装载 Jar 文件。等到 5 秒钟的时候，attach 程序自动结束。而在 main 函数里面，程序每隔半秒钟输出一次返回值（显示出返回值从 1 变成 2）。</p>
<p>TransClass 类和 Transformer 类的代码不变，参看上一节介绍。 含有 main 函数的 TestMainInJar 代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMainInJar</span> </span>&#123; </span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span>
<span class="line">        System.out.println(<span class="keyword">new</span> TransClass().getNumber()); </span>
<span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; </span>
<span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span>
<span class="line">            Thread.sleep(<span class="number">500</span>); </span>
<span class="line">            count++; </span>
<span class="line">            <span class="keyword">int</span> number = <span class="keyword">new</span> TransClass().getNumber(); </span>
<span class="line">            System.out.println(number); </span>
<span class="line">            <span class="keyword">if</span> (<span class="number">3</span> == number || count &gt;= <span class="number">10</span>) &#123; </span>
<span class="line">                <span class="keyword">break</span>; </span>
<span class="line">            &#125; </span>
<span class="line">        &#125; </span>
<span class="line">    &#125; </span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>含有 agentmain 的 AgentMain 类的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassDefinition; </span>
<span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation; </span>
<span class="line"><span class="keyword">import</span> java.lang.instrument.UnmodifiableClassException; </span>
<span class="line"></span>
<span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentMain</span> </span>&#123; </span>
<span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>
<span class="line">            <span class="keyword">throws</span> ClassNotFoundException, UnmodifiableClassException, </span>
<span class="line">            InterruptedException </span>&#123; </span>
<span class="line">        inst.addTransformer(<span class="keyword">new</span> Transformer (), <span class="keyword">true</span>); </span>
<span class="line">        inst.retransformClasses(TransClass.class); </span>
<span class="line">        System.out.println(<span class="string">"Agent Main Done"</span>); </span>
<span class="line">    &#125; </span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>其中，retransformClasses 是 Java SE 6 里面的新方法，它跟 redefineClasses 一样，可以批量转换类定义，多用于 agentmain 场合。</p>
<p>Jar 文件跟 Premain 那个例子里面的 Jar 文件差不多，也是把 main 和 agentmain 的类，TransClass，Transformer 等类放在一起，打包为“TestInstrument1.jar”，而 Jar 文件当中的 Manifest 文件为 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">Manifest-Version: <span class="number">1.0</span> </span>
<span class="line">Agent-Class: AgentMain</span>
</pre></td></tr></table></figure>
<p>另外，为了运行 Attach API，我们可以再写一个控制程序来模拟监控过程：（代码片段）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
<span class="line">33</span>
<span class="line">34</span>
<span class="line">35</span>
<span class="line">36</span>
<span class="line">37</span>
<span class="line">38</span>
<span class="line">39</span>
<span class="line">40</span>
<span class="line">41</span>
<span class="line">42</span>
<span class="line">43</span>
<span class="line">44</span>
<span class="line">45</span>
<span class="line">46</span>
<span class="line">47</span>
<span class="line">48</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine; </span>
<span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor; </span>
<span class="line">……</span>
<span class="line"><span class="comment">// 一个运行 Attach API 的线程子类</span></span>
<span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123; </span>
<span class="line">   </span>
<span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;VirtualMachineDescriptor&gt; listBefore; </span>
<span class="line"></span>
<span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String jar; </span>
<span class="line"></span>
<span class="line">   AttachThread(String attachJar, List&lt;VirtualMachineDescriptor&gt; vms) &#123; </span>
<span class="line">       listBefore = vms;  <span class="comment">// 记录程序启动时的 VM 集合</span></span>
<span class="line">       jar = attachJar; </span>
<span class="line">   &#125; </span>
<span class="line"></span>
<span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span>
<span class="line">       VirtualMachine vm = <span class="keyword">null</span>; </span>
<span class="line">       List&lt;VirtualMachineDescriptor&gt; listAfter = <span class="keyword">null</span>; </span>
<span class="line">       <span class="keyword">try</span> &#123; </span>
<span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>; </span>
<span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span>
<span class="line">               listAfter = VirtualMachine.list(); </span>
<span class="line">               <span class="keyword">for</span> (VirtualMachineDescriptor vmd : listAfter) &#123; </span>
<span class="line">                   <span class="keyword">if</span> (!listBefore.contains(vmd)) &#123; </span>
<span class="line"><span class="comment">// 如果 VM 有增加，我们就认为是被监控的 VM 启动了</span></span>
<span class="line"><span class="comment">// 这时，我们开始监控这个 VM </span></span>
<span class="line">                       vm = VirtualMachine.attach(vmd); </span>
<span class="line">                       <span class="keyword">break</span>; </span>
<span class="line">                   &#125; </span>
<span class="line">               &#125; </span>
<span class="line">               Thread.sleep(<span class="number">500</span>); </span>
<span class="line">               count++; </span>
<span class="line">               <span class="keyword">if</span> (<span class="keyword">null</span> != vm || count &gt;= <span class="number">10</span>) &#123; </span>
<span class="line">                   <span class="keyword">break</span>; </span>
<span class="line">               &#125; </span>
<span class="line">           &#125; </span>
<span class="line">           vm.loadAgent(jar); </span>
<span class="line">           vm.detach(); </span>
<span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123; </span>
<span class="line">            ignore </span>
<span class="line">       &#125; </span>
<span class="line">   &#125; </span>
<span class="line">&#125; </span>
<span class="line">……</span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123; 	 </span>
<span class="line"><span class="keyword">new</span> AttachThread(<span class="string">"TestInstrument1.jar"</span>, VirtualMachine.list()).start(); </span>
<span class="line"></span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>运行时，可以首先运行上面这个启动新线程的 main 函数，然后，在 5 秒钟内（仅仅简单模拟 JVM 的监控过程）运行如下命令启动测试 Jar 文件 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">java – javaagent:TestInstrument2.jar – cp TestInstrument2.jar TestMainInJar</span>
</pre></td></tr></table></figure>
<p>如果时间掌握得不太差的话，程序首先会在屏幕上打出 1，这是改动前的类的输出，然后会打出一些 2，这个表示 agentmain 已经被 Attach API 成功附着到 JVM 上，代理程序生效了，当然，还可以看到“Agent Main Done”字样的输出。</p>
<p>以上例子仅仅只是简单示例，简单说明这个特性而已。真实的例子往往比较复杂，而且可能运行在分布式环境的多个 JVM 之中。</p>
<h3 id="Java-SE-6-新特性：本地方法的-Instrumentation"><a href="#Java-SE-6-新特性：本地方法的-Instrumentation" class="headerlink" title="Java SE 6 新特性：本地方法的 Instrumentation"></a>Java SE 6 新特性：本地方法的 Instrumentation</h3><p>在 1.5 版本的 instumentation 里，并没有对 Java 本地方法（Native Method）的处理方式，而且在 Java 标准的 JVMTI 之下，并没有办法改变 method signature， 这就使替换本地方法非常地困难。一个比较直接而简单的想法是，在启动时替换本地代码所在的动态链接库 —— 但是这样，本质上是一种静态的替换，而不是动态的 Instrumentation。而且，这样可能需要编译较大数量的动态链接库 —— 比如，我们有三个本地函数，假设每一个都需要一个替换，而在不同的应用之下，可能需要不同的组合，那么如果我们把三个函数都编译在同一个动态链接库之中，最多我们需要 8 个不同的动态链接库来满足需要。当然，我们也可以独立地编译之，那样也需要 6 个动态链接库——无论如何，这种繁琐的方式是不可接受的。</p>
<p>在 Java SE 6 中，新的 Native Instrumentation 提出了一个新的 native code 的解析方式，作为原有的 native method 的解析方式的一个补充，来很好地解决了一些问题。这就是在新版本的 java.lang.instrument 包里，我们拥有了对 native 代码的 instrument 方式 —— 设置 prefix。</p>
<p>假设我们有了一个 native 函数，名字叫 nativeMethod，在运行中过程中，我们需要将它指向另外一个函数（需要注意的是，在当前标准的 JVMTI 之下，除了 native 函数名，其他的 signature 需要一致）。比如我们的 Java 代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nativeTester; </span>
<span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nativePrefixTester</span></span>&#123; </span>
<span class="line">	…</span>
<span class="line">	 <span class="function"><span class="keyword">native</span> <span class="keyword">int</span> <span class="title">nativeMethod</span><span class="params">(<span class="keyword">int</span> input)</span></span>; </span>
<span class="line">	…</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>那么我们已经实现的本地代码是 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Java_nativeTester_nativeMethod</span><span class="params">(jclass thiz, jobject thisObj, jint input)</span></span>;</span>
</pre></td></tr></table></figure>
<p>现在我们需要在调用这个函数时，使之指向另外一个函数。那么按照 J2SE 的做法，我们可以按他的命名方式，加上一个<br><code>prefix</code> 作为新的函数名。比如，我们以 “another_” 作为 prefix，那么我们新的函数是 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">Java_nativeTester_another_nativePrefixTester</span><span class="params">(jclass thiz, jobject thisObj, </span>
<span class="line">jint input)</span></span>;</span>
</pre></td></tr></table></figure>
<p>然后将之编入动态链接库之中。</p>
<p>现在我们已经有了新的本地函数，接下来就是做 instrument 的设置。正如以上所说的，我们可以使用 premain 方式，在虚拟机启动之时就载入 premain 完成 instrument 代理设置。也可以使用 agentmain 方式，去 attach 虚拟机来启动代理。而设置 native 函数的也是相当简单的 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line">premain()&#123;  <span class="comment">// 或者也可以在 agentmain 里</span></span>
<span class="line">    …</span>
<span class="line">    <span class="keyword">if</span> (!isNativeMethodPrefixSupported())&#123; </span>
<span class="line">    	 <span class="keyword">return</span>; <span class="comment">// 如果无法设置，则返回</span></span>
<span class="line">    &#125; </span>
<span class="line">    setNativeMethodPrefix(transformer,<span class="string">"another_"</span>); <span class="comment">// 设置 native 函数的 prefix，注意这个下划线必须由用户自己规定</span></span>
<span class="line">    …</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>在这里要注意两个问题。一是不是在任何的情况下都是可以设置 native 函数的 prefix 的。首先，我们要注意到 agent 包之中的 Manifest 所设定的特性 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">Can-Set-Native-Method-Prefix</span>
</pre></td></tr></table></figure>
<p>要注意，这一个参数都可以影响是否可以设置 native prefix，而且，在默认的设置之中，这个参数是 false 的，我们需要将之设置成 true（顺便说一句，对 Manifest 之中的属性来说都是大小写无关的，当然，如果给一个不是“true”的值，就会被当作 false 值处理）。</p>
<p>当然，我们还需要确认虚拟机本身是否支持 setNativePrefix。在 Java API 里，Instrumentation 类提供了一个函数 isNativePrefix，通过这个函数我们可以知道该功能是否可以实行。</p>
<p>二是我们可以为每一个 ClassTransformer 加上它自己的 nativeprefix；同时，每一个 ClassTransformer 都可以为同一个 class 做 transform，因此对于一个 Class 来说，一个 native 函数可能有不同的 prefix，因此对这个函数来说，它可能也有好几种解析方式。</p>
<p>在 Java SE 6 当中，Native prefix 的解释方式如下：对于某一个 package 内的一个 class 当中的一个 native method 来说，首先，假设我们对这个函数的 transformer 设置了 native 的 prefix“another”，它将这个函数接口解释成 :</p>
<p>由 Java 的函数接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>和上述 prefix”another”，去寻找本地代码中的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_package_class_another_method</span><span class="params">(jclass theClass, jobject thiz)</span></span>;</span>
</pre></td></tr></table></figure>
<p> // 请注意 prefix 在函数名中出现的位置！<br>一旦可以找到，那么调用这个函数，整个解析过程就结束了；如果没有找到，那么虚拟机将会做进一步的解析工作。我们将利用 Java native 接口最基本的解析方式 , 去找本地代码中的函数 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_package_class_method</span><span class="params">(jclass theClass, jobject thiz)</span></span>;</span>
</pre></td></tr></table></figure>
<p>如果找到，则执行之。否则，因为没有任何一个合适的解析方式，于是宣告这个过程失败。</p>
<p>那么如果有多个 transformer，同时每一个都有自己的 prefix，又该如何解析呢？事实上，虚拟机是按 transformer 被加入到的 Instrumentation 之中的次序去解析的（还记得我们最基本的 addTransformer 方法吗？）。</p>
<p>假设我们有三个 transformer 要被加入进来，他们的次序和相对应的 prefix 分别为：transformer1 和“prefix1<em>”，transformer2 和 “prefix2</em>”，transformer3 和 “prefix3_”。那么，虚拟机会首先做的就是将接口解析为 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prefix1_prefix2_prefix3_native_method</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>然后去找它相对应的 native 代码。</p>
<p>但是如果第二个 transformer（transformer2）没有设定 prefix，那么很简单，我们得到的解析是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prefix1_prefix3_native_method</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>这个方式简单而自然。</p>
<p>当然，对于多个 prefix 的情况，我们还要注意一些复杂的情况。比如，假设我们有一个 native 函数接口是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native_method</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>然后我们为它设置了两个 prefix，比如 “wrapped<em>“ 和 “wrapped2</em>“，那么，我们得到的是什么呢？是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Java_package_class_wrapped_wrapped2_method</span><span class="params">(jclass theClass, jobject thiz)</span></span>;</span>
</pre></td></tr></table></figure>
<p> // 这个函数名正确吗？<br>吗？答案是否定的，因为事实上，对 Java 中 native 函数的接口到 native 中的映射，有一系列的规定，因此可能有一些特殊的字符要被代入。而实际中，这个函数的正确的函数名是：</p>
<p> void Java_package_class_wrapped_1wrapped2_1method(jclass theClass, jobject thiz);<br> // 只有这个函数名会被找到<br>很有趣不是吗？因此如果我们要做类似的工作，一个很好的建议是首先在 Java 中写一个带 prefix 的 native 接口，用 javah 工具生成一个 c 的 header-file，看看它实际解析得到的函数名是什么，这样我们就可以避免一些不必要的麻烦。</p>
<p>另外一个事实是，与我们的想像不同，对于两个或者两个以上的 prefix，虚拟机并不做更多的解析；它不会试图去掉某一个 prefix，再来组装函数接口。它做且仅作两次解析。</p>
<p>总之，新的 native 的 prefix-instrumentation 的方式，改变了以前 Java 中 native 代码无法动态改变的缺点。在当前，利用 JNI 来写 native 代码也是 Java 应用中非常重要的一个环节，因此它的动态化意味着整个 Java 都可以动态改变了 —— 现在我们的代码可以利用加上 prefix 来动态改变 native 函数的指向，正如上面所说的，如果找不到，虚拟机还会去尝试做标准的解析，这让我们拥有了动态地替换 native 代码的方式，我们可以将许多带不同 prefix 的函数编译在一个动态链接库之中，而通过 instrument 包的功能，让 native 函数和 Java 函数一样动态改变、动态替换。</p>
<p>当然，现在的 native 的 instrumentation 还有一些限制条件，比如，不同的 transformer 会有自己的 native prefix，就是说，每一个 transformer 会负责他所替换的所有类而不是特定类的 prefix —— 因此这个粒度可能不够精确。</p>
<h3 id="Java-SE-6-新特性：BootClassPath-SystemClassPath-的动态增补"><a href="#Java-SE-6-新特性：BootClassPath-SystemClassPath-的动态增补" class="headerlink" title="Java SE 6 新特性：BootClassPath / SystemClassPath 的动态增补"></a>Java SE 6 新特性：BootClassPath / SystemClassPath 的动态增补</h3><p>我们知道，通过设置系统参数或者通过虚拟机启动参数，我们可以设置一个虚拟机运行时的 boot class 加载路径（-Xbootclasspath）和 system class（-cp）加载路径。当然，我们在运行之后无法替换它。然而，我们也许有时候要需要把某些 jar 加载到 bootclasspath 之中，而我们无法应用上述两个方法；或者我们需要在虚拟机启动之后来加载某些 jar 进入 bootclasspath。在 Java SE 6 之中，我们可以做到这一点了。</p>
<p>实现这几点很简单，首先，我们依然需要确认虚拟机已经支持这个功能，然后在 premain/agantmain 之中加上需要的 classpath。我们可以在我们的 Transformer 里使用 appendToBootstrapClassLoaderSearch/appendToSystemClassLoaderSearch 来完成这个任务。</p>
<p>同时我们可以注意到，在 agent 的 manifest 里加入 Boot-Class-Path 其实一样可以在动态地载入 agent 的同时加入自己的 boot class 路径，当然，在 Java code 中它可以更加动态方便和智能地完成 —— 我们可以很方便地加入判断和选择成分。</p>
<p>在这里我们也需要注意几点。首先，我们加入到 classpath 的 jar 文件中不应当带有任何和系统的 instrumentation 有关的系统同名类，不然，一切都陷入不可预料之中 —— 这不是一个工程师想要得到的结果，不是吗？</p>
<p>其次，我们要注意到虚拟机的 ClassLoader 的工作方式，它会记载解析结果。比如，我们曾经要求读入某个类 someclass，但是失败了，ClassLoader 会记得这一点。即使我们在后面动态地加入了某一个 jar，含有这个类，ClassLoader 依然会认为我们无法解析这个类，与上次出错的相同的错误会被报告。</p>
<p>再次我们知道在 Java 语言中有一个系统参数“java.class.path”，这个 property 里面记录了我们当前的 classpath，但是，我们使用这两个函数，虽然真正地改变了实际的 classpath，却不会对这个 property 本身产生任何影响。</p>
<p>在公开的 JavaDoc 中我们可以发现一个很有意思的事情，Sun 的设计师们告诉我们，这个功能事实上依赖于 ClassLoader 的 appendtoClassPathForInstrumentation 方法 —— 这是一个非公开的函数，因此我们不建议直接（使用反射等方式）使用它，事实上，instrument 包里的这两个函数已经可以很好的解决我们的问题了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://jakarta.apache.org/bcel/index.html" target="_blank" rel="external">http://jakarta.apache.org/bcel/index.html</a><br><a href="http://www.ibm.com/developerworks/cn/java/j-lo-instrumentation/" target="_blank" rel="external">Java 5 特性 Instrumentation 实践</a></p>
<p><a href="http://www.infoq.com/cn/articles/javaagent-illustrated" target="_blank" rel="external">JVM源码分析之javaagent原理完全解读</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是Java的Instrumentation&quot;&gt;&lt;a href=&quot;#什么是Java的Instrumentation&quot; class=&quot;headerlink&quot; title=&quot;什么是Java的Instrumentation ?&quot;&gt;&lt;/a&gt;什么是Java的Instrumentation ?&lt;/h3&gt;&lt;p&gt;JDK™5.0中引入包&lt;code&gt;java.lang.instrument&lt;/code&gt;。 该包提供了一个Java编程API，可以用来开发增强Java应用程序的工具，例如监视它们或收集性能信息。 使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。&lt;/p&gt;
&lt;p&gt;在 Java SE 6 里面，instrumentation 包被赋予了更强大的功能：&lt;code&gt;启动后的 instrument&lt;/code&gt;、&lt;code&gt;本地代码（native code）instrument&lt;/code&gt;，以及&lt;code&gt;动态改变 classpath&lt;/code&gt; 等等。这些改变，意味着 Java 具有了更强的动态控制、解释能力，它使得 Java 语言变得更加灵活多变。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>activemq监控之hawtio</title>
    <link href="https://leokongwq.github.io/2017/12/21/activemq-monitor-hawtio.html"/>
    <id>https://leokongwq.github.io/2017/12/21/activemq-monitor-hawtio.html</id>
    <published>2017-12-21T12:38:12.000Z</published>
    <updated>2017-12-21T13:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>要对系统进行压测，而系统依赖的消息中间件是Apache ActiveMQ。 在压测中需要衡量队列的堆积和消费情况。ActiveMQ自己的console不够友好，直观，需要不停的F5才能看到队列的堆积情况，而且只能反映瞬时的值，不能够知道整个压测过程过ActiveMQ的状态。</p>
<a id="more"></a>
<p>Google后发现ActiveMQ的监控有多种方式，具体可以参考官网地址：<a href="http://activemq.apache.org/how-can-i-monitor-activemq.html" target="_blank" rel="external">How can I monitor ActiveMQ</a></p>
<p>生产环境使用的是ActiveMQ版本是5.8，默认是集成了<a href="http://www.jolokia.org/" target="_blank" rel="external">Jolokia</a>。这样我们就可以通过<a href="http://hawt.io/" target="_blank" rel="external">hawt.io</a>这个开源的web console来对ActiveMQ进行监控。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>第一步：下载hawtio 地址为：<a href="http://hawt.io/getstarted/index.html" target="_blank" rel="external">http://hawt.io/getstarted/index.html</a></p>
<p>我使用的是<code>jar</code>方式。</p>
<p>第二部：启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">java -jar hawtio-app-1.5.6.jar --port 9999</span>
</pre></td></tr></table></figure>
<p>启动后打开地址：<a href="http://localhost:9999/hawtio" target="_blank" rel="external">http://localhost:9999/hawtio</a></p>
<p>点击右上角的connect菜单：</p>
<img src="/2017/12/21/activemq-monitor-hawtio/connect.jpg" alt="connect.jpg" title="">
<p>输入下面的参数：</p>
<ul>
<li>项目连接名称(用于保存连接使用)</li>
<li>ActiveMQ主机ip(或主机名)</li>
<li>ActiveMQ端口号(即ActiveMQ的jetty.xml文件中配置的管理页面端口号)</li>
<li>jolokia路径名(对ActiveMQ，使用/api/jolokia)</li>
</ul>
<p>保存后，点击<code>connect to remote server</code>。</p>
<p>在输出的页面中输入ActiveMQ Web Console的用户名和密码即可。</p>
<img src="/2017/12/21/activemq-monitor-hawtio/hawtio-index.png" alt="hawtio-index.png" title="">
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>hawtio 从版本 <code>1.5.0</code>开始，在连接远程JVM时，你需要在hawtio的启动JVM参数中添加：<code>hawtio.proxyWhitelist</code>。 格式是以’,’分割的域名或IP</p>
<p>具体参考：<a href="http://hawt.io/configuration/index.html" target="_blank" rel="external">http://hawt.io/configuration/index.html</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://hawt.io/getstarted/index.html" target="_blank" rel="external">http://hawt.io/getstarted/index.html</a><br><a href="https://stackoverflow.com/questions/43206932/unable-to-connect-to-remote-server-from-hawtio-dashboard" target="_blank" rel="external">https://stackoverflow.com/questions/43206932/unable-to-connect-to-remote-server-from-hawtio-dashboard</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;要对系统进行压测，而系统依赖的消息中间件是Apache ActiveMQ。 在压测中需要衡量队列的堆积和消费情况。ActiveMQ自己的console不够友好，直观，需要不停的F5才能看到队列的堆积情况，而且只能反映瞬时的值，不能够知道整个压测过程过ActiveMQ的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="MQ" scheme="https://leokongwq.github.io/categories/MQ/"/>
    
    
      <category term="ActiveQM" scheme="https://leokongwq.github.io/tags/ActiveQM/"/>
    
  </entry>
  
  <entry>
    <title>centos下安装crond</title>
    <link href="https://leokongwq.github.io/2017/12/20/centos-crond.html"/>
    <id>https://leokongwq.github.io/2017/12/20/centos-crond.html</id>
    <published>2017-12-20T07:05:50.000Z</published>
    <updated>2017-12-20T07:13:25.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在测试环境执行命令<code>crontab -l</code>，系统提示找不到该命令。很奇怪？印象中这中情况是第一次遇到。Google了一下了解到不是所有系统或某个发行版的所有版本都会默认安装该命令。</p>
<a id="more"></a>
<h3 id="centos6安装-crond"><a href="#centos6安装-crond" class="headerlink" title="centos6安装 crond"></a>centos6安装 crond</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">yum -y install vixie-cron</span>
<span class="line"></span>
<span class="line">service crond start</span>
<span class="line"></span>
<span class="line">chkconfig crond on</span>
</pre></td></tr></table></figure>
<h3 id="centos7安装-crond"><a href="#centos7安装-crond" class="headerlink" title="centos7安装 crond"></a>centos7安装 crond</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">yum install cronie</span>
</pre></td></tr></table></figure>
<h3 id="cron-服务"><a href="#cron-服务" class="headerlink" title="cron 服务"></a>cron 服务</h3><p>cron 是linux的内置服务，但它不是自动起来，可以用以下的方法启动、关闭这个服务：</p>
<p><code>/sbin/service crond start</code> //启动服务<br><code>/sbin/service crond stop</code> //关闭服务<br><code>/sbin/service crond restart</code> //重启服务<br><code>/sbin/service crond reload</code> //重新载入配置</p>
<p>查看crontab服务状态：<code>service crond status</code></p>
<p>查看crontab服务是否已设置为开机启动，执行命令：<code>ntsysv</code></p>
<p>加入开机自动启动:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">chkconfig --level 35 crond on</span>
</pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在测试环境执行命令&lt;code&gt;crontab -l&lt;/code&gt;，系统提示找不到该命令。很奇怪？印象中这中情况是第一次遇到。Google了一下了解到不是所有系统或某个发行版的所有版本都会默认安装该命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://leokongwq.github.io/tags/linux/"/>
    
      <category term="centos" scheme="https://leokongwq.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>vert.x异步回调地狱处理方式总结</title>
    <link href="https://leokongwq.github.io/2017/12/16/vertx-async-callback-hell.html"/>
    <id>https://leokongwq.github.io/2017/12/16/vertx-async-callback-hell.html</id>
    <published>2017-12-16T05:31:07.000Z</published>
    <updated>2017-12-16T14:00:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么是callback hell呢？看下图</p>
<img src="/2017/12/16/vertx-async-callback-hell/call-back-hello.jpg" alt="call-back-hello.jpg" title="">
<p>有过<a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>开发经验的人，一定程度上都被各种回调嵌套<code>折磨</code>过。过去和现在有很多针对Node.js异步回调嵌套处理的解决办法，这里就不讨论了。感兴趣的可以Google。</p>
<p>Vert.x号称JVM上的Node.js 肯定也会有遇到各种回调嵌套的问题。总结这些回调嵌套处理方式对我们使用Vert.x是非常有帮助的。</p>
<a id="more"></a>
<h3 id="通过Future来解决"><a href="#通过Future来解决" class="headerlink" title="通过Future来解决"></a>通过Future来解决</h3><p>前面我们知道<code>Future</code>接口中有一个方法是<code>setHandler</code>方法，这个方法设置Future完成时被调用的处理器；另外一个与之相对应的是<code>completer()</code>方法，这个方法返回的就是<code>setHandler</code>设置的handler函数。</p>
<p>有两个这个基础，下面来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
</pre></td><td class="code"><pre><span class="line">String filePath = <span class="string">"/data/abc.txt"</span>;</span>
<span class="line">fileSystem.createFile(filePath, as -&gt; &#123;</span>
<span class="line">    fileSystem.writeFile(filePath, Buffer.buffer(<span class="string">"hello"</span>.getBytes()), wr -&gt; &#123;</span>
<span class="line">        System.out.println(<span class="string">"write success"</span>);</span>
<span class="line">    &#125;);</span>
<span class="line">&#125;);</span>
</pre></td></tr></table></figure>
<p>上面的代码创建了文件，并在文件中写入一个字符串。下面我们用Future进行一下改写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
</pre></td><td class="code"><pre><span class="line">Future&lt;Void&gt; future = Future.future();</span>
<span class="line">future.setHandler(as -&gt; &#123;</span>
<span class="line">  System.out.println(<span class="string">"write success"</span>);</span>
<span class="line">  async.complete();</span>
<span class="line">&#125;);</span>
<span class="line">String filePath = <span class="string">"/data/abc.txt"</span>;</span>
<span class="line">FileSystem fileSystem = vertx.fileSystem();</span>
<span class="line">fileSystem.createFile(filePath, as -&gt; &#123;</span>
<span class="line">    fileSystem.writeFile(filePath, Buffer.buffer(<span class="string">"hello"</span>.getBytes()), future);</span>
<span class="line">&#125;);</span>
</pre></td></tr></table></figure>
<p>这样就消除了一个嵌套的回调函数。</p>
<p>再来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
</pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span>
<span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateFile2</span><span class="params">(TestContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span>
<span class="line">   Async async = context.async();</span>
<span class="line">   String filePath = <span class="string">"/data/abc.txt"</span>;</span>
<span class="line">   FileSystem fileSystem = vertx.fileSystem();</span>
<span class="line"></span>
<span class="line">   Future&lt;Void&gt; createFileFuture = Future.future();</span>
<span class="line">   Future&lt;Void&gt; writeFileFuture = Future.future();</span>
<span class="line">   writeFileFuture.setHandler(as -&gt; &#123;</span>
<span class="line">       System.out.println(<span class="string">"success"</span>);</span>
<span class="line">       async.complete();</span>
<span class="line">   &#125;);</span>
<span class="line">   createFileFuture.compose(as -&gt; &#123;</span>
<span class="line">       fileSystem.writeFile(filePath, Buffer.buffer(<span class="string">"Hello"</span>.getBytes()), writeFileFuture);</span>
<span class="line">   &#125;, writeFileFuture);</span>
<span class="line"></span>
<span class="line">   fileSystem.createFile(filePath, createFileFuture);</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>通过Future的compose方法我们可以对Future进行组合，以次来消除callback hell。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;什么是callback hell呢？看下图&lt;/p&gt;
&lt;img src=&quot;/2017/12/16/vertx-async-callback-hell/call-back-hello.jpg&quot; alt=&quot;call-back-hello.jpg&quot; title=&quot;&quot;&gt;
&lt;p&gt;有过&lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;开发经验的人，一定程度上都被各种回调嵌套&lt;code&gt;折磨&lt;/code&gt;过。过去和现在有很多针对Node.js异步回调嵌套处理的解决办法，这里就不讨论了。感兴趣的可以Google。&lt;/p&gt;
&lt;p&gt;Vert.x号称JVM上的Node.js 肯定也会有遇到各种回调嵌套的问题。总结这些回调嵌套处理方式对我们使用Vert.x是非常有帮助的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vert.x" scheme="https://leokongwq.github.io/tags/vert-x/"/>
    
  </entry>
  
  <entry>
    <title>vertx-Future</title>
    <link href="https://leokongwq.github.io/2017/12/15/vertx-Future.html"/>
    <id>https://leokongwq.github.io/2017/12/15/vertx-Future.html</id>
    <published>2017-12-15T11:57:31.000Z</published>
    <updated>2017-12-16T13:12:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Java中<code>Future</code>表示一个异步计算的结果，提供了许多方法来获取结果，取消计算等。在Vert.x中<code>Future</code>表示一个动作的结果，该结果可能出现也可能没有出现。二者有许多相似之处。</p>
<p>Vert.x中<code>Future</code>的继承层次如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AsyncResult</span>&lt;<span class="title">T</span>&gt;, <span class="title">Handler</span>&lt;<span class="title">AsyncResult</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span>
<span class="line">    ...</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>在分析<code>Future</code>前我们先来看下<code>AsyncResult</code>和<code>Handler</code>的具体功能。</p>
<h3 id="AsyncResult"><a href="#AsyncResult" class="headerlink" title="AsyncResult"></a>AsyncResult</h3><p><code>AsyncResult</code>包装了一个异步操作的结果。接口声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span>
<span class="line">    ...</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>主要方法有：</p>
<h4 id="T-result"><a href="#T-result" class="headerlink" title="T result()"></a>T result()</h4><p><code>T result()</code> 方法用来获取异步操作的结果。</p>
<h4 id="Throwable-cause"><a href="#Throwable-cause" class="headerlink" title="Throwable cause()"></a>Throwable cause()</h4><p><code>Throwable cause()</code> 方法用来异步操作失败的异常。</p>
<h4 id="boolean-succeeded"><a href="#boolean-succeeded" class="headerlink" title="boolean succeeded()"></a>boolean succeeded()</h4><p><code>boolean succeeded()</code> 方法用来判断异步操作是否成功。</p>
<h4 id="boolean-failed"><a href="#boolean-failed" class="headerlink" title="boolean failed();"></a>boolean failed();</h4><p><code>boolean failed()</code> 方法用来判断异步操作是否失败。</p>
<h4 id="default-AsyncResult-map-Function-mapper"><a href="#default-AsyncResult-map-Function-mapper" class="headerlink" title="default  AsyncResult map(Function mapper)"></a>default <u> AsyncResult<u> map(Function<t, u=""> mapper)</t,></u></u></h4><p>该方法用来该异步操作的结果通过一个映射<code>mapper</code>函数转换为另一个结果。</p>
<h4 id="default-AsyncResult-map-V-value"><a href="#default-AsyncResult-map-V-value" class="headerlink" title="default  AsyncResult map(V value)"></a>default <v> AsyncResult<v> map(V value)</v></v></h4><p>该方法用来该异步操作的结果映射为参数<code>value</code>指定的值。</p>
<h4 id="default-AsyncResult-mapEmpty"><a href="#default-AsyncResult-mapEmpty" class="headerlink" title="default  AsyncResult mapEmpty()"></a>default <v> AsyncResult<v> mapEmpty()</v></v></h4><p>该方法用来将异步操作的结果映射为一个空值。</p>
<h4 id="default-AsyncResult-otherwise-Function-mapper"><a href="#default-AsyncResult-otherwise-Function-mapper" class="headerlink" title="default AsyncResult otherwise(Function mapper)"></a>default AsyncResult<t> otherwise(Function<throwable, t=""> mapper)</throwable,></t></h4><p>该方法用来在该异步操作结果是失败时，通过参数<code>mapper</code>指定映射函数将结果映射为其它值。</p>
<h4 id="default-AsyncResult-otherwise-T-value"><a href="#default-AsyncResult-otherwise-T-value" class="headerlink" title="default AsyncResult otherwise(T value)"></a>default AsyncResult<t> otherwise(T value)</t></h4><p>该方法和上一个方法功能相同。</p>
<h4 id="default-AsyncResult-otherwiseEmpty"><a href="#default-AsyncResult-otherwiseEmpty" class="headerlink" title="default AsyncResult otherwiseEmpty()"></a>default AsyncResult<t> otherwiseEmpty()</t></h4><p>该方法和上一个方法功能相同，不同点在于返回一个空值。</p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><code>Handler</code> 在Vert.x中非常重要，用来处理Vert.x中所有的异步操作结果。</p>
<p>它只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(E event)</span></span>;</span>
</pre></td></tr></table></figure>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p><code>Future</code>的方法很多，我们只分析非常重要的一些。</p>
<h4 id="创建一个Future对象"><a href="#创建一个Future对象" class="headerlink" title="创建一个Future对象"></a>创建一个<code>Future</code>对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">future</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>上面的代码创建了一个还没有完成的Future。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">future</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; handler)</span></span></span>
</pre></td></tr></table></figure>
<p>上面的代码创建了一个还没有完成的Future，并且在该Future还没有返回前就传递给参数指定的<code>Handler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">succeededFuture</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<p>上面的代码创建了一个已经完成的Future，其结果为null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">succeededFuture</span><span class="params">(T result)</span></span></span>
</pre></td></tr></table></figure>
<p>上面的代码创建了一个已经完成的Future，其结果为参数<code>result</code>指定的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">failedFuture</span><span class="params">(Throwable t)</span> </span>
<span class="line"><span class="keyword">static</span> &lt;T&gt; Future&lt;T&gt; <span class="title">failedFuture</span><span class="params">(String failureMessage)</span></span></span>
</pre></td></tr></table></figure>
<p>上面的代码创建了失败的Future。</p>
<h4 id="判断Future的结果"><a href="#判断Future的结果" class="headerlink" title="判断Future的结果"></a>判断Future的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isComplete</span><span class="params">()</span></span>; <span class="comment">//是否完成</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">succeeded</span><span class="params">()</span></span>; <span class="comment">//是否成功</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">failed</span><span class="params">()</span></span>; <span class="comment">//是否是否</span></span>
</pre></td></tr></table></figure>
<h4 id="设置Future的结果"><a href="#设置Future的结果" class="headerlink" title="设置Future的结果"></a>设置Future的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">(T result)</span></span>; <span class="comment">//设置Future的结果为参数指定值</span></span>
<span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span></span>; <span class="comment">//设置Future的结果为null</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryComplete</span><span class="params">(T result)</span></span>;  <span class="comment">//尝试设置Future的结果为参数指定值</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryComplete</span><span class="params">()</span></span>; <span class="comment">//尝试设置Future的结果为null</span></span>
<span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable cause)</span></span>; <span class="comment">//设置Future为失败状态</span></span>
<span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(String failureMessage)</span></span>; <span class="comment">//设置Future为失败状态</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryFail</span><span class="params">(Throwable cause)</span></span>; <span class="comment">//尝试设置Future为失败状态</span></span>
<span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryFail</span><span class="params">(String failureMessage)</span></span>; <span class="comment">//尝试设置Future为失败状态</span></span>
</pre></td></tr></table></figure>
<h4 id="Future的组合"><a href="#Future的组合" class="headerlink" title="Future的组合"></a>Future的组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;U&gt; <span class="function">Future&lt;U&gt; <span class="title">compose</span><span class="params">(Handler&lt;T&gt; handler, Future&lt;U&gt; next)</span></span>
<span class="line"><span class="keyword">default</span> &lt;U&gt; Future&lt;U&gt; <span class="title">compose</span><span class="params">(Function&lt;T, Future&lt;U&gt;&gt; mapper)</span></span></span>
</pre></td></tr></table></figure>
<h4 id="Future-的转换-映射"><a href="#Future-的转换-映射" class="headerlink" title="Future 的转换/映射"></a>Future 的转换/映射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;U&gt; <span class="function">Future&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;T, U&gt; mapper)</span></span>
<span class="line"><span class="keyword">default</span> &lt;V&gt; Future&lt;V&gt; <span class="title">map</span><span class="params">(V value)</span></span>
<span class="line"><span class="keyword">default</span> &lt;V&gt; Future&lt;V&gt; <span class="title">mapEmpty</span><span class="params">()</span></span></span>
</pre></td></tr></table></figure>
<h4 id="Future-setHandler-Handler"><a href="#Future-setHandler-Handler" class="headerlink" title="Future setHandler(Handler"></a>Future<t> setHandler(Handler<asyncresult<t>&gt; handler)</asyncresult<t></t></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;T&gt; <span class="title">setHandler</span><span class="params">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span></span></span>
</pre></td></tr></table></figure>
<p>该方法用来设置该Future完成时被调用的处理器的。</p>
<h4 id="default-Handler"><a href="#default-Handler" class="headerlink" title="default Handler"></a>default Handler<asyncresult<t>&gt; completer()</asyncresult<t></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Handler&lt;AsyncResult&lt;T&gt;&gt; completer()</span>
</pre></td></tr></table></figure>
<p>该方法用来返回该Future完成时被调用的处理器的。</p>
<h3 id="Future-使用的一个例子"><a href="#Future-使用的一个例子" class="headerlink" title="Future 使用的一个例子"></a>Future 使用的一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
</pre></td><td class="code"><pre><span class="line">Async async = context.async();</span>
<span class="line">Future&lt;Void&gt; future = Future.future();</span>
<span class="line">future.setHandler(as -&gt; &#123;</span>
<span class="line">  System.out.println(<span class="string">"write success"</span>);</span>
<span class="line">  async.complete();</span>
<span class="line">&#125;);</span>
<span class="line">String filePath = <span class="string">"/data/abc.txt"</span>;</span>
<span class="line">FileSystem fileSystem = vertx.fileSystem();</span>
<span class="line">fileSystem.createFile(filePath, as -&gt; &#123;</span>
<span class="line">    fileSystem.writeFile(filePath, Buffer.buffer(<span class="string">"hello"</span>.getBytes()), future);</span>
<span class="line">&#125;);</span>
</pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Java中&lt;code&gt;Future&lt;/code&gt;表示一个异步计算的结果，提供了许多方法来获取结果，取消计算等。在Vert.x中&lt;code&gt;Future&lt;/code&gt;表示一个动作的结果，该结果可能出现也可能没有出现。二者有许多相似之处。&lt;/p&gt;
&lt;p&gt;Vert.x中&lt;code&gt;Future&lt;/code&gt;的继承层次如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="vert.x" scheme="https://leokongwq.github.io/tags/vert-x/"/>
    
  </entry>
  
  <entry>
    <title>vertx集群模式</title>
    <link href="https://leokongwq.github.io/2017/12/06/vertx-cluster.html"/>
    <id>https://leokongwq.github.io/2017/12/06/vertx-cluster.html</id>
    <published>2017-12-06T11:34:26.000Z</published>
    <updated>2017-12-06T13:00:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vert-x-集群简介"><a href="#vert-x-集群简介" class="headerlink" title="vert.x 集群简介"></a>vert.x 集群简介</h3><p>在 Vert.x 中，集群化与高可用均是开箱即用的。Vert.x 通过可插拔的集群管理器（cluster manager）来实现集群管理。在 Vert.x 中，采用 Hazelcast 作为默认的集群管理器。</p>
<h3 id="vert-x-集群器管理的作用"><a href="#vert-x-集群器管理的作用" class="headerlink" title="vert.x 集群器管理的作用"></a>vert.x 集群器管理的作用</h3><p>在 Vert.x 中，集群管理器可用于各种功能，包括：</p>
<ul>
<li>对集群中 <code>Vert.x</code>结点进行分组，服务注册和发现</li>
<li>维护集群范围中的主题订阅者列表（所以我们可知道哪些节点对哪个Event Bus地址感兴趣）</li>
<li>分布式Map的支持</li>
<li>分布式锁</li>
<li>分布式计数器</li>
</ul>
<p>集群管理器不处理Event Bus节点之间的传输，这是由 Vert.x 直接通过TCP连接完成。</p>
<a id="more"></a>
<h3 id="vert-x集群管理器设置"><a href="#vert-x集群管理器设置" class="headerlink" title="vert.x集群管理器设置"></a>vert.x集群管理器设置</h3><p>Vert.x发行版中使用的默认集群管理器是使用的Hazelcast集群管理器，但是它可以轻松被替换成实现了Vert.x集群管理器接口的不同实现，因为Vert.x集群管理器可替换的。</p>
<p>集群管理器必须实现<code>ClusterManager</code>接口，Vert.x在运行时使用Java的服务加载器（<code>Service Loader</code>）功能查找集群管理器，以便在类路径中查找<code>ClusterManager</code>的实例。</p>
<h4 id="命令行设置"><a href="#命令行设置" class="headerlink" title="命令行设置"></a>命令行设置</h4><p>若您在命令行中使用Vert.x并要使用集群，则应确保Vert.x安装的lib目录包含您的集群管理器jar。</p>
<h4 id="依赖设置"><a href="#依赖设置" class="headerlink" title="依赖设置"></a>依赖设置</h4><p>若您在 Maven/Gradle 项目使用Vert.x，则只需将集群管理器jar作为项目依赖添加。</p>
<p>maven</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
</pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span>
<span class="line">  &lt;groupId&gt;io.vertx&lt;/groupId&gt;</span>
<span class="line">  &lt;artifactId&gt;vertx-hazelcast&lt;/artifactId&gt;</span>
<span class="line">  &lt;version&gt;3.5.0&lt;/version&gt;</span>
<span class="line">&lt;/dependency&gt;</span>
</pre></td></tr></table></figure>
<p>gradle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.vertx:vertx-hazelcast:3.5.0'</span></span>
</pre></td></tr></table></figure>
<h4 id="编程设置"><a href="#编程设置" class="headerlink" title="编程设置"></a>编程设置</h4><p>您也可以以编程的方式在嵌入Vert.x 时使用<code>setClusterManager</code>指定集群管理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
</pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ClusterManger对象</span></span>
<span class="line">ClusterManager mgr = <span class="keyword">new</span> HazelcastClusterManager();</span>
<span class="line"><span class="comment">//设置到Vertx启动参数中</span></span>
<span class="line">VertxOptions options = <span class="keyword">new</span> VertxOptions().setClusterManager(mgr);</span>
<span class="line"></span>
<span class="line">Vertx.clusteredVertx(options, res -&gt; &#123;</span>
<span class="line">  <span class="keyword">if</span> (res.succeeded()) &#123;</span>
<span class="line">    Vertx vertx = res.result();</span>
<span class="line">  &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">    <span class="comment">// failed!</span></span>
<span class="line">  &#125;</span>
<span class="line">&#125;);</span>
</pre></td></tr></table></figure>
<h4 id="集群管理器设置顺序"><a href="#集群管理器设置顺序" class="headerlink" title="集群管理器设置顺序"></a>集群管理器设置顺序</h4><figure class="highlight java"><figcaption><span>VertxImpl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
<span class="line">14</span>
<span class="line">15</span>
<span class="line">16</span>
<span class="line">17</span>
<span class="line">18</span>
<span class="line">19</span>
<span class="line">20</span>
<span class="line">21</span>
<span class="line">22</span>
<span class="line">23</span>
<span class="line">24</span>
<span class="line">25</span>
<span class="line">26</span>
<span class="line">27</span>
<span class="line">28</span>
<span class="line">29</span>
<span class="line">30</span>
<span class="line">31</span>
<span class="line">32</span>
</pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ClusterManager <span class="title">getClusterManager</span><span class="params">(VertxOptions options)</span> </span>&#123;</span>
<span class="line">    <span class="comment">//是否启用集群模式</span></span>
<span class="line">    <span class="keyword">if</span> (options.isClustered()) &#123;</span>
<span class="line">        <span class="comment">// 编程设置优先</span></span>
<span class="line">        <span class="keyword">if</span> (options.getClusterManager() != <span class="keyword">null</span>) &#123;</span>
<span class="line">            <span class="keyword">return</span> options.getClusterManager();</span>
<span class="line">        &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">            ClusterManager mgr;</span>
<span class="line">            <span class="comment">//命令行参数</span></span>
<span class="line">            String clusterManagerClassName =    System.getProperty(<span class="string">"vertx.cluster.managerClass"</span>);</span>
<span class="line">            <span class="keyword">if</span> (clusterManagerClassName != <span class="keyword">null</span>) &#123;</span>
<span class="line">                <span class="comment">// We allow specify a sys prop for the cluster manager factory which </span></span>
<span class="line">                <span class="comment">// overrides ServiceLoader</span></span>
<span class="line">                <span class="keyword">try</span> &#123;</span>
<span class="line">                    Class&lt;?&gt; clazz = Class.forName(clusterManagerClassName);</span>
<span class="line">                    mgr = (ClusterManager) clazz.newInstance();</span>
<span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span>
<span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to instantiate "</span> +  clusterManagerClassName, e);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">                <span class="comment">// 服务查找</span></span>
<span class="line">                mgr = ServiceHelper.loadFactoryOrNull(ClusterManager.class);</span>
<span class="line">                <span class="keyword">if</span> (mgr == <span class="keyword">null</span>) &#123;</span>
<span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No ClusterManagerFactory instances found on classpath"</span>);</span>
<span class="line">                &#125;</span>
<span class="line">            &#125;</span>
<span class="line">            <span class="keyword">return</span> mgr;</span>
<span class="line">        &#125;</span>
<span class="line">    &#125; <span class="keyword">else</span> &#123;</span>
<span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span>
<span class="line">    &#125;</span>
<span class="line">&#125;</span>
</pre></td></tr></table></figure>
<p>总结一下查找顺序：</p>
<ol>
<li>首先通过 VertxOptions 对象获取集群管理器</li>
<li>通过命令行参数指定 集群管理器的实现类</li>
<li>通过Java的<code>service load</code>方式加载</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vert-x-集群简介&quot;&gt;&lt;a href=&quot;#vert-x-集群简介&quot; class=&quot;headerlink&quot; title=&quot;vert.x 集群简介&quot;&gt;&lt;/a&gt;vert.x 集群简介&lt;/h3&gt;&lt;p&gt;在 Vert.x 中，集群化与高可用均是开箱即用的。Vert.x 通过可插拔的集群管理器（cluster manager）来实现集群管理。在 Vert.x 中，采用 Hazelcast 作为默认的集群管理器。&lt;/p&gt;
&lt;h3 id=&quot;vert-x-集群器管理的作用&quot;&gt;&lt;a href=&quot;#vert-x-集群器管理的作用&quot; class=&quot;headerlink&quot; title=&quot;vert.x 集群器管理的作用&quot;&gt;&lt;/a&gt;vert.x 集群器管理的作用&lt;/h3&gt;&lt;p&gt;在 Vert.x 中，集群管理器可用于各种功能，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对集群中 &lt;code&gt;Vert.x&lt;/code&gt;结点进行分组，服务注册和发现&lt;/li&gt;
&lt;li&gt;维护集群范围中的主题订阅者列表（所以我们可知道哪些节点对哪个Event Bus地址感兴趣）&lt;/li&gt;
&lt;li&gt;分布式Map的支持&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;li&gt;分布式计数器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群管理器不处理Event Bus节点之间的传输，这是由 Vert.x 直接通过TCP连接完成。&lt;/p&gt;
    
    </summary>
    
    
      <category term="vert.x" scheme="https://leokongwq.github.io/tags/vert-x/"/>
    
  </entry>
  
</feed>
