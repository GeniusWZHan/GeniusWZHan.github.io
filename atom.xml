<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戒修-沉迷技术的小沙弥</title>
  <subtitle>认识自己很重要！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leokongwq.github.io/"/>
  <updated>2020-05-31T12:06:54.768Z</updated>
  <id>https://leokongwq.github.io/</id>
  
  <author>
    <name>kongwenqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring aop 与 aspectj</title>
    <link href="https://leokongwq.github.io/2020/05/31/spring-aop-aspectj.html"/>
    <id>https://leokongwq.github.io/2020/05/31/spring-aop-aspectj.html</id>
    <published>2020-05-31T08:30:15.000Z</published>
    <updated>2020-05-31T12:06:54.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="aspectj-是什么？"><a href="#aspectj-是什么？" class="headerlink" title="aspectj 是什么？"></a>aspectj 是什么？</h2><p>官网如此描述:</p>
<ul>
<li>对Java编程语言中的AOP进行无缝扩展(这点很重要)</li>
<li>适用Java平台</li>
<li>易学易用</li>
</ul>
<h2 id="aspectj如何使用"><a href="#aspectj如何使用" class="headerlink" title="aspectj如何使用"></a>aspectj如何使用</h2><p>aspectj 有三种使用方式：</p>
<ol>
<li>编译时织入，利用ajc编译器直接将切面织入到源代码中并编译为class</li>
<li>编译后织入，利用ajc编译器向编译后的class或jar织入切面代码</li>
<li>运行时织入，不使用ajc编译器，而是利用java agent的能力，在类加载时将切面织入目标代码。</li>
</ol>
<p>下面我们就看看这三种方式具体如何使用：</p>
<a id="more"></a>
<h3 id="编译时织入"><a href="#编译时织入" class="headerlink" title="编译时织入"></a>编译时织入</h3><p>现在都是使用Maven管理项目，必然后对应的Maven插件来满足编译时织入的目的：</p>
<p>aspectj-maven-plugin 插件配置如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.11&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;complianceLevel&gt;$&#123;source.version&#125;&lt;/complianceLevel&gt;</span><br><span class="line">        &lt;source&gt;$&#123;source.version&#125;&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;$&#123;source.version&#125;&lt;/target&gt;</span><br><span class="line">        &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt;</span><br><span class="line">        &lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">        &lt;outputDirectory&gt;$&#123;build.outputDirectory&#125;&lt;/outputDirectory&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                &lt;goal&gt;test-compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p>要增强的目标类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2020/5/31 - 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloApp app = <span class="keyword">new</span> HelloApp();</span><br><span class="line">        app.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>aspectj文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2020/5/31 - 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> aspect AjAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointcut <span class="title">say</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">            <span class="title">execution</span><span class="params">(* HelloApp.say(..)</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    before(): say() &#123;</span><br><span class="line">        System.out.println(<span class="string">"before say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(): say() &#123;</span><br><span class="line">        System.out.println(<span class="string">"after say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mvn compile 后，观察增强后的class文件和切面类文件:</p>
<p>AjAspect.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ajc$postClinit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var1) &#123;</span><br><span class="line">            ajc$initFailureCause = var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AjAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(</span><br><span class="line">        value = <span class="string">"say()"</span>,</span><br><span class="line">        argNames = <span class="string">""</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> ajc$before$com_leokongwq_springlearn_aop_AjAspect$<span class="number">1</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">        System.out.println(<span class="string">"before say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(</span><br><span class="line">        value = <span class="string">"say()"</span>,</span><br><span class="line">        argNames = <span class="string">""</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> ajc$after$com_leokongwq_springlearn_aop_AjAspect$<span class="number">2</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">        System.out.println(<span class="string">"after say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AjAspect <span class="title">aspectOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ajc$perSingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoAspectBoundException(<span class="string">"com_leokongwq_springlearn_aop_AjAspect"</span>, ajc$initFailureCause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ajc$perSingletonInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ajc$perSingletonInstance != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见切面描述文件<code>AjAspect.aj</code> 被编译为一个单例类，增强的功能对应一个静态方法。</p>
<p>HelloApp.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.leokongwq.springlearn.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AjAspect.aspectOf().ajc$before$com_leokongwq_springlearn_aop_AjAspect$<span class="number">1</span>$<span class="number">682722</span>c();</span><br><span class="line">            System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var2) &#123;</span><br><span class="line">            AjAspect.aspectOf().ajc$after$com_leokongwq_springlearn_aop_AjAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AjAspect.aspectOf().ajc$after$com_leokongwq_springlearn_aop_AjAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloApp app = <span class="keyword">new</span> HelloApp();</span><br><span class="line">        app.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被增强类的方法中直接包含了增强逻辑。</p>
<h4 id="基于注解增强"><a href="#基于注解增强" class="headerlink" title="基于注解增强"></a>基于注解增强</h4><p>上面展示了如何基于<code>*.aj</code>文件对目标类进行增强。其实也可以通过基于Aspectj注解的Java类来描述切面和增强逻辑等相关信息，进而对目标类进行源代码级别的增强。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.leokongwq.springlearn.aop.HelloApp.sayHi(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">watchPerform</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"########### around before invoke ###############"</span>);</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"########### around after invoke ###############"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增强后的class文件内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leokongwq.springlearn.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.runtime.reflect.*;</span><br><span class="line"><span class="keyword">import</span> com.leokongwq.springlearn.component.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="comment">/* synthetic */</span> JoinPoint$StaticPart ajc$tjp_0;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AjAspect.aspectOf().ajc$before$com_leokongwq_springlearn_aop_AjAspect$<span class="number">1</span>$<span class="number">682722</span>c();</span><br><span class="line">            System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            AjAspect.aspectOf().ajc$after$com_leokongwq_springlearn_aop_AjAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        AjAspect.aspectOf().ajc$after$com_leokongwq_springlearn_aop_AjAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> JoinPoint jp = Factory.makeJP(HelloApp.ajc$tjp_0, (Object)<span class="keyword">this</span>, (Object)<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (String)sayHi_aroundBody1$advice(<span class="keyword">this</span>, jp, AopAspect.aspectOf(), (ProceedingJoinPoint)jp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HelloApp app = <span class="keyword">new</span> HelloApp();</span><br><span class="line">        app.say();</span><br><span class="line">        app.sayHi();</span><br><span class="line">        System.out.println(Math.abs(-<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ajc$preClinit();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="comment">/* synthetic */</span> <span class="function">String <span class="title">sayHi_aroundBody0</span><span class="params">(<span class="keyword">final</span> HelloApp ajc$<span class="keyword">this</span>, <span class="keyword">final</span> JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hi java"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="comment">/* synthetic */</span> Object sayHi_aroundBody1$advice(<span class="keyword">final</span> HelloApp ajc$<span class="keyword">this</span>, <span class="keyword">final</span> JoinPoint thisJoinPoint, <span class="keyword">final</span> AopAspect ajc$aspectInstance, <span class="keyword">final</span> ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">        System.out.println(<span class="string">"########### around before invoke ###############"</span>);</span><br><span class="line">        <span class="keyword">final</span> Object result = sayHi_aroundBody0(ajc$<span class="keyword">this</span>, (JoinPoint)joinPoint);</span><br><span class="line">        System.out.println(<span class="string">"########### around after invoke ###############"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> ajc$preClinit() &#123;</span><br><span class="line">        <span class="keyword">final</span> Factory factory = <span class="keyword">new</span> Factory(<span class="string">"HelloApp.java"</span>, (Class)HelloApp.class);</span><br><span class="line">        ajc$tjp_0 = factory.makeSJP(<span class="string">"method-execution"</span>, (Signature)factory.makeMethodSig(<span class="string">"1"</span>, <span class="string">"sayHi"</span>, <span class="string">"com.leokongwq.springlearn.aop.HelloApp"</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"java.lang.String"</span>), <span class="number">13</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以class文件的内容可以看到<code>sayHi</code>方法被增强了。</p>
<h3 id="编译后织入"><a href="#编译后织入" class="headerlink" title="编译后织入"></a>编译后织入</h3><p>这个功能主要是用来面向依赖的第三方类库的。因为通常我们不能修改源代码，但是还有对它进行增强的需求。那么只能依赖于编译后织入，或者在类加载时transform。</p>
<p>maven配置</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.11&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;complianceLevel&gt;$&#123;source.version&#125;&lt;/complianceLevel&gt;</span><br><span class="line">        &lt;source&gt;$&#123;source.version&#125;&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;$&#123;source.version&#125;&lt;/target&gt;</span><br><span class="line">        &lt;showWeaveInfo&gt;true&lt;/showWeaveInfo&gt;</span><br><span class="line">        &lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">        &lt;!--&lt;aspectDirectory&gt;src/main/java/com/leokongwq/springlearn/aop&lt;/aspectDirectory&gt;--&gt;</span><br><span class="line">        &lt;outputDirectory&gt;$&#123;build.outputDirectory&#125;&lt;/outputDirectory&gt;</span><br><span class="line">        &lt;!-- 对依赖的包进行织入 --&gt;</span><br><span class="line">        &lt;weaveDependencies&gt;</span><br><span class="line">            &lt;weaveDependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">            &lt;/weaveDependency&gt;</span><br><span class="line">        &lt;/weaveDependencies&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                &lt;goal&gt;test-compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p>示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.google.gson.Gson.toJson(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">watchtoJson</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"########### around before toJson ###############"</span>);</span><br><span class="line">    Object result = joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"########### around after toJson ###############"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    result.put(<span class="string">"code"</span>, <span class="string">"SUCCESS"</span>);</span><br><span class="line">    System.out.println(gson.toJson(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">########### around before toJson ###############</span><br><span class="line">########### around before toJson ###############</span><br><span class="line">########### around before toJson ###############</span><br><span class="line">########### around before toJson ###############</span><br><span class="line">########### around after toJson ###############</span><br><span class="line">########### around after toJson ###############</span><br><span class="line">########### around after toJson ###############</span><br><span class="line">########### around after toJson ###############</span><br><span class="line">&#123;<span class="string">"code"</span>:<span class="string">"SUCCESS"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>为啥有多行呢？答案留给读者朋友。</p>
<h3 id="加载时增强"><a href="#加载时增强" class="headerlink" title="加载时增强"></a>加载时增强</h3><p>加载时增强和编译后增强本质上是一样的。不同点在于将增强的时机延迟到JVM加载类的时候。</p>
<p>maven配置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.10&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;argLine&gt;</span><br><span class="line">            -javaagent:$&#123;user.home&#125;/.m2/repository/org/aspectj/aspectjweaver/$&#123;aspectj.version&#125;/aspectjweaver-$&#123;aspectj.version&#125;.jar</span><br><span class="line">        &lt;/argLine&gt;</span><br><span class="line">        &lt;useSystemClassLoader&gt;true&lt;/useSystemClassLoader&gt;</span><br><span class="line">        &lt;forkMode&gt;always&lt;/forkMode&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<p>这个配置主要是用来添加命令行参数。当然了，你也可以在idea的<code>VM options</code>配置框里面填写参数，或者在项目启动脚本中配置JVM参数。 这里需要指定的参数是<code>-javaagent:/path/to/agent.jar</code></p>
<p>只是指定了javaagent还不够，还需要指定需要对那些类进行什么样的增强。</p>
<p>在将项目的resources目录下面建一个子目录<code>META-INF</code>，在该目录中创建配置文件<code>aop.xml</code>，文件内如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"com.leokongwq.springlearn.component.GsonAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">weaver</span> <span class="attr">options</span>=<span class="string">"-verbose -showWeaveInfo"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">"com.google.gson.*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>到此就配置好了。启动单元测试，就能看到结果。</p>
<h2 id="aspectj-与Spring-AOP的关系"><a href="#aspectj-与Spring-AOP的关系" class="headerlink" title="aspectj 与Spring AOP的关系"></a>aspectj 与Spring AOP的关系</h2><p>从上一篇文章和上面的内容可知:</p>
<ol>
<li>在日常的Spring AOP使用过程中我们并没有用到Aspectj的<strong>织入</strong>能力，使用到的大都是Aspectj提供的注解和切面相关的语法。</li>
<li>Spring AOP的实现底层是基于JDK代理和CGLIB代理实现的。</li>
<li>AOP的实现可以基于织入，也可以基于代理。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;aspectj-是什么？&quot;&gt;&lt;a href=&quot;#aspectj-是什么？&quot; class=&quot;headerlink&quot; title=&quot;aspectj 是什么？&quot;&gt;&lt;/a&gt;aspectj 是什么？&lt;/h2&gt;&lt;p&gt;官网如此描述:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对Java编程语言中的AOP进行无缝扩展(这点很重要)&lt;/li&gt;
&lt;li&gt;适用Java平台&lt;/li&gt;
&lt;li&gt;易学易用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;aspectj如何使用&quot;&gt;&lt;a href=&quot;#aspectj如何使用&quot; class=&quot;headerlink&quot; title=&quot;aspectj如何使用&quot;&gt;&lt;/a&gt;aspectj如何使用&lt;/h2&gt;&lt;p&gt;aspectj 有三种使用方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译时织入，利用ajc编译器直接将切面织入到源代码中并编译为class&lt;/li&gt;
&lt;li&gt;编译后织入，利用ajc编译器向编译后的class或jar织入切面代码&lt;/li&gt;
&lt;li&gt;运行时织入，不使用ajc编译器，而是利用java agent的能力，在类加载时将切面织入目标代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们就看看这三种方式具体如何使用：&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://leokongwq.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring中AOP实现分析-第一篇</title>
    <link href="https://leokongwq.github.io/2020/05/29/spring-aop-analyze-1.html"/>
    <id>https://leokongwq.github.io/2020/05/29/spring-aop-analyze-1.html</id>
    <published>2020-05-29T14:27:16.000Z</published>
    <updated>2020-05-30T13:19:42.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇关于Spring AOP的总结分析文章，帮助自己记忆。</p>
<h2 id="AOP配置"><a href="#AOP配置" class="headerlink" title="AOP配置"></a>AOP配置</h2><p>下面的例子是通过注解驱动的AOP例子：</p>
<p>启用Spring AOP：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者通过下面的注解方式启用Spring AOP</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(exposeProxy = <span class="keyword">true</span>, proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>待增强的类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2020/5/29 - 22:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hi : "</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重用的切点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.leokongwq.springlearn.service.IHelloService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"perform()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"########### before invoke ###############"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的步骤我们就配置好了一个简单的Spring AOP 使用例子。</p>
<p>执行效果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">########### around before invoke ###############</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了简单起见，不在演示切点表达式如何写，这种Advice的效果。</p>
</blockquote>
<p>效果有了，那spring究竟是如何实现的呢？分析如下。</p>
<h2 id="Spring-实现-AOP分析"><a href="#Spring-实现-AOP分析" class="headerlink" title="Spring 实现 AOP分析"></a>Spring 实现 AOP分析</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这配置究竟有何魔法呢？答案就在于对<code>aop</code>命名空间的处理上。如下所示：</p>
<h3 id="AopNamespaceHandler"><a href="#AopNamespaceHandler" class="headerlink" title="AopNamespaceHandler"></a>AopNamespaceHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AopNamespaceHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line">        <span class="keyword">this</span>.registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以知道<code>aspectj-autoproxy</code>起作用的原因在于，该配置向Spring容器中注册了相关Bean。<br>我们关系的是<code>AspectJAutoProxyBeanDefinitionParser</code></p>
<h3 id="AspectJAutoProxyBeanDefinitionParser"><a href="#AspectJAutoProxyBeanDefinitionParser" class="headerlink" title="AspectJAutoProxyBeanDefinitionParser"></a>AspectJAutoProxyBeanDefinitionParser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这一步很重要，代理类的Creator就是在这一步注册到Spring容器中的        AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span></span><br><span class="line">        <span class="keyword">this</span>.extendBeanDefinition(element, parserContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AopNamespaceUtils"><a href="#AopNamespaceUtils" class="headerlink" title="AopNamespaceUtils"></a>AopNamespaceUtils</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">        useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">        registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">### AopConfigUtils</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>)) &#123;</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, -<span class="number">2147483648</span>);</span><br><span class="line">        beanDefinition.setRole(<span class="number">2</span>);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"org.springframework.aop.config.internalAutoProxyCreator"</span>, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这步<code>AnnotationAwareAspectJAutoProxyCreator.class</code>就被注册到容器中了。</p>
<h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAwareAspectJAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJAwareAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAdvisorAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">AbstractAutoProxyCreator</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AbstractAutoProxyCreator"><a href="#AbstractAutoProxyCreator" class="headerlink" title="AbstractAutoProxyCreator"></a>AbstractAutoProxyCreator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>重头戏来了：<code>AbstractAutoProxyCreator</code>实现了接口：<code>SmartInstantiationAwareBeanPostProcessor</code>。 该接口是Spring提供给开发者的一个扩展点，</p>
<figure class="highlight java"><figcaption><span>SmartInstantiationAwareBeanPostProcessor</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null</span></span><br><span class="line">Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择合适的构造器，比如目标对象有多个构造器，在这里可以进行一些定制化，选择合适的构造器</span></span><br><span class="line"><span class="comment">// beanClass参数表示目标实例的类型，beanName是目标实例在Spring容器中的name</span></span><br><span class="line"><span class="comment">// 返回值是个构造器数组，如果返回null，会执行下一个PostProcessor的determineCandidateConstructors方法；否则选取该PostProcessor选择的构造器</span></span><br><span class="line">Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得提前暴露的bean引用。主要用于解决循环引用的问题</span></span><br><span class="line"><span class="comment">// 只有单例对象才会调用此方法</span></span><br><span class="line"><span class="function">Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure>
<p><code>AbstractAutoProxyCreator</code> 就是使用了接口的扩展能力，对创建的Bean进行代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Object cacheKey = <span class="keyword">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">        <span class="comment">//如果需要就对目前对象进行AOP代理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.isInfrastructureClass(bean.getClass()) &amp;&amp; !<span class="keyword">this</span>.shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        Object[] specificInterceptors = <span class="keyword">this</span>.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, (TargetSource)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">            <span class="comment">//创建代理类</span></span><br><span class="line">            Object proxy = <span class="keyword">this</span>.createProxy(bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">            <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">            <span class="keyword">return</span> proxy;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)<span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//如果么有设置 proxy-target-class 配置项为true, 并且被增强Bean也没有实现接口</span></span><br><span class="line">    <span class="comment">//那么spring还是会通过CGLIB进行代理</span></span><br><span class="line">    <span class="comment">//如果设置proxy-target-class为true,那么就算目标实现接口，也会进行CGLIB增强</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = <span class="keyword">this</span>.buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    <span class="keyword">this</span>.customizeProxyFactory(proxyFactory);</span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(<span class="keyword">this</span>.getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultAopProxyFactory"><a href="#DefaultAopProxyFactory" class="headerlink" title="DefaultAopProxyFactory"></a>DefaultAopProxyFactory</h3><p>该类负责具体代理的创建:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAopProxyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="comment">// JDK 动态代理</span></span><br><span class="line">        <span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//CGLIB 代理</span></span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">        <span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a>JdkDynamicAopProxy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">true  <span class="comment">// 如果配置了exposeProxy，那么Spring就会将代理对象放入ThreadLocal中</span></span><br><span class="line">true  <span class="comment">// 如果是CGLIB, 可以查看类：DynamicUnadvisedExposedInterceptor</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">truetruetruetrue<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">truetruetruetrueoldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">truetruetruetruesetProxyContext = <span class="keyword">true</span>;</span><br><span class="line">truetrue&#125;</span><br><span class="line">true&#125;</span><br><span class="line">true</span><br><span class="line">true<span class="meta">@Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">truetruetruelogger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueClass&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">truetruefindDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">truetrue<span class="comment">// 这行代码应该非常熟悉了</span></span><br><span class="line">truetrue<span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JdkDynamicAopProxy 作用有2个（CglibAopProxy同理）：</p>
<ol>
<li>创建代理对象。</li>
<li>拦截目标对象的方法调用，实现增强。这个从类的签名就可以知道，它实现了接口<code>InvocationHandler</code>，并且在创建JDK代理对象时，将this作为参数传入<code>Proxy.newProxyInstance</code>方法。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>spring  既可以基于接口也可以基于类对目标对象进行AOP增强。</li>
<li>proxy-target-class默认为false，在默认配置下，Spring会自动判是基于接口还是类进行AOP增强。</li>
<li>如果将proxy-target-class设置为true，那么统一执行基于的类的通过CGLIB实行的AOP增强。</li>
<li>expose-proxy 默认为false，当设置为true时，即暴露出代理对象。内部使用的是ThreadLocal来实现代理对象的暴露。可以通过<code>AopContext.currentProxy()</code>获取代理对象(在Spring事务方法中获取代理对象，调用另一个事务方法，形成嵌套事务)。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是一篇关于Spring AOP的总结分析文章，帮助自己记忆。&lt;/p&gt;
&lt;h2 id=&quot;AOP配置&quot;&gt;&lt;a href=&quot;#AOP配置&quot; class=&quot;headerlink&quot; title=&quot;AOP配置&quot;&gt;&lt;/a&gt;AOP配置&lt;/h2&gt;&lt;p&gt;下面的例子是通过注解驱动的AOP例子：&lt;/p&gt;
&lt;p&gt;启用Spring AOP：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;aop:aspectj-autoproxy&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;proxy-target-class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;expose-proxy&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者通过下面的注解方式启用Spring AOP&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; jiexiu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@EnableAspectJAutoProxy&lt;/span&gt;(exposeProxy = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, proxyTargetClass = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Config&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="spring" scheme="https://leokongwq.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>nacos学习笔记</title>
    <link href="https://leokongwq.github.io/2020/05/13/nacos-learn.html"/>
    <id>https://leokongwq.github.io/2020/05/13/nacos-learn.html</id>
    <published>2020-05-13T15:11:57.000Z</published>
    <updated>2020-05-13T15:31:33.899Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nacos是什么？"><a href="#nacos是什么？" class="headerlink" title="nacos是什么？"></a>nacos是什么？</h3><p>Nacos 是 Dynamic Naming and Configuration Service 的缩写。</p>
<p>总结来说：nacos一个专门为微服务架构设计提供了诸如：服务注册，服务发现，服务元数据管理，服务动态配置管理，流量管理等功能的中间件。通过使用nacos你可以快速搭建微服务架构，并可以和业界优秀的开源项目，像k8s,Dubbo,Spring Cloud进行整合 或 和公司内部的中间件进行整合。</p>
<h3 id="nacos-一致性模型"><a href="#nacos-一致性模型" class="headerlink" title="nacos 一致性模型"></a>nacos 一致性模型</h3><p>说到底，nacos是一个分布式存储系统。既然是存储系统，那么它的一致性模型必然是人们首要关注的问题。<br>根据官网文档介绍可知。Nacos选择了AP下的最终一致性模型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;nacos是什么？&quot;&gt;&lt;a href=&quot;#nacos是什么？&quot; class=&quot;headerlink&quot; title=&quot;nacos是什么？&quot;&gt;&lt;/a&gt;nacos是什么？&lt;/h3&gt;&lt;p&gt;Nacos 是 Dynamic Naming and Configuration S
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>异步调用转为同步</title>
    <link href="https://leokongwq.github.io/2020/02/05/async-to-sync-call.html"/>
    <id>https://leokongwq.github.io/2020/02/05/async-to-sync-call.html</id>
    <published>2020-02-05T05:41:21.000Z</published>
    <updated>2020-02-05T11:23:33.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在日常的开发工作中，我们经常会有一些任务需要异步执行。那么如何获取异步任务的结果呢？常见的解决方案有两种：1，任务异步执行，调用方同步获取结果（本篇文章需要讨论的）；2，通过Callback 或 Listener进行处理。</p>
<p>针对需要同步获取异步计算结果的需求，下面分场景进行讨论并给出解决方案和原理分析。</p>
<h3 id="Future-线程池"><a href="#Future-线程池" class="headerlink" title="Future + 线程池"></a>Future + 线程池</h3><p>这个是最常见模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;String&gt; result = executorService.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result.get());</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>线程池用来执行异步任务，主线程等待任务执行完成，获取结果。很容易想到底层实现必然涉及到线程的等待-通知。下面就深入进行下原理分析：</p>
<p>上面代码<code>executorService.submit</code>返回值的真实类型是<code>FutureTask</code>，它实现了<code>Future</code>接口和<code>Runnable</code>接口</p>
<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步任务的执行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 异步任务的结算结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 任务是新创建 或 执行中，则将当前线程添加到等待队列中。</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Awaits completion or aborts on interrupt or timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed true if use timed waits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos time to wait, if timed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> state upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 自旋 或 等待执行完成。</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 调用线程被中断，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 异步任务 正常结束，被中断，被取消，执行异常，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让出CPU，提高异步任务的执行机会</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 新创建的任务，第一次循环，创建节点</span></span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 添加到等待队列， 第二次循环</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 超时了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使当前线程等待指定的时间 或 被unpark</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 使当前线程一直等待，直到被unpark</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现了 Runnable 接口的run方法，被线程池调用，完成异步任务的执行。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常执行完成，设置执行结果，</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置异步任务执行的结果</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and signals all waiting threads, invokes done(), and</span></span><br><span class="line"><span class="comment"> * nulls out callable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒等待的线程。</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预留的扩展钩子方法，任务执行完成后获得通知。</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>异步任务由线程池里面的线程进行异步执行。</li>
<li>Future的作用是当任务未完成时，使得调用线程排队等待。</li>
<li>异步任务完成后，设置Future中表示结果字段的值，并唤醒等待的线程。</li>
</ol>
<h3 id="自定义Future实现"><a href="#自定义Future实现" class="headerlink" title="自定义Future实现"></a>自定义Future实现</h3><p>在RPC调用中，一般有三种调用方式：</p>
<ul>
<li>oneWay 不需要获取返回结果</li>
<li>sync 同步调用</li>
<li>async 异步调用</li>
</ul>
<h4 id="RPC-同步调用实现分析"><a href="#RPC-同步调用实现分析" class="headerlink" title="RPC 同步调用实现分析"></a>RPC 同步调用实现分析</h4><p>大多数RPC框架目前都是基于一些NIO框架(Netty, Mina等)实现的，远程调用的过程就是将请求信息进行序列化并写入到Socket的过程。问题在于完成请求发送完成后，代码执行流程会继续执行，如何获得远程调用的结果呢？</p>
<p>如果是全异步编程环境或者异步处理返货结果，很简单，只需要注册一个Callback，请求结果返回后，由RPC框架进行调用。</p>
<p>如果需要同步获取结果，那么还是需要一种机制使当前调用线程进行等待，调用结果返回后通知唤醒等待的调用线程。</p>
<p>下面给出一个RPC框架中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该Listener 在请求响应返回调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">responseReceived</span><span class="params">(T obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于Lock实现的 Future </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> leokongwq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockBasedResponseListenerFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">ResponseListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 是否完成的标识</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> T response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有完成，则使得当前调用线程进行等待</span></span><br><span class="line">                <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有完成，则使得当前调用线程进行等待</span></span><br><span class="line">                <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> done = condition.await(timeout, unit);</span><br><span class="line">                    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"waiting response timeout!"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">responseReceived</span><span class="params">(T response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算完成，设置结果，唤醒等待的线程。</span></span><br><span class="line">            <span class="keyword">this</span>.response = response;</span><br><span class="line">            <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的Lock也也可以替换为<code>CountDownLatch</code>，本质都是线程间协调。</p>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><p><code>CompletableFuture</code>是JDK8提供的一个类，更好的支持异步编程和函数式编程风格。<br><code>CompletableFuture</code>实现了接口<code>Future</code>，但是功能更强，可以提供了异步任务完成方法。<br>关于<code>CompletableFuture</code>的详细介绍建议参考文章<a href="https://colobu.com/2016/02/29/Java-CompletableFuture/" target="_blank" rel="noopener">Java-CompletableFuture</a></p>
<p>那如何使用<code>CompletableFuture</code>来完成异步转同步呢？如下示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">executorService.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异步计算任务线程，完成异步计算。</span></span><br><span class="line">    completableFuture.complete(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 阻塞获取计算结果</span></span><br><span class="line">String str = completableFuture.get(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>
<p>翻看最新的Dubbo代码，发现同步和异步调用都使用了<code>CompletableFuture</code>，这里需要赞一下。</p>
<p>需要注意的是，最底层的原理还是线程的协调，和<code>FutureTask</code>一样底层都是使用了<code>LockSupport</code>工具类。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在日常的开发工作中，我们经常会有一些任务需要异步执行。那么如何获取异步任务的结果呢？常见的解决方案有两种：1，任务异步执行，调用方同步获取结果（本篇文章需要讨论的）；2，通过Callback 或 Listener进行处理。&lt;/p&gt;
&lt;p&gt;针对需要同步获取异步计算结果的需求，下面分场景进行讨论并给出解决方案和原理分析。&lt;/p&gt;
&lt;h3 id=&quot;Future-线程池&quot;&gt;&lt;a href=&quot;#Future-线程池&quot; class=&quot;headerlink&quot; title=&quot;Future + 线程池&quot;&gt;&lt;/a&gt;Future + 线程池&lt;/h3&gt;&lt;p&gt;这个是最常见模式：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ExecutorService executorService = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;String&amp;gt; result = executorService.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Callable&amp;lt;String&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(result.get());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://leokongwq.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>架构模式</title>
    <link href="https://leokongwq.github.io/2020/01/31/Architecture-Patterns.html"/>
    <id>https://leokongwq.github.io/2020/01/31/Architecture-Patterns.html</id>
    <published>2020-01-31T06:06:58.000Z</published>
    <updated>2020-02-01T10:50:21.282Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href>Software Architecture Patterns</a>。</p>
<h3 id="Layered-Architecture"><a href="#Layered-Architecture" class="headerlink" title="Layered Architecture"></a>Layered Architecture</h3><p>分层架构是最通用和使用频率最高的架构模式，通常也称之为N-层架构。这种模式也是大多数Java EE应用程序的事实上的架构标准，因此，它被大多数架构师，设计人员和开发人员所广泛了解。 分层架构模式能与传统的IT通信和大多数公司中的组织结构紧密匹配，这使其成为大多数业务应用程序开发工作的自然选择。</p>
<h4 id="Pattern-Description"><a href="#Pattern-Description" class="headerlink" title="Pattern Description"></a>Pattern Description</h4><p>分层架构模式中的组件被组织为水平分隔的层，每一层在应用程序中扮演特定的角色（例如，表示层或业务逻辑层）。 尽管分层体系架构模式没有指定模式中必须存在的层的数量和类型，但是大多数分层架构都由四个标准层组成：<code>表示层</code>，<code>业务层</code>，<code>持久性</code>和<code>数据库层</code>，如图（图1-1）所示。在某些情况下，尤其是在将持久性逻辑（例如SQL或HSQL）嵌入业务层组件中时，业务层和持久性层会组合为一个业务层。 因此，较小的应用程序可能仅具有三层，而较大且更复杂的业务应用程序可能包含五层或更多层。</p>
<a id="more"></a>
<p>分层体系结构模式的每一层在应用程序中都有特定的角色和职责。例如，表示层将负责处理所有用户界面和浏览器通信逻辑，而业务层将负责执行与请求关联的特定业务规则。架构中的每个层围绕需要完成的工作形成抽象，以满足特定的业务需求。例如，表示层无需了解或担心如何获取客户数据；它只需要以特定格式在屏幕上显示该信息。同样，业务层无需担心如何格式化客户数据以在屏幕上显示，甚至客户数据来自何处；它只需要从持久层获取数据，对数据执行业务逻辑（例如，计算值或汇总数据），然后将该信息传递到表示层。</p>
<img src="/2020/01/31/Architecture-Patterns/layered-architecture.png">  
<p>Figure 1-1. Layered architecture pattern</p>
<p>分层体系结构模式的强大功能之一是组件之间关注点的分离。 特定层中的组件仅处理与该层有关的逻辑。 例如，表示层中的组件仅处理表示逻辑，而驻留在业务层中的组件仅处理业务逻辑。 这种类型的组件分类使你可以轻松地在体系结构中建立有效的角色和责任模型，并且由于定义良好的组件接口和有限的组件范围，因此可以使用此体系结构模式轻松开发，测试，管理和维护应用程序。</p>
<h4 id="Key-Concepts"><a href="#Key-Concepts" class="headerlink" title="Key Concepts"></a>Key Concepts</h4><p>请注意，在图1-2中，体系结构中的每个层都标记为已关闭。 在分层架构模式中，这是一个非常重要的概念。 封闭层意味着当请求不能跨层。 例如，来自表示层的请求必须先经过业务层，然后再到达持久层，然后才到达数据库层。</p>
<img src="/2020/01/31/Architecture-Patterns/closed-layers-and-request-access.png">  
<p>Figure 1-2. Closed layers and request access</p>
<p>那么，为什么不允许表示层直接访问持久层或数据库层呢？ 毕竟，从表示层进行直接数据库访问要比经过一堆不必要的层要快得多。 这个问题的答案在于一个关键概念，即层隔离。</p>
<p>层隔离意味着在架构的任意一层中进行的更改通常不会影响其它层中的组件：更改仅与该层中的组件相关。 如果允许表示层直接访问持久层，则在持久层中对SQL所做的更改将影响业务层和表示层，从而产生一个紧密耦合的应用程序，在组件之间具有许多相互依赖关系。 这种类型的体系结构变得非常困难且更改成本很高。</p>
<p>层隔离也意味着每一层都独立于其他层，因此对体系结构中其它层的内部运作了解甚少或根本不了解。 为了理解此概念的强大功能和重要性，请考虑进行大量的重构工作，以将表示框架从JSP（Java服务器页面）转换为JSF（Java Server Faces）。 假设表示层和业务层之间使用的合同（例如，模型）保持不变，则业务层不受重新引用的影响，并且完全独立于表示层使用的用户界面框架的类型 。</p>
<p>虽然封闭的层有助于层隔离，因此有助于隔离架构中的更改，但有时某些层是开放的是有意义的。 例如，<br>假设你想在架构中添加一个包含公共服务组件的层，该层需要被业务逻辑层访问。那么通常一个好的实践是添加一个服务层。因为架构体系限制了对共享服务层的访问。如果没有一个单独的层来表示该感念，那么就没有一个规则来限制对共享服务的访问。</p>
<p>在此示例中，新服务层可能会驻留在业务层下方，以指示无法从表示层访问此服务层中的组件。 但是，这带来了一个问题，即现在需要业务层经过服务层才能到达持久层，这根本没有意义。 这是分层体系结构中的一个古老问题，可以通过在体系结构中创建开放层来解决。</p>
<p>如图1-3所示，在这种情况下，服务层被标记为“开放”，这意味着允许请求绕过该开放层并直接进入其下一层。 在下面的示例中，由于服务层是开放的，因此现在允许业务层绕过它，而直接进入持久层，这是很有意义的。</p>
<img src="/2020/01/31/Architecture-Patterns/open-layers-and-request-flow.png">  
<p>Figure 1-3. Open layers and request flow</p>
<p>利用开放层和封闭层的概念可以帮助定义架构中层和请求流之间的关系，还可以为设计人员和开发人员提供必要的信息，以了解架构中各个层的<strong>访问限制</strong>。 无法记录或正确传达架构中哪些层是打开和关闭的（以及原因）通常会导致紧密耦合且脆弱的架构，这很难测试，维护和部署。</p>
<h4 id="Pattern-Example"><a href="#Pattern-Example" class="headerlink" title="Pattern Example"></a>Pattern Example</h4><p>为了说明分层架构是如何工作的，下面以一个获取客户信息的用例来进行具体说明，如图1-4所示。 黑色箭头表示直到数据库以检索客户数据的请求，红色箭返回到屏幕的数据响应。 在此示例中，客户信息包含客户数据和订单数据（客户下的订单）。</p>
<p>客户屏幕负责接受请求并显示客户信息。它不知道数据在哪里，如何检索它，或者必须查询多少个数据库表才能获取数据。客户屏幕一旦收到获取特定个人的客户信息的请求，便会将请求转发到客户委托模块。该模块负责了解业务层中的哪些模块可以处理该请求，以及如何到达该模块以及它需要哪些数据（合同）。业务层中的客户对象负责汇总业务请求所需的所有信息（在这种情况下，是获取客户信息）。此模块调出持久性层中的customer dao（数据访问对象）模块以获取客户数据，还调用order dao模块以获取订单信息。这些模块依次执行SQL语句以检索相应的数据，并将其传递回业务层中的客户对象。一旦客户对象接收到数据，它将汇总数据并将信息传递回客户委托人，然后由客户委托人将数据传递给客户屏幕以呈现给用户。</p>
<img src="/2020/01/31/Architecture-Patterns/layered-architecture-example.png">  
<p>Figure 1-4. Layered architecture example</p>
<p>从技术角度来看，这些模块可以通过多种方式实现。 例如，在Java平台中，客户屏幕可以是（JSF）Java Server Faces。 业务层中的客户对象可以是本地Spring Bean或远程EJB3 Bean。 上一个示例中说明的数据访问对象可以实现为简单的POJO（普通的Java对象），MyBatis XML Mapper文件，甚至可以封装原始JDBC调用或Hibernate查询的对象。 从Microsoft平台的角度来看，客户屏幕可以是使用.NET框架访问业务层中C＃模块的ASP（活动服务器页面）模块，而客户和订单数据访问模块则实现为ADO（ActiveX） 数据对象）。</p>
<h4 id="Considerations"><a href="#Considerations" class="headerlink" title="Considerations"></a>Considerations</h4><p>分层体系结构模式是可靠的，通用的架构模式，是大多数应用程序的良好起点，尤其是当你不确定哪种体系结构模式最适合您的应用程序时。但是，从系统架构的角度来看，选择此模式时需要考虑几件事。</p>
<p>首先要注意的是所谓的“体系结构坑洞反模式”。此反模式将请求流过架构的多个层的情况描述为简单的直通处理，而在每个层中执行的逻辑很少或没有执行逻辑。例如，假设表示层响应来自用户的请求以检索客户数据。表示层将请求传递给业务层，业务层仅将请求传递给持久层，然后持久层对数据库层进行简单的SQL调用以检索客户数据。然后，数据将一直传递到整个堆栈，而无需其他处理或逻辑来聚合，计算或转换数据。</p>
<p>每个分层架构中都或多或少包含一些反模式。但是，关键是分析属于反模式的请求的百分比。 通常，遵循8/2原则是确定你是否正在经历架构下陷反模式的好习惯。 通常，将大约20％的请求作为简单的直通处理进行处理，并将80％的请求具有与该请求相关联的某些业务逻辑。 但是，如果你发现真实的请求比例于此相反，并且大多数请求都是简单的直通处理，则可能要考虑使分层架构中的某些层打开，请记住，控制变更将更加困难 由于缺乏层隔离。</p>
<h4 id="Pattern-Analysis"><a href="#Pattern-Analysis" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h4><p>下表是对分层架构模式的通用体系结构特征的评估和分析。 对每个特性的评级都基于该特性的自然趋势，即基于模式的典型实现以及该模式通常所知的能力。 有关此模式与本报告中其他模式的关系的并行比较，请参阅本报告末尾的附录A。</p>
<h5 id="Overall-agility"><a href="#Overall-agility" class="headerlink" title="Overall agility"></a>Overall agility</h5><p>评分：低<br>分析：整体敏捷性是对不断变化的环境做出快速响应的能力。 虽然可以通过此模式可以将每个层的修改进行隔离，但是发现现实中，模式的大多数该实现中，组件都会紧密耦合，因此在该架构模式中进行更改仍然很麻烦且耗时。</p>
<h5 id="Ease-of-deployment"><a href="#Ease-of-deployment" class="headerlink" title="Ease of deployment"></a>Ease of deployment</h5><p>评分：低<br>分析：根据你实施此模式的方式，部署可能会成为一个问题，尤其是对于大型应用程序。 对组件的一小处更改可能需要重新部署整个应用程序（或应用程序的很大一部分），从而导致需要在下班时间或周末计划，安排和执行部署。 因此，这种模式不容易使自己适应连续的交付管道，从而进一步降低了部署的总体评级。</p>
<h5 id="Testability"><a href="#Testability" class="headerlink" title="Testability"></a>Testability</h5><p>评分：高<br>分析：由于组件属于架构中特定的层，因此可以对其他层进行Mock或打桩处理，使得这种模式相对易于测试。 开发人员可以模拟演示组件或屏幕以隔离业务组件中的测试，也可以模拟业务层以测试某些屏幕功能。</p>
<h5 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h5><p>评分：低<br>分析：虽然某些分层架构确实可以很好的工作。但是由于几乎所有请求必须穿过多个层级，导致效率低下，因此该模式不适用于高性能应用程序。</p>
<h5 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h5><p>评分：低<br>分析：由于这种模式趋向于紧密耦合和整体实现的趋势，使用这种架构模式构建的应用程序通常很难扩展。你可以通过将层拆分为单独的物理部署或将整个应用程序复制到多个节点来扩展分层体系结构，但是总体而言，粒度太宽泛，因此扩展成本很高。</p>
<h5 id="Ease-of-development"><a href="#Ease-of-development" class="headerlink" title="Ease of development"></a>Ease of development</h5><p>评分：高<br>分析：易于开发获得了相对较高的分数，主要是因为这种模式众所周知，并且实施起来并不太复杂。 因为大多数公司通过将技能集按层次（表示，业务，数据库）分开来开发应用程序，所以这种模式成为大多数业务应用程序开发的自然选择。 概述了公司的沟通和组织结构与软件开发方式之间的联系，这就是所谓的康韦定律。 您可以使用Google的“康韦定律”获取有关这种引人入胜的相关性的更多信息。</p>
<h3 id="Event-Driven-Architecture"><a href="#Event-Driven-Architecture" class="headerlink" title="Event-Driven-Architecture"></a>Event-Driven-Architecture</h3><p>事件驱动的架构模式是一种流行的分布式异步架构模式，用于构建高度可伸缩的应用程序。 它还具有很高的适应性，可用于小型应用程序以及大型，复杂的应用程序。 事件驱动架构由高度架构，职责单一的事件处理组件组成，这些组件异步接收和处理事件。</p>
<p>事件驱动的架构模式由两个主要拓扑组成，即调解器和代理。 当你需要通过中央调解器协调事件中的多个步骤时，通常使用调解器拓扑结构；而当你希望不使用中央调解器将事件链接在一起时，则使用代理拓扑。 由于这两种拓扑的体系结构特征和实施策略不同，因此重要的是要了解每个拓扑，以了解哪种拓扑最适合您的特定情况。</p>
<!-- more -->
<h4 id="Mediator-Topology"><a href="#Mediator-Topology" class="headerlink" title="Mediator Topology"></a>Mediator Topology</h4><p>调解器拓扑结构对于具有多个步骤并且需要某种编排级别的事件才能处理的事件很有用。 例如，进行一次股票交易的单个事件可能需要你首先验证交易，然后根据各种合规性规则检查该股票交易的合规性，将交易分配给经纪人，计算佣金，最后放置 与那个经纪人交易。 所有这些步骤都需要一定程度的编排，以确定步骤的顺序以及哪些步骤可以串行和并行完成。</p>
<p>调解器拓扑中有四种主要类型的体系结构组件：事件队列，事件调解器，事件通道和事件处理器。 事件流从客户端将事件发送到事件队列开始，该事件队列用于将事件传输到事件调解器。 事件调解器接收初始事件，并通过将其他异步事件发送到事件通道以执行流程的每个步骤来协调该事件。 监听事件通道的事件进程从事件调解器接收事件，并执行特定的业务逻辑来处理事件。 图2-1说明了事件驱动的体系结构模式的一般介体拓扑。</p>
<img src="/2020/01/31/Architecture-Patterns/mediator-topology.png">  
<p>Figure 2-1. Event-driven architecture mediator topology</p>
<p>在事件驱动架构中，通常有十几到数百个事件队列。 该模式未指定事件队列组件的实现。 它可以是消息队列，Web服务终结点或其任何组合。</p>
<p>在该模式中有两种类型的事件：初始事件和处理事件。 初始事件是调解器接收到的原始事件，而处理事件是由调解器生成并由事件处理组件接收的事件。</p>
<p>事件调解器组件负责协调初始事件中包含的步骤。 对于初始事件中的每个步骤，事件调解器都会将特定的处理事件发送到事件通道，然后由事件处理器进行接收和处理。 需要注意的是，事件调解器实际上并未执行处理初始事件所需的业务逻辑； 相反，它知道处理初始事件所需的步骤。</p>
<p>事件调解器使用事件通道将与初始事件中每个步骤相关的特定处理事件异步传递给事件处理器。 事件通道可以是消息队列，也可以是消息主题，尽管消息主题在调解器拓扑结构中使用最广泛，所以处理事件可以由多个事件处理器处理（每个事件处理器根据接收到的处理事件执行不同的任务）。</p>
<p>事件处理器组件包含处理处理事件所需的应用程序业务逻辑。 事件处理器是独立的，高度分离的架构组件，它们在应用程序或系统中执行特定任务。 尽管事件处理程序组件的粒度可以从细粒度（例如，计算订单的销售税）到粗粒度（例如，处理保险索赔），但重要的是要记住，每个事件处理器组件应执行单个业务任务，而不要依赖其他事件处理器来完成其特定任务。</p>
<p>事件中介器可以通过多种方式实现。 作为架构师，你应该了解所有这些实现选项，以确保为事件介体选择的解决方案符合您的需求。</p>
<p>事件中介器的最简单，最常见的实现方法是通过开源集成中心，例如Spring Integration，Apache Camel或Mule ESB。 这些开源集成中心中的事件流通常通过Java代码或DSL（领域特定语言）实现。 对于更复杂的中介和业务流程，可以将BPEL（业务流程执行语言）与BPEL引擎（例如开源Apache ODE）结合使用。 BPEL是一种类似于XML的标准语言，它描述了处理初始事件所需的数据和步骤。 对于需要更复杂的业务流程的大型应用程序（包括涉及人机交互的步骤），您可以使用业务流程管理器（BPM）（例如jBPM）来实现事件中介程序。</p>
<p>了解你的需求并将其与正确的事件中介器实现相匹配对于使用此拓扑的任何事件驱动的架构的成功至关重要。 与实施BPM解决方案以执行简单的路由逻辑一样，使用开源的集成中心进行非常复杂的业务流程管理流程是失败的秘诀。</p>
<p>为了说明调解器拓扑的工作原理，假设你已通过一家保险公司投保，并且决定搬家。 在这种情况下，初始事件可能称为重定位事件。 处理重定位事件所涉及的步骤包含在事件中介器中，如图2-2所示。 对于每个初始事件步骤，事件介体创建一个处理事件（例如，更改地址，重新计算报价等），将该处理事件发送到事件通道，并等待该处理事件被相应的事件处理器处理（例如， ，客户流程，报价流程等）。 该过程一直持续到初始事件中的所有步骤都已处理完毕。 事件调解器中重新计算报价和更新声明步骤上的单条表示可以同时运行这些步骤。</p>
<h4 id="Broker-Topology"><a href="#Broker-Topology" class="headerlink" title="Broker Topology"></a>Broker Topology</h4><p>代理拓扑与中介器拓扑的不同之处在于，不存在中央事件中介器。 而是通过轻量级消息代理（例如ActiveMQ，HornetQ等）以链状方式将消息流分布在事件处理器组件之间。 当你具有相对简单的事件处理流程并且不需要（或不需要）集中事件编排时，此拓扑很有用。</p>
<p>代理拓扑中有两种主要类型的体系结构组件：代理组件和事件处理器组件。 代理组件可以是集中式的或联合的，并包含事件流中使用的所有事件通道。</p>
<p>代理组件中包含的事件通道可以是消息队列，消息主题或两者的组合。</p>
<img src="/2020/01/31/Architecture-Patterns/mediator-topology-example.png">  
<p>Figure 2-2. Mediator topology example</p>
<p>这种拓扑如图2-3所示。 从图中可以看出，没有中央事件中介器组件来控制和协调初始事件。 相反，每个事件处理器组件负责处理一个事件并发布一个新事件，以指示其刚刚执行的操作。 例如，平衡股票投资组合的事件处理器可能会收到一个称为股票分割的初始事件。 基于该初始事件，事件处理器可以进行一些投资组合重新平衡，然后将一个新事件发布到称为重新平衡投资组合的经纪人，然后由另一个事件处理器处理该新事件。 请注意，有时某个事件是由事件处理器发布但未被其他任何事件处理器处理的。 在开发应用程序或提供将来的功能和扩展时，这很常见。</p>
<img src="/2020/01/31/Architecture-Patterns/broker-topology.png">  
<p>Figure 2-3. Event-driven architecture broker topology</p>
<p>为了说明代理拓扑的工作方式，我们将使用与调解器拓扑相同的示例（被保险人移动）。由于没有中间事件中介程序可以在代理拓扑中接收初始事件，因此客户流程组件可以直接接收该事件，更改客户地址并发送事件，说明它更改了客户地址（例如，更改地址事件） 。在此示例中，有两个对更改地址事件感兴趣的事件处理器：报价过程和声明过程。报价处理器组件根据地址更改重新计算新的自动保险费率，并将一个事件发布到系统的其余部分，以指示其所做的事情（例如，重新计算报价事件）。另一方面，理赔处理组件接收相同的变更地址事件，但是在这种情况下，它会更新未完成的保险理赔并将事件作为更新理赔事件发布到系统。然后，这些新事件将由其他事件处理器组件接收，并且事件链会贯穿整个系统，直到不再有针对该特定发起事件的事件发布为止。</p>
<img src="/2020/01/31/Architecture-Patterns/broker-topology-example.png">  
<p>Figure 2-4. Broker topology example</p>
<p>从图2-4中可以看到，代理拓扑完全是有关事件链以执行业务功能的。 理解代理拓扑的最好方法是将其视为中继竞赛。 在接力赛中，跑步者握住警棍并跑一定距离，然后将警棍交给下一位跑步者，依此类推，直到最后一名选手越过终点线。 在接力赛中，一旦跑步者交出了接力棒，她就完成了比赛。 代理拓扑也是如此：一旦事件处理器移交该事件，该事件将不再参与该特定事件的处理。</p>
<h4 id="Considerations-1"><a href="#Considerations-1" class="headerlink" title="Considerations"></a>Considerations</h4><p>事件驱动的架构模式是一种相对复杂的实现方式，主要是由于其异步的分布式特性。 实施此模式时，必须解决各种分布式体系结构问题，例如远程进程可用性，缺乏响应能力以及在代理或中介程序发生故障的情况下代理重新连接逻辑。</p>
<p>选择这种体系结构模式时要考虑的一个考虑因素是单个业务流程缺乏原子事务。由于事件处理器组件高度分离和分布，因此很难在它们之间维护事务性工作单元。因此，在使用这种模式设计应用程序时，您必须不断考虑哪些事件可以独立运行，也可以不独立运行，并相应地计划事件处理器的粒度。如果发现需要在事件处理器之间划分单个工作单元，也就是说，如果您对应该是不可分割事务的事物使用单独的处理器，那么这可能不是适合您的应用程序的模式。</p>
<p>事件驱动的架构模式中最困难的方面之一可能是事件处理器组件合同的创建，维护和治理。每个事件通常都有一个与之相关的特定协定（例如，将数据值和数据格式传递给事件处理器）。使用此模式来建立标准数据格式（例如XML，JSON，Java对象等）并从一开始就制定合同版本控制政策时，这一点至关重要。</p>
<h4 id="Pattern-Analysis-1"><a href="#Pattern-Analysis-1" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h4><p>下表包含事件驱动架构模式的通用架构特征的评级和分析。 对每个特性的评级都基于该特性的自然趋势，即基于模式的典型实现以及该模式通常所知的能力。 有关此模式与本报告中其他模式的关系的并行比较，请参阅本报告末尾的附录A。</p>
<h5 id="Overall-agility-1"><a href="#Overall-agility-1" class="headerlink" title="Overall agility"></a>Overall agility</h5><p>评分：高<br>分析：整体敏捷性是对不断变化的环境做出快速响应的能力。 由于事件处理器组件是单一用途的，并且与其他事件处理器组件完全脱钩，因此更改通常隔离到一个或几个事件处理器，并且可以快速进行而不会影响其他组件。</p>
<h4 id="Ease-of-deployment-1"><a href="#Ease-of-deployment-1" class="headerlink" title="Ease of deployment"></a>Ease of deployment</h4><p>评分：高<br>分析：总体而言，由于事件处理器组件的分离性质，此模式相对易于部署。 代理拓扑往往比事件中介拓扑更易于部署，主要是因为事件介体组件在某种程度上与事件处理器紧密耦合：事件处理器组件的更改也可能需要事件介体的更改，这需要同时 部署用于任何给定的更改。</p>
<h5 id="Testability-1"><a href="#Testability-1" class="headerlink" title="Testability"></a>Testability</h5><p>评分：低<br>分析：尽管单个单元测试不是很困难，但是它确实需要某种专门的测试客户端或测试工具来生成事件。 这种模式的异步特性也使测试变得复杂。</p>
<h5 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h5><p>评分：高<br>分析：虽然由于所有消息传递基础架构的原因，可能实现一个性能不佳的事件驱动架构是可能的，但通常，该模式通过其异步功能可实现高性能； 换句话说，执行解耦，并行异步操作的能力超过了对消息进行排队和出队的成本。</p>
<h5 id="Scalability-1"><a href="#Scalability-1" class="headerlink" title="Scalability"></a>Scalability</h5><p>评分：高<br>分析：通过高度独立和解耦的事件处理器，自然可以在这种模式下实现可伸缩性。 每个事件处理器可以分别缩放，以实现细粒度的可伸缩性。</p>
<h5 id="Ease-of-development-1"><a href="#Ease-of-development-1" class="headerlink" title="Ease of development"></a>Ease of development</h5><p>评分：低<br>分析：由于模式的异步性质以及合同创建，并且对于无响应的事件处理器和失败的代理程序，代码中需要更高级的错误处理条件，因此开发可能会有些复杂。</p>
<h3 id="Microkernel-Architecture"><a href="#Microkernel-Architecture" class="headerlink" title="Microkernel Architecture"></a>Microkernel Architecture</h3><p>微内核架构模式（有时也称为插件架构模式）是用于实现基于产品的应用程序的自然模式。 基于产品的应用程序是一种打包的应用程序，可以作为典型的第三方产品的版本进行下载。也有许多公司的业务应用也遵循这种模式，开发，发布版本，附带版本说明，版本新增的特性。微内核架构模式允许你将其他应用程序功能作为插件添加到核心应用程序，从而提供可扩展性以及功能分离和隔离。</p>
<h4 id="Pattern-Description-1"><a href="#Pattern-Description-1" class="headerlink" title="Pattern Description"></a>Pattern Description</h4><p>微内核架构模式由两个架构组件组成：核心系统 和 插件模块。应用的逻辑被分隔到每个相互独立的插件和基础的系统核心上。应用程序具有可扩展性，灵活性，并且应用的功能和特殊的业务逻辑具备隔离性。如图3-1，展示了微内核架构模式。</p>
<img src="/2020/01/31/Architecture-Patterns/microkernel-architecture-pattern.png">
<p>从业务应用程序的角度来看，核心系统通常定义为通用业务逻辑，没有特殊情况，特殊规则或复杂的条件处理的自定义代码。</p>
<p>插件模块是独立的独立组件，包含专门的处理，附加功能和自定义代码，旨在增强或扩展核心系统以产生更多的业务功能。通常，插件模块应独立于其他插件模块，但是你当然可以设计需要依赖其他插件的插件。无论哪种方式，都必须将插件之间的通信保持在最小限度，以避免依赖关系。</p>
<p>核心系统需要知道哪些插件模块可用以及如何获得它们。一种通用的实现方法是通过某种插件注册表。该注册表包含有关每个插件模块的信息，包括其名称，数据约定和远程访问协议详细信息（取决于插件如何连接到核心系统）。例如，标记高风险税收审核项目的税收软件插件可能具有一个注册表项，其中包含服务名称（AuditChecker），数据合同（输入数据和输出数据）以及合同格式（XML）。如果通过SOAP访问该插件，则它也可能包含WSDL（Web服务定义语言）。</p>
<p>插件模块可以通过多种方式连接到核心系统，包括OSGi（开放服务网关倡议），消息传递，Web服务，甚至直接点对点绑定（即对象实例化）。你使用的连接类型取决于你正在构建的应用程序类型（小型产品或大型业务应用程序）以及你的特定需求（例如，单部署或分布式部署）。架构模式本身没有指定任何这些实现​​细节，只是插件模块必须彼此独立。</p>
<p>插件模块和核心系统之间的合同范围很广，从标准合同到定制合同都可以。自定义合同通常在第三方开发插件组件的情况下发现，而您无法控制插件使用的合同。在这种情况下，通常在插件触点和您的标准合同之间创建一个适配器，这样核心系统就不需要每个插件的专门代码。创建标准合同（通常通过XML或Java Map实现）时，切记要从头开始创建版本控制策略，这一点很重要。</p>
<h4 id="Pattern-Examples"><a href="#Pattern-Examples" class="headerlink" title="Pattern Examples"></a>Pattern Examples</h4><p>也许微内核体系结构的最佳示例是Eclipse IDE。下载基本的Eclipse产品仅能为您提供精美的编辑器。但是，一旦开始添加插件，它将成为高度可定制和有用的产品。互联网浏览器是使用微内核架构的另一个常见产品示例：查看器和其他插件添加了其他功能，而这些功能是基本浏览器（即核心系统）中找不到的。</p>
<p>对于基于产品的软件，示例无穷无尽，但是大型企业应用程序呢？微内核架构也适用于这些情况。为了说明这一点，让我们使用另一个保险公司示例，但这一次涉及保险索赔处理。</p>
<p>索赔处理是一个非常复杂的过程。每个州对于保险索赔中允许和不允许的内容都有不同的规则和规定。例如，如果您的挡风玻璃被一块岩石损坏，某些州允许免费更换挡风玻璃，而其他州则不允许。这为标准索赔流程创造了几乎无限的条件。</p>
<p>毫不奇怪，大多数保险索赔应用程序利用大型而复杂的规则引擎来处理这种复杂性中的大部分。 但是，这些规则引擎可能会变成一个复杂的大团团，在其中更改一个规则会影响其他规则，或者使简单的规则更改需要大量的分析人员，开发人员和测试人员。 使用微内核架构模式可以解决许多这些问题。</p>
<p>如在图3-2中看到的文件夹堆栈代表了索赔处理的核心系统。 它包含保险公司处理索赔所需的基本业务逻辑，除非没有任何自定义处理。 每个插件模块都包含该状态的特定规则。 在此示例中，可以使用自定义源代码或单独的规则引擎实例来实现插件模块。 无论采用哪种实施方式，关键点是特定于状态的规则和处理与核心声明系统是分开的，可以添加，删除和更改，而对其余核心系统或其他插件模块几乎没有影响 。</p>
<img src="/2020/01/31/Architecture-Patterns/microkernel-architecture-example.png">
<h4 id="Considerations-2"><a href="#Considerations-2" class="headerlink" title="Considerations"></a>Considerations</h4><p>关于微内核架构模式的一个很棒的事情是它可以被嵌入到应用中或用作另一种架构模式的一部分。 例如，如果此模式解决了应用程序特定易失区域的特定问题，则可能会发现你无法使用此模式实现整个体系结构。 在这种情况下，你可以将微服务架构模式嵌入到你正在使用的其他模式（例如分层架构）中。 类似地，可以使用微服务架构模式来实现上一节中有关事件驱动架构的事件处理器组件。</p>
<p>微服务架构模式为演化设计和增量开发提供了强大的支持。 你可以首先创建一个坚实的核心系统，然后随着应用程序的逐步发展，无需对核心系统进行重大更改即可添加功能。</p>
<p>对于基于产品的应用程序，微内核架构模式应始终是你的初始架构的首选，尤其是对于那些随着时间的推移将发布其他功能并希望控制哪些用户获得哪些功能的产品。 如果随着时间的流逝，你发现该模式不能满足您的所有需求，那么你始终可以将你的应用程序重构为更适合你特定需求的另一种架构模式。</p>
<h4 id="Pattern-Analysis-2"><a href="#Pattern-Analysis-2" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h4><p>下表包含事件驱动架构模式的通用架构特征的评级和分析。 对每个特性的评级都基于该特性的自然趋势，即基于模式的典型实现以及该模式通常所知的能力。 有关此模式与本报告中其他模式的关系的并行比较，请参阅本报告末尾的附录A。</p>
<h5 id="Overall-agility-2"><a href="#Overall-agility-2" class="headerlink" title="Overall agility"></a>Overall agility</h5><p>评分：高<br>分析：整体敏捷性是对不断变化的环境做出快速响应的能力。 通过松散耦合的插件模块，可以很大程度上隔离和快速实现更改。 通常，大多数微内核体系结构的核心系统趋向于快速稳定，因此相当健壮，并且随着时间的推移几乎不需要更改。</p>
<h5 id="Ease-of-deployment-2"><a href="#Ease-of-deployment-2" class="headerlink" title="Ease of deployment"></a>Ease of deployment</h5><p>评分：高<br>分析：根据模式的实现方式，可以在运行时（例如，热部署）将插件模块动态添加到核心系统，从而最大程度地减少部署期间的停机时间。</p>
<h5 id="Testability-2"><a href="#Testability-2" class="headerlink" title="Testability"></a>Testability</h5><p>评分：高<br>分析：插件模块可以单独进行测试，并且可以由核心系统轻松模拟，以演示或原型化特定功能，而对核心系统的更改很少或没有更改。</p>
<h5 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h5><p>评分：高<br>分析：虽然微内核模式无法自然地适用于高性能应用程序，但是通常来说，大多数使用微内核架构模式构建的应用程序都表现良好，因为你可以自定义和简化应用程序以仅包含所需的那些功能。 JBoss应用服务器就是一个很好的例子：借助其插件体系结构，你可以对应用服务器进行剪裁，只保留需要的功能，删除哪些消耗CPU，内存而且用不上的功能，例如远程访问，消息传递和消耗内存的缓存。</p>
<h5 id="Scalability-2"><a href="#Scalability-2" class="headerlink" title="Scalability"></a>Scalability</h5><p>评分：低<br>分析：由于大多数微内核体系结构实现都是基于产品的，并且通常尺寸较小，因此它们被实现为单个单元，因此无法高度扩展。 根据实现插件模块的方式，有时可以在插件功能级别提供可伸缩性，但是总的来说，这种模式因产生高度可扩展的应用程序而闻名。</p>
<h5 id="Ease-of-development-2"><a href="#Ease-of-development-2" class="headerlink" title="Ease of development"></a>Ease of development</h5><p>评分：低<br>分析：微内核架构模式需要仔细设计和契约治理，因此实施起来相当复杂。 契约版本控制，内部插件注册中心，插件粒度以及可用于插件连接的广泛选择都增加了实现此模式所涉及的复杂性。</p>
<h3 id="Microservices-Architecture-Pattern"><a href="#Microservices-Architecture-Pattern" class="headerlink" title="Microservices Architecture Pattern"></a>Microservices Architecture Pattern</h3><p>作为单体应用程序和SOA架构模式的可行替代方案，微服务体系结构模式正在业界迅速普及。 由于这种架构模式仍在不断发展，因此业界对这种模式的意义以及实现方式存在很多困惑。 该报告的这一部分将为你提供必要的关键概念和基础知识，以了解这种重要架构模式的好处（以及权衡取舍），以及它是否适合您的应用程序。</p>
<h4 id="Pattern-Description-2"><a href="#Pattern-Description-2" class="headerlink" title="Pattern Description"></a>Pattern Description</h4><p>无论选择哪种拓扑或实现方式，都有几个通用的核心概念适用于常规体系结构模式。 这些概念中的第一个就是独立部署的单元。 如图4-1所示，微服务体系结构的每个组件都作为一个单独的单元进行部署，从而可以通过有效且简化的交付管道，更强的可伸缩性以及应用程序内部组件高度耦来简化应用程序部署。</p>
<p>理解微服务架构模式，最重要的概念就是好服务组件。与其考虑微服务架构中的服务，不如考虑服务组件，服务组件的粒度可以是单个模块或整个应用的大部分功能。 服务组件包含一个或多个模块（例如Java类），这些模块表示单一用途的功能（例如，为特定城市或城镇提供天气）或大型业务应用程序的独立部分（例如，股票交易） 放置位置或确定自动保险费率）。 设计合适的服务组件粒度是微服务体系结构中的最大挑战之一。 在以下服务组件编排小节中将更详细地讨论此挑战。</p>
<img src="/2020/01/31/Architecture-Patterns/basic-microservices-architecture-pattern.png">
<p>微服务架构模式中的另一个关键概念是分布式架构，这意味着架构中的所有组件都完全相互分离，并可以通过某种远程访问协议（例如JMS，AMQP，REST， SOAP，RMI等）。 这种体系结构模式的分布式性质是它如何实现其某些出色的可扩展性和部署特性。</p>
<p>微服务架构令人兴奋的事情之一是，它是从与其他常见架构模式相关的问题演变而来的，而不是作为等待问题发生的解决方案而创建的。 微服务架构样式自然是从两个主要来源演变而来：使用分层架构模式开发的单体应用程序和通过SOA架构开发的分布式应用程序。</p>
<p>从单体应用程序到微服务架构模式的演进路径主要是由持续交付的发展所推动的，即从开发到生产的持续部署管道的概念简化了应用程序的部署。 整体应用程序通常由紧密耦合的组件组成，这些组件是单个可部署单元的一部分，这使得它麻烦且难以更改，测试和部署应用程序（因此，通常在大型应用程序中通常会出现“每月部署”周期的增加） IT商店）。 这些因素通常导致脆弱的应用程序在每次部署新内容时都会中断。 微服务架构模式通过将应用程序分为多个可部署单元（服务组件）来解决这些问题，这些可部署单元可以独立于其他服务组件进行单独开发，测试和部署。</p>
<p>导致微服务架构模式的另一条演进路径是来自实现面向服务的架构模式（SOA）的应用程序发现的问题。 尽管SOA模式非常强大，并提供无与伦比的抽象水平，异构连接，服务编排以及使业务目标与IT功能保持一致的希望，但它却是复杂，昂贵，无处不在，难以理解和实现的， 对于大多数应用程序来说通常是多余的。 微服务架构风格通过简化服务概念，消除编排需求以及简化连接和对服务组件的访问来解决此复杂性。</p>
<h4 id="Pattern-Topologies"><a href="#Pattern-Topologies" class="headerlink" title="Pattern Topologies"></a>Pattern Topologies</h4><p>尽管实际上有数十种方法来实现微服务架构模式，但三种主要的拓扑结构是最常见和流行的：基于API REST的拓扑，基于应用程序REST的拓扑和集中式消息传递拓扑。</p>
<p>基于API REST的拓扑对于通过某种API（应用程序编程接口）提供公开的，独立且自包含服务的小型网站很有用。这种拓扑结构如图4-2所示，由非常细粒度的服务组件（因此称为微服务）组成，这些服务组件包含一个或两个模块，这些模块执行独立于其余服务的特定业务功能。 在这种拓扑中，通常使用独立部署的WEB服务，基于REST api来访问这些细粒度的服务组件。 这种拓扑的示例包括Yahoo，Google和Amazon发现的一些常见的基于云的单一用途RESTful Web服务。</p>
<img src="/2020/01/31/Architecture-Patterns/API-REST-based-topology.png">
<p>基于应用程序REST的拓扑与基于API REST的方法的不同之处在于，通过传统的基于Web或胖客户端的业务应用程序屏幕而不是通过简单的API层来接收客户端请求。 如图4-3所示，该应用程序的用户界面层被部署为一个单独的Web应用程序，可通过基于REST的简单接口远程访问单独部署的服务组件（业务功能）。 此拓扑中的服务组件与基于API-REST的拓扑中的服务组件的不同之处在于，这些服务组件往往更大，更粗糙，并且只占整个业务应用程序的一小部分，而不是细粒度的单项应用。 行动服务。 对于具有相对较低复杂度的中小型企业应用程序，此拓扑是常见的。</p>
<img src="/2020/01/31/Architecture-Patterns/app-REST-based-topology.png">
<p>微服务架构模式中的另一种常见方法是集中式消息传递拓扑。 该拓扑（如图4-4所示）与以前的基于REST的应用程序拓扑类似，不同之处在于，该拓扑使用轻量级的集中消息代理（例如ActiveMQ，HornetQ等）代替了使用REST进行远程访问。 。 在查看此拓扑时，不要将其与面向服务的体系结构模式混淆或将其视为“ SOA-Lite”，这一点至关重要。在此拓扑中找到的轻量级消息代理不执行任何编排，转换或复杂的路由。 ;而是访问远程服务组件的轻量级传输。</p>
<p>集中式消息传递拓扑通常在较大的业务应用程序或需要在用户界面和服务组件之间的传输层上进行更复杂控制的应用程序中找到。 与以前讨论的基于REST的简单拓扑相比，此拓扑的优点是高级排队机制，异步消息传递，监视，错误处理以及更好的总体负载平衡和可伸缩性。 通常通过代理群集和代理联合来解决通常与集中式代理相关的单点故障和体系结构瓶颈问题（将单个代理实例拆分为多个代理实例，以根据系统功能区域划分消息吞吐量负载）。</p>
<img src="/2020/01/31/Architecture-Patterns/Centralized-messaging-topology.png">
<h4 id="Avoid-Dependencies-and-Orchestration"><a href="#Avoid-Dependencies-and-Orchestration" class="headerlink" title="Avoid Dependencies and Orchestration"></a>Avoid Dependencies and Orchestration</h4><p>微服务架构模式的主要挑战之一是为服务组件确定正确的粒度级别。 如果服务组件的粒度过于粗糙，你可能不会得到微服务架构模式所带来的好处（部署，可伸缩性，可测试性和松散耦合）。 但是，太细粒度的服务组件将导致对服务编排的要求，这将迅速将你的精益微服务架构转变为重量级的SOA架构，并通常会面临所有SOA架构中的复杂性：复杂性高，混乱，费用和不足。</p>
<p>如果发现需要从应用程序的用户界面或API层内部编排服务组件，则可能是服务组件的粒度太细。 同样，如果发现需要在服务组件之间执行服务间通信以处理单个请求，则从业务功能的角度来看，服务组件的粒度可能太细或分配不正确。</p>
<p>可以通过共享数据库来处理服务间通信，这可能会导致组件之间发生意外耦合。 例如，如果处理Internet订单的服务组件需要客户信息，则可以转到数据库以检索必要的数据，而不是调用客户服务组件中的功能。</p>
<p>共享数据库可以处理信息需求，但是共享功能呢？ 如果服务组件需要另一个服务组件中包含的功能或所有服务组件都具有的功能，则有时您可以跨服务组件复制共享功能（从而违反了DRY原则：请勿重复自己的操作）。 在大多数实现微服务架构模式的业务应用程序中，这是相当普遍的做法，为了保持服务组件独立并分离其部署，需要折衷重复业务逻辑的小部分的冗余。 小型实用程序类可能属于此类重复代码。</p>
<p>如果您发现无论服务组件的粒度级别如何，您仍然无法避免对服务组件进行编排，那么这很好地表明这可能不是您应用程序的正确架构模式。 由于该模式具有分布式特性，因此很难在服务组件之间（以及之间）维护单个事务性工作单元。 这种做法需要某种事务补偿框架来回滚事务，这给这种相对简单而优雅的体系结构模式增加了极大的复杂性。</p>
<h4 id="Considerations-3"><a href="#Considerations-3" class="headerlink" title="Considerations"></a>Considerations</h4><p>微服务架构模式解决了在单片应用程序和面向服务的架构中发现的许多常见问题。 由于主要的应用程序组件被分解为较小的，单独部署的单元，因此使用微服务架构模式构建的应用程序通常更健壮，提供更好的可伸缩性并且可以更轻松地支持连续交付。</p>
<p>这种模式的另一个优点是，它提供了进行实时生产部署的能力，从而大大减少了对传统的每月或周末“大爆炸”生产部署的需求。 由于更改通常与特定服务组件隔离，因此仅需要部署更改的服务组件。 如果只有服务组件的单个实例，则可以在用户界面应用程序中编写专门的代码以检测活动的热部署并将用户重定向到错误页面或等待页面。 或者，您可以在实时部署期间内外交换服务组件的多个实例，从而在部署周期内保持连续可用性（这对于分层体系结构模式来说很难做到）。</p>
<p>需要考虑的最后一个考虑因素是，由于微服务架构模式是分布式架构，因此它也存在一些与事件驱动的架构模式相同的复杂问题，包括合同创建，维护和管理。 ，远程系统可用性以及远程访问身份验证和授权。</p>
<h4 id="Pattern-Analysis-3"><a href="#Pattern-Analysis-3" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h4><p>下表包含事件驱动架构模式的通用架构特征的评级和分析。 对每个特性的评级都基于该特性的自然趋势，即基于模式的典型实现以及该模式通常所知的能力。 有关此模式与本报告中其他模式的关系的并行比较，请参阅本报告末尾的附录A。</p>
<h5 id="Overall-agility-3"><a href="#Overall-agility-3" class="headerlink" title="Overall agility"></a>Overall agility</h5><p>评分：高<br>分析：整体敏捷性是对不断变化的环境做出快速响应的能力。 由于是分开部署的单元的概念，通常将更改隔离到单个服务组件中，从而可以快速轻松地进行部署。 同样，使用此模式构建的应用程序往往非常松散地耦合在一起，这也有助于促进更改。</p>
<h5 id="Ease-of-deployment-3"><a href="#Ease-of-deployment-3" class="headerlink" title="Ease of deployment"></a>Ease of deployment</h5><p>评分：高<br>分析：由于每个服务的细粒度和独立性，微服务架构下的服务独立部署性很高。 服务通常作为单独的软件单元进行部署，从而能够在白天或晚上的任何时间进行“热部署”。 总体部署风险也大大降低了，因为失败的部署可以更快的回滚，并且仅影响和正常部署上线的服务有依赖关系的服务的操作，其他没有依赖关系的操作可以正常执行。</p>
<h5 id="Testability-3"><a href="#Testability-3" class="headerlink" title="Testability"></a>Testability</h5><p>评分：高<br>分析：由于将业务功能分离和隔离在独立的应用程序中，因此可以对测试进行范围划分，从而可以进行更有针对性的测试工作。 与针对整个整体应用程序的回归测试相比，针对特定服务组件的回归测试要容易得多，也更可行。 而且，由于这种模式中的服务组件是松散耦合的，因此从开发的角度来看，进行更改的可能性较小，这会破坏应用程序的另一部分，从而减轻了必须测试整个应用程序的测试负担。 一个小的变化。</p>
<h5 id="Performance-3"><a href="#Performance-3" class="headerlink" title="Performance"></a>Performance</h5><p>评分：低<br>分析：虽然你可以通过在此模式下创建和实现性能很好的应用程序，但是由于微服务架构模式的分布式性质，因此，总体而言，此模式并不自然地适合于高性能应用程序。</p>
<h5 id="Scalability-3"><a href="#Scalability-3" class="headerlink" title="Scalability"></a>Scalability</h5><p>评分：高<br>分析：由于将应用程序划分为单独部署的单元，因此每个服务组件都可以单独扩展，从而可以对应用程序进行微调。 例如，由于该功能的用户量少，可能不需要扩展该股票交易应用程序的管理区域，但是由于大多数交易应用程序为此需要高吞吐量，因此可能需要扩展该交易交易服务组件 功能。</p>
<h5 id="Ease-of-development-3"><a href="#Ease-of-development-3" class="headerlink" title="Ease of development"></a>Ease of development</h5><p>评分：高<br>分析：由于功能被隔离到单独且不同的服务组件中，因此由于范围较小且隔离，开发变得更加容易。 开发人员对一个服务组件进行更改而影响其他服务组件的机会要少得多，从而减少了开发人员或开发团队之间所需的协调。</p>
<h3 id="Space-Based-Architecture"><a href="#Space-Based-Architecture" class="headerlink" title="Space-Based Architecture"></a>Space-Based Architecture</h3><p>大多数基于Web的业务应用程序遵循相同的常规请求流：浏览器的请求命中Web服务器，然后是应用程序服务器，最后是数据库服务器。尽管此模式对一小部分用户适用，但随着用户负载的增加，瓶颈开始出现，首先在Web服务器层，然后在应用程序服务器层，最后在数据库服务器层。针对用户负载增加导致的瓶颈。通常的应对策略是扩展Web服务器。这是相对容易且便宜的，并且有时可以解决瓶颈问题。但是，在大多数用户负载较高的情况下，扩展Web服务器层只会将瓶颈移至应用程序服务器。扩展应用程序服务器可能比Web服务器更为复杂和昂贵，并且通常只是将瓶颈转移到数据库服务器上，而扩展规模甚至更加困难且昂贵。即使可以扩展数据库，最终最终还是一个三角形的拓扑，三角形的最宽部分是Web服务器（最容易扩展），最小的部分是数据库（最难扩展）。</p>
<p>在任何具有大量并发用户，高负载的应用程序中，数据库通常是你可以同时处理多少个事务的最终限制因素。 尽管各种缓存技术和数据库扩展产品有助于解决这些问题，但事实是，针对极端负载扩展正常应用程序是非常困难的。</p>
<p>基于空间的架构模式被设计用于专门解决应用的可伸缩性和并发性问题。 对于具有可变且不可预测的并发用户数量的应用程序，这也是一种有用的架构模式。 从结构上解决极端和可变的可伸缩性问题通常是比尝试扩展数据库或将缓存技术改造为不可扩展的体系结构更好的方法。</p>
<h4 id="模式说明"><a href="#模式说明" class="headerlink" title="模式说明"></a>模式说明</h4><p>基于空间的架构模式（有时也称为云架构模式）使限制应用程序扩展的因素最小化。该模式的名称来自元组空间的概念，即分布式共享内存的概念。通过消除中央数据库约束，并通过使用基于内存的数据网格来实现高可伸缩性。应用程序数据保存在内存中，并在所有活动处理单元之间复制。随着用户负载的增加和减少，处理单元可以动态启动和关闭，从而解决了可变的可扩展性。因为没有中央数据库，所以消除了数据库瓶颈，在应用程序中提供了几乎无限的可伸缩性。</p>
<p>符合此模式的大多数应用程序都是标准网站，这些网站从浏览器接收请求并执行某种操作。一个竞标拍卖网站就是一个很好的例子。该站点通过浏览器请求不断接收来自互联网用户的出价。该应用程序将接收特定项目的出价，记录带有时间戳的出价，并更新该项目的最新出价信息，然后将信息发送回浏览器。</p>
<p>该体系结构模式中有两个主要组件：处理单元和虚拟化中间件。 图5-1说明了基本的基于空间的架构模式及其主要架构组件。</p>
<p>处理单元组件包含应用程序组件（或应用程序组件的一部分）。 这包括基于Web的组件以及后端业务逻辑。 处理单元的内容根据应用程序的类型而有所不同-较小的基于Web的应用程序可能会部署到单个处理单元中，而较大的应用程序可能会基于应用程序将应用程序功能拆分为多个处理单元 应用程序的功能区域。 处理单元通常包含应用程序模块，以及内存中的数据网格和用于故障转移的可选异步持久性存储。 它还包含一个复制引擎，虚拟化的中间件使用该复制引擎将一个处理单元所做的数据更改复制到其他活动的处理单元。</p>
<img src="/2020/01/31/Architecture-Patterns/space-based-architecture-pattern.png">
<p>Figure 5-1. Space-based architecture pattern</p>
<p>虚拟中间件组件处理内部管理和通信。 它包含控制数据同步和请求处理各个方面的组件。 虚拟化中间件中包括消息传递网格，数据网格，处理网格和Deployment Manager。 下一部分将详细介绍这些组件，这些组件可以定制编写或作为第三方产品购买。</p>
<h4 id="Pattern-Dynamics"><a href="#Pattern-Dynamics" class="headerlink" title="Pattern Dynamics"></a>Pattern Dynamics</h4><p>基于空间的架构模式的神奇之处在于虚拟化的中间件组件和每个处理单元内包含的内存数据网格。 图5-2显示了典型的处理单元架构，其中包含应用程序模块，内存数据网格，用于故障转移的可选异步持久性存储以及数据复制引擎。</p>
<p>虚拟化的中间件实质上是体系结构的控制器，并管理请求，会话，数据复制，分布式请求处理和流程单元部署。 虚拟化中间件中有四个主要的体系结构组件：<br>消息传递网格，数据网格，处理网格和部署管理器。</p>
<img src="/2020/01/31/Architecture-Patterns/processing-unit-component.png">
<p>Figure 5-2. Processing-unit component</p>
<h5 id="Messaging-Grid"><a href="#Messaging-Grid" class="headerlink" title="Messaging Grid"></a>Messaging Grid</h5><p>图5-3中所示的消息传递网格管理输入请求和会话信息。 当请求进入虚拟化中间件组件时，消息传递网格组件确定哪些活动处理组件可用于接收请求，并将请求转发到那些处理单元之一。 消息传递网格的复杂性可以从简单的循环算法到更复杂的下一个可用算法，后者可以跟踪哪个处理单元正在处理哪个请求。</p>
<h5 id="Data-Grid"><a href="#Data-Grid" class="headerlink" title="Data Grid"></a>Data Grid</h5><p>数据网格组件可能是此模式中最重要和至关重要的组件。 数据网格与每个处理单元中的数据复制引擎进行交互，以在发生数据更新时管理处理单元之间的数据复制。 由于消息传递网格可以将请求转发到任何可用的处理单元，因此每个处理单元在其内存数据网格中包含完全相同的数据至关重要。 尽管图5-4显示了处理单元之间的同步数据复制，但实际上这是异步并行且非常快速地完成的，有时会在几微秒（百万分之一秒）的时间内完成数据同步。</p>
<img src="/2020/01/31/Architecture-Patterns/messaging-grid-component.png">
<p>Figure 5-3. Messaging-grid component</p>
<img src="/2020/01/31/Architecture-Patterns/data-grid-component.png">
<p>Figure 5-4. data-grid component</p>
<h5 id="Processing-Grid"><a href="#Processing-Grid" class="headerlink" title="Processing Grid"></a>Processing Grid</h5><p>如图5-5所示，处理网格是虚拟化中间件中的可选组件，当存在多个处理单元（每个处理一部分应用程序）时，该组件可管理分布式请求处理。 如果有要求在处理单元类型（例如，订单处理单元和客户处理单元）之间进行协调的请求，则处理网格在这两个处理单元之间中介和协调请求。</p>
<img src="/2020/01/31/Architecture-Patterns/data-grid-component.png">
<p>Figure 5-5. Processing-grid component</p>
<h4 id="Deployment-Manager"><a href="#Deployment-Manager" class="headerlink" title="Deployment Manager"></a>Deployment Manager</h4><p>部署管理器组件根据负载条件管理处理单元的动态启动和关闭。 该组件持续监视响应时间和用户负载，并在负载增加时启动新的处理单元，并在负载减少时关闭处理单元。 它是实现应用程序中可变的可伸缩性需求的关键组件。</p>
<h4 id="Considerations-4"><a href="#Considerations-4" class="headerlink" title="Considerations"></a>Considerations</h4><p>基于空间的体系结构模式是一种复杂且昂贵的实现模式。 对于负载可变的较小的基于Web的应用程序（例如社交媒体网站，竞标和拍卖网站），这是一个不错的体系结构选择。 但是，它不适用于具有大量操作数据的传统大规模关系数据库应用程序。</p>
<p>尽管基于空间的体系结构模式不需要集中的数据存储，但是通常会包含一个空间来执行初始内存数据网格加载并异步保存处理单元进行的数据更新。 创建单独的分区来隔离易失性和广泛使用的事务数据与非活动数据也是一种常见的做法，以减少每个处理单元中内存数据网格的内存占用。</p>
<p>重要的是要注意，虽然此模式的替代名称是基于云的体系结构，但处理单元（以及虚拟化中间件）不必驻留在基于云的托管服务或PaaS（平台作为 服务）。 它可以轻松地驻留在本地服务器上，这就是我更喜欢“基于空间的体系结构”的原因之一。<br>从产品实施的角度来看，您可以通过第三方产品（例如GemFire，JavaSpaces，GigaSpaces，IBM Object Grid，nCache和Oracle Coherence）以这种模式实施许多架构组件。 由于这种模式的实现在成本和功能（尤其是数据复制时间）方面差异很大，因此，作为一名架构师，您应该首先确定自己的特定目标和需求，然后再进行产品选择。</p>
<h4 id="Pattern-Analysis-4"><a href="#Pattern-Analysis-4" class="headerlink" title="Pattern Analysis"></a>Pattern Analysis</h4><p>下表包含事件驱动架构模式的通用架构特征的评级和分析。 对每个特性的评级都基于该特性的自然趋势，即基于模式的典型实现以及该模式通常所知的能力。 有关此模式与本报告中其他模式的关系的并行比较，请参阅本报告末尾的附录A。</p>
<h5 id="Overall-agility-4"><a href="#Overall-agility-4" class="headerlink" title="Overall agility"></a>Overall agility</h5><p>评分：高<br>分析：整体敏捷性是对不断变化的环境做出快速响应的能力。 因为可以快速启动和关闭处理单元（应用程序的部署实例），所以应用程序对与用户负载增加或减少有关的更改（环境更改）反应良好。<br>使用这种模式创建的体系结构通常会因小应用程序大小和模式的动态性质而对编码更改做出很好的响应。</p>
<h5 id="Ease-of-deployment-4"><a href="#Ease-of-deployment-4" class="headerlink" title="Ease of deployment"></a>Ease of deployment</h5><p>评分：高<br>分析：尽管基于空间的体系结构通常不分离和分布，但它们是动态的，并且基于云的复杂工具允许将应用程序轻松“推送”到服务器，从而简化了部署。</p>
<h5 id="Testability-4"><a href="#Testability-4" class="headerlink" title="Testability"></a>Testability</h5><p>评分：低<br>分析：在测试环境中实现非常高的用户负载既昂贵又耗时，从而难以测试应用程序的可伸缩性方面。</p>
<h5 id="Performance-4"><a href="#Performance-4" class="headerlink" title="Performance"></a>Performance</h5><p>评分：高<br>分析：通过内存中的数据访问和此模式中内置的缓存机制可实现高性能。</p>
<h5 id="Scalability-4"><a href="#Scalability-4" class="headerlink" title="Scalability"></a>Scalability</h5><p>评分：高<br>分析：高可伸缩性来自于对集中式数据库几乎没有依赖性的事实，因此从本质上消除了可伸缩性方程式中的这一限制瓶颈。</p>
<h5 id="Ease-of-development-4"><a href="#Ease-of-development-4" class="headerlink" title="Ease of development"></a>Ease of development</h5><p>评分：低<br>分析：复杂的缓存和内存中的数据网格产品使这种模式的开发相对复杂，这主要是由于对创建这种类型的架构所用的工具和产品缺乏了解。 此外，在开发这些类型的体系结构时必须格外小心，以确保源代码中的任何内容都不会影响性能和可伸缩性。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href&gt;Software Architecture Patterns&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;Layered-Architecture&quot;&gt;&lt;a href=&quot;#Layered-Architecture&quot; class=&quot;headerlink&quot; title=&quot;Layered Architecture&quot;&gt;&lt;/a&gt;Layered Architecture&lt;/h3&gt;&lt;p&gt;分层架构是最通用和使用频率最高的架构模式，通常也称之为N-层架构。这种模式也是大多数Java EE应用程序的事实上的架构标准，因此，它被大多数架构师，设计人员和开发人员所广泛了解。 分层架构模式能与传统的IT通信和大多数公司中的组织结构紧密匹配，这使其成为大多数业务应用程序开发工作的自然选择。&lt;/p&gt;
&lt;h4 id=&quot;Pattern-Description&quot;&gt;&lt;a href=&quot;#Pattern-Description&quot; class=&quot;headerlink&quot; title=&quot;Pattern Description&quot;&gt;&lt;/a&gt;Pattern Description&lt;/h4&gt;&lt;p&gt;分层架构模式中的组件被组织为水平分隔的层，每一层在应用程序中扮演特定的角色（例如，表示层或业务逻辑层）。 尽管分层体系架构模式没有指定模式中必须存在的层的数量和类型，但是大多数分层架构都由四个标准层组成：&lt;code&gt;表示层&lt;/code&gt;，&lt;code&gt;业务层&lt;/code&gt;，&lt;code&gt;持久性&lt;/code&gt;和&lt;code&gt;数据库层&lt;/code&gt;，如图（图1-1）所示。在某些情况下，尤其是在将持久性逻辑（例如SQL或HSQL）嵌入业务层组件中时，业务层和持久性层会组合为一个业务层。 因此，较小的应用程序可能仅具有三层，而较大且更复杂的业务应用程序可能包含五层或更多层。&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://leokongwq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据是如何到达目标主机的</title>
    <link href="https://leokongwq.github.io/2019/12/29/tcp-ip-summary-chapter-one.html"/>
    <id>https://leokongwq.github.io/2019/12/29/tcp-ip-summary-chapter-one.html</id>
    <published>2019-12-29T03:06:09.000Z</published>
    <updated>2020-02-05T11:06:36.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近重新翻看了<code>图解TCP/IP</code>，有必要将一些知识点记下来，方便以后自己和其他人理解记忆。本文主要总结一个数据是如何发送到目标主机的。</p>
<h3 id="假设模型"><a href="#假设模型" class="headerlink" title="假设模型"></a>假设模型</h3><img src="/2019/12/29/tcp-ip-summary-chapter-one/tcp-ip-summary-chapter-one-1.png">
<p>模型中假设主机1(IP地址为：192.168.1.3) 要给主机2(IP地址为：192.168.2.3)发送数据。</p>
<a id="more"></a>
<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="OSI-模型和-和-以太网帧"><a href="#OSI-模型和-和-以太网帧" class="headerlink" title="OSI 模型和 和 以太网帧"></a>OSI 模型和 和 以太网帧</h4><p>根据OSI参考模型，每层都将上次传递过来的数据添加本层的头信息后发送给下一层。</p>
<table>
<thead>
<tr>
<th>以太网帧头</th>
<th>IP数据报头</th>
<th>TCP包头</th>
<th>数据</th>
<th>FCS</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>802.3 以太网帧头</p>
<img src="/2019/12/29/tcp-ip-summary-chapter-one/tcp-ip-summary-chapter-one-2.png">
<p>从802.3 以太网帧头格式可以知道，发送方需要知道目的主机的的MAC地址。<br>那如何得到目的主机的MAC地址呢？答案是通过<a href="https://zh.wikipedia.org/zh-hans/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">ARP</a></p>
<p>如何具体总结如下：</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>ARP（地址解析协议，全称：Address Resolution Protocol）是一个通过解析网络层地址(IP地址)来找寻数据链路层地址的网络传输协议，它在IPv4中极其重要。ARP最初在1982年的RFC 826（征求意见稿）[1]中提出并纳入互联网标准 STD 37. ARP 也可能指是在多数操作系统中管理其相关地址的一个进程。</p>
<h5 id="在同一个网段"><a href="#在同一个网段" class="headerlink" title="在同一个网段"></a>在同一个网段</h5><ol>
<li>ARP高速缓存有目标IP的MAC地址。</li>
<li>ARP高速缓存没有目标IP的MAC地址，通过ARP广播请求目标IP的MAC地址，缓存该MAC地址。</li>
</ol>
<h5 id="不在同一个网段"><a href="#不在同一个网段" class="headerlink" title="不在同一个网段"></a>不在同一个网段</h5><p>主机通过子网掩码和目的IP进行运算，判断是不是同一个网络号。</p>
<p>不是同一个网段：则需要将包发给默认网关，所以需要获取网关的MAC地址。</p>
<ol>
<li>ARP高速缓存有默认网关的MAC地址：直接封包发送给默认网关，再由网关转发到目标网络。</li>
<li>ARP高速缓存没有默认网关的MAC地址 ：还是发送ARP广播请求默认网关的MAC地址，缓存该地址，并且发送数据报到网关。</li>
</ol>
<p>注意：</p>
<ol>
<li>所以主机上配置的默认网关IP非常重要。</li>
<li>通过手动配置，也可以分属于不同网段或子网的两台主机进行通信，原因是数据链路层根本不关心IP地址是不是同一个网段或子网。二层交换机在广播ARP请求时，所有连接到交换机端口上的主机都可以做出响应，交换机通过学习，可以把所有端口和MAC地址的对应关系拿到并缓存起来。</li>
</ol>
<h3 id="不同VLAN的通信方式"><a href="#不同VLAN的通信方式" class="headerlink" title="不同VLAN的通信方式"></a>不同VLAN的通信方式</h3><h4 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h4><img src="/2019/12/29/tcp-ip-summary-chapter-one/816886223a180599bb5085c894d52e3972d92275.png">
<p>缺点：如果不同VLAN间的流量非常大，那么路由器就会成为瓶颈，出现掉包、或者通信堵塞。</p>
<h4 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h4><p>三层交换机本质上具备路由功能的二层交换机。</p>
<img src="/2019/12/29/tcp-ip-summary-chapter-one/9bb3ce246913a47d749da732f59318111a11e443.png">
<p>在三层交换机内部，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>a. 第一步，通过ARP获取目标主机的MAC地址，如果不在同一个网段或子网，则获取默认网关的MAC地址（网关一般是路由器，它会响应ARP广播请求，返回自己的MAC地址）。<br>b. 第二步，二层交换机通过分析目标MAC地址，查转发表，把帧发送到对应的端口上，这个端口可能对应的是同一个网段的主机或是路由器。<br>c. 第三步，路由器拿到帧数据后，发现数据帧中的目标MAC地址是自己的某一个端口的物理地址，这时路由器会把以太网数据帧的封装去掉。获取帧里面的目标IP地址（路由器工作在OSI模型的网络层，所以需要一直解析包数据，直到获取IP数据报头信息），判断目标IP是不是本地网络（通过网络号），不是则通过路由表查找下一个跳路由器的IP（没有路由项，则使用缺省路由）。获取IP后，继续通过ARP获取下一跳路由器的MAC地址，重新封包后发送到一下跳路由器。后续的路由转发都是以此规则进行。<br>d. 目标网络的网关路由器发现目标IP地址是本网段的IP，通过ARP获取目标IP的MAC地址，重新封装后发送到对应的端口，该端口后面是二层交换机。<br>e. 二层交换机通过目标IP查找转发表，获取目标IP对应的MAC地址和端口，将数据转发到指定的端口，目标数据就收到了数据。<br>f. 主机验证MAC地址和IP地址是否属于本机，是本机则投递给协议栈对应的层进行处理。</p>
<ol>
<li>路由器转发数据包不会对它的IP源地址和目标地址做修改，只会修改MAC</li>
<li>有一种情况，源和目标IP是被改变的，那就是NAT</li>
<li>路由的每一条可用的路由都和路由嚣上的接口是对应的</li>
<li>路由表和MAC转发表的区别在于，路由表存放的是目的IP下一步要去的地方的IP。</li>
<li>广播在路由器能够结束，原因就是路由器会在查找不到对应MAC表时，根据目的IP进行路由。路由过程的两种情况都不存在广播。</li>
</ol>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表:"></a>路由表:</h4><p>路由表存储的信息包括：<br>直连路径：来自活动路由接口的路径。当接口为活动状态并配置了IP地址时，路由器添加一条直连路径。<br>远端路径：远端的网络连接到其他路由。通过静态配置或动态路由协议到达该网络。<br>路由表是存储在RAM中的一份数据文件，用于存储直连以及远端网络的路由信息。路由表中包含网络或下一跳地址的信息。这些信息告知路由器可以通过将报文发送至代表下一跳地址的路由器以最佳路劲到达目的地址。下一跳信息也可以是到下一个目的地的输出接口。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/read/cv3673331/" target="_blank" rel="noopener">https://www.bilibili.com/read/cv3673331/</a><br><a href="https://wizardforcel.gitbooks.io/network-basic/3.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/network-basic/3.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近重新翻看了&lt;code&gt;图解TCP/IP&lt;/code&gt;，有必要将一些知识点记下来，方便以后自己和其他人理解记忆。本文主要总结一个数据是如何发送到目标主机的。&lt;/p&gt;
&lt;h3 id=&quot;假设模型&quot;&gt;&lt;a href=&quot;#假设模型&quot; class=&quot;headerlink&quot; title=&quot;假设模型&quot;&gt;&lt;/a&gt;假设模型&lt;/h3&gt;&lt;img src=&quot;/2019/12/29/tcp-ip-summary-chapter-one/tcp-ip-summary-chapter-one-1.png&quot;&gt;
&lt;p&gt;模型中假设主机1(IP地址为：192.168.1.3) 要给主机2(IP地址为：192.168.2.3)发送数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TCP/IP" scheme="https://leokongwq.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>logback最佳实践</title>
    <link href="https://leokongwq.github.io/2019/12/14/logback-best-practise.html"/>
    <id>https://leokongwq.github.io/2019/12/14/logback-best-practise.html</id>
    <published>2019-12-14T10:51:31.000Z</published>
    <updated>2019-12-14T12:44:01.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在最近的一次项目性能优化过程中，通过火焰图工具发现logback占用CPU很多，因此有了这篇总结文章。</p>
<h3 id="logback-同步-vs-异步"><a href="#logback-同步-vs-异步" class="headerlink" title="logback 同步 vs 异步"></a>logback 同步 vs 异步</h3><p>同步写日志一般配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ORDER_LOG"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span>&gt;</span>/data/logs/AAA/order.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%-5p] [%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%X&#123;tracing_id&#125;] [%C&#123;1&#125;:%M:%L] %m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">immediateFlush</span>&gt;</span>false<span class="tag">&lt;/<span class="name">immediateFlush</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>/data/logs/AAA/order.log.%d&#123;yyyy-MM-dd_HH&#125;<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>从配置可以看出来，写日志到日志文件的操作由<code>RollingFileAppender</code>完成，该类的继承结构如下：</p>
<img src="/2019/12/14/logback-best-practise/RollingFileAppender.jpeg">
<p>从继承结构可以知道<code>RollingFileAppender</code>继承了<code>UnsynchronizedAppenderBase</code>，根据doc文档说明，<code>RollingFileAppender</code>需要自己处理多线程同步的问题。 在内部它确实也自己做了同步。</p>
<figure class="highlight java"><figcaption><span>RollingFileAppender</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(E event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The roll-over check must precede actual writing. This is the</span></span><br><span class="line">    <span class="comment">// only correct behavior for time driven triggers.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to synchronize on triggeringPolicy so that only one rollover</span></span><br><span class="line">    <span class="comment">// occurs at a time</span></span><br><span class="line">    <span class="keyword">synchronized</span> (triggeringPolicy) &#123;</span><br><span class="line">      <span class="keyword">if</span> (triggeringPolicy.isTriggeringEvent(currentlyActiveFile, event)) &#123;</span><br><span class="line">        rollover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.subAppend(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OutputStreamAppender.java</p>
<figure class="highlight java"><figcaption><span>OutputStreamAppender.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* All synchronization in this class is done via the lock object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> LogbackLock lock = <span class="keyword">new</span> LogbackLock();</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subAppend</span><span class="params">(E event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// this step avoids LBCLASSIC-139</span></span><br><span class="line">      <span class="keyword">if</span> (event <span class="keyword">instanceof</span> DeferredProcessingAware) &#123;</span><br><span class="line">        ((DeferredProcessingAware) event).prepareForDeferredProcessing();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// the synchronization prevents the OutputStream from being closed while we</span></span><br><span class="line">      <span class="comment">// are writing. It also prevents multiple threads from entering the same</span></span><br><span class="line">      <span class="comment">// converter. Converters assume that they are in a synchronized block.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        writeOut(event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      <span class="comment">// as soon as an exception occurs, move to non-started state</span></span><br><span class="line">      <span class="comment">// and add a single ErrorStatus to the SM.</span></span><br><span class="line">      <span class="keyword">this</span>.started = <span class="keyword">false</span>;</span><br><span class="line">      addStatus(<span class="keyword">new</span> ErrorStatus(<span class="string">"IO failure in appender"</span>, <span class="keyword">this</span>, ioe));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 encode进行日志序列化，格式化写入</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeOut</span><span class="params">(E event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.encoder.doEncode(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LayoutWrappingEncoder.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LayoutWrappingEncoder.java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> immediateFlush = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doEncode</span><span class="params">(E event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String txt = layout.doLayout(event);</span><br><span class="line">    outputStream.write(convertToBytes(txt));</span><br><span class="line">    <span class="comment">//是否立即写入</span></span><br><span class="line">    <span class="keyword">if</span> (immediateFlush)</span><br><span class="line">      outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码逻辑可以得出如下结论：</p>
<ol>
<li>RollingFileAppender 写日志自己实现了多线程同步。 </li>
<li>RollingFileAppender 写日志是直接接入到日志文件中的。</li>
<li>RollingFileAppender 默认日志到文件后会立刻flush，保证日志不丢失。</li>
<li>因为是顺序写文件，速度还是很高的，但是应为每次都flush，这会影响性能。</li>
</ol>
<p>为了防止写日志影响应用性能， 我们需要使用异步写日志的方式。</p>
<p>异步写日志一般配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> =<span class="string">"ASYNC_ORDER_LOG"</span> <span class="attr">class</span>= <span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    // 不丢弃日志</span><br><span class="line">    <span class="tag">&lt;<span class="name">discardingThreshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">discardingThreshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">queueSize</span>&gt;</span>512<span class="tag">&lt;/<span class="name">queueSize</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeCallerData</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeCallerData</span>&gt;</span></span><br><span class="line">    // 如果设置为true，队列满了会直接丢弃信息，而不是阻塞（其实就是使用的offer而不是put方法）</span><br><span class="line">    <span class="tag">&lt;<span class="name">neverBlock</span>&gt;</span>false<span class="tag">&lt;/<span class="name">neverBlock</span>&gt;</span></span><br><span class="line">    // 指定底层真实使用的Appender</span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span> =<span class="string">"ORDER_LOG"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/2019/12/14/logback-best-practise/AsyncAppender.jpeg">
<p><code>AsyncAppender</code> 继承自 <code>AsyncAppenderBase</code>。 <code>AsyncAppenderBase</code>的doc文档有如下的描述：</p>
<blockquote>
<p>AsyncAppenderBase的子类写日志是异步的方式，内部使用了 BlockingQueue（异步写日志就是一个生产者-消费者模式）。<br>BlockingQueue 的使用者负责在应用关闭时关闭BlockingQueue，来确保不丢失日志。</p>
</blockquote>
<p>注意：不丢失日志，可以通过如下的方式实现:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">shutdownHook</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.hook.DelayingShutdownHook"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runtime.addShutdownHook(<span class="keyword">new</span> Thread (() -&gt; &#123;</span><br><span class="line">   LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line">    loggerContext.stop();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p><code>AsyncAppenderBase</code>代码分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">256</span>;</span><br><span class="line"><span class="comment">// 默认阻塞队列大小</span></span><br><span class="line"><span class="keyword">int</span> queueSize = DEFAULT_QUEUE_SIZE;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 初始值为 -1， 在启动时默认值是通过queueSize的大小计算出来的。</span></span><br><span class="line"><span class="keyword">int</span> discardingThreshold = UNDEFINED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步写日志的线程</span></span><br><span class="line">Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (appenderCount == <span class="number">0</span>) &#123;</span><br><span class="line">      addError(<span class="string">"No attached appenders found."</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queueSize &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      addError(<span class="string">"Invalid queue size ["</span> + queueSize + <span class="string">"]"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;E&gt;(queueSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (discardingThreshold == UNDEFINED)</span><br><span class="line">      discardingThreshold = queueSize / <span class="number">5</span>;</span><br><span class="line">    addInfo(<span class="string">"Setting discardingThreshold to "</span> + discardingThreshold);</span><br><span class="line">    worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    worker.setName(<span class="string">"AsyncAppender-Worker-"</span> + worker.getName());</span><br><span class="line">    <span class="comment">// make sure this instance is marked as "started" before staring the worker Thread</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">    worker.start();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以的队列容量小于配置的值 并且 日志事件的级别为INFO及一下，那么就丢弃日志。</span></span><br><span class="line">    <span class="keyword">if</span> (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preprocess(eventObject);</span><br><span class="line">    put(eventObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isQueueBelowDiscardingThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (blockingQueue.remainingCapacity() &lt; discardingThreshold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDiscardable</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">    Level level = event.getLevel();</span><br><span class="line">    <span class="keyword">return</span> level.toInt() &lt;= Level.INFO_INT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(ILoggingEvent eventObject)</span> </span>&#123;</span><br><span class="line">    eventObject.prepareForDeferredProcessing();</span><br><span class="line">    <span class="comment">// 是否需要获取调用者信息，这也是一个耗时操作，默认是false（内部通过创建异常对象，获取堆栈信息，从而计算日志发送的类，方法，行号信息）。</span></span><br><span class="line">    <span class="keyword">if</span>(includeCallerData)</span><br><span class="line">      eventObject.getCallerData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞操作</span></span><br><span class="line">        blockingQueue.put(eventObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AsyncAppenderBase&lt;E&gt; parent = AsyncAppenderBase.<span class="keyword">this</span>;</span><br><span class="line">      AppenderAttachableImpl&lt;E&gt; aai = parent.aai;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// loop while the parent is started</span></span><br><span class="line">      <span class="keyword">while</span> (parent.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 从队列中获取数据，其实就是消费者</span></span><br><span class="line">          E e = parent.blockingQueue.take();</span><br><span class="line">          aai.appendLoopOnAppenders(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      addInfo(<span class="string">"Worker thread will flush remaining events before exiting. "</span>);</span><br><span class="line">      <span class="keyword">for</span> (E e : parent.blockingQueue) &#123;</span><br><span class="line">        aai.appendLoopOnAppenders(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      aai.detachAndStopAllAppenders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>同步写日志而且immediateFlush=true的配置下，性能最差。原因是写磁盘导致其他线程等待时间过长，虽然是顺序写，但是毕竟是持久化数据到磁盘。当然了，SSD能好一点。</li>
<li>异步写在JVM突然crash的时候有丢失数据的风险，但是性能很高，原因在于避免了直接写磁盘带来的性能消耗。但是需要注意的是多线程操作同一个阻塞队列也会因为锁争用的问题影响性能。<br> a. 不同的模块配置不同的日志文件和Appender，能减少锁争用的问题。<br> b. 减少不必要的日志输出。<br> c. 增加阻塞队列的大小，在<code>neverBlock=false</code>的情况下避免线程等待问题。<br> d. 多个Appender（SiftingAppender），底层还是写同一个文件。好处是减少了多线程在阻塞队列上的锁竞争问题。</li>
</ol>
<h3 id="SiftingAppender"><a href="#SiftingAppender" class="headerlink" title="SiftingAppender"></a>SiftingAppender</h3><p>SiftingAppender是logback根据mdc中的变量动态创建appender的代理，只要我们将一个线程号作为日志名分发器discriminator注入到SiftingAppender中，它就可以动态的为我们创建不同的appender，达到分线程的目的，配置方式举例如下：</p>
<pre><code class="xml"><span class="comment">&lt;!-- 分线程输出源 --&gt;</span>
<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"frameworkthread"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.SiftingAppender"</span>&gt;</span>
        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">class</span>=<span class="string">"ThreadDiscriminator"</span>&gt;</span>
            <span class="tag">&lt;<span class="name">key</span>&gt;</span>threadName<span class="tag">&lt;/<span class="name">key</span>&gt;</span>
        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span>
        <span class="tag">&lt;<span class="name">sift</span>&gt;</span>
            <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE-${threadName}"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span>
                <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>
                    <span class="tag">&lt;<span class="name">Encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">Encoding</span>&gt;</span>
                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d{yyyy-MM-dd HH:mm:ss.SSS}[%c][%thread][%X{tradeNo}][%p]-%m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>
                <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>
                <span class="tag">&lt;<span class="name">rollingPolicy</span>
                    <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span>        
                    <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>D:/test/threadlogs/${threadName}-%d{yyyy-MM-dd}.%i.log
                    <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>
                    <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span>
                    <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span>
                    <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span>
                <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>
            <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>
        <span class="tag">&lt;/<span class="name">sift</span>&gt;</span>
<span class="tag">&lt;/<span class="name">appender</span>&gt;</span>
</code></pre>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://logback.qos.ch/manual/appenders.html" target="_blank" rel="noopener">http://logback.qos.ch/manual/appenders.html</a><br><a href="https://segmentfault.com/a/1190000016204970" target="_blank" rel="noopener">一次logback多线程调优的经历</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在最近的一次项目性能优化过程中，通过火焰图工具发现logback占用CPU很多，因此有了这篇总结文章。&lt;/p&gt;
&lt;h3 id=&quot;logback-同步-vs-异步&quot;&gt;&lt;a href=&quot;#logback-同步-vs-异步&quot; class=&quot;headerlink&quot; title=&quot;logback 同步 vs 异步&quot;&gt;&lt;/a&gt;logback 同步 vs 异步&lt;/h3&gt;&lt;p&gt;同步写日志一般配置如下：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;appender&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;ORDER_LOG&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;file&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/logs/AAA/order.log&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;file&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;[%-5p] [%d&amp;#123;yyyy-MM-dd HH:mm:ss.SSS&amp;#125;] [%X&amp;#123;tracing_id&amp;#125;] [%C&amp;#123;1&amp;#125;:%M:%L] %m%n&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;immediateFlush&lt;/span&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;immediateFlush&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;INFO&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;level&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;rollingPolicy&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/logs/AAA/order.log.%d&amp;#123;yyyy-MM-dd_HH&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;fileNamePattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;rollingPolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;appender&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://leokongwq.github.io/categories/java/"/>
    
    
      <category term="logback" scheme="https://leokongwq.github.io/tags/logback/"/>
    
  </entry>
  
  <entry>
    <title>Java 对象内存布局</title>
    <link href="https://leokongwq.github.io/2019/12/14/java-object-memeory-layout.html"/>
    <id>https://leokongwq.github.io/2019/12/14/java-object-memeory-layout.html</id>
    <published>2019-12-14T01:22:49.000Z</published>
    <updated>2019-12-14T03:55:45.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>所有试验代码都是在Mac os JDK8 64位JVM上测试（默认开启了指针压缩）。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>一道面试题。 问题是：A和B两个类，A类中有一个private的字段age，B类继承自A类。创建一个B类的对象b，对象b的内存中是否包含父类A中的字段age的内存空间。</p>
<p>类似代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 09:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 09:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这个问题刚开始你一听可能觉得很懵，父类的private字段子类也不能<strong>直接</strong>访问，那么在子类对象的内存空间中还有分配的必要吗？但是你静下心来推敲一下，答案是不言自明的。可以通过反正法来证明。</p>
<ol>
<li>通过Java反射API，子类中也是可以访问到父类中声明的private字段的。如果子类对象的内存中没有这部分内存内容，那么JVM该从哪里去找呢？不能无中生有的。</li>
<li>父类的字段的是private的，但是父类中提供了public方法来访问声明的private字段。</li>
</ol>
<p>问题回答完了。但是该问题的引深问题是Java对象占用内存是如何分配的。</p>
<h3 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a>Java对象内存布局</h3><p>一个Java对象在内存中有三部分组成：1，对象头。2，实例数据。3，内存填充。</p>
<p>看下面一张图：</p>
<img src="/2019/12/14/java-object-memeory-layout/java-object-memory-layout.jpg">
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul>
<li>Mark Word：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；</li>
<li>Class Pointer：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节(如果在64位JVM上开启了压缩指针，那么占用4个字节)；</li>
<li>Length：如果是数组对象，还有一个保存数组长度的空间，占4个字节；</li>
</ul>
<p>32位的对象头</p>
<img src="/2019/12/14/java-object-memeory-layout/java-object-header-32bit.jpg">
<p>64位的对象头</p>
<img src="/2019/12/14/java-object-memeory-layout/java-object-header-64bit.jpg">
<p>小结：</p>
<ol>
<li>32 位JVM上，非数组对象头占用8个字节，数组对象头占用12个字节。</li>
<li>64 为JVM上，非数组对象头占用16个字节，数组对象占用20个字节。如果开启压缩指针的话，非数组对象头占用12个字节（8 + 4），数组对象头占用16个字节（8 + 4 + 4）。</li>
</ol>
<h4 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a>对象大小</h4><p>上面了解了对象头的组成和大小信息。下面就了解下对象的大小和内存布局。</p>
<p>先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 10:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyObject</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EmptyObject emptyObject = <span class="keyword">new</span> EmptyObject();</span><br></pre></td></tr></table></figure>
<p><code>emptyObject</code> 大小是多大呢？</p>
<p>答案和分析：没有任何字段，父类是Object类，也没有任何字段。那么它的大小在64JVM开启指针压缩的情况下是 8 + 4 = 12 字节。 理论上没有问题，但是实际上JVM为了内存对齐，还有4字节的填充，所以总的大小是16字节。</p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">System.out.println(ClassLayout.parseClass(EmptyObject.class).toPrintable());</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.EmptyObject object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12        (object header)                           N/A</span><br><span class="line">     12     4        (loss due to the next object alignment) 内存对齐</span><br><span class="line">Instance size: 16 bytes // 总大小</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>使用文章开头定义的<code>Animal</code>类再次试验，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Animal object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12        (object header)                           N/A</span><br><span class="line">     12     4    int Animal.age                                N/A</span><br><span class="line">Instance size: 16 bytes</span><br></pre></td></tr></table></figure>
<p>因为 age是int类型，占用4个字节。和对象头加起来刚好是8字节的整数倍，不需要填充。</p>
<p>如果我们把age的类型定义为long，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Animal object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12        (object header)                           N/A</span><br><span class="line">     12     4        (alignment/padding gap)                  </span><br><span class="line">     16     8   long Animal.age                                N/A</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>
<p>结果表明还是有4字节的填充。</p>
<p>在<code>age</code>字段后面再定义一个4字节的字段，再次测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Animal object internals:</span><br><span class="line"> OFFSET  SIZE    TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12         (object header)                           N/A</span><br><span class="line">     12     4   float Animal.weight                             N/A</span><br><span class="line">     16     8    long Animal.age                                N/A</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>
<p>从这次结果可以看出来，JVM会对字段进行排序，尽可能的利用内存，减少padding。</p>
<h4 id="一个复杂的内存布局"><a href="#一个复杂的内存布局" class="headerlink" title="一个复杂的内存布局"></a>一个复杂的内存布局</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 09:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 09:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> f2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> f3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> f4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试代码，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Dog object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12                    (object header)                           N/A</span><br><span class="line">     12     4                int Animal.height                             N/A</span><br><span class="line">     16     4                int Animal.age                                N/A</span><br><span class="line">     20     4                int Dog.f1                                    N/A</span><br><span class="line">     24     8             double Dog.weight                                N/A</span><br><span class="line">     32     2               char Dog.f2                                    N/A</span><br><span class="line">     34     1            boolean Dog.f3                                    N/A</span><br><span class="line">     35     1               byte Dog.f4                                    N/A</span><br><span class="line">     36     4   java.lang.Object Dog.object                                N/A</span><br><span class="line">Instance size: 40 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>
<p>观察数据总结结论：</p>
<ol>
<li>任何对象的大小都是8个字节的整数倍，不够的进行padding。目的是为了提高CPU的工作效率。</li>
<li>实例域按照如下优先级进行排列：长整型和双精度类型；整型和浮点型；字符和短整型；字节类型和布尔类型，最后是引用类型。这些实例域都按照各自的单位对齐。目的是为了减少padding。</li>
<li>不同类继承关系中的实例域不能混合排列。首先按照规则2处理父类中的实例域，接着才是子类的实例域</li>
<li>当父类中最后一个成员和子类第一个成员的间隔如果不够4个字节的话，就必须扩展到4个字节的基本单位。</li>
<li>如果子类第一个实例域是一个双精度或者长整型，并且父类并没有用完8个字节，JVM会破坏规则2，按照整形（int），短整型（short），字节型（byte），引用类型（reference）的顺序，向未填满的空间填充。</li>
</ol>
<h4 id="回到面试题"><a href="#回到面试题" class="headerlink" title="回到面试题"></a>回到面试题</h4><p>测试Dog类的内存布局，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Dog object internals:</span><br><span class="line"> OFFSET  SIZE     TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>    <span class="number">12</span>          (object header)                           N/A</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>      <span class="keyword">int</span> Animal.age                                N/A</span><br><span class="line">     <span class="number">16</span>     <span class="number">8</span>   <span class="keyword">double</span> Dog.weight                                N/A</span><br><span class="line">Instance size: <span class="number">24</span> bytes</span><br><span class="line">Space losses: <span class="number">0</span> bytes internal + <span class="number">0</span> bytes external = <span class="number">0</span> bytes total</span><br></pre></td></tr></table></figure>
<p>结果一目了然，父类Animal的private字段age也分配了内存。</p>
<h3 id="题外话-Java对象全部分配在堆上吗？"><a href="#题外话-Java对象全部分配在堆上吗？" class="headerlink" title="题外话-Java对象全部分配在堆上吗？"></a>题外话-Java对象全部分配在堆上吗？</h3><p>答案1：全部分配在堆上。没问题，可以这么设计，但是需要考虑分配效率问题和GC压力。<br>答案2：也可能分配在栈上。当开启逃逸分析<code>-XX:+DoEscapeAnalysis</code>时，方法内部分配的对象完全可以在栈上分配，只要对象引用不会逸出到方法外面。方法调用结束，内存释放，GC压力也没有了。</p>
<p>做个试验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10M -XX:+PrintGCDetails -XX:+DoEscapeAnalysis</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/12/14 - 09:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private byte[] _M = new byte[1024 * 1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> f2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> f3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> f4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(ClassLayout.parseClass(Dog.class).toPrintable());</span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"take time:"</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">com.leokongwq.java.jvm.Dog object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0    12                    (object header)                           N/A</span><br><span class="line">     12     4                int Animal.height                             N/A</span><br><span class="line">     16     4                int Animal.age                                N/A</span><br><span class="line">     20     4                int Dog.f1                                    N/A</span><br><span class="line">     24     8             double Dog.weight                                N/A</span><br><span class="line">     32     2               char Dog.f2                                    N/A</span><br><span class="line">     34     1            boolean Dog.f3                                    N/A</span><br><span class="line">     35     1               byte Dog.f4                                    N/A</span><br><span class="line">     36     4   java.lang.Object Dog.object                                N/A</span><br><span class="line">Instance size: 40 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">********************</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1631K-&gt;512K(2048K)] 3217K-&gt;2297K(9216K), 0.0006654 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1535K-&gt;224K(2048K)] 3321K-&gt;2209K(9216K), 0.0012281 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1247K-&gt;0K(2048K)] 3233K-&gt;2193K(9216K), 0.0004912 secs] [Times: user=0.00 sys=0.01, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1023K-&gt;96K(2048K)] 3217K-&gt;2289K(9216K), 0.0003646 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1119K-&gt;0K(2048K)] 3313K-&gt;2217K(9216K), 0.0009835 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0004940 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003785 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003809 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003755 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003896 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003721 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003373 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;0K(2048K)] 3241K-&gt;2217K(9216K), 0.0003653 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">take time:13ms</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2048K, used 350K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">  eden space 1024K, 34% used [0x00000007bfd00000,0x00000007bfd57930,0x00000007bfe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)</span><br><span class="line"> ParOldGen       total 7168K, used 2217K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000)</span><br><span class="line">  object space 7168K, 30% used [0x00000007bf600000,0x00000007bf82a460,0x00000007bfd00000)</span><br><span class="line"> Metaspace       used 8039K, capacity 8280K, committed 8576K, reserved 1056768K</span><br><span class="line">  class space    used 950K, capacity 1032K, committed 1152K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>耗时： 13毫秒，分配了 40byte * 100000000 ≈ 4G。 很明显如果是在10M的堆上进行分配，不能够这么快，GC日志输出也不是如此。</p>
<p>结论：</p>
<ol>
<li>不会溢出的对象完全没有再堆上分配的必要，可以减少内存分配的竞争，减轻GC的压力。</li>
<li>不是所有的对象都在栈上分配。因为栈的大小是有限的，例如1M的栈大小怎么能分配2M大小的对象呢？</li>
<li>如果把Dog类中的1M大小的字节数组字段打开注释，重新测试，内存分配就没有这么快了。</li>
</ol>
<h3 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h3><ol>
<li>访问一个对象的字段，JVM是如何定位对象字段的内存地址呢？</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://zhuanlan.zhihu.com/p/50984945" target="_blank" rel="noopener">聊聊java对象内存布局</a><br><a href="http://openjdk.java.net/projects/code-tools/jol/" target="_blank" rel="noopener">jol</a><br><a href="https://www.zhihu.com/question/51920553" target="_blank" rel="noopener">https://www.zhihu.com/question/51920553</a><br><a href="https://juejin.im/post/5d0fa403f265da1bb67a2335" target="_blank" rel="noopener">一个Java对象到底占多少内存</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;所有试验代码都是在Mac os JDK8 64位JVM上测试（默认开启了指针压缩）。&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;一道面试题。 问题是：A和B两个类，A类中有一个private的字段age，B类继承自A类。创建一个B类的对象b，对象b的内存中是否包含父类A中的字段age的内存空间。&lt;/p&gt;
&lt;p&gt;类似代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; jiexiu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * created 2019/12/14 - 09:26&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Animal&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getAge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; jiexiu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * created 2019/12/14 - 09:26&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Animal&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://leokongwq.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL中join操作总结</title>
    <link href="https://leokongwq.github.io/2019/12/13/mysql-join-summary.html"/>
    <id>https://leokongwq.github.io/2019/12/13/mysql-join-summary.html</id>
    <published>2019-12-13T15:17:50.000Z</published>
    <updated>2019-12-14T04:06:56.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在数据库中Join操作被称为连接。目的是从多个表中获取数据作为结果集返回给客户端。join 操作分为如下几种：</p>
<p>外连接：<code>left join</code>，<code>right join</code><br>内连接：<code>inner join</code><br>全连接：<code>full join</code><br>笛卡尔积： <code>cross join</code> </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>新建2个表t1, t2，结构相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h3><p><code>left join</code> 只需要记住左表的数据全部保留，右表满足连接条件的记录展示，不满足的条件的记录全是null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT  JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">| id | a    | b    | id   | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |    1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |    2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 | NULL | NULL | NULL |</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h3><p><code>right join</code> 只需要记住右表的数据全部保留，左表满足连接条件的记录展示，不满足的条件的记录全是null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 right JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">| id   | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">|    1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|    2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">| NULL | NULL | NULL |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p><code>inner join</code> 只保留左右两个表中满足连接条件的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="full-join"><a href="#full-join" class="headerlink" title="full join"></a>full join</h3><p>mysql 不支持<code>full join</code>，不过可以通过<code>union</code>来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT  JOIN t2 ON t1.id = t2.id union SELECT * FROM t1 right JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">| id   | a    | b    | id   | a    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">|    1 |    1 |    1 |    1 |    1 |    1 |</span><br><span class="line">|    2 |    2 |    2 |    2 |    2 |    2 |</span><br><span class="line">|    3 |    3 |    3 | NULL | NULL | NULL |</span><br><span class="line">| NULL | NULL | NULL |    4 |    4 |    4 |</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>从结果可以看出来，左右表不满足连接条件的记录也保留了下来。</p>
<h3 id="cross-join"><a href="#cross-join" class="headerlink" title="cross join"></a>cross join</h3><blockquote>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × &gt; Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。</p>
</blockquote>
<p><code>cross join</code> 结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 CROSS JOIN t2;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  1 |    1 |    1 |</span><br><span class="line">|  3 |    3 |    3 |  1 |    1 |    1 |</span><br><span class="line">|  1 |    1 |    1 |  2 |    2 |    2 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 |  2 |    2 |    2 |</span><br><span class="line">|  1 |    1 |    1 |  4 |    4 |    4 |</span><br><span class="line">|  2 |    2 |    2 |  4 |    4 |    4 |</span><br><span class="line">|  3 |    3 |    3 |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>那我们再看一下不加连接条件的<code>inner join</code>的执行结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  1 |    1 |    1 |</span><br><span class="line">|  3 |    3 |    3 |  1 |    1 |    1 |</span><br><span class="line">|  1 |    1 |    1 |  2 |    2 |    2 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 |  2 |    2 |    2 |</span><br><span class="line">|  1 |    1 |    1 |  4 |    4 |    4 |</span><br><span class="line">|  2 |    2 |    2 |  4 |    4 |    4 |</span><br><span class="line">|  3 |    3 |    3 |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看出不加连接条件的<code>inner join</code> 和 <code>cross join</code> 的结果相同。</p>
<p>在MySQL中 <code>join</code>，<code>cross join</code>, <code>inner join</code></p>
<h3 id="Join语句是怎么执行的？"><a href="#Join语句是怎么执行的？" class="headerlink" title="Join语句是怎么执行的？"></a>Join语句是怎么执行的？</h3><p>MySQL中join语句的执行有3中方式，分别如下所示：</p>
<h4 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a = t2.a)</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ol>
<li>从表 t1 中读入一行数据R；</li>
<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>
<li>取出表 t2 中满足条件的行，和 R 组成一行，作为结果集的一部分；</li>
<li>重复执行步骤 1 和 3 ，知道 t1 的末尾循环结束。</li>
</ol>
<p>在形式上，这个过程就跟我们写成程序时的嵌套查询类似，并且<strong>可以用上被驱动表的索引</strong>，所以我们成为<code>Index Nested-Loop Join</code>，简称<code>NLJ</code>。</p>
<p>如果不使用join:</p>
<ol>
<li>执行select * from t1，查出t1的所有数据，100行</li>
<li>循环遍历这100行：<ul>
<li>从每一行R取出字段a的值$R.a;</li>
<li>执行select * from t2 where a=$R.a;</li>
<li>把返回结果和R构成结果集的一行。</li>
</ul>
</li>
</ol>
<p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句。</p>
<p>显然，这么做还不如直接join好。</p>
<p>假设被驱动表的行数是M。每次查找被驱动表中一行数据时，要先搜索索引a，再搜索主键索引树。每次搜索一棵树近似复杂度是以 2 为底的M的对数，记为log2M，所以再被驱动表上查一行的时间复杂度是 2*log2M。</p>
<p>结论：</p>
<ol>
<li>使用join语句，性能比强行拆成多个单表执行sql语句的性能要好。</li>
<li>如果使用join语句的话，需要让小表做驱动表</li>
</ol>
<p>但是，需要注意，这个结论的前提是<strong>可以使用被驱动表的索引</strong></p>
<h4 id="Simple-Nested-loop-join"><a href="#Simple-Nested-loop-join" class="headerlink" title="Simple Nested-loop join"></a>Simple Nested-loop join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a = t2.b)</span><br></pre></td></tr></table></figure>
<p>t1是驱动表，t2是被驱动表。</p>
<p>由于表t2的字段b上没有索引，因此再用上面提到的执行流程时，每次到t2去匹配的时候，就要做一次<strong>全表扫描</strong></p>
<p>这时，每次t2去匹配的时候，就要做一次全表扫描。这个sql请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p>
<p>当然MYSQL没有使用这个方法，而是下面的 <strong>Block Nested-Loop Join</strong></p>
<h4 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h4><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>把表t1的数据读入线程内存<code>join_buffer</code>中，由于我们这个语句中写的是<code>select *</code>，因此是把整个t1放入了内存；</li>
<li>扫描表t2，把表t2的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足join条件的(也就是on指定的条件)，作为结果集的一部分返回。</li>
</ol>
<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100.由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万行。</p>
<p>前面我们说过，如果使用<code>Simple Nested-Loop Join</code>算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好</p>
<p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p>
<p>假设小表的行数据是N，大表的行数是M，那么在这个算法里：</p>
<p>两个表都做一次全表扫描，所以总的扫描行数是M+N；<br>内存中的判断次数是M*N<br>可以看到，调换这两个算式中的M和N没有区别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p>
<p>然后，你可能马上就会问了，这个例子里t1才100行，要是表t1是一个大表，<code>join_buffer</code>放不下怎么办呢？</p>
<p><code>join_buffer</code> 的大小是由<code>join_buffer_size</code>设定的，默认值是256k。如果放不下t1的所有数据的话，策略很简单，就是分段放。把<code>join_buffer_size</code>改成1200，再执行：</p>
<p><strong>过程就变成了：</strong></p>
<ol>
<li>扫描表t1，顺序读取数据行放入<code>join_buffer</code>中，放完第88行join_buffer满了，继续第二步</li>
<li>扫描表t2，把t2中的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足join条件的，作为结果集的一部分返回；<br>清空<code>join_buffer</code><br>继续扫描表t1，顺序读取最后的12行数据放入<code>join_buffer</code>中，继续执行第2步<br>这个流程才体现出了这个算法名字中<code>Block</code>的由来，表示<code>分块去join</code></li>
</ol>
<p>可以看到，这时候由于表t1被分成两次放入join_buffer中，导致表t2会被扫描两次，但是判断等值条件的次数还是不变的，（88+12）*1000=10万次。</p>
<p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol>
<li>扫描行数是 N+λ<em>N</em>M；</li>
<li>内存判断 N*M 次。</li>
</ol>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，N 小一些，整个算式的结果会更小。</p>
<p>当然，你会发现，在 N+λ<em>N</em>M 这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p>
<p>刚刚我们说了 N 越大，分段数 K 越大。那么，N 固定的时候，什么参数会影响 K 的大小呢？（也就是λ的大小）答案是 join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p>
<p>这就是为什么，你可能会看到一些建议告诉你，如果你的 join 语句很慢，就把 join_buffer_size 改大。</p>
<h3 id="on-字句和-where-的顺序问题"><a href="#on-字句和-where-的顺序问题" class="headerlink" title="on 字句和 where 的顺序问题"></a>on 字句和 where 的顺序问题</h3><p>直接说结论：从上面的分析可以知道，on字句的条件用来过滤被驱动表中的数据。where字句指定的条件用来过滤最终join的结果集。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://dev.mysql.com/worklog/task/?id=1604" target="_blank" rel="noopener">https://dev.mysql.com/worklog/task/?id=1604</a></p>
<p><a href="https://time.geekbang.org/column/article/83183" target="_blank" rel="noopener">MySQL45讲 - 我订阅的课程</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/join.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在数据库中Join操作被称为连接。目的是从多个表中获取数据作为结果集返回给客户端。join 操作分为如下几种：&lt;/p&gt;
&lt;p&gt;外连接：&lt;code&gt;left join&lt;/code&gt;，&lt;code&gt;right join&lt;/code&gt;&lt;br&gt;内连接：&lt;code&gt;inner join&lt;/code&gt;&lt;br&gt;全连接：&lt;code&gt;full join&lt;/code&gt;&lt;br&gt;笛卡尔积： &lt;code&gt;cross join&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;新建2个表t1, t2，结构相同。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`t1`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`t2`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; t1 &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; t2 &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://leokongwq.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://leokongwq.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于timeout你必须了解</title>
    <link href="https://leokongwq.github.io/2019/11/30/all-timeout-summary.html"/>
    <id>https://leokongwq.github.io/2019/11/30/all-timeout-summary.html</id>
    <published>2019-11-30T05:14:37.000Z</published>
    <updated>2019-12-14T03:57:41.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有经验的开发同学都知道访问依赖的服务服务时需要设置超时时间。这些外部服务可能是一个http接口，RPC接口，获取分布式锁等等。没有合理的超时时间设置，你的系统可能出现雪崩。但是在工作中发现大部分同学，包括我自己在内对如何合理的设置timeout没有形成一个完整的知识链条，这就会导致你可能设置了timeout，但系统并不会像你想象中的正常工作。</p>
<p>下面以一个简单的访问数据库的HTTP请求来串起整个理论。可能理解或实践有误，还请发现的同学留言斧正。</p>
<blockquote>
<p>注意：所有代码例子都是在Linux 3.10.0 测试上通过，使用Java语言编写的。</p>
</blockquote>
<a id="more"></a>
<h3 id="connect-timeout"><a href="#connect-timeout" class="headerlink" title="connect timeout"></a>connect timeout</h3><p>我们使用最为广泛的数据库驱动底层是通过TCP来完成Client和Server通信的，在通信前必须建立网络连接。</p>
<img src="/2019/11/30/all-timeout-summary/tcp-connect.jpg">
<p>如图所示，Client 发送的syn包如果在一定的时间内没有收到Server的响应，那么Client就会报<code>ConnectException</code></p>
<h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><p>为了模拟syn丢包，我们通过在Server上添加如下的防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.110.82.169 -j DROP</span><br></pre></td></tr></table></figure>
<p>客户端IP : 10.110.82.169 进来的包都会被DROP</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/11/30 - 13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket socketServer = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"10.13.40.95"</span>, <span class="number">3333</span>);</span><br><span class="line">        socketServer.bind(socketAddress, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Server started."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/11/30 - 13:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket();</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"10.13.40.95"</span>, <span class="number">3333</span>);</span><br><span class="line">        client.connect(socketAddress);</span><br><span class="line">        System.out.println(<span class="string">"Client connect Server success."</span>);</span><br><span class="line">        client.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">        OutputStream outputStream = client.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sat Nov <span class="number">30</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.net.ConnectException: <span class="function">Connection timed <span class="title">out</span> <span class="params">(Connection timed out)</span></span></span><br><span class="line"><span class="function">        at java.net.PlainSocketImpl.<span class="title">socketConnect</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">doConnect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connectToAddress</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.SocksSocketImpl.<span class="title">connect</span><span class="params">(SocksSocketImpl.java:<span class="number">392</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">589</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">538</span>)</span></span></span><br><span class="line"><span class="function">        at Client.<span class="title">main</span><span class="params">(Client.java:<span class="number">15</span>)</span></span></span><br><span class="line"><span class="function">Sat Nov 30 15:39:52 CST 2019</span></span><br></pre></td></tr></table></figure>
<p>可以看到超时时间大概是：<code>3s</code></p>
<p>那为什么是3s呢？这是因为Linux内核关于TCP协议栈的配置。</p>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep retries</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.dccp.default.request_retries = 6</span><br><span class="line">net.dccp.default.retries1 = 3</span><br><span class="line">net.dccp.default.retries2 = 15</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_retries1 = 3</span><br><span class="line">net.ipv4.tcp_retries2 = 15</span><br><span class="line"># 下面2个配置很重要</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br></pre></td></tr></table></figure>
<p>可以看到机器配置的<code>net.ipv4.tcp_syn_retries</code>和<code>net.ipv4.tcp_synack_retries</code>都是1。</p>
<p>注意: 1表示的是重试的次数，每次重试的间隔都是2的N次幂。例如：1, 2, 4, 8, 16, 32, 64。</p>
<p>将重试次数设置为7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure>
<p>重新测试，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date</span><br><span class="line">Sat Nov <span class="number">30</span> <span class="number">16</span>:<span class="number">16</span>:<span class="number">27</span> CST <span class="number">2019</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.net.ConnectException: <span class="function">Connection timed <span class="title">out</span> <span class="params">(Connection timed out)</span></span></span><br><span class="line"><span class="function">        at java.net.PlainSocketImpl.<span class="title">socketConnect</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">doConnect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connectToAddress</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.SocksSocketImpl.<span class="title">connect</span><span class="params">(SocksSocketImpl.java:<span class="number">392</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">589</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">538</span>)</span></span></span><br><span class="line"><span class="function">        at Client.<span class="title">main</span><span class="params">(Client.java:<span class="number">15</span>)</span></span></span><br><span class="line"><span class="function">Sat Nov 30 16:20:34 CST 2019</span></span><br></pre></td></tr></table></figure>
<p>耗时大概是：4分7秒 = 247 &lt; 1+2+4+8+16+32+64+128 = 255 (结果表明这个时间有误差) </p>
<p>将重试次数设置为8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 8 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure>
<p>重新测试，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date                    </span><br><span class="line">Sat Nov 30 16:26:14 CST 2019</span><br><span class="line">Exception in thread &quot;main&quot; java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">        at Client.main(Client.java:15)</span><br><span class="line">Sat Nov 30 16:32:22 CST 2019</span><br></pre></td></tr></table></figure>
<p>耗时是 6分8秒 = 368 约等于 1+2+4+8+16+32+64+128 + 128 = 383</p>
<p>man page 解释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcp_syn_retries (integer; default: 5; since Linux 2.2)</span><br><span class="line">      The maximum number of times initial SYNs for an active TCP</span><br><span class="line">      connection attempt will be retransmitted.  This value should</span><br><span class="line">      not be higher than 255.  The default value is 5, which</span><br><span class="line">      corresponds to approximately 180 seconds.</span><br></pre></td></tr></table></figure>
<p>默认重试5次，最大值不应该大于255。 在默认情况下大概是180秒左右超时。</p>
<p>再次设置为5，测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> java Client; date                    </span><br><span class="line">Sat Nov 30 16:47:14 CST 2019</span><br><span class="line">Exception in thread &quot;main&quot; java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">        at Client.main(Client.java:15)</span><br><span class="line">Sat Nov 30 16:48:18 CST 2019</span><br></pre></td></tr></table></figure>
<p>超时时间是：63秒。 这个值和文档的值有出入，可能是原因是新的内核版本对这部分逻辑进行了修改。</p>
<blockquote>
<p>注意：不同的OS内核实现机制是不同的，例如基于BSD包括Mac OS X 在内，最大的等待时间是75秒。</p>
</blockquote>
<h3 id="read-timeout"><a href="#read-timeout" class="headerlink" title="read timeout"></a>read timeout</h3><p>连接建立了，那么就要相互交换数据了。举个例子：你发出了一个请求，通过读取对端的响应数据来判断对端是否正确处理了请求，如果不设置读取超时时间，那么就只能死等，非阻塞读还好，如果是阻塞模式，那么就导致线程占用，整个机器的线程资源会很快耗尽，不能服务。</p>
<p>这里需要注意的是：写操作是写入socket写缓冲区就返回了(TCP会进行重试)，作为客户端你是不知道你的请求对端究竟有没有收到。只能通过对端对请求的响应来判断。</p>
<h3 id="数据库应该开发中超时设置"><a href="#数据库应该开发中超时设置" class="headerlink" title="数据库应该开发中超时设置"></a>数据库应该开发中超时设置</h3><p>目前开发的大多数应用都是基于数据库，数据库作为稀缺资源一定要谨慎使用。</p>
<p>举个例子：如果没有设置java.sql.Statement执行sql的超时时间，哪个不小心上线了一个慢查询SQL，很容导致数据库连接池打满，整个服务不可用。</p>
<h4 id="MySQL-连接超时和读取超时"><a href="#MySQL-连接超时和读取超时" class="headerlink" title="MySQL 连接超时和读取超时"></a>MySQL 连接超时和读取超时</h4><p>MySQL的超时时间可以通过连接MySQL的url参数来指定，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?connectTimeout=10000&amp;socketTimeout=3000</span></span><br></pre></td></tr></table></figure>
<p>connectTimeout 连接超时时间，单位为毫秒，默认值为0，依赖OS设置。</p>
<p>socketTimeout 读写超时时间，单位为毫秒，默认值为0。</p>
<h4 id="java-jdbc-Statement-超时时间"><a href="#java-jdbc-Statement-超时时间" class="headerlink" title="java.jdbc.Statement 超时时间"></a>java.jdbc.Statement 超时时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setQueryTimeout</span><span class="params">(<span class="keyword">int</span> seconds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>设置数据库驱动等待Statement执行的超时时间，默认是0，表示永不超时。如果超时会抛出<code>SQLTimeoutException</code>异常。</p>
<p>在MySQL的驱动实现中，通过一个定时器来检查SQL执行超时，如果超时则通过一个新的连接给MySQL发送<code>kill query</code>命令，并抛出一个异常告诉客户端SQL执行超时。</p>
<h4 id="事务超时时间"><a href="#事务超时时间" class="headerlink" title="事务超时时间"></a>事务超时时间</h4><p>事务超时通常是基于我们使用的事物框架来设置的。我们通常使用的是Spring提供的事物管理器。</p>
<p>AbstractPlatformTransactionManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Specify the default timeout that this transaction manager should apply</span></span><br><span class="line"><span class="comment">	 * if there is no timeout specified at the transaction level, in seconds.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is the underlying transaction infrastructure's default timeout,</span></span><br><span class="line"><span class="comment">	 * e.g. typically 30 seconds in case of a JTA provider, indicated by the</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;TransactionDefinition.TIMEOUT_DEFAULT&lt;/code&gt; value.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDefaultTimeout</span><span class="params">(<span class="keyword">int</span> defaultTimeout)</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (defaultTimeout &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">truetruetrue<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid default timeout"</span>, defaultTimeout);</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">this</span>.defaultTimeout = defaultTimeout;</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，没有设置事务超时时间。 </p>
<h5 id="spring实现超时"><a href="#spring实现超时" class="headerlink" title="spring实现超时"></a>spring实现超时</h5><ol>
<li>根据timeout+当前时间点 赋值给一个deadLine。</li>
<li>每一次执行sql，就会获取到一个statement时，计算liveTime =（deadline- 当前时间），分如下两种情况处理：<ol>
<li>如果liveTime&gt;0，此时就执行stam</li>
<li>如果liveTime &lt; 0,此时就抛出异常</li>
</ol>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/eefe3877650f" target="_blank" rel="noopener">mac下的iptables—pfctl</a><br><a href="https://blog.scottlowe.org/2013/05/15/using-pf-on-os-x-mountain-lion/" target="_blank" rel="noopener">Using pf on OS X Mountain Lion</a><br><a href="https://krypted.com/mac-security/a-cheat-sheet-for-using-pf-in-os-x-lion-and-up/" target="_blank" rel="noopener">A Cheat Sheet For Using pf in OS X Lion and Up</a><br><a href="http://willbryant.net/overriding_the_default_linux_kernel_20_second_tcp_socket_connect_timeout" target="_blank" rel="noopener">Overriding the default Linux kernel 20-second TCP socket connect timeout</a><br><a href="http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/" target="_blank" rel="noopener">聊一聊重传次数</a><br><a href="https://www.cnblogs.com/lshs/p/6038527.html" target="_blank" rel="noopener">TCP系列12—重传—2、Linux超时重传引入示例</a><br><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">Configuration Properties for Connector/J</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有经验的开发同学都知道访问依赖的服务服务时需要设置超时时间。这些外部服务可能是一个http接口，RPC接口，获取分布式锁等等。没有合理的超时时间设置，你的系统可能出现雪崩。但是在工作中发现大部分同学，包括我自己在内对如何合理的设置timeout没有形成一个完整的知识链条，这就会导致你可能设置了timeout，但系统并不会像你想象中的正常工作。&lt;/p&gt;
&lt;p&gt;下面以一个简单的访问数据库的HTTP请求来串起整个理论。可能理解或实践有误，还请发现的同学留言斧正。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：所有代码例子都是在Linux 3.10.0 测试上通过，使用Java语言编写的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="网络" scheme="https://leokongwq.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ学习总结</title>
    <link href="https://leokongwq.github.io/2019/11/28/RockeqMQ-summary.html"/>
    <id>https://leokongwq.github.io/2019/11/28/RockeqMQ-summary.html</id>
    <published>2019-11-28T15:21:09.000Z</published>
    <updated>2019-12-14T04:04:43.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RocketMQ算是当前国内MQ领域内的明星产品。网上关于它文章非常的多。但是总觉得任何一项你想要在生产环境使用的技术，你必须亲自深入学习一遍才能更好的使用它，出了问题也好定位。在学习源码的过程中可能有许多意想不到的收获，也是提示技术能力的一种方式。</p>
<h3 id="RocketMQ-文件目录"><a href="#RocketMQ-文件目录" class="headerlink" title="RocketMQ 文件目录"></a>RocketMQ 文件目录</h3><p>RocketMQ 作为一个具有持久化功能的消息中间件，必然需要强大的存储功能。那么首先需要了解的就是它的存储架构。</p>
<p>RocketMQ 存储目录结构</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── abort</span><br><span class="line">├── checkpoint</span><br><span class="line">├── commitlog</span><br><span class="line">│   ├── <span class="number">00000000000000000000</span></span><br><span class="line">│   └── <span class="number">00000000001073741824</span></span><br><span class="line">├── config</span><br><span class="line">│   ├── consumerFilter.json</span><br><span class="line">│   ├── consumerFilter.json.bak</span><br><span class="line">│   ├── consumerOffset.json</span><br><span class="line">│   ├── consumerOffset.json.bak</span><br><span class="line">│   ├── delayOffset.json</span><br><span class="line">│   ├── delayOffset.json.bak</span><br><span class="line">│   ├── subscriptionGroup.json</span><br><span class="line">│   ├── topics.json</span><br><span class="line">│   └── topics.json.bak</span><br><span class="line">├── consumequeue</span><br><span class="line">│   ├── rmq-test-topic</span><br><span class="line">│   │   ├── <span class="number">0</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">1</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">2</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">3</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">4</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">5</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">6</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   └── <span class="number">7</span></span><br><span class="line">│   │       └── <span class="number">00000000000000000000</span></span><br><span class="line">│   └── SCHEDULE_TOPIC_XXXX</span><br><span class="line">│       └── <span class="number">2</span></span><br><span class="line">│           └── <span class="number">00000000000000000000</span></span><br><span class="line">├── index</span><br><span class="line">│   └── <span class="number">20191014212222129</span></span><br><span class="line">└── lock</span><br></pre></td></tr></table></figure>
<p> RocketMQ 整体存储结构<img src="https://upload-images.jianshu.io/upload_images/4325076-6021ce04990eef9e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1146/format/webp" alt="img"> </p>
<p>上图是测试环境搭建的一个单机集群（只有一个NameServer和Broker）的目录结构。</p>
<h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>commitlog 文件夹下面的每个文件大小默认 1G，内容是每条消息的完整内容。</p>
<blockquote>
<p> 需要注意的是：不可能所有的消息加起来恰好等于1G, 所以文件的尾部可能会有填充。</p>
</blockquote>
<h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>consumequeue 文件夹下面是每个Topic的消费队列数据。</p>
<p>每个消费队列文件中保存的待消费的消息：结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset:length:taghash</span><br></pre></td></tr></table></figure>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 目录保存的是一些配置信息</p>
<h4 id="consumerFilter-json"><a href="#consumerFilter-json" class="headerlink" title="consumerFilter.json"></a>consumerFilter.json</h4><p>该文件保存的是每个Topic中消息的过滤逻辑。</p>
<h4 id="consumerOffset-json"><a href="#consumerOffset-json" class="headerlink" title="consumerOffset.json"></a>consumerOffset.json</h4><p>该文件保存每个consumer group 的消费进度</p>
<h4 id="delayOffset-json"><a href="#delayOffset-json" class="headerlink" title="delayOffset.json"></a>delayOffset.json</h4><p>该文件保存构建延迟消息的进度</p>
<h4 id="subscriptionGroup-json"><a href="#subscriptionGroup-json" class="headerlink" title="subscriptionGroup.json"></a>subscriptionGroup.json</h4><p>该文件保存consumerGroup和Topic的订阅关系</p>
<h4 id="topics-json"><a href="#topics-json" class="headerlink" title="topics.json"></a>topics.json</h4><p>该文件保存Topic信息</p>
<h4 id="abort文件"><a href="#abort文件" class="headerlink" title="abort文件"></a>abort文件</h4><p>abort 文件是在<code>DefaultMessageStore</code>启动时创建在，在正常关机的情况下会删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTempFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String fileName = StorePathConfigHelper.getAbortFile(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir());</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    MappedFile.ensureDirOK(file.getParent());</span><br><span class="line">    <span class="keyword">boolean</span> result = file.createNewFile();</span><br><span class="line">    log.info(fileName + (result ? <span class="string">" create OK"</span> : <span class="string">" already exists"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="checkpoint-文件"><a href="#checkpoint-文件" class="headerlink" title="checkpoint 文件"></a>checkpoint 文件</h4><p>文件内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StoreCheckpoint</span><span class="params">(<span class="keyword">final</span> String scpPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(scpPath);</span><br><span class="line">    MappedFile.ensureDirOK(file.getParent());</span><br><span class="line">    <span class="keyword">boolean</span> fileExists = file.exists();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.randomAccessFile = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="keyword">this</span>.fileChannel = <span class="keyword">this</span>.randomAccessFile.getChannel();</span><br><span class="line">    <span class="keyword">this</span>.mappedByteBuffer = fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, MappedFile.OS_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line">        log.info(<span class="string">"store checkpoint file exists, "</span> + scpPath);</span><br><span class="line">        <span class="keyword">this</span>.physicMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.logicsMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.indexMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">16</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"store checkpoint file not exists, "</span> + scpPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MappedFile-amp-MappedFileQueue-amp-AllocateMappedFileService"><a href="#MappedFile-amp-MappedFileQueue-amp-AllocateMappedFileService" class="headerlink" title="MappedFile &amp; MappedFileQueue &amp; AllocateMappedFileService"></a>MappedFile &amp; MappedFileQueue &amp; AllocateMappedFileService</h3><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><p>MappedFile ：顾名思义就是一个内存映射文件。内存映射文件写入时，首先写入<code>OS Page Cache</code>中，OS会定期刷新文件内容到磁盘上。也可以通过如下的方法强制写入磁盘：</p>
<ol>
<li>FileChannel.force</li>
<li>MappedByteBuffer.force</li>
</ol>
<p>MappedFile 是最底层，真正用来保存消息的，主要的保存消息方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(msg, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessages</span><span class="params">(<span class="keyword">final</span> MessageExtBatch messageExtBatch, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(messageExtBatch, cb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Broker 写入消息时调用的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line">true<span class="comment">// 当前写入MappedFile文件的位置</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">// writeBuffer 本身也是一个DirectBuffer, 默认大小1G 和 MappedFile大小相同</span></span><br><span class="line">        <span class="comment">// 每次slice 都会得到position == 0, limit 和 capacity 等于1G 的影子ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        <span class="comment">// 通过设置position， 使得上面获取的影子ByteBuffer写入时不会覆盖原有数据</span></span><br><span class="line">        <span class="comment">// 只能从底层真实的ByteBuffer的position处开始写数据</span></span><br><span class="line">        <span class="comment">// 因为 writeBuffer 和 mappedByteBuffer 的position一直保持不变</span></span><br><span class="line">        <span class="comment">// 所以设置position的方法不会抛出异常</span></span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">"MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;"</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((currentPos + data.length) &lt;= <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.position(currentPos);</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when append message to mappedFile."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(data.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAbleToFlush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上次刷盘的位置</span></span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.flushedPosition.get();</span><br><span class="line">    <span class="comment">// 当前的写入位置</span></span><br><span class="line">    <span class="keyword">int</span> write = getReadPosition();</span><br><span class="line">true<span class="comment">//如果文件写满了，那么需要刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">//计算是否满足最少刷盘页数的的要求</span></span><br><span class="line">    <span class="keyword">if</span> (flushLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不可以用(write - flush) / OS_PAGE_SIZE 吗？</span></span><br><span class="line">        <span class="comment">// OS_PAGE_SIZE 写死为 4k, 如果启用大页， 吞吐量不是更高吗？</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 只要上次刷盘后有新的数据写入，就可以刷盘</span></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The current flushed position</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = getReadPosition();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//We only append data to fileChannel or mappedByteBuffer, never both.</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="comment">// 如果 使用了writeBuffer, getReadPosition返回的是当前写入的position</span></span><br><span class="line">            <span class="comment">// 写入的position 是大于等于 刷盘的位置的，没有刷盘就更新flushedPosition合适吗？</span></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// writeBuffer 为 NULL 表示消息是直接写入MappedByteBuffer的</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All dirty data has been committed to FileChannel.</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MappedFileQueue"><a href="#MappedFileQueue" class="headerlink" title="MappedFileQueue"></a>MappedFileQueue</h4><p>MappedFileQueue  就是由多个<code>MappedFile</code>组成的一个队列。由它来管理多个分配的内存映射文件。多个文件组成一个逻辑上的单一文件，供上层的业务使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有分配的MappedFile</span></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MappedFile&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存刷盘位置, 该字段的值是在Broker启动时，恢复状态时计算出来的。</span></span><br><span class="line">    <span class="comment">// 正常情况下，是CommmitLog在磁盘上最后一个MappedFile中最后一个正常消息的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flushedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 写入到PageCache的位置， 在Broker启动时，值和flushedWhere计算逻辑一致。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> committedWhere = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行刷盘操作，由刷盘后台线程调用</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">            <span class="comment">// 最底层的刷盘操作，返回MappedFile中已经落盘的数据量</span></span><br><span class="line">            <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class="line">            <span class="comment">// 计算并更新下次刷盘的位置</span></span><br><span class="line">            <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">            result = where == <span class="keyword">this</span>.flushedWhere;</span><br><span class="line">            <span class="keyword">this</span>.flushedWhere = where;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == flushLeastPages) &#123;</span><br><span class="line">                <span class="keyword">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AllocateMappedFileService"><a href="#AllocateMappedFileService" class="headerlink" title="AllocateMappedFileService"></a>AllocateMappedFileService</h4><p>MappedFile 的创建有2种方式：</p>
<ol>
<li>通过MappedFile的构造方法进行创建。</li>
<li>通过AllocateMappedFileService进行异步创建。(内部有一个创建的<code>MappedFile</code>的请求队列，由独立的线程进行<code>MappedFile</code>创建)</li>
</ol>
<p><code>MappedFileQueue</code> 在进行消息保存，需要创建新的<code>MappedFile</code>时，内部是通过 <code>DefaultMessageStore</code>创建时创建的<code>AllocateMappedFileService</code>进行<code>MappedFile</code>创建的。</p>
<p>AllocateMappedFileService 会使用<code>MappedFile</code>如下的构造方法进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MappedFile</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize, transientStorePool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="comment">// 消息会先写入ByteBuffer中，然后再写入FileChannel</span></span><br><span class="line">    <span class="comment">// writeBuffer 大小默认是1G, 和 MappedFile的文件大小相同</span></span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();</span><br><span class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultMessageStore-启动流程"><a href="#DefaultMessageStore-启动流程" class="headerlink" title="DefaultMessageStore 启动流程"></a>DefaultMessageStore 启动流程</h3><h4 id="DefaultMessageStore-初始化"><a href="#DefaultMessageStore-初始化" class="headerlink" title="DefaultMessageStore 初始化"></a>DefaultMessageStore 初始化</h4><p>初始化过程最重要的是加载消息文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否上次是否是正常退出。 正常退出是没有abort文件的</span></span><br><span class="line">        <span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</span><br><span class="line">        log.info(<span class="string">"last shutdown &#123;&#125;"</span>, lastExitOK ? <span class="string">"normally"</span> : <span class="string">"abnormally"</span>);</span><br><span class="line">true    <span class="comment">// 先加载延迟消息		</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">            result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load Commit Log</span></span><br><span class="line">        <span class="comment">// 加载 Commit Log 文件，其实是通过 MappedFileQueue加载每一个MappedFile</span></span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load Consume Queue</span></span><br><span class="line">        <span class="comment">// 实现机制和 Commit Log 一样</span></span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 初始化checkpoint</span></span><br><span class="line">            <span class="keyword">this</span>.storeCheckpoint =</span><br><span class="line">                <span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">truetruetrue<span class="comment">// 加载索引文件</span></span><br><span class="line">            <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">truetruetrue<span class="comment">// 进行状态恢复， 底层还是通过</span></span><br><span class="line">            <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"load over, and the max phy offset = &#123;&#125;"</span>, <span class="keyword">this</span>.getMaxPhyOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"load exception"</span>, e);</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.allocateMappedFileService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 恢复消费队列状态</span></span><br><span class="line">    <span class="keyword">this</span>.recoverConsumeQueue();</span><br><span class="line">true<span class="comment">// 恢复Commit Log 状态</span></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverNormally();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DefaultMessageStore-启动"><a href="#DefaultMessageStore-启动" class="headerlink" title="DefaultMessageStore 启动"></a>DefaultMessageStore 启动</h4><h3 id="CommitLog-启动流程"><a href="#CommitLog-启动流程" class="headerlink" title="CommitLog 启动流程"></a>CommitLog 启动流程</h3><h4 id="CommitLog-加载"><a href="#CommitLog-加载" class="headerlink" title="CommitLog 加载"></a>CommitLog 加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.mappedFileQueue.load();</span><br><span class="line">    log.info(<span class="string">"load commit log "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Failed"</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载的过程就是对构成的Commit Log的所有磁盘文件，创建对应的MappedFile，并通过MappedFileQueue进行组织的过程。再次过程，申请了虚拟内存空间，但是并没有读取磁盘文件。</p>
<h4 id="CommitLog-启动"><a href="#CommitLog-启动" class="headerlink" title="CommitLog 启动"></a>CommitLog 启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动消息 刷盘后台服务线程</span></span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService.start();</span><br><span class="line">true<span class="comment">// 如果启用了异步刷盘，则启动 消息commit后台服务线程</span></span><br><span class="line">    <span class="keyword">if</span> (defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLogService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CommitLog-恢复"><a href="#CommitLog-恢复" class="headerlink" title="CommitLog  恢复"></a>CommitLog  恢复</h4><p>恢复分为正常恢复和异常恢复</p>
<h5 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否校验数据完成性，这个会导致启动变慢</span></span><br><span class="line">    <span class="keyword">boolean</span> checkCRCOnRecover = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isCheckCRCOnRecover();</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从最后三个文件进行恢复</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">truetrue</span><br><span class="line">        MappedFile mappedFile = mappedFiles.get(index);</span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="comment">//本文件的起始偏移量，也就是文件名称</span></span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">// 从0开始校验消息文件</span></span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">            <span class="comment">// Normal data</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Come the end of the file, switch to the next file Since the</span></span><br><span class="line">            <span class="comment">// return 0 representatives met last hole,</span></span><br><span class="line">            <span class="comment">// this can not be included in truncate offset</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 所有文件都验证完成</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                    <span class="comment">// Current branch can not happen</span></span><br><span class="line">                    log.info(<span class="string">"recover last 3 physics file over, last mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 切换下一个文件进行校验</span></span><br><span class="line">                    mappedFile = mappedFiles.get(index);</span><br><span class="line">                    byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                    processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                    mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                    log.info(<span class="string">"recover next physics file, "</span> + mappedFile.getFileName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intermediate file read error</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// processOffset 就是有效消息的位置</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">// 丢弃broken的消息</span></span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverAbnormally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recover by the minimum time stamp</span></span><br><span class="line">    <span class="keyword">boolean</span> checkCRCOnRecover = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isCheckCRCOnRecover();</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第一个开始恢复， 在load的时候，按文件名称排序的</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            mappedFile = mappedFiles.get(index);</span><br><span class="line">            <span class="comment">//查找第一个需要需要恢复的文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">                log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 没有满足恢复查找条件的问题件，那么从第一个文件开始恢复</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            mappedFile = mappedFiles.get(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Normal data</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">truetruetruetrue<span class="comment">// 是否允许重复消息</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">                    <span class="comment">// getCommitLogOffset 返回的是 消息在Commit Log中的偏移量</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.getCommitLogOffset() &lt; <span class="keyword">this</span>.defaultMessageStore.getConfirmOffset()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.defaultMessageStore.doDispatch(dispatchRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 构建索引 和 消费队列</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMessageStore.doDispatch(dispatchRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intermediate file read error</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Come the end of the file, switch to the next file</span></span><br><span class="line">            <span class="comment">// Since the return 0 representatives met last hole, this can</span></span><br><span class="line">            <span class="comment">// not be included in truncate offset</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  <span class="comment">// 文件末尾</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123; <span class="comment">// 最后一个文件</span></span><br><span class="line">                    <span class="comment">// The current branch under normal circumstances should</span></span><br><span class="line">                    <span class="comment">// not happen</span></span><br><span class="line">                    log.info(<span class="string">"recover physics file over, last mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 切换下一个文件进行恢复</span></span><br><span class="line">                    mappedFile = mappedFiles.get(index);</span><br><span class="line">                    byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                    processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                    mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                    log.info(<span class="string">"recover next physics file, "</span> + mappedFile.getFileName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 设置初始状态</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear ConsumeQueue redundant data</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commitlog case files are deleted</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Broker消息保存流程"><a href="#Broker消息保存流程" class="headerlink" title="Broker消息保存流程"></a>Broker消息保存流程</h3><h4 id="1-Rpc请求处理"><a href="#1-Rpc请求处理" class="headerlink" title="1. Rpc请求处理"></a>1. Rpc请求处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RemotingCommand</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            processMessageReceived(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand cmd = msg;</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">                processRequestCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">                processResponseCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process incoming request command issued by remote peer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx channel handler context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd request command.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequestCommand</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同任务的请求是由不同的线程池和Processor进行处理的</span></span><br><span class="line">    <span class="comment">// 这样可以实现请求隔离，防止意外请求导致整个服务不可用</span></span><br><span class="line">    <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched = <span class="keyword">this</span>.processorTable.get(cmd.getCode());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">null</span> == matched ? <span class="keyword">this</span>.defaultRequestProcessor : matched;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">true</span><br><span class="line">    <span class="keyword">if</span> (pair != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 构造异步请求任务，准备投递到对于的线程池中    </span></span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行钩子程序</span></span><br><span class="line">                    RPCHook rpcHook = NettyRemotingAbstract.<span class="keyword">this</span>.getRPCHook();</span><br><span class="line">                    <span class="keyword">if</span> (rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line"> rpcHook.doBeforeRequest(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd);</span><br><span class="line">                    &#125;</span><br><span class="line">truetruetruetruetrue<span class="comment">// 真正进行请求的处理， SendMessageProcessor</span></span><br><span class="line">                    <span class="keyword">final</span> RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line">                    <span class="keyword">if</span> (rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 执行钩子程序    rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd, response);</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            response.setOpaque(opaque);</span><br><span class="line">                            response.markResponseType();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ctx.writeAndFlush(response);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                log.error(<span class="string">"process request over, but response failed"</span>, e);</span><br><span class="line">                                log.error(cmd.toString());</span><br><span class="line">                                log.error(response.toString());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"process request exception"</span>, e);</span><br><span class="line">                    log.error(cmd.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_ERROR,</span><br><span class="line">                                                                                               RemotingHelper.exceptionSimpleDesc(e));</span><br><span class="line">                        response.setOpaque(opaque);</span><br><span class="line">                        ctx.writeAndFlush(response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 请求处理线程池拒绝服务，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pair.getObject1().rejectRequest()) &#123;</span><br><span class="line">            <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,</span><br><span class="line">                                                                                   <span class="string">"[REJECTREQUEST]system busy, start flow control for a while"</span>);</span><br><span class="line">            response.setOpaque(opaque);</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//投递到线程池进行处理</span></span><br><span class="line">            <span class="keyword">final</span> RequestTask requestTask = <span class="keyword">new</span> RequestTask(run, ctx.channel(), cmd);</span><br><span class="line">            pair.getObject2().submit(requestTask);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.currentTimeMillis() % <span class="number">10000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                log.warn(RemotingHelper.parseChannelRemoteAddr(ctx.channel())</span><br><span class="line">                         + <span class="string">", too many requests and system thread pool busy, RejectedExecutionException "</span></span><br><span class="line">                         + pair.getObject2().toString()</span><br><span class="line">                         + <span class="string">" request code: "</span> + cmd.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 返回系统繁忙，客户端可以重试</span></span><br><span class="line">            <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,</span><br><span class="line">                                                                                       <span class="string">"[OVERLOAD]system busy, start flow control for a while"</span>);</span><br><span class="line">                response.setOpaque(opaque);</span><br><span class="line">                ctx.writeAndFlush(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持的请求CODE</span></span><br><span class="line">        String error = <span class="string">" request type "</span> + cmd.getCode() + <span class="string">" not supported"</span>;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response =</span><br><span class="line">            RemotingCommand.createResponseCommand(RemotingSysResponseCode.REQUEST_CODE_NOT_SUPPORTED, error);</span><br><span class="line">        response.setOpaque(opaque);</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">        log.error(RemotingHelper.parseChannelRemoteAddr(ctx.channel()) + error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-消息处理器SendMessageProcessor"><a href="#2-消息处理器SendMessageProcessor" class="headerlink" title="2. 消息处理器SendMessageProcessor"></a>2. 消息处理器SendMessageProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="comment">// 处理消费者ack</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="comment">// 执行钩子程序</span></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            String topic = requestHeader.getTopic();</span><br><span class="line">            <span class="keyword">this</span>.checkTopicAuthority(ctx, topic);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 执行钩子程序</span></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"receive SendMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Broker还没有开始服务</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimestamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimestamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">"broker unable to service, until %s"</span>, UtilAll.timeMillisToHumanString2(startTimestamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line">true<span class="comment">// 获取 队列id，判断是否是发送到指定的队列</span></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 随机选择一个队列进行写入</span></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    <span class="comment">// 处理重试消息</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="comment">// 事务消息处理</span></span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">        transHalfMsg = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// schedule message don't support transaction message now</span></span><br><span class="line">        <span class="keyword">int</span> delayInSeconds = msgInner.getDelayTimeInSeconds();</span><br><span class="line">        <span class="keyword">int</span> delayLevel = msgInner.getDelayTimeLevel();</span><br><span class="line">        <span class="keyword">if</span> (delayInSeconds != <span class="number">0</span> &amp;&amp; delayLevel != <span class="number">0</span>) &#123;</span><br><span class="line">            response.setCode(ResponseCode.MESSAGE_ILLEGAL);</span><br><span class="line">            response.setRemark(<span class="string">"delayInSeconds and delayTimeLevel should not be specified at the same time."</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延迟消息处理</span></span><br><span class="line">        <span class="keyword">if</span> (delayInSeconds != <span class="number">0</span>) &#123;</span><br><span class="line">            putMessageResult = <span class="keyword">this</span>.brokerController.getScheduledMessageStore().putMessage(msgInner);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 普通消息处理</span></span><br><span class="line">            putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sendMessageContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendMessageContext.buildTrackMsgType(transHalfMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通消息保存"><a href="#普通消息保存" class="headerlink" title="普通消息保存"></a>普通消息保存</h4><p>普通消息保存是由 <code>DefaultMessageStore.putMessage</code>来实现消息具体的保存逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store has shutdown, so putMessage is forbidden"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，获取锁后，消息写入MappedFile的时间超过1s，表示OS Page Cache 忙</span></span><br><span class="line">    <span class="comment">// 此处应该是异步刷盘，同步刷盘超时概率变大</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    <span class="comment">// CommitLog 真正写入消息</span></span><br><span class="line">    PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">if</span> (eclipseTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;"</span>, eclipseTime, msg.getBody().length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控消息写入性能 和 失败率</span></span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CommitLog写入消息"><a href="#CommitLog写入消息" class="headerlink" title="CommitLog写入消息"></a>CommitLog写入消息</h4><p><code>CommitLog</code>表示RocketMQ Broker上保存的所有消息。 消息分布在多个<code>MappedFile</code>文件中，所有的<code>MappedFile</code>组成一个<code>MappedFileQueue</code>。</p>
<h5 id="MappedFile-1"><a href="#MappedFile-1" class="headerlink" title="MappedFile"></a>MappedFile</h5><p>顾名思义<code>MappedFile</code>表示一个内存映射文件，通过下面的代码创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br></pre></td></tr></table></figure>
<p>为什么用内存映射文件呢？</p>
<p>答案是：效率。消息写入直接写入内存页，由OS负责刷新内存中的内容到磁盘 或 通过API <code>MappedByteBuffer.force</code> 和 <code>FileChannel.force</code>方法来手动刷盘。</p>
<h5 id="putMessage"><a href="#putMessage" class="headerlink" title="putMessage"></a>putMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    String topic = msg.getTopic();</span><br><span class="line">    <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="comment">// commit 消息 或 非事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入到固定的Topic SCHEDULE_TOPIC_XXXX</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            <span class="comment">// 根据延迟时间登记，选择一个队列</span></span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取最后一个使用的MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">        <span class="comment">// 创建第一个文件 或 创建下一个使用的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 写入共享内存</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                <span class="comment">// 文件满了，创建新文件来保存消息</span></span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statistics</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line">true<span class="comment">// 通知刷盘线程进行刷盘操作</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    <span class="comment">// 主从复制处理</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MappedFileQueue-getLastMappedFile"><a href="#MappedFileQueue-getLastMappedFile" class="headerlink" title="MappedFileQueue.getLastMappedFile()"></a>MappedFileQueue.getLastMappedFile()</h5><p><code>MappedFileQueue</code>是由多个<code>MappedFile</code>组成。 获取最近一次使用的<code>MappedFile</code>时，存在2种情况。</p>
<ol>
<li>队列为空，创建第一个MappedFile</li>
<li>不为空，返回最近一次使用的MappedFile</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFileLast = <span class="keyword">null</span>;</span><br><span class="line">true</span><br><span class="line">    <span class="comment">//有并发问题，此处简化处理了</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mappedFileLast = <span class="keyword">this</span>.mappedFiles.get(<span class="keyword">this</span>.mappedFiles.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"getLastMappedFile has exception."</span>, e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列为空，直接返回null, 下面的方法会创建一个新的MappedFile </span></span><br><span class="line">    <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MappedFileQueue-getLastMappedFile-final-long-startOffset-boolean-needCreate"><a href="#MappedFileQueue-getLastMappedFile-final-long-startOffset-boolean-needCreate" class="headerlink" title="MappedFileQueue.getLastMappedFile(final long startOffset, boolean needCreate)"></a>MappedFileQueue.getLastMappedFile(final long startOffset, boolean needCreate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLastMappedFile(startOffset, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset, <span class="keyword">boolean</span> needCreate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> createOffset = -<span class="number">1</span>;</span><br><span class="line">    MappedFile mappedFileLast = getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFileLast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        createOffset = startOffset - (startOffset % <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 满了， 创建一个新文件，新文件的名称 = createOffset</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFileLast != <span class="keyword">null</span> &amp;&amp; mappedFileLast.isFull()) &#123;</span><br><span class="line">        createOffset = mappedFileLast.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 新创建的文件,名称必须是20个0， 或者 mappedFileSize的整数倍(格式化后为20位)</span></span><br><span class="line">    <span class="keyword">if</span> (createOffset != -<span class="number">1</span> &amp;&amp; needCreate) &#123;</span><br><span class="line">        String nextFilePath = <span class="keyword">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</span><br><span class="line">        String nextNextFilePath = <span class="keyword">this</span>.storePath + File.separator</span><br><span class="line">            + UtilAll.offset2FileName(createOffset + <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">truetrue<span class="comment">// 交给 MappedFile 分配服务，异步创建。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allocateMappedFileService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line">                                                                                      nextNextFilePath, <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//直接创建MappedFile</span></span><br><span class="line">                mappedFile = <span class="keyword">new</span> MappedFile(nextFilePath, <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"create mappedFile exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">                mappedFile.setFirstCreateInQueue(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CommitLog-Flush-流程"><a href="#CommitLog-Flush-流程" class="headerlink" title="CommitLog Flush 流程"></a>CommitLog Flush 流程</h3><p>消息刷盘的过程是由 <code>FlushCommitLogService</code>的3GroupCommitService个子类完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> GroupCommitService();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> FlushRealTimeService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.commitLogService = <span class="keyword">new</span> CommitRealTimeService();</span><br></pre></td></tr></table></figure>
<h4 id="CommitRealTimeService"><a href="#CommitRealTimeService" class="headerlink" title="CommitRealTimeService"></a>CommitRealTimeService</h4><p>CommitRealTimeService 该后台服务线程起作用的前提是<code>MappedFile</code>写入数据时使用了<code>WriteBuffer</code>，</p>
<p>也就是配置项<code>transientStorePoolEnable</code> 的值为true，并且刷盘模式是<code>ASYNC_FLUSH</code>， 而且是Master。</p>
<p>作用是：消息先写入DirectByteBuffer中，然后通过该后台服务线程写入到FileChannel （）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastCommitTimestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommitRealTimeService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">// 默认值200ms, 只有在启用了 TransientStorePool 的时候使用</span></span><br><span class="line">            <span class="comment">// 刷新数据到FileChannel</span></span><br><span class="line">            <span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line">truetruetrue<span class="comment">// 默认的页数 4页</span></span><br><span class="line">            <span class="keyword">int</span> commitDataLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line">truetruetrue<span class="comment">// 默认值 200ms</span></span><br><span class="line">            <span class="keyword">int</span> commitDataThoroughInterval =</span><br><span class="line">                CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (begin &gt;= (<span class="keyword">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">                commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">                    <span class="comment">//now wake up flush thread.</span></span><br><span class="line">                    flushCommitLogService.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"Commit data to file costs &#123;&#125; ms"</span>, end - begin);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                CommitLog.log.error(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">            result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(<span class="number">0</span>);</span><br><span class="line">            CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service shutdown, retry "</span> + (i + <span class="number">1</span>) + <span class="string">" times "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Not OK"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GroupCommitService"><a href="#GroupCommitService" class="headerlink" title="GroupCommitService"></a>GroupCommitService</h4><p>如果配置了同步刷盘模式，则使用<code>GroupCommitService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupCommitService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;GroupCommitRequest&gt; requestsWrite = <span class="keyword">new</span> ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;GroupCommitRequest&gt; requestsRead = <span class="keyword">new</span> ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">true</span><br><span class="line">    <span class="comment">// 提交同步刷盘请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(<span class="keyword">final</span> GroupCommitRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsWrite) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestsWrite.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;GroupCommitRequest&gt; tmp = <span class="keyword">this</span>.requestsWrite;</span><br><span class="line">        <span class="keyword">this</span>.requestsWrite = <span class="keyword">this</span>.requestsRead;</span><br><span class="line">        <span class="keyword">this</span>.requestsRead = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                    <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                    <span class="comment">// two times the flush</span></span><br><span class="line">                    <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否已经刷盘了</span></span><br><span class="line">                        flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                        <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                            <span class="comment">// 刷盘页数为0表示直接调用force方法</span></span><br><span class="line">                            <span class="comment">// 不再判断commited 和 write直接的差值</span></span><br><span class="line">                            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">truetruetruetruetrue<span class="comment">// 唤醒等待的消息写入线程</span></span><br><span class="line">                    req.wakeupCustomer(flushOK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">                <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">                <span class="comment">// will come to this process</span></span><br><span class="line">                CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有被通知刷盘，则等待10ms</span></span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 执行刷盘操作</span></span><br><span class="line">                <span class="keyword">this</span>.doCommit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 优雅停机时，执行下面的操作</span></span><br><span class="line">        <span class="comment">// Under normal circumstances shutdown, wait for the arrival of the</span></span><br><span class="line">        <span class="comment">// request, and then flush</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="string">"GroupCommitService Exception, "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swapRequests();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.doCommit();</span><br><span class="line"></span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.swapRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GroupCommitService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getJointime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FlushRealTimeService"><a href="#FlushRealTimeService" class="headerlink" title="FlushRealTimeService"></a>FlushRealTimeService</h4><p>如果配置了异步刷盘模式，则使用<code>FlushRealTimeService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastFlushTimestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> printTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">//是否定时进行CommitLog的刷盘操作, 默认是False (也就是说默认同步刷盘)</span></span><br><span class="line">            <span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line">truetruetrue<span class="comment">// 刷盘的时间间隔， 默认是 500 毫秒</span></span><br><span class="line">            <span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line">            <span class="comment">// 每次刷盘至少需要刷盘的页数，默认是4</span></span><br><span class="line">            <span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line">truetruetrue<span class="comment">// 默认是 10 * 1000</span></span><br><span class="line">            <span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line"> CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> printFlushProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Print flush progress</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">                flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">                printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是异步刷盘，则休眠 500 毫秒后进行刷盘操作</span></span><br><span class="line">                <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                    Thread.sleep(interval);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 同步刷盘，则等待通知</span></span><br><span class="line">                    <span class="comment">// CommitLog 完成消息写入后，通过方法handleDiskFlush来唤醒刷盘线程</span></span><br><span class="line">                    <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">                &#125;</span><br><span class="line">truetruetruetrue<span class="comment">// 输出刷盘信息， 源码输出日志被注释</span></span><br><span class="line">                <span class="keyword">if</span> (printFlushProgress) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 真正执行刷盘</span></span><br><span class="line">                CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line">                <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">                <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> past = System.currentTimeMillis() - begin;</span><br><span class="line">                <span class="keyword">if</span> (past &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"Flush data to disk costs &#123;&#125; ms"</span>, past);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">                <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Normal shutdown, to ensure that all the flush before exit</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">            result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service shutdown, retry "</span> + (i + <span class="number">1</span>) + <span class="string">" times "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Not OK"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line"></span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FlushRealTimeService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFlushProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CommitLog.log.info("how much disk fall behind memory, "</span></span><br><span class="line">        <span class="comment">// + CommitLog.this.mappedFileQueue.howMuchFallBehind());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getJointime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列索引构建流程"><a href="#队列索引构建流程" class="headerlink" title="队列索引构建流程"></a>队列索引构建流程</h3><p>所有消息都是先写入CommitLog文件中(不同的Topic消息也是在一个文件中)，然后异步构建消息队列 和 消息索引。</p>
<h4 id="ReputMessageService"><a href="#ReputMessageService" class="headerlink" title="ReputMessageService"></a>ReputMessageService</h4><p>该类是一个后台服务线程。它在Broker启动时，从CommitLog文件指定的offset处开始读取消息，然后通过<code>CommitLogDispatcher</code>进行消息分发。</p>
<blockquote>
<p>注意：Broker启动时应该从哪个位置读取消息进行分发是非常重要的。通常有2个选择：</p>
<ol>
<li>从CommitLog文件最大的可读数据点开始分发（可以是最后写入消息的位置 或 已经commit的消息位置）。</li>
<li>从CommitLog确认点开放分发。（如果开启了 duplicationEnable = true 配置项）</li>
</ol>
</blockquote>
<p>DefaultMessageStore 在启动时的代码，计算reput的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要reput的位置后有新写入的消息，则可以构建消费队里和消息索引</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitLogAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> <span class="keyword">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">truetrue<span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="keyword">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                    DispatchRequest dispatchRequest =</span><br><span class="line">                        DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                                                                          dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                                                                          dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                                                                          dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                            readSize += size;</span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                    .addAndGet(dispatchRequest.getMsgSize());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                            readSize = result.getSize();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;"</span>, reputFromOffset);</span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            doNext = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                                log.error(<span class="string">"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;"</span>,</span><br><span class="line">                                          <span class="keyword">this</span>.reputFromOffset);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                result.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doNext = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLogDispatcherBuildConsumeQueue 此类用来构建队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">// 从方法名称能看出，是保存消息位置信息</span></span><br><span class="line">                <span class="comment">// 队列中保存的是消息的offset，size, tag</span></span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLogDispatcherBuildIndex 此类用来构建消息索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">             DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延迟消息实现"><a href="#延迟消息实现" class="headerlink" title="延迟消息实现"></a>延迟消息实现</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RocketMQ延迟消息的实现，是通过将延迟消息根据延迟的时间长度不同，写入到不同时间粒度的Block中。</p>
<p>满足即将要发送（可能是一个小时内要发送的消息）的延迟消息会加载到内存中，通过TimeWheel来发送到目标Topicz中。通过后台线程不断查询满足条件的消息，及时加载到TimeWheel中。</p>
<h3 id="RocketMQ-目录和文件"><a href="#RocketMQ-目录和文件" class="headerlink" title="RocketMQ 目录和文件"></a>RocketMQ 目录和文件</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>数据存储根目录：user.home /store </p>
<p>commit log 存储目录：user.home /store/commitlog</p>
<p>延迟消息存储目录：user.home /store/scheduledtempdata</p>
<h4 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h4><p>消费者队列文件每个文件大小 30w * 20 byte</p>
<p>user.home / store / abort.scheduled  文件存在表示上次是正常关机，否则是异常关机（延迟消息恢复时使用）。</p>
<h3 id="ScheduledMessageStore"><a href="#ScheduledMessageStore" class="headerlink" title="ScheduledMessageStore"></a>ScheduledMessageStore</h3><p>ScheduledMessageStore 提供访问延迟消息的API。</p>
<ol>
<li>load</li>
<li>start</li>
</ol>
<h3 id="Block-介绍"><a href="#Block-介绍" class="headerlink" title="Block 介绍"></a>Block 介绍</h3><p>Block是一个逻辑概念，底层是由多个大小相同的log文件组成。时间粒度一般为一个小时。</p>
<p>Block文件目录结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user.home/store/scheduledtempdata/<span class="number">20190910</span></span><br><span class="line">    /log/<span class="number">000000</span>xxxxxx <span class="comment">// log目录下每个文件大小相同都是128M, 顺序写</span></span><br><span class="line">    /queue/<span class="number">000000</span>xxxxx <span class="comment">// 每个文件大小为 30w * 24 字节</span></span><br><span class="line">    /checkpoint</span><br></pre></td></tr></table></figure>
<h3 id="ScheduledTempBlock"><a href="#ScheduledTempBlock" class="headerlink" title="ScheduledTempBlock"></a>ScheduledTempBlock</h3><p>保存特定时间范围内的延迟消息，提供对于的操作API。</p>
<h3 id="延迟消息加载逻辑"><a href="#延迟消息加载逻辑" class="headerlink" title="延迟消息加载逻辑"></a>延迟消息加载逻辑</h3><p>RocketMQ启动时，需要恢复延迟消息到上次关机是的状态。</p>
<ol>
<li>检查是否正常关机并打印日志。是否正常关机通过文件:<code>user.home / store / abort.scheduled</code>是否存在来判断。</li>
<li>加载Block。遍历保存延迟消息的Block目录，通过每个<code>ScheduledTempBlock.load</code>方法来load各个Block。</li>
<li>每个Block是由大小相同的文件组成，这些文件组成<code>MappedFileQueue</code>，每个Block load时，底层其实是通过<code>MappedFileQueue</code>来恢复，<code>MappedFileQueue.load</code>时，会把该Block对应的所有文件进行<code>mmap</code>，并恢复<code>MappedFile</code>的状态。</li>
<li>恢复Block。遍历保存延迟消息的Block目录，通过每个<code>ScheduledTempBlock.revover</code>方法进行状态恢复。底层实现是通过<code>ScheduledTempQueue.recover</code>和<code>ScheduledTempLog.recoverNormally</code>来实现恢复。如果Queue 文件个数小于等于3,则从第一个Queue文件恢复，否则从倒数第三个开始恢复。</li>
<li>TimeWheelService 加载延迟消息。</li>
</ol>
<h3 id="Consumer-Queue-文件结构"><a href="#Consumer-Queue-文件结构" class="headerlink" title="Consumer Queue 文件结构"></a>Consumer Queue 文件结构</h3><p>ConsumeQueue中每个消息时20Byte长。结构为</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5149787-be103f4e0b434fe5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="相关知识总结"><a href="#相关知识总结" class="headerlink" title="相关知识总结"></a>相关知识总结</h2><h3 id="JVM-shutdownhook"><a href="#JVM-shutdownhook" class="headerlink" title="JVM shutdownhook"></a>JVM shutdownhook</h3><p>JVM 在在shutdown时， 会响应如下两种事件：</p>
<ol>
<li>进程正常退出（最后一个非Daemon线程退出） 或 通过<code>System.exit(int status)</code>方法 或 这等价方法退出。</li>
<li>用户中断进程(例如：Ctrl + C)， 或OS系统事件(用户退出， 系统关机)</li>
</ol>
<p>shutdownhook 本质上是一个已经初始化，但是未启动的线程。</p>
<p>JVM 在进入shutdown 流程后，多个shutdownhook会并发执行。所有的shutdownhook执行完成后，如果开启了<code>finalization-on-exit</code>时，JVM 还会执行所有未被调用的<code>finalizers</code>。 </p>
<blockquote>
<p>注意：如果是通过<code>System.exit</code>触发的shutdown流程，则在shutdown流程中，Daemon 和 非Daemon线程还在继续执行。</p>
<p>shutdown流程一旦开启，则是不可逆的，除非通过调用<code>Runtime.halt</code>方法，该方法会强制关闭JVM。</p>
<p>shutdown流程执行中，不能再添加或删除shutdownhook，否则会抛出IllegalStateException异常。</p>
<p>shutdownhook 代码需要精心编写：例如是线程安全，不会导致死锁，不会有异常等。</p>
<p>JVM 不能响应 kill -9 （SIGKILL）信号</p>
</blockquote>
<p> <a href="https://www.jianshu.com/p/3cb9aacc26a2" target="_blank" rel="noopener">JVM对于signal的处理及案例分析</a> </p>
<h3 id="JNA"><a href="#JNA" class="headerlink" title="JNA"></a>JNA</h3><p>在RocketMQ实现中，为了实现高性能，避免进程内存页被swap，它通过调用本地C库API来锁定内存页。这里面就涉及到了Java如何调用本地库的实现。在<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>之前，我们只能通过<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html" target="_blank" rel="noopener">JNI</a>进行跨语言的相互调用，非常的繁琐。幸亏有了JNA，使我们得以非常快捷的实现跨语言调用。</p>
<p>RocketMQ中的实现。</p>
<h4 id="定义本地调用接口"><a href="#定义本地调用接口" class="headerlink" title="定义本地调用接口"></a>定义本地调用接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LibC</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">    LibC INSTANCE = (LibC) Native.loadLibrary(Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>, LibC.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MADV_WILLNEED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> MADV_DONTNEED = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MCL_CURRENT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> MCL_FUTURE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> MCL_ONFAULT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sync memory asynchronously */</span></span><br><span class="line">    <span class="keyword">int</span> MS_ASYNC = <span class="number">0x0001</span>;</span><br><span class="line">    <span class="comment">/* invalidate mappings &amp; caches */</span></span><br><span class="line">    <span class="keyword">int</span> MS_INVALIDATE = <span class="number">0x0002</span>;</span><br><span class="line">    <span class="comment">/* synchronous memory sync */</span></span><br><span class="line">    <span class="keyword">int</span> MS_SYNC = <span class="number">0x0004</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">madvise</span><span class="params">(Pointer var1, NativeLong var2, <span class="keyword">int</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Pointer <span class="title">memset</span><span class="params">(Pointer p, <span class="keyword">int</span> v, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlockall</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(Pointer p, NativeLong length, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本地库接口一般继承<code>Library</code> ，在接口中定义你需要调用的本地API对应的Java方法。这里需要非常注意Jav、a中的数据类型和本地接口的数据类型匹配问题。此外还需要注意一定订单一个<code>public static</code>的变量</p>
<p>该变量就是你调用本地API的入口对象。</p>
</blockquote>
<h4 id="内存锁定"><a href="#内存锁定" class="headerlink" title="内存锁定"></a>内存锁定</h4><p>有了和本地API进行交互的能力后，就可以方便的利用Java SDK中不具备，只能通过本地接口提供的功能了。</p>
<h5 id="mlock"><a href="#mlock" class="headerlink" title="mlock"></a>mlock</h5><p>mlock 方法接受2个参数，一个是要锁定内存的起始地址，一个是锁定的大小。但是需要注意的是你锁定的页面当前页可能并不在物理内存中，因此你需要对要锁定的内存区域写入数据。RocketMQ就是在创建MappedFile并warm的时候写入0进行内存完全占用的。</p>
<p>内存锁定是危险操作，需要具有ROOT权限。</p>
<h5 id="munlock"><a href="#munlock" class="headerlink" title="munlock"></a>munlock</h5><p>作用同mlock相反，用来取消内存锁定。</p>
<h2 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h2><ol>
<li><p>OS_PAGE_SIZE 在刷盘时，是按照页大小4K进行的，如果操作系统(应用进程)启用了大页，是不是可以通过大页作为单位呢？</p>
</li>
<li><p>刷盘时，最少页数的计算 ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages; 是不是可以通过 (write - flush) / OS_PAGE_SIZE &gt;= flushLeastPages 呢？</p>
</li>
<li><p>同步刷盘需要处理一个刷盘请求队列，队列里面有多个请求，当刷盘请求较密集时(还有线程切换原因)，可能导致多次调用force方法，但是每次刷盘的数据其实不会很多。现有的逻辑是每次等待10ms来达到类似MySQL redo log组提交的效果，其实 10ms 这个值可以通过 磁盘的IOPS 和 配置参数进行调节，这样刷盘效果可能更好。</p>
</li>
<li><p>感觉消息持久化逻辑和InnoDB的redo log 刷盘逻辑很类型。</p>
</li>
<li><p>NUMA 架构下的优化</p>
</li>
<li><p>MappedFile wrotePosition, commitedPosition, flushedPosition。 </p>
<ol>
<li>wrotePosition 是写入到MappedByteBuffer的位置</li>
<li>commitedPosition 是启用了TransientStorePool后，写入到DirectByteBuffer的位置。</li>
<li>flushedPosition 是最后刷盘的位置</li>
<li>wrotePosition  &gt;= commitedPosition &gt;= flushedPosition</li>
</ol>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></p>
<p> <a href="https://www.jianshu.com/p/ccdf6fc710b0" target="_blank" rel="noopener">https://www.jianshu.com/p/ccdf6fc710b0</a> </p>
<p> <a href="https://www.jianshu.com/p/6d0c118c17de" target="_blank" rel="noopener">https://www.jianshu.com/p/6d0c118c17de</a> </p>
<p> <a href="http://jm.taobao.org/2017/03/23/20170323/" target="_blank" rel="noopener">http://jm.taobao.org/2017/03/23/20170323/</a> </p>
<p> <a href="https://www.cnblogs.com/lanxuezaipiao/p/3635556.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxuezaipiao/p/3635556.html</a> </p>
<p> <a href="https://github.com/OpenHFT/Java-Thread-Affinity" target="_blank" rel="noopener">https://github.com/OpenHFT/Java-Thread-Affinity</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RocketMQ算是当前国内MQ领域内的明星产品。网上关于它文章非常的多。但是总觉得任何一项你想要在生产环境使用的技术，你必须亲自深入学习一遍才能更好的使用它，出了问题也好定位。在学习源码的过程中可能有许多意想不到的收获，也是提示技术能力的一种方式。&lt;/p&gt;
&lt;h3 id=&quot;RocketMQ-文件目录&quot;&gt;&lt;a href=&quot;#RocketMQ-文件目录&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ 文件目录&quot;&gt;&lt;/a&gt;RocketMQ 文件目录&lt;/h3&gt;&lt;p&gt;RocketMQ 作为一个具有持久化功能的消息中间件，必然需要强大的存储功能。那么首先需要了解的就是它的存储架构。&lt;/p&gt;
&lt;p&gt;RocketMQ 存储目录结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="https://leokongwq.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>elastic-job学习总结</title>
    <link href="https://leokongwq.github.io/2019/11/12/elastic-job-summary.html"/>
    <id>https://leokongwq.github.io/2019/11/12/elastic-job-summary.html</id>
    <published>2019-11-12T13:22:49.000Z</published>
    <updated>2019-12-14T04:11:46.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elastic-job-是什么？"><a href="#elastic-job-是什么？" class="headerlink" title="elastic-job 是什么？"></a>elastic-job 是什么？</h2><p>还是看官方文档介绍：<a href="http://elasticjob.io/docs/elastic-job-lite/00-overview/" target="_blank" rel="noopener">http://elasticjob.io/docs/elastic-job-lite/00-overview/</a></p>
<h2 id="elastic-job-实现分析"><a href="#elastic-job-实现分析" class="headerlink" title="elastic-job 实现分析"></a>elastic-job 实现分析</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="http://elasticjob.io/docs/elastic-job-lite/img/architecture/elastic_job_lite.png" alt="Elastic-Job-Lite Architecture"></p>
<p>从上图可以看到 elastic-job 的实现主要依赖的外部组件是zookeeper。 用zookeeper来实现分布式任务的协调及相关任务信息的保存。具体任务的调度触发还是依赖core模块里面的Quartz API提供的能力。</p>
<a id="more"></a>
<h3 id="spring-集成分析"><a href="#spring-集成分析" class="headerlink" title="spring 集成分析"></a>spring 集成分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;reg:zookeeper id=<span class="string">"regCenter"</span></span><br><span class="line">                   server-lists=<span class="string">"$&#123;elastic.job.zk.host&#125;"</span></span><br><span class="line">                   namespace=<span class="string">"viptrade-job"</span></span><br><span class="line">                   base-sleep-time-milliseconds=<span class="string">"1000"</span></span><br><span class="line">                   max-sleep-time-milliseconds=<span class="string">"3000"</span></span><br><span class="line">                   max-retries=<span class="string">"3"</span></span><br><span class="line">                   session-timeout-milliseconds=<span class="string">"5000"</span></span><br><span class="line">                   connection-timeout-milliseconds=<span class="string">"3000"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;job:simple id=<span class="string">"mySimpleElasticJob"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.leokongwq.elasticjob.elasticjobdemo.job.MySimpleElasticJob"</span> </span><br><span class="line">    registry-center-ref=<span class="string">"regCenter"</span></span><br><span class="line">    cron=<span class="string">"0/10 * * * * ?"</span></span><br><span class="line">    job-parameter=<span class="string">"name=sky;age=21"</span></span><br><span class="line">    sharding-total-count=<span class="string">"3"</span></span><br><span class="line">    sharding-item-parameters=<span class="string">"0=A,1=B,2=C"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>从上面的配置容易看出， elastic-job 是采用spring提供的命名空间扩展能力进行集成的。</p>
<p>具体是通过如下的配置和类实现：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.dangdang.com/schema/ddframe/reg/reg.xsd=META-INF/namespace/reg.xsd</span><br><span class="line">http\://www.dangdang.com/schema/ddframe/job/job.xsd=META-INF/namespace/job.xsd</span><br><span class="line"></span><br><span class="line">http\://www.dangdang.com/schema/ddframe/reg=io.elasticjob.lite.spring.reg.handler.RegNamespaceHandler</span><br><span class="line">http\://www.dangdang.com/schema/ddframe/job=io.elasticjob.lite.spring.job.handler.JobNamespaceHandler</span><br></pre></td></tr></table></figure>
<p><code>RegNamespaceHandler</code> 来负责解析 <code>reg</code>命名空间配置。<code>JobNamespaceHandler</code> 来解析<code>job</code>命名空间配置</p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>目前只支持基于zookeeper的注册中心，核心的类是<code>ZookeeperRegistryCenter</code>。</p>
<p>支持的核心配置如下：</p>
<ul>
<li>serverLists  zookeeper节点列表，逗号分隔</li>
<li>namespace 任务的命名空间， 同时也是Curator操作的命名空间，所有的操作都是相对于这个命名空间的。</li>
<li>baseSleepTimeMilliseconds maxSleepTimeMilliseconds maxRetries 这三个都是底层Curator的重试策略<code>ExponentialBackoffRetry</code>配置属性</li>
<li>sessionTimeoutMilliseconds zookeeper 回话超时时间</li>
<li>connectionTimeoutMilliseconds zookeeper 连接超时时间</li>
<li>digest zookeeper认证信息</li>
</ul>
<h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><p>不同的job定义是通过不同的Handler类处理的。</p>
<p>SimpleJobBeanDefinitionParser 处理 simple 命名空间的任务定义</p>
<p>DataflowJobBeanDefinitionParser 处理 dataflow命名空间的任务定义</p>
<p>ScriptJobBeanDefinitionParser 处理 script命名空间的任务定义</p>
<p>所有job 在spring容器中最终生成的 Bean 类型 都是 <code>SpringJobScheduler</code> 并通过<code>init</code>方法进行初始化。</p>
<h3 id="zookeeper-目录结构"><a href="#zookeeper-目录结构" class="headerlink" title="zookeeper 目录结构"></a>zookeeper 目录结构</h3><p>/jobname</p>
<p>/jobname/systemtime/current 保存当前时间</p>
<p>/jobname/config  job 配置信息</p>
<p>/jobname/guarantee/started/0  # 分布式环境下，任务同时开始</p>
<p>/jobname/guarantee/stoped/0  # 分布式环境下，任务同时结束</p>
<p>/jobname/servers/ip #曾经注册了可以执行job的机器. 数据节点的值为空字符串表示正常，disabled表示不可用</p>
<p>/jobname/instances/ip@-@pid #表示存活的实例，节点值为空字符串</p>
<p>/jobname/sharding/0/instance # 节点的值是instanceId eg. 10.3.9.7@-@4256</p>
<p>/jobname/sharding/0/running # 表示分片运行状态</p>
<p>/jobname/sharding/0/misfire # 表示任务被错过执行标志，第二次调度时，第一次的任务还没有执行完成。</p>
<p>/jobname/sharding/0/disabled # 表示分片被禁用</p>
<p>/jobname/sharding/0/failover # 表示执行分片failover， 节点的值是执行失败分片的实例id,即 instanceId</p>
<p>/jobname/learder/sharding/necessary # 表示Job是否需要分片， 分片完成后被删除</p>
<p>/jobname/learder/sharding/processing # 表示Job正在进行分片， 分片完成后被删除</p>
<p>/jobname/learder/election/latch # 表示进行选主的根节点</p>
<p>/jobname/learder/election/instance # 表示被选为master的实例，节点的值是master实例的instanceId</p>
<p>/jobname/learder/failover/items/0 # 表示需要failover的分片</p>
<h3 id="Quartz-如何调度任务？"><a href="#Quartz-如何调度任务？" class="headerlink" title="Quartz 如何调度任务？"></a>Quartz 如何调度任务？</h3><h4 id="QuartzSchedulerThread"><a href="#QuartzSchedulerThread" class="headerlink" title="QuartzSchedulerThread"></a>QuartzSchedulerThread</h4><figure class="highlight java"><figcaption><span>QuartzSchedulerThread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JobRunShell shell = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">    shell.initialize(qs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">    qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (qsRsrcs.getThreadPool().runInThread(shell) == <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="comment">// this case should never happen, as it is indicative of the</span></span><br><span class="line">    <span class="comment">// scheduler being shutdown or a bug in the thread pool or</span></span><br><span class="line">    <span class="comment">// a thread pool being used concurrently - which the docs</span></span><br><span class="line">    <span class="comment">// say not to do...</span></span><br><span class="line">    getLog().error(<span class="string">"ThreadPool.runInThread() return false!"</span>);</span><br><span class="line">    qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobFactory"><a href="#JobFactory" class="headerlink" title="JobFactory"></a>JobFactory</h4><p><code>JobFactory</code>负责Job的创建。 一般是通过<code>JobDetail</code>指的class属性，通过反射API进行创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobFactory</span> <span class="keyword">implements</span> <span class="title">JobFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Logger <span class="title">getLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Job <span class="title">newJob</span><span class="params">(TriggerFiredBundle bundle, Scheduler Scheduler)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        JobDetail jobDetail = bundle.getJobDetail();</span><br><span class="line">        Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(</span><br><span class="line">                    <span class="string">"Producing instance of Job '"</span> + jobDetail.getKey() + </span><br><span class="line">                    <span class="string">"', class="</span> + jobClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> jobClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Problem instantiating class '"</span></span><br><span class="line">                            + jobDetail.getJobClass().getName() + <span class="string">"'"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobRunShell"><a href="#JobRunShell" class="headerlink" title="JobRunShell"></a>JobRunShell</h4><p><code>JobRunShell</code>  提供Job执行环境，真正负责Job的执行。</p>
<figure class="highlight java"><figcaption><span>JobRunShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(QuartzScheduler sched)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.qs = sched;</span><br><span class="line"></span><br><span class="line">        Job job = <span class="keyword">null</span>;</span><br><span class="line">        JobDetail jobDetail = firedTriggerBundle.getJobDetail();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//负责Job的创建， 通过反射API创建</span></span><br><span class="line">            job = sched.getJobFactory().newJob(firedTriggerBundle, scheduler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">            sched.notifySchedulerListenersError(</span><br><span class="line">                    <span class="string">"An error occured instantiating job to be executed. job= '"</span></span><br><span class="line">                            + jobDetail.getKey() + <span class="string">"'"</span>, se);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ncdfe) &#123; <span class="comment">// such as NoClassDefFoundError</span></span><br><span class="line">            SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Problem instantiating class '"</span></span><br><span class="line">                            + jobDetail.getJobClass().getName() + <span class="string">"' - "</span>, ncdfe);</span><br><span class="line">            sched.notifySchedulerListenersError(</span><br><span class="line">                    <span class="string">"An error occured instantiating job to be executed. job= '"</span></span><br><span class="line">                            + jobDetail.getKey() + <span class="string">"'"</span>, se);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 创建Job执行上下文</span></span><br><span class="line">        <span class="keyword">this</span>.jec = <span class="keyword">new</span> JobExecutionContextImpl(scheduler, firedTriggerBundle, job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">trueqs.addInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OperableTrigger trigger = (OperableTrigger) jec.getTrigger();</span><br><span class="line">        JobDetail jobDetail = jec.getJobDetail();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">truetruetrue<span class="comment">// 删除一部分代码</span></span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> endTime = startTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// execute the job</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Calling execute on job "</span> + jobDetail.getKey());</span><br><span class="line">                <span class="comment">// job 开始执行</span></span><br><span class="line">                job.execute(jec);</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JobExecutionException jee) &#123;</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">                jobExEx = jee;</span><br><span class="line">                getLog().info(<span class="string">"Job "</span> + jobDetail.getKey() +</span><br><span class="line">                              <span class="string">" threw a JobExecutionException: "</span>, jobExEx);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">                getLog().error(<span class="string">"Job "</span> + jobDetail.getKey() +</span><br><span class="line">                               <span class="string">" threw an unhandled Exception: "</span>, e);</span><br><span class="line">                SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Job threw an unhandled exception."</span>, e);</span><br><span class="line">                qs.notifySchedulerListenersError(<span class="string">"Job ("</span></span><br><span class="line">                                                 + jec.getJobDetail().getKey()</span><br><span class="line">                                                 + <span class="string">" threw an exception."</span>, se);</span><br><span class="line">                jobExEx = <span class="keyword">new</span> JobExecutionException(se, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 删除部分代码</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        qs.removeInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LiteJob"><a href="#LiteJob" class="headerlink" title="LiteJob"></a>LiteJob</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lite调度作业.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangliang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> JobFacade jobFacade;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LiteJob</code> 实现了Quartz 中表示任务的接口<code>Job</code> ， 通过<code>LiteJob</code>类，elastic-job实现了和Quartz的整合。</p>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h4 id="JobInstance-amp-JobRegistry"><a href="#JobInstance-amp-JobRegistry" class="headerlink" title="JobInstance &amp; JobRegistry"></a>JobInstance &amp; JobRegistry</h4><p>JobRegistry 表示job注册中心，在Job创建时 以job的名称为key， JobInstance为Value保存到一个Map中。</p>
<p>JobInstance 本质上是一个字符串，来唯一标识一个Job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler</span><br><span class="line">JobRegistry.getInstance().addJobInstance(liteJobConfig.getJobName(), <span class="keyword">new</span> JobInstance());</span><br><span class="line"></span><br><span class="line">JobRegistry</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加作业实例.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jobInstance 作业实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJobInstance</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobInstance jobInstance)</span> </span>&#123;</span><br><span class="line">    jobInstanceMap.put(jobName, jobInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GuaranteeService"><a href="#GuaranteeService" class="headerlink" title="GuaranteeService"></a>GuaranteeService</h4><p>保证分布式任务全部开始和结束状态的服务。</p>
<p>一个多片任务，通过该类实现所有分片同时开始，等待所有分片都完成。</p>
<h5 id="注册开始分片："><a href="#注册开始分片：" class="headerlink" title="注册开始分片："></a>注册开始分片：</h5><p>如果一个Job分为三片，那么就会在zookeeper上创建三个不同的<code>持久化</code>节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">job 开始</span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">1</span></span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">2</span></span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">job 结束</span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">1</span></span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">2</span></span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="LeaderService"><a href="#LeaderService" class="headerlink" title="LeaderService"></a>LeaderService</h4><p><code>LeaderService</code>是Job在zookeeper上主节点服务类，主要作用如下：</p>
<ol>
<li>Job主节点选举</li>
<li>判断当前节点是否是主节点</li>
<li>判断Job是否有主节点</li>
<li>删除主节点</li>
</ol>
<p>选举主节点底层是通过Curator提供的master选举功能。创建的节点路径是<code>Job名称/leader/election/latch/latch-*</code>  , * 表示1,2,3…(临时顺序节点)</p>
<p>并写入当前Job执行实例的<code>instanceId</code></p>
<p>说白了就是操作<code>jobName/leader</code>及其子节点的工具类</p>
<h4 id="ServerService"><a href="#ServerService" class="headerlink" title="ServerService"></a>ServerService</h4><p><code>ServerService</code>类用来操作<code>jobName/servers</code>及其子节点。主要功能如下：</p>
<ol>
<li>创建执行Job的服务节点<code>jobName</code>/servers/ip；如果该节点可用，则保存的数据为空字符串，不可用保存的数据为<code>DISABLED</code></li>
<li>判断是否还有可用的Job执行节点。其实就是判断<code>jobName</code>/servers/ip<code>节点存在并且保存的值是空字符串，并且节点</code>jobName/instances/ip`存在。</li>
</ol>
<h4 id="InstanceService"><a href="#InstanceService" class="headerlink" title="InstanceService"></a>InstanceService</h4><p><code>InstanceService</code>用来操作节点<code>jobName/instances</code>。主要功能如下：</p>
<ol>
<li>标识Job实例上线。其实就是创建一个节点<code>jobName/instances/instanceId</code></li>
<li>删除instance节点</li>
</ol>
<h4 id="ListenerManager"><a href="#ListenerManager" class="headerlink" title="ListenerManager"></a>ListenerManager</h4><p><code>ListenerManager</code>用来管理所有elastic-job的各种<code>Listener</code>或其他的<code>ListenerManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作业注册中心的监听器管理者.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangliang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElectionListenerManager electionListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingListenerManager shardingListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverListenerManager failoverListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorExecutionListenerManager monitorExecutionListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShutdownListenerManager shutdownListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TriggerListenerManager triggerListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RescheduleListenerManager rescheduleListenerManager;</span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 任务执行前或执行后的监听器， 在分布式环境下，确保只通知一次。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GuaranteeListenerManager guaranteeListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryCenterConnectionStateListener regCenterConnectionStateListener;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerManager</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners)</span> </span>&#123;</span><br><span class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</span><br><span class="line">        electionListenerManager = <span class="keyword">new</span> ElectionListenerManager(regCenter, jobName);</span><br><span class="line">        shardingListenerManager = <span class="keyword">new</span> ShardingListenerManager(regCenter, jobName);</span><br><span class="line">        failoverListenerManager = <span class="keyword">new</span> FailoverListenerManager(regCenter, jobName);</span><br><span class="line">        monitorExecutionListenerManager = <span class="keyword">new</span> MonitorExecutionListenerManager(regCenter, jobName);</span><br><span class="line">        shutdownListenerManager = <span class="keyword">new</span> ShutdownListenerManager(regCenter, jobName);</span><br><span class="line">        triggerListenerManager = <span class="keyword">new</span> TriggerListenerManager(regCenter, jobName);</span><br><span class="line">        rescheduleListenerManager = <span class="keyword">new</span> RescheduleListenerManager(regCenter, jobName);</span><br><span class="line">        guaranteeListenerManager = <span class="keyword">new</span> GuaranteeListenerManager(regCenter, jobName, elasticJobListeners);</span><br><span class="line">        regCenterConnectionStateListener = <span class="keyword">new</span> RegistryCenterConnectionStateListener(regCenter, jobName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启所有监听器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAllListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        electionListenerManager.start();</span><br><span class="line">        shardingListenerManager.start();</span><br><span class="line">        failoverListenerManager.start();</span><br><span class="line">        monitorExecutionListenerManager.start();</span><br><span class="line">        shutdownListenerManager.start();</span><br><span class="line">        triggerListenerManager.start();</span><br><span class="line">        rescheduleListenerManager.start();</span><br><span class="line">        guaranteeListenerManager.start();</span><br><span class="line">        jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShardingContext"><a href="#ShardingContext" class="headerlink" title="ShardingContext"></a>ShardingContext</h4><p>分片上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业名称.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业任务ID.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片总数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业自定义参数.</span></span><br><span class="line"><span class="comment">     * 可以配置多个相同的作业, 但是用不同的参数作为不同的调度实例.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配于本作业实例的分片项.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingItem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配于本作业实例的分片参数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobExecutorFactory"><a href="#JobExecutorFactory" class="headerlink" title="JobExecutorFactory"></a>JobExecutorFactory</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 作业执行器工厂.</span><br><span class="line"> *</span><br><span class="line"> * @author zhangliang</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span><br><span class="line">public final class JobExecutorFactory &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取作业执行器.</span><br><span class="line">     *</span><br><span class="line">     * @param elasticJob 分布式弹性作业</span><br><span class="line">     * @param jobFacade 作业内部服务门面服务</span><br><span class="line">     * @return 作业执行器</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static AbstractElasticJobExecutor getJobExecutor(final ElasticJob elasticJob, final JobFacade jobFacade) &#123;</span><br><span class="line">        if (null == elasticJob) &#123;</span><br><span class="line">            return new ScriptJobExecutor(jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        if (elasticJob instanceof SimpleJob) &#123;</span><br><span class="line">            return new SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        if (elasticJob instanceof DataflowJob) &#123;</span><br><span class="line">            return new DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new JobConfigurationException(&quot;Cannot support job type &apos;%s&apos;&quot;, elasticJob.getClass().getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractElasticJobExecutor"><a href="#AbstractElasticJobExecutor" class="headerlink" title="AbstractElasticJobExecutor"></a>AbstractElasticJobExecutor</h4><p><code>AbstractElasticJobExecutor</code>是Job执行的核心类。它有如下三个子类，分别对应不同种类的任务</p>
<ol>
<li>SimpleJobExecutor</li>
<li>DataflowJobExecutor</li>
<li>ScriptJobExecutor</li>
</ol>
<h3 id="作业初始化"><a href="#作业初始化" class="headerlink" title="作业初始化"></a>作业初始化</h3><p>所有配置的Job 最终都是生成一个调度对象<code>JobScheduler</code>进行任务的触发调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化作业.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="comment">//更新配置信息</span></span><br><span class="line">    LiteJobConfiguration liteJobConfigFromRegCenter = schedulerFacade.updateJobConfiguration(liteJobConfig);</span><br><span class="line"><span class="comment">//设置Job当前的分片总数			JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());</span></span><br><span class="line">    <span class="comment">// 创建Job调度控制器</span></span><br><span class="line">trueJobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</span><br><span class="line">                createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</span><br><span class="line">true<span class="comment">//添加作业调度控制器</span></span><br><span class="line">    JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);</span><br><span class="line">true<span class="comment">//注册作业启动信息， 这个步骤非常重要</span></span><br><span class="line">    schedulerFacade.registerStartUpInfo(!liteJobConfigFromRegCenter.isDisabled());</span><br><span class="line"><span class="comment">// 调度Job		jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-冲突检查-amp-更新配置"><a href="#1-冲突检查-amp-更新配置" class="headerlink" title="1.冲突检查&amp;更新配置"></a>1.冲突检查&amp;更新配置</h4><p>每个Job的配置信息在 zookeeper上的节点路径是<code>/命名空间/job名称/config</code> 格式是一个json字符串。</p>
<p>如果配置信息里面保存的Job <code>class名称</code>和本地配置的<code>class</code>名称不同，此时elastic-job会提升冲突<code>JobConfigurationException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConflictJob</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//查询zookeeper上的配置信息</span></span><br><span class="line">    	Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (liteJobConfigFromZk.isPresent() &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job conflict with register center. The job '%s' in register center's class is '%s', your job class is '%s'"</span>, </span><br><span class="line">                    liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Job配置的属性<code>overwrite=true</code>，则用本地的配置信息更新zookeeper上的配置信息。</p>
<h4 id="2-启动所有监听器"><a href="#2-启动所有监听器" class="headerlink" title="2. 启动所有监听器"></a>2. 启动所有监听器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开启所有监听器.</span><br><span class="line"> */</span><br><span class="line">public void startAllListeners() &#123;</span><br><span class="line">    electionListenerManager.start(); </span><br><span class="line">    shardingListenerManager.start(); </span><br><span class="line">    failoverListenerManager.start(); </span><br><span class="line">    monitorExecutionListenerManager.start(); // </span><br><span class="line">    shutdownListenerManager.start();</span><br><span class="line">    triggerListenerManager.start();</span><br><span class="line">    rescheduleListenerManager.start();</span><br><span class="line">    guaranteeListenerManager.start();</span><br><span class="line">    jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ElectionListener"><a href="#ElectionListener" class="headerlink" title="ElectionListener"></a>ElectionListener</h5><p>选主监听器，当master奔溃或上下线job服务器或服务器被禁用，进行选主</p>
<h5 id="ShardingListenerManager"><a href="#ShardingListenerManager" class="headerlink" title="ShardingListenerManager"></a>ShardingListenerManager</h5><p>job分片数调整，或job服务器上下线时触发分片调整（任务下次执行时，真正进行调整，listener只是设置需要调整分片标志）</p>
<p>当前的实现逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isInstanceChange(eventType, path) || isServerChange(path))) &#123;</span><br><span class="line">                shardingService.setReshardingFlag();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是`jobName/instances`开头的路径，并且不是数据更新事件，</span></span><br><span class="line">        <span class="comment">// 那么就必然是 NODE_ADD, 或 NODE_REMOVE 事件了</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> serverNode.isServerPath(path);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FailoverListenerManager"><a href="#FailoverListenerManager" class="headerlink" title="FailoverListenerManager"></a>FailoverListenerManager</h5><ol>
<li><p>job执行中奔溃， 如果设置了Job的failover配置，那么进行Job的故障转移</p>
</li>
<li><p>如果将job的failover配置调整为false，那么删除job所有分片的failover节点。 <code>jobName/sharding/0/failover</code></p>
</li>
</ol>
<h5 id="MonitorExecutionListenerManager"><a href="#MonitorExecutionListenerManager" class="headerlink" title="MonitorExecutionListenerManager"></a>MonitorExecutionListenerManager</h5><ol>
<li>如果将job的配置项<code>monitorExecution</code>设置为false，那么删除Job所有分片的running节点。<code>jobName/sharding/0/running</code></li>
</ol>
<h5 id="ShutdownListenerManager"><a href="#ShutdownListenerManager" class="headerlink" title="ShutdownListenerManager"></a>ShutdownListenerManager</h5><ol>
<li>如果<code>jobName/sharding/0/instance</code> 节点被删除，那么该实例不再参与任务调度。</li>
<li>关闭Monitor Socket,  如果是master，则放弃master身份。关闭 job对应的Quartz调度器。</li>
<li>释放缓存</li>
<li>删除内存中的状态数据</li>
</ol>
<h5 id="TriggerListenerManager"><a href="#TriggerListenerManager" class="headerlink" title="TriggerListenerManager"></a>TriggerListenerManager</h5><ol>
<li>将<code>jobName/instances/instanceid</code> 节点的值设置为 <code>trigger</code>, 并且当前Job不处于运行中，则直接触发Job的执行。</li>
</ol>
<h5 id="RescheduleListenerManager"><a href="#RescheduleListenerManager" class="headerlink" title="RescheduleListenerManager"></a>RescheduleListenerManager</h5><ol>
<li>当修改任务的cron表达式时， 触发任务重新调度。 </li>
</ol>
<h5 id="GuaranteeListenerManager"><a href="#GuaranteeListenerManager" class="headerlink" title="GuaranteeListenerManager"></a>GuaranteeListenerManager</h5><ol>
<li>当节点<code>jobName/guarantee/started</code>节点被删除时，通知对应的Listener.</li>
<li>当节点<code>jobName/guarantee/completed</code>节点被删除时，通知对应的Listener.</li>
</ol>
<h5 id="RegistryCenterConnectionStateListener"><a href="#RegistryCenterConnectionStateListener" class="headerlink" title="RegistryCenterConnectionStateListener"></a>RegistryCenterConnectionStateListener</h5><p>zk连接状态监听器。</p>
<ol>
<li>当断开连接 或 连接出去挂起状态，暂时任务调度。<code>jobScheduleController.pauseJob();</code></li>
<li>连接重新建立时，上线<code>server</code>和<code>instance</code> , 清除分片的<code>running</code>状态。恢复job调度。</li>
</ol>
<h4 id="3-选取主节点"><a href="#3-选取主节点" class="headerlink" title="3.选取主节点"></a>3.选取主节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaderService.electLeader();</span><br><span class="line">/**</span><br><span class="line"> * 选举主节点.</span><br><span class="line"> */</span><br><span class="line">public void electLeader() &#123;</span><br><span class="line">    log.debug(&quot;Elect a new leader now.&quot;);</span><br><span class="line">    jobNodeStorage.executeInLeader(LeaderNode.LATCH, new 	LeaderElectionExecutionCallback());</span><br><span class="line">    log.debug(&quot;Leader election completed.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主节点选取成功后，获得master角色的实例，将它的实例id写入<code>jobName/leader/election/instance</code>节点</p>
<h4 id="4-上线服务器和实例"><a href="#4-上线服务器和实例" class="headerlink" title="4.上线服务器和实例"></a>4.上线服务器和实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverService.persistOnline(enabled);</span><br><span class="line">instanceService.persistOnline();</span><br></pre></td></tr></table></figure>
<p><code>/jobName/servers/ip</code> 数据设置为空字符串</p>
<p><code>/jobName/instances/instanceid</code> 数据设置为空字符串</p>
<h4 id="5-设置需要分片信息"><a href="#5-设置需要分片信息" class="headerlink" title="5.设置需要分片信息"></a>5.设置需要分片信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shardingService.setReshardingFlag();</span><br></pre></td></tr></table></figure>
<p>设置需要分片标识<code>/jobName/leader/sharding/necessary</code> </p>
<h4 id="6-打开监控端口"><a href="#6-打开监控端口" class="headerlink" title="6.打开监控端口"></a>6.打开监控端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorService.listen();</span><br></pre></td></tr></table></figure>
<h4 id="7-启动分布式状态不一致修复服务"><a href="#7-启动分布式状态不一致修复服务" class="headerlink" title="7. 启动分布式状态不一致修复服务"></a>7. 启动分布式状态不一致修复服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!reconcileService.isRunning()) &#123;</span><br><span class="line">    reconcileService.startAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作业执行"><a href="#作业执行" class="headerlink" title="作业执行"></a>作业执行</h3><p>elastic-job 中作业的执行是通过不同的<code>JobExecutor</code>来实现的。核心逻辑都封装在父类<code>AbstractElasticJobExecutor</code>中。下面我们主要以<code>SimpleJobExecutor</code>来分析Job的执行流程。</p>
<h4 id="SimpleJobExecutor"><a href="#SimpleJobExecutor" class="headerlink" title="SimpleJobExecutor"></a>SimpleJobExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(jobFacade);</span><br><span class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</span><br><span class="line">        simpleJob.execute(shardingContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Job-执行入口-AbstractElasticJobExecutor"><a href="#Job-执行入口-AbstractElasticJobExecutor" class="headerlink" title="Job 执行入口 AbstractElasticJobExecutor"></a>Job 执行入口 AbstractElasticJobExecutor</h4><figure class="highlight java"><figcaption><span>AbstractElasticJobExecutor.execute</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行作业.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查执行环境，主要是检查时间误差是否在允许的时间范围内。</span></span><br><span class="line">        jobFacade.checkJobExecutionEnvironment();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobExecutionEnvironmentException cause) &#123;</span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造Job执行上下文对象，非常重要，后面专门分析</span></span><br><span class="line">    ShardingContexts shardingContexts = jobFacade.getShardingContexts();</span><br><span class="line">    <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</span><br><span class="line">        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Job仍处于执行状态，则设置missfire标志</span></span><br><span class="line">    <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</span><br><span class="line">            jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</span><br><span class="line">                <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </span><br><span class="line">                shardingContexts.getShardingItemParameters().keySet()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 ElasticJobListener </span></span><br><span class="line">        jobFacade.beforeJobExecuted(shardingContexts);</span><br><span class="line">        <span class="comment">//CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</span><br><span class="line">        <span class="comment">//CHECKSTYLE:ON</span></span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 job</span></span><br><span class="line">    execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</span><br><span class="line">    <span class="comment">// 如果开启了misfire功能，则再次Job</span></span><br><span class="line">    <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</span><br><span class="line">        jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</span><br><span class="line">        execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有任务分片执行失败了，并且启用了failover功能，则重新执行失败了的分片</span></span><br><span class="line">    jobFacade.failoverIfNecessary();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 ElasticJobListener</span></span><br><span class="line">        jobFacade.afterJobExecuted(shardingContexts);</span><br><span class="line">        <span class="comment">//CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</span><br><span class="line">        <span class="comment">//CHECKSTYLE:ON</span></span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LiteJobFacade-getShardingContexts"><a href="#LiteJobFacade-getShardingContexts" class="headerlink" title="LiteJobFacade.getShardingContexts"></a>LiteJobFacade.getShardingContexts</h4><p>获取Job执行的上下文信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ShardingContexts getShardingContexts() &#123;</span><br><span class="line">trueboolean isFailover = configService.load(true).isFailover();</span><br><span class="line">true//如果开始了failover功能</span><br><span class="line">    if (isFailover) &#123;</span><br><span class="line">    	// 获取分配到本机的failover分片</span><br><span class="line">        List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</span><br><span class="line">        log.debug(&quot;failover sharding items is &#123;&#125;&quot;, failoverShardingItems);</span><br><span class="line">        // 如果有分配给本实例执行的failover分片，则执行。</span><br><span class="line">        // 这里有个疑问， 本次任务调度，执行上次调度其他实例执行失败的分片， 那该实例本次调度</span><br><span class="line">        // 需要执行的任务还如何执行呢?</span><br><span class="line">        if (!failoverShardingItems.isEmpty()) &#123;</span><br><span class="line">            return executionContextService.getJobShardingContext(failoverShardingItems);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果需要，进行job分片处理</span><br><span class="line">    shardingService.shardingIfNecessary();</span><br><span class="line">    // 获取分配到本实例的分片，遍历job的所有分片，找出instance节点值和</span><br><span class="line">    // 当前job实例instanceId相同的分片</span><br><span class="line">    List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</span><br><span class="line">    // 如果开启了failover功能，去除failover分片</span><br><span class="line">    if (isFailover) &#123;</span><br><span class="line">        shardingItems.removeAll(failoverService.getLocalTakeOffItems());</span><br><span class="line">    &#125;</span><br><span class="line">    // 去除处于disabled状态的分片</span><br><span class="line">trueshardingItems.removeAll(executionService.getDisabledItems(shardingItems));</span><br><span class="line">true</span><br><span class="line">truereturn executionContextService.getJobShardingContext(shardingItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shardingService-shardingIfNecessary"><a href="#shardingService-shardingIfNecessary" class="headerlink" title="shardingService.shardingIfNecessary"></a>shardingService.shardingIfNecessary</h4><figure class="highlight java"><figcaption><span>shardingService.shardingIfNecessary()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要分片且当前节点为主节点, 则作业分片.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果当前无可用节点则不分片.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</span><br><span class="line">    <span class="comment">// 存在 jobName/leader/sharding/necessary 并且 有在线的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!isNeedSharding() || availableJobInstances.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断自己是否是主节点 或 等待选举完成后再次判断</span></span><br><span class="line">    <span class="comment">// 只有主节点才能进行分片</span></span><br><span class="line">    <span class="keyword">if</span> (!leaderService.isLeaderUntilBlock()) &#123;</span><br><span class="line">        <span class="comment">// 非主节点，则等待主节点完成分片操作</span></span><br><span class="line">        blockUntilShardingCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待正在执行的Job执行完成后，再执行分片调整。</span></span><br><span class="line">    waitingOtherJobCompleted();</span><br><span class="line">    LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> shardingTotalCount = liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</span><br><span class="line">    log.debug(<span class="string">"Job '&#123;&#125;' sharding begin."</span>, jobName);</span><br><span class="line">    jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, <span class="string">""</span>);</span><br><span class="line">    resetShardingInfo(shardingTotalCount);</span><br><span class="line">    JobShardingStrategy jobShardingStrategy = JobShardingStrategyFactory.getStrategy(liteJobConfig.getJobShardingStrategyClass());</span><br><span class="line">    jobNodeStorage.executeInTransaction(<span class="keyword">new</span> PersistShardingInfoTransactionExecutionCallback(jobShardingStrategy.sharding(availableJobInstances, jobName, shardingTotalCount)));</span><br><span class="line">    log.debug(<span class="string">"Job '&#123;&#125;' sharding complete."</span>, jobName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分片完成后的回调处理逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistShardingInfoTransactionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">TransactionExecutionCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CuratorTransactionFinal curatorTransactionFinal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> shardingItem : entry.getValue()) &#123;</span><br><span class="line">                curatorTransactionFinal.create().forPath(jobNodePath.getFullPath(ShardingNode.getInstanceNode(shardingItem)), entry.getKey().getJobInstanceId().getBytes()).and();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 删除分片相关节点，Follower 节点不再等待，继续执行Job      curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.NECESSARY)).and();</span></span><br><span class="line">        curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.PROCESSING)).and();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExecutionContextService-getJobShardContext"><a href="#ExecutionContextService-getJobShardContext" class="headerlink" title="ExecutionContextService.getJobShardContext"></a>ExecutionContextService.getJobShardContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前作业服务器分片上下文.</span><br><span class="line"> * </span><br><span class="line"> * @param shardingItems 分片项, 有可能是只包含failover节点的分片项</span><br><span class="line"> * @return 分片上下文</span><br><span class="line"> */</span><br><span class="line">public ShardingContexts getJobShardingContext(final List&lt;Integer&gt; shardingItems) &#123;</span><br><span class="line">    LiteJobConfiguration liteJobConfig = configService.load(false);</span><br><span class="line">    // 去除还处于执行状态的分片</span><br><span class="line">    removeRunningIfMonitorExecution(liteJobConfig.isMonitorExecution(), shardingItems);</span><br><span class="line">    log.debug(&quot;After remove running sharding item, result is &#123;&#125;&quot;, shardingItems);</span><br><span class="line">    if (shardingItems.isEmpty()) &#123;</span><br><span class="line">        return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), </span><br><span class="line">                liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), Collections.&lt;Integer, String&gt;emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line">    // 构造分片参数map， key是分片下标， values是分片参数</span><br><span class="line">    Map&lt;Integer, String&gt; shardingItemParameterMap = new ShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</span><br><span class="line">    </span><br><span class="line">    log.info(&quot;sharding Item parameters : &#123;&#125;&quot;, shardingItemParameterMap);</span><br><span class="line">    // 返回值</span><br><span class="line">    return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</span><br><span class="line">            liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), getAssignedShardingItemParameterMap(shardingItems, shardingItemParameterMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="failover实现逻辑"><a href="#failover实现逻辑" class="headerlink" title="failover实现逻辑"></a>failover实现逻辑</h3><p>failover指的是在Job执行中，突然宕机，elastic-job 将中断的Job重新调度到其他可用实例的过程。有一下几点需要注意：</p>
<ol>
<li>开启failover功能。</li>
<li>Job可以调度的实例大于1。</li>
<li>Job执行结果具有幂等性，否则对业务会有影响。</li>
</ol>
<h4 id="failover-监听"><a href="#failover-监听" class="headerlink" title="failover 监听"></a>failover 监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobCrashedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听 jobName/instances/IP@-<span class="doctag">@PID</span> 节点的 remove事件，进行failover</span></span><br><span class="line"><span class="comment">         * note: 每个任务都会监听 job实例 crash 的事件, 如果job正在执行中，那么failover是正常的。</span></span><br><span class="line"><span class="comment">         * 但是有一种情况是: job已经执行完成了，此时重新调度执行就有问题了。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path zk 事件发生的path</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> eventType &#123;<span class="doctag">@link</span> Type&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data  zk 事件发生的path 节点的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启failover特性， 并且是 instance奔溃触发的zk事件</span></span><br><span class="line">        <span class="keyword">if</span> (isFailoverEnabled() &amp;&amp; Type.NODE_REMOVED == eventType &amp;&amp; instanceNode.isInstancePath(path)) &#123;</span><br><span class="line">            String jobInstanceId = path.substring(instanceNode.getInstanceFullPath().length() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (jobInstanceId.equals(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId())) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"Job instance '&#123;&#125;' with path '&#123;&#125;' crashed! will trigger failover."</span>, jobInstanceId, path);</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; failoverItems = failoverService.getFailoverItems(jobInstanceId);</span><br><span class="line">            <span class="keyword">if</span> (!failoverItems.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> each : failoverItems) &#123;</span><br><span class="line">                    <span class="comment">// 创建节点 jobName/leader/failover/items/each </span></span><br><span class="line">                    failoverService.setCrashedFailoverFlag(each);</span><br><span class="line">                    <span class="comment">// 重新调度分片</span></span><br><span class="line">                    failoverService.failoverIfNecessary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取分配给该实例的Job分片信息, 设置failover相关节点，进行failover</span></span><br><span class="line">                <span class="comment">// 此处需要理解的是：</span></span><br><span class="line">                <span class="comment">// 1. 每个Job都有该监听器，每个Job会处理自己的failover逻辑</span></span><br><span class="line">                <span class="comment">// 2. 分片后的Job, 每个分片自己处理自己负责分片的failover逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingService.getShardItemsForFailover(jobInstanceId)) &#123;</span><br><span class="line">                    failoverService.setCrashedFailoverFlag(each);</span><br><span class="line">                    failoverService.failoverIfNecessary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShardingService获取需要重新调度的分片"><a href="#ShardingService获取需要重新调度的分片" class="headerlink" title="ShardingService获取需要重新调度的分片"></a>ShardingService获取需要重新调度的分片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取作业运行实例的分片项集合.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jobInstanceId 作业运行实例主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 作业运行实例的分片项集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getShardingItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</span><br><span class="line">    JobInstance jobInstance = <span class="keyword">new</span> JobInstance(jobInstanceId);</span><br><span class="line">    <span class="comment">// 判断Job Crash 的实例ip 对应得服务器是否可用</span></span><br><span class="line">    <span class="comment">// 1. 该server是可用状态</span></span><br><span class="line">    <span class="comment">// 2. 该server还有在线的instance</span></span><br><span class="line">    <span class="keyword">if</span> (!serverService.isAvailableServer(jobInstance.getIp())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobInstance.getJobInstanceId().equals(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断作业服务器是否可用.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ip 作业服务器IP地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 作业服务器是否可用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isEnableServer(ip) &amp;&amp; hasOnlineInstances(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断服务器是否启用.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip 作业服务器IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务器是否启用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ServerStatus.DISABLED.name().equals(jobNodeStorage.getJobNodeData(serverNode.getServerNode(ip)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOnlineInstances</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String each : jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (each.startsWith(ip)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实是有问题的，具体分析如下：</p>
<ol>
<li>突然挂掉的Job实例所在的服务器可能是没有Down机的，并且也不会被Disable。</li>
<li>在实践中中，一个server我们只会启动一个Job实例进程，如果该进程挂掉了，那么该Ip上就没有可用的调度实例了。</li>
<li>由1和2可以得出结论，getShardingItems 返回的结果集肯定是空，所有failover功能其实是失效的（除非一个服务器启动多个Job实例）。</li>
</ol>
<p>这个是在实践中得出的结论，并且<a href="https://github.com/elasticjob/elastic-job-lite/issues/669" target="_blank" rel="noopener">github上有多人反馈这个问题</a>，至今未修复。（好死不死，我就是在本机启动2个Job实例来测试failover功能的，没有问题啊）。只能自己fork了一个版本进行修复。</p>
<h4 id="FailoverServer-进行failover"><a href="#FailoverServer-进行failover" class="headerlink" title="FailoverServer 进行failover"></a>FailoverServer 进行failover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果需要失效转移, 则执行作业失效转移.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needFailover()) &#123;</span><br><span class="line">        jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要进行failover</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 表示需要，false 表示不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needFailover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.ITEMS_ROOT) &amp;&amp; !jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).isEmpty()</span><br><span class="line">        &amp;&amp; !JobRegistry.getInstance().isJobRunning(jobName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverLeaderExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !needFailover()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为什么是get(0)呢？ 原因在于每个分片都在不同的实例上面</span></span><br><span class="line">        <span class="comment">// 但是也有例外啊！ 分片数大于实例数也是可能的。 但是没有理由这么部署。</span></span><br><span class="line">        <span class="keyword">int</span> crashedItem = Integer.parseInt(jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).get(<span class="number">0</span>));</span><br><span class="line">        log.debug(<span class="string">"Failover job '&#123;&#125;' begin, crashed item '&#123;&#125;'"</span>, jobName, crashedItem);</span><br><span class="line">        jobNodeStorage.fillEphemeralJobNode(FailoverNode.getExecutionFailoverNode(crashedItem), JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</span><br><span class="line">        jobNodeStorage.removeJobNodeIfExisted(FailoverNode.getItemsNode(crashedItem));</span><br><span class="line">        <span class="comment">// TODO 不应使用triggerJob, 而是使用executor统一调度</span></span><br><span class="line">        JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jobScheduleController) &#123;</span><br><span class="line">            jobScheduleController.triggerJob();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="elastic-job-console"><a href="#elastic-job-console" class="headerlink" title="elastic-job-console"></a>elastic-job-console</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过Jetty实现的restful API。</p>
<h3 id="job状态"><a href="#job状态" class="headerlink" title="job状态"></a>job状态</h3><ul>
<li>crash ： 如果job没有可用的instance实例，则为此状态</li>
<li>disabled：如果job所有的server节点保存的值都是<code>disabled</code>，则为此状态</li>
<li>分片调整中：</li>
</ul>
<h3 id="server-操作"><a href="#server-操作" class="headerlink" title="server 操作"></a>server 操作</h3><h4 id="获取服务器总个数"><a href="#获取服务器总个数" class="headerlink" title="获取服务器总个数"></a>获取服务器总个数</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>/api/servers/count </p>
<h5 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>通过遍历每个Job节点下的<code>servers</code>子节点，获取所有的server ip ，进行计数。</p>
<h4 id="获取服务器简明信息"><a href="#获取服务器简明信息" class="headerlink" title="获取服务器简明信息"></a>获取服务器简明信息</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>/api/servers</p>
<h5 id="实现逻辑-1"><a href="#实现逻辑-1" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历根目录，获取去重后的server IP，统计每个server上注册的Job数量，统计每个Job的运行实例个数。</p>
<h4 id="失效server"><a href="#失效server" class="headerlink" title="失效server"></a>失效server</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>下线或禁用该服务器节点</p>
<h5 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/disable</p>
<h5 id="实现逻辑-2"><a href="#实现逻辑-2" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>jobName/servers/ip</code> 节点的数据设置为<code>disabled</code></p>
<h4 id="启用server"><a href="#启用server" class="headerlink" title="启用server"></a>启用server</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>上线线或启用该服务器节点</p>
<h5 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h5><p>DELETE /api/servers/10.110.114.42/disable</p>
<h5 id="实现逻辑-3"><a href="#实现逻辑-3" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，将<code>jobName/servers/ip</code> 节点的数据设置为空字符串。 </p>
<h4 id="终止server"><a href="#终止server" class="headerlink" title="终止server"></a>终止server</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/shutdown</p>
<h5 id="实现逻辑-4"><a href="#实现逻辑-4" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，删除<code>jobName/instances/ip@-@pid</code> 节点。 </p>
<h4 id="清理server"><a href="#清理server" class="headerlink" title="清理server"></a>清理server</h4><h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h5><p>DELETE  /api/servers/10.110.114.42</p>
<h5 id="实现逻辑-5"><a href="#实现逻辑-5" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，删除<code>jobName/servers/ip</code> 节点。 </p>
<h4 id="获取该服务器下Job注册的简明详情"><a href="#获取该服务器下Job注册的简明详情" class="headerlink" title="获取该服务器下Job注册的简明详情"></a>获取该服务器下Job注册的简明详情</h4><h5 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h5><p>获取该服务器上注册的Job的简明信息</p>
<h5 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h5><p>/api/servers/10.110.114.42/jobs?order=asc&amp;offset=0&amp;limit=10&amp;_=1568597724872</p>
<h5 id="实现逻辑-6"><a href="#实现逻辑-6" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>通过遍历每个<code>job</code>节点下的<code>servers</code>子节点（<code>jobName/servers/ip</code>），判断servers子节点的ip是否和参数指定的ip相同，如果相同则命中，构造job的名称，状态(<code>jobName/servers/ip</code>节点数据，取值如果是非<code>disabled</code>则就是正常)，运行实例（<code>jobname/instances/ip@-@xxxxxx</code>）个数信息。</p>
<h4 id="禁用作业"><a href="#禁用作业" class="headerlink" title="禁用作业"></a>禁用作业</h4><h5 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h5><p>禁用作业</p>
<h5 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/jobs/{jobName}/disable</p>
<h5 id="实现逻辑-7"><a href="#实现逻辑-7" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>/jobName/servers</code>下指定IP的子节点（<code>jobName/servers/ip</code>）的数据设置为<code>disabled</code></p>
<h4 id="启用作业"><a href="#启用作业" class="headerlink" title="启用作业"></a>启用作业</h4><h5 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h5><p>启用作业</p>
<h5 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h5><p>DELETE /api/servers/10.110.114.42/jobs/{jobName}/disable</p>
<h5 id="实现逻辑-8"><a href="#实现逻辑-8" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>/jobName/servers</code>下指定IP的子节点（<code>jobName/servers/ip</code>）的数据设置为空字符串</p>
<h4 id="清理Job"><a href="#清理Job" class="headerlink" title="清理Job"></a>清理Job</h4><h5 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-9"><a href="#API-9" class="headerlink" title="API"></a>API</h5><p>DELETE  /api/servers/10.110.114.42/jobs/{jobName}</p>
<h5 id="实现逻辑-9"><a href="#实现逻辑-9" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>删除<code>jobName/instances/ip@-@pid</code> 节点。 删除<code>jobName/servers/ip</code> 节点。</p>
<h3 id="Job操作"><a href="#Job操作" class="headerlink" title="Job操作"></a>Job操作</h3><h4 id="Job-数量"><a href="#Job-数量" class="headerlink" title="Job 数量"></a>Job 数量</h4><h5 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h5><p>获取Job的数量</p>
<h5 id="API-10"><a href="#API-10" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs/count</p>
<h5 id="实现逻辑-10"><a href="#实现逻辑-10" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有<code>namespace</code>下的jobName节点，累加。</p>
<h4 id="Job-简明信息列表"><a href="#Job-简明信息列表" class="headerlink" title="Job 简明信息列表"></a>Job 简明信息列表</h4><h5 id="作用-9"><a href="#作用-9" class="headerlink" title="作用"></a>作用</h5><p>获取Job简要列表信息</p>
<h5 id="API-11"><a href="#API-11" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs</p>
<h5 id="实现逻辑-11"><a href="#实现逻辑-11" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有jobName节点，构造job简明信息。</p>
<p><code>jobName/config</code>节点的数据是json格式的Job配置信息。</p>
<h4 id="触发Job"><a href="#触发Job" class="headerlink" title="触发Job"></a>触发Job</h4><h5 id="作用-10"><a href="#作用-10" class="headerlink" title="作用"></a>作用</h5><p>触发作业立刻执行</p>
<h5 id="API-12"><a href="#API-12" class="headerlink" title="API"></a>API</h5><p>get /api/jobs/{jobName}/trigger</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>通过将节点<code>jobName/instances/</code>下的每个子节点<code>instanceId</code>的数据修改为<code>TRIGGER</code>来触发job的执行。 </p>
<p>因为执行job的机器会监听<code>jobName/instances/instanceId</code>节点的数据变化，然后通过quartz API来触发job的执行。前提是job当前没有执行。后续的版本可能改为堆积式执行。</p>
<h4 id="失效-生效"><a href="#失效-生效" class="headerlink" title="失效/生效"></a>失效/生效</h4><h5 id="作用-11"><a href="#作用-11" class="headerlink" title="作用"></a>作用</h5><p>禁用作业执行</p>
<h5 id="API-13"><a href="#API-13" class="headerlink" title="API"></a>API</h5><p>get /api/jobs/{jobName}/disable</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>通过将节点<code>jobName/servers/</code>下的每个子节点<code>ip</code>的数据修改为disabled来禁止Job的执行。原理是在Job执行时需要分片，分片时会判断分片所在Server 是不是可用状态（即，<code>jobName/servers/ip</code>）节点的值不是<code>disabled</code>。</p>
<p>我们在操作<code>servers/ip</code>节点或<code>intances/instanceId</code>节点时，监听器都会设置需要分片的标志，下次任务执行时，就会重新分片，即使原有的分片都OK。</p>
<p>禁用Job， 其实就是让Job没有可用的Server。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ShardingService</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</span><br><span class="line">    <span class="keyword">if</span> (!isNeedSharding() || availableJobInstances.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略代码   </span></span><br><span class="line">&#125; </span><br><span class="line">InstanceService</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JobInstance&gt; <span class="title">getAvailableJobInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String each : jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT)) &#123;</span><br><span class="line">        JobInstance jobInstance = <span class="keyword">new</span> JobInstance(each);</span><br><span class="line">        <span class="keyword">if</span> (serverService.isEnableServer(jobInstance.getIp())) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> JobInstance(each));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerService</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ServerStatus.DISABLED.name().equals(jobNodeStorage.getJobNodeData(serverNode.getServerNode(ip)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><h5 id="API-14"><a href="#API-14" class="headerlink" title="API"></a>API</h5><p>PUT /api/jobs/{jobName}/shutdown</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>删除<code>jobName/instances</code>节点下的所有子节点。</p>
<p>如果是从Server维度来操作的话，则只删除指定IP下的所有instance。<code>jobName/instances/instanceId</code> instanceId的ip是指定的IP。</p>
<p>监听器会处理instances节点变更时间，导致Job下次执行时重新分片，分片时因为没有可用的分片(jobName/instances 节点下面没有子节点)</p>
<p>终止Job，实质上就是让Job调度时没有可用的实例。</p>
<h4 id="PUT-修改job信息"><a href="#PUT-修改job信息" class="headerlink" title="PUT 修改job信息"></a>PUT 修改job信息</h4><h5 id="API-15"><a href="#API-15" class="headerlink" title="API"></a>API</h5><p>PUT /api/jobs/config</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><p>直接修改<code>jobName/config</code>节点的值</p>
<h4 id="获取Job分片信息"><a href="#获取Job分片信息" class="headerlink" title="获取Job分片信息"></a>获取Job分片信息</h4><h5 id="作用-12"><a href="#作用-12" class="headerlink" title="作用"></a>作用</h5><p>获取job的详细分片信息</p>
<h5 id="API-16"><a href="#API-16" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs/{jobName}/sharding</p>
<h5 id="实现逻辑-12"><a href="#实现逻辑-12" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>返回数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"item"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"serverIp"</span>: <span class="string">"10.110.27.147"</span>,</span><br><span class="line">        <span class="attr">"instanceId"</span>: <span class="string">"8535"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"SHARDING_FLAG"</span>,</span><br><span class="line">        <span class="attr">"failover"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>遍历<code>jobName/sharding</code>节点下的所有子节点(名称从0开始)，获取每个分片执行实例<code>jobName/sharding/0/instance</code>   的实例id,</p>
<p><code>jobName/sharding/0/disabled</code> 是否禁用，<code>jobName/sharding/0/running</code> 是否执行。</p>
<p>判断节点<code>jobName/instances/instanceId</code> 是否存，不存在表示分片error。</p>
<p>failover 值的判断逻辑为：判断节点<code>jobName/sharding/0/failover</code>是否存，存在表示可以failover。</p>
<p>status 值的判断逻辑为：如果<code>jobName/sharding/0/disabled</code>节点存在，则为<code>DISABLED</code>的。</p>
<p>如果<code>jobName/sharding/0/running</code>节点存在，则为<code>RUNNING</code>的。</p>
<p>如果<code>jobName/instances/instanceId</code> <code>节点不存在，则为</code>SHARDING_FLAG`的，表示需要分片。</p>
<p>其它情况表示待调度执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;elastic-job-是什么？&quot;&gt;&lt;a href=&quot;#elastic-job-是什么？&quot; class=&quot;headerlink&quot; title=&quot;elastic-job 是什么？&quot;&gt;&lt;/a&gt;elastic-job 是什么？&lt;/h2&gt;&lt;p&gt;还是看官方文档介绍：&lt;a href=&quot;http://elasticjob.io/docs/elastic-job-lite/00-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://elasticjob.io/docs/elastic-job-lite/00-overview/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;elastic-job-实现分析&quot;&gt;&lt;a href=&quot;#elastic-job-实现分析&quot; class=&quot;headerlink&quot; title=&quot;elastic-job 实现分析&quot;&gt;&lt;/a&gt;elastic-job 实现分析&lt;/h2&gt;&lt;h3 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://elasticjob.io/docs/elastic-job-lite/img/architecture/elastic_job_lite.png&quot; alt=&quot;Elastic-Job-Lite Architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到 elastic-job 的实现主要依赖的外部组件是zookeeper。 用zookeeper来实现分布式任务的协调及相关任务信息的保存。具体任务的调度触发还是依赖core模块里面的Quartz API提供的能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="任务调度" scheme="https://leokongwq.github.io/tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>HttpMessageConverter总结</title>
    <link href="https://leokongwq.github.io/2019/09/13/HttpMessageConverter%E6%80%BB%E7%BB%93.html"/>
    <id>https://leokongwq.github.io/2019/09/13/HttpMessageConverter总结.html</id>
    <published>2019-09-13T14:31:14.000Z</published>
    <updated>2019-12-14T04:07:40.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HttpMessageConverter-是什么？"><a href="#HttpMessageConverter-是什么？" class="headerlink" title="HttpMessageConverter 是什么？"></a>HttpMessageConverter 是什么？</h3><p>简单来说<code>HttpMessageConverter</code>是spring-web提供的一个接口，用来将HTTP请求转为应用使用的数据，或将HTTP接口的返回数据转为客户端需要的数据。</p>
<p>接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据参数判断该Converter是否能对请求进行转换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据参数判断是否可以转换，生成指定的HTTP响应</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the list of &#123;<span class="doctag">@link</span> MediaType&#125; objects supported by this converter.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the list of supported media types</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从 inputMessage 读取数据，转为class指定的对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将参数t指定的数据，转换为 contentType 指定的媒体类型，写入到HTTP响应。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="FastJsonHttpMessageConverter"><a href="#FastJsonHttpMessageConverter" class="headerlink" title="FastJsonHttpMessageConverter"></a>FastJsonHttpMessageConverter</h3><p><code>FastJsonHttpMessageConverter</code> 是fastjson提供的一个 <code>HttpMessageConverter</code>实现，</p>
<p>在实践中，用来将HTTP请求(请求体是json格式)， 或将响应对象转为 json响应(application/json)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractHttpMessageConverter</span>&lt;<span class="title">Object</span>&gt;//</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">GenericHttpMessageConverter</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * with fastJson config</span></span><br><span class="line"><span class="comment">     * 可以通过 FastJsonConfig 设置 json 序列化的配置， 例如：日期格式，编码等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Can serialize/deserialize all types.</span></span><br><span class="line"><span class="comment">     * MediaType.ALL 表示可以转换所有的媒体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(MediaType.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fastJsonConfig the fastJsonConfig to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFastJsonConfig</span><span class="params">(FastJsonConfig fastJsonConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastJsonConfig = fastJsonConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    FastJsonHttpMessageConverter jsonHttpMessageConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">    FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">    fastJsonConfig.setCharset(Charsets.UTF_8);</span><br><span class="line">    fastJsonConfig.setDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    jsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">    <span class="keyword">super</span>.extendMessageConverters(converters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-如何获取支持的媒体类型-MediaType"><a href="#spring-mvc-如何获取支持的媒体类型-MediaType" class="headerlink" title="spring-mvc 如何获取支持的媒体类型 (MediaType) ?"></a>spring-mvc 如何获取支持的媒体类型 (MediaType) ?</h3><p>答：通过获取所有<code>HttpMessageConverter</code>支持的媒体类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractMessageConverterMethodArgumentResolver 类：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;MediaType&gt; <span class="title">getAllSupportedMediaTypes</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">truetrueSet&lt;MediaType&gt; allSupportedMediaTypes = <span class="keyword">new</span> LinkedHashSet&lt;MediaType&gt;();</span><br><span class="line">truetrue<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; messageConverter : messageConverters) &#123;</span><br><span class="line">truetruetrueallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueList&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(allSupportedMediaTypes);</span><br><span class="line">truetrueMediaType.sortBySpecificity(result);</span><br><span class="line">truetrue<span class="keyword">return</span> Collections.unmodifiableList(result);</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-针对Response对象如何获取可以生成的媒体类-MediaType"><a href="#spring-mvc-针对Response对象如何获取可以生成的媒体类-MediaType" class="headerlink" title="spring-mvc 针对Response对象如何获取可以生成的媒体类(MediaType) ?"></a>spring-mvc 针对Response对象如何获取可以生成的媒体类(MediaType) ?</h3><p>答：通过判断所有<code>HttpMessageConverter</code>是否可以转换(<code>canWrite</code>)Response对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AbstractMessageConverterMethodProcessor 类：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;MediaType&gt; <span class="title">getProducibleMediaTypes</span><span class="params">(HttpServletRequest request, Class&lt;?&gt; valueClass, Type declaredType)</span> </span>&#123;</span><br><span class="line">truetrueSet&lt;MediaType&gt; mediaTypes = (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">truetrue<span class="keyword">if</span> (!CollectionUtils.isEmpty(mediaTypes)) &#123;</span><br><span class="line">truetruetrue<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(mediaTypes);</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allSupportedMediaTypes.isEmpty()) &#123;</span><br><span class="line">truetruetrueList&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;();</span><br><span class="line">truetruetrue<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">truetruetruetrue<span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter &amp;&amp; declaredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">truetruetruetruetrue<span class="keyword">if</span> (((GenericHttpMessageConverter&lt;?&gt;) converter).canWrite(declaredType, valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">truetruetruetruetruetrueresult.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">truetruetruetruetrue&#125;</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">if</span> (converter.canWrite(valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">truetruetruetruetrueresult.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue<span class="keyword">return</span> result;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">else</span> &#123;</span><br><span class="line">truetruetrue<span class="keyword">return</span> Collections.singletonList(MediaType.ALL);</span><br><span class="line">truetrue&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-如何判断客户端请求的媒体类-MediaType"><a href="#spring-mvc-如何判断客户端请求的媒体类-MediaType" class="headerlink" title="spring-mvc 如何判断客户端请求的媒体类(MediaType) ?"></a>spring-mvc 如何判断客户端请求的媒体类(MediaType) ?</h3><p>答：通过<code>ContentNegotiationStrategy</code> 策略接口的实现类来判断。</p>
<ul>
<li>HeaderContentNegotiationStrategy 通过请求头<code>Accept</code></li>
<li>FixedContentNegotiationStrategy  固定类型</li>
<li>PathExtensionContentNegotiationStrategy  通过扩</li>
<li>ServletPathExtensionContentNegotiationStrategy 通过请求路径扩展名称 eg. user.json / user.xml</li>
<li>ParameterContentNegotiationStrategy 通过请求参数。user?format<strong>=</strong>json</li>
<li>OptionalPathExtensionContentNegotiationStrategy</li>
</ul>
<h3 id="spring-mvc-如何进行请求和响应内容的匹配和选择呢？"><a href="#spring-mvc-如何进行请求和响应内容的匹配和选择呢？" class="headerlink" title="spring-mvc 如何进行请求和响应内容的匹配和选择呢？"></a>spring-mvc 如何进行请求和响应内容的匹配和选择呢？</h3><p>答：根据请求的媒体类型和框架组件能生成的媒体类型进行匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithMessageConverters</span><span class="params">(T value, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, </span></span><br><span class="line"><span class="function">HttpMessageNotWritableException </span>&#123;</span><br><span class="line">true<span class="comment">//省略</span></span><br><span class="line">    Set&lt;MediaType&gt; compatibleMediaTypes = <span class="keyword">new</span> LinkedHashSet&lt;MediaType&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MediaType requestedType : requestedMediaTypes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MediaType producibleType : producibleMediaTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    </span><br><span class="line">    List&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(compatibleMediaTypes);</span><br><span class="line">true<span class="comment">//排序， 越是具体的媒体类型越靠前</span></span><br><span class="line">    MediaType.sortBySpecificityAndQuality(mediaTypes);</span><br><span class="line">    MediaType selectedMediaType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (MediaType mediaType : mediaTypes) &#123;</span><br><span class="line">        <span class="comment">// 选择第一个具体的媒体类型</span></span><br><span class="line">        <span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">            selectedMediaType = mediaType;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) &#123;</span><br><span class="line">            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-HttpMessageConverter-写入Response"><a href="#spring-mvc-HttpMessageConverter-写入Response" class="headerlink" title="spring-mvc HttpMessageConverter 写入Response"></a>spring-mvc HttpMessageConverter 写入Response</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedMediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">    <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; messageConverter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">        <span class="comment">//泛型实现</span></span><br><span class="line">        <span class="keyword">if</span> (messageConverter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((GenericHttpMessageConverter) messageConverter).canWrite(</span><br><span class="line">                declaredType, valueType, selectedMediaType)) &#123;</span><br><span class="line">                <span class="comment">// 可以对outputValue进行进一步处理，例如jsonp接口</span></span><br><span class="line">                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,</span><br><span class="line">                                                              (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(),</span><br><span class="line">                                                              inputMessage, outputMessage);</span><br><span class="line">                <span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">                    ((GenericHttpMessageConverter) messageConverter).write(</span><br><span class="line">                        outputValue, declaredType, selectedMediaType, outputMessage);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Written ["</span> + outputValue + <span class="string">"] as \""</span> + selectedMediaType +</span><br><span class="line">                                     <span class="string">"\" using ["</span> + messageConverter + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (messageConverter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">            outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,</span><br><span class="line">                                                          (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(),</span><br><span class="line">                                                          inputMessage, outputMessage);</span><br><span class="line">            <span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">                ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Written ["</span> + outputValue + <span class="string">"] as \""</span> + selectedMediaType +</span><br><span class="line">                                 <span class="string">"\" using ["</span> + messageConverter + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-返回jsonp"><a href="#spring-mvc-返回jsonp" class="headerlink" title="spring-mvc 返回jsonp"></a>spring-mvc 返回jsonp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FastJsonpResponseBodyAdvice <span class="title">fastJsonpResponseBodyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当请求参数有 callback 或 jsonp时，次Advice生效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastJsonpResponseBodyAdvice(<span class="string">"callback"</span>, <span class="string">"jsonp"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MediaType <span class="title">getContentType</span><span class="params">(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"javascript"</span>, Charsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 需要注意的是，如果是jsonp响应， <code>FastJsonHttpMessageConverter</code>会重新设置<code>Content-Type</code>响应头， 并且不带<code>charset</code>属性。1.2.28 没有问题。 为了修复安全漏洞，1.2.58有问题了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isJsonp = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不知道为什么会有这行代码， 但是为了保持和原来的行为一致，还是保留下来</span></span><br><span class="line">Object value = strangeCodeForJackson(object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> FastJsonContainer) &#123;</span><br><span class="line">    FastJsonContainer fastJsonContainer = (FastJsonContainer) value;</span><br><span class="line">    PropertyPreFilters filters = fastJsonContainer.getFilters();</span><br><span class="line">    allFilters.addAll(filters.getFilters());</span><br><span class="line">    value = fastJsonContainer.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//revise 2017-10-23 ,</span></span><br><span class="line"><span class="comment">// 保持原有的MappingFastJsonValue对象的contentType不做修改 保持旧版兼容。</span></span><br><span class="line"><span class="comment">// 但是新的JSONPObject将返回标准的contentType：application/javascript ，不对是否有function进行判断</span></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> MappingFastJsonValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(((MappingFastJsonValue) value).getJsonpFunction())) &#123;</span><br><span class="line">        isJsonp = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> JSONPObject) &#123;</span><br><span class="line">    isJsonp = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isJsonp) &#123;</span><br><span class="line">     <span class="comment">// 重新设置了Content-Type的值</span></span><br><span class="line">     headers.setContentType(APPLICATION_JAVASCRIPT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-内容协商"><a href="#spring-mvc-内容协商" class="headerlink" title="spring-mvc 内容协商"></a>spring-mvc 内容协商</h3><p>参考：<a href="https://junq.io/spring-mvc实现http内容协商-content-negotiation.html" target="_blank" rel="noopener">https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HttpMessageConverter-是什么？&quot;&gt;&lt;a href=&quot;#HttpMessageConverter-是什么？&quot; class=&quot;headerlink&quot; title=&quot;HttpMessageConverter 是什么？&quot;&gt;&lt;/a&gt;HttpMessageConverter 是什么？&lt;/h3&gt;&lt;p&gt;简单来说&lt;code&gt;HttpMessageConverter&lt;/code&gt;是spring-web提供的一个接口，用来将HTTP请求转为应用使用的数据，或将HTTP接口的返回数据转为客户端需要的数据。&lt;/p&gt;
&lt;p&gt;接口定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HttpMessageConverter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 根据参数判断该Converter是否能对请求进行转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 根据参数判断是否可以转换，生成指定的HTTP响应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canWrite&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * Return the list of &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; MediaType&amp;#125; objects supported by this converter.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the list of supported media types&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;List&amp;lt;MediaType&amp;gt; &lt;span class=&quot;title&quot;&gt;getSupportedMediaTypes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 从 inputMessage 读取数据，转为class指定的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;? extends T&amp;gt; clazz, HttpInputMessage inputMessage)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotReadableException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 将参数t指定的数据，转换为 contentType 指定的媒体类型，写入到HTTP响应。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t, MediaType contentType, HttpOutputMessage outputMessage)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotWritableException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://leokongwq.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>java 中的内存映射</title>
    <link href="https://leokongwq.github.io/2019/09/12/java-mmap.html"/>
    <id>https://leokongwq.github.io/2019/09/12/java-mmap.html</id>
    <published>2019-09-12T14:57:50.000Z</published>
    <updated>2019-12-14T04:01:23.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在阅读公司内部扩展的RocketMQ中延迟消息的实现代码，其中使用到了一个组件<code>MappedFile</code>。<code>MappedFile</code>就代表了一个mmap的文件。其实在很早前就了解到RMQ实现用使用了mmap技术，但是一直没有深入了解，借此机会就将Java中mmap的内容进行一次总结。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p> <code>mmap</code>是一个系统调用。它的作用是将一个文件或者其它对象的一部分内容映射到进程的地址空间。这样进程就可以直接读写这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间。通过<code>mmap</code>也可以实现不同进程间的共享内存。</p>
 <a id="more"></a>
<h3 id="Java中如何使用mmap"><a href="#Java中如何使用mmap" class="headerlink" title="Java中如何使用mmap"></a>Java中如何使用mmap</h3><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_MB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RandomAccessFile  raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/Users/jiexiu/a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    MappedByteBuffer mappedByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, TEN_MB);</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FileChannel-map方法详解"><a href="#FileChannel-map方法详解" class="headerlink" title="FileChannel.map方法详解"></a><code>FileChannel.map</code>方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>将FileChannle对于的文件的一部分直接映射到内存。（这里的内存是堆外内存）</li>
<li>映射模式可以是<code>MapMode.READ_ONLY</code>(只读)，<code>MapMode.READ_WRITE</code>(读写)，<code>MapMode.PRIVATE</code>（私有，写时复制）</li>
<li>如果是只读模式映射，那么文件通道必须是以只读模式打开。</li>
<li>方法返回的<code>MappedByteBuffer</code>的<code>position</code>是0，<code>limit</code> 和 <code>capacity</code>的值是参数<code>size</code>的值。</li>
<li>一旦映射完成，那么该<code>MappedByteBuffer</code>就和创建它的<code>FileChannel</code>无关。关闭<code>FileChannel</code>不会影响该<code>MappedByteBuffer</code>。</li>
<li>该方法的底层实现依赖于具体操作系统中mmap系统调用的实现逻辑。不同的操作系统可能表现不同。例如：程序修改了<code>MappedByteBuffer</code>的内容，操作系统何时将变更写入到磁盘，这个是不确定的。</li>
<li>对大多数操作系统来说该方法都是一个昂贵的操作，如果仅仅是映射很小范围，那么不建议使用。针对大文件推荐使用该操作。</li>
</ol>
<h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p><code>MappedByteBuffer</code>本质上是一块对外内存，也就是<code>DirectByteBuffer</code>。通过<code>FileChannel.map</code>来创建，直到被GC才结束它的生命。</p>
<p>它有两个非常重要的方法，分别是<code>load</code>和<code>force</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载该缓存的内容到物理内存中。这是因为mapp完成后，OS并没有直接读取文件的内容，当真正要访问的时候，通过缺页异常来进行读磁盘操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>force 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制将修改后的的内容写入到存储设备上。</span></span><br><span class="line"><span class="comment"> * 需要注意的是：如果是本地设备，那么该方法返回时，确保自从该缓存区创建后或该方法最后一次调用后，变更的内容一定写入了设备，如果是网络文件则没有该保证。</span></span><br><span class="line"><span class="comment"> * 如果不是通过`MapMode.READ_WRITE`模式映射的，调用该方法没有任何影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于force方法多说一点：即使我们不手动调动该方法写缓存区的更改写入底层设备，操作系统底层也会定时将变更的脏页刷到设备上，不过时间不确定。</p>
<p>MappedByteBuffer 在我们关闭FileChannel和文件后如果还没有被GC，那么对于的文件也是无法删除的，因为底层的文件句柄还没有释放。在RocketMQ中有专门针对该问题编写的代码。具体如下：</p>
<figure class="highlight java"><figcaption><span>MappedFile.clean</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">final</span> ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="keyword">null</span> || !buffer.isDirect() || buffer.capacity() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    invoke(invoke(viewed(buffer), <span class="string">"cleaner"</span>), <span class="string">"clean"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用是获取<code>DirectByteBuffer</code>中的<code>Cleaner</code>，然后调用它的<code>clean</code>方法来回收该<code>DirectByteBuffer</code>，也就是<code>MappedByteBuffer</code>。</p>
<p><code>Cleaner</code>底层是通过<code>unsafe.freeMemory(address);</code>来释放内存的。</p>
<h3 id="题外话-如何创建指定大小的文件"><a href="#题外话-如何创建指定大小的文件" class="headerlink" title="题外话 - 如何创建指定大小的文件"></a>题外话 - 如何创建指定大小的文件</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile  raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/Users/jiexiu/a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">raf.setLength(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>); <span class="comment">// 10M</span></span><br><span class="line">raf.close()</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    fos.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=hello.txt bs=100M count=1</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">文件IO操作的一些最佳实践</a><br><a href="https://how2playlife.com/2018/05/27/Javanet8/" target="_blank" rel="noopener">Java网络编程与NIO详解8：浅析mmap和Direct Buffer</a><br><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析mmap：是什么 为什么 怎么用</a><br><a href="https://blog.csdn.net/aitangyong/article/details/39455229" target="_blank" rel="noopener">使用sun.misc.Cleaner或者PhantomReference实现堆外内存的自动释放</a><br><a href="https://how2playlife.com/2018/05/27/Javanet8/" target="_blank" rel="noopener">Java网络编程与NIO详解8：浅析mmap和Direct Buffer</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在阅读公司内部扩展的RocketMQ中延迟消息的实现代码，其中使用到了一个组件&lt;code&gt;MappedFile&lt;/code&gt;。&lt;code&gt;MappedFile&lt;/code&gt;就代表了一个mmap的文件。其实在很早前就了解到RMQ实现用使用了mmap技术，但是一直没有深入了解，借此机会就将Java中mmap的内容进行一次总结。&lt;/p&gt;
&lt;h3 id=&quot;mmap&quot;&gt;&lt;a href=&quot;#mmap&quot; class=&quot;headerlink&quot; title=&quot;mmap&quot;&gt;&lt;/a&gt;mmap&lt;/h3&gt;&lt;p&gt; &lt;code&gt;mmap&lt;/code&gt;是一个系统调用。它的作用是将一个文件或者其它对象的一部分内容映射到进程的地址空间。这样进程就可以直接读写这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间。通过&lt;code&gt;mmap&lt;/code&gt;也可以实现不同进程间的共享内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mmap" scheme="https://leokongwq.github.io/tags/mmap/"/>
    
      <category term="RMQ" scheme="https://leokongwq.github.io/tags/RMQ/"/>
    
  </entry>
  
  <entry>
    <title>springboot配置activemq</title>
    <link href="https://leokongwq.github.io/2019/08/28/springboot-jms.html"/>
    <id>https://leokongwq.github.io/2019/08/28/springboot-jms.html</id>
    <published>2019-08-28T12:09:19.000Z</published>
    <updated>2019-08-28T13:54:24.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网上有好多介绍springboot集成activemq的文章，看了一些文章感觉比较零散，还是抽时间自己详细总结一个如何使用，需要注意哪些点。尤其是关于连接池的配置，需要重点关注，否则在消息量大的情况下会把服务器搞挂。</p>
<h3 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h3><p>如果你只是连接一个activemq集群或节点，那么配置非常简单(这也是springboot便捷的原因)。</p>
<p>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp:<span class="comment">//127.0.0.1:61616?connectionTimeout=3000&amp;soTimeout=500&amp;tcpNoDelay=true&amp;jms.redeliveryPolicy.maximumRedeliveries=1&amp;jms.redeliveryPolicy.initialRedeliveryDelay=10</span></span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br></pre></td></tr></table></figure>
<p>就这么简单！有了上面的配置你就可以发送消息了(通过JmsTemplate)。这背后的原理是通过springboot提供的<code>ActiveMQAutoConfiguration</code>来实现的。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(JmsAutoConfiguration.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; JndiConnectionFactoryAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; ConnectionFactory.class, ActiveMQConnectionFactory.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConnectionFactory.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ActiveMQProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; ActiveMQXAConnectionFactoryConfiguration.class,</span><br><span class="line">truetrueActiveMQConnectionFactoryConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>ActiveMQAutoConfiguration</code>的代码能得知，只要你的classpath里面存在<code>ConnectionFactory.class和ActiveMQConnectionFactory.class</code> 并且容器里面没有类型为<code>ConnectionFactory.class</code>的Bean，那么该自动配置组件就会生效。</p>
<p>通过<code>ActiveMQAutoConfiguration</code>，我们在spring容器中就能自动获取一个类型为<code>ConnectionFactory.class</code>的Bean 和 <code>JmsTemplate.class</code>的Bean。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(profiles = &#123;<span class="string">"dev"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSendAmqMsg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMsgDefault</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        jmsTemplate.convertAndSend(<span class="string">"java"</span>);</span><br><span class="line">        <span class="comment">//等待消费，因为是自发自消费</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实是不能正常工作的。原因是<code>jmsTemplate.convertAndSend</code>没有指定<code>Destination</code>。</p>
<p><code>Destination</code>的指定有两种方式，一种是通过方法参数指定。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmsTemplate.convertAndSend(<span class="string">"hello-jms-queue"</span>, <span class="string">"java"</span>);</span><br></pre></td></tr></table></figure>
<p>一种是通过在application.properties文件中指定一个默认值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.template.<span class="keyword">default</span>-destination=hello-jms-<span class="keyword">default</span></span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是<code>Destination</code>类型，是Topic还是Queue。默认是Queue。<code>Destination</code>类型也可以通过两种方式设置。</p>
<p>一种是通过在application.properties文件中指定一个默认值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># false 表示是Queue</span><br><span class="line">spring.jms.pub-sub-domain=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>一种是通过API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmsTemplate.setPubSubDomain(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上面的例子虽然能实现消息的发送和接收，但是非常有局限性。一个ActiveMQ上既有Topic也有Queue，我们通过<code>JmsTemplate</code>发送和消费消息时，最好是通过参数<code>Destination</code>来指定目的地，热不是一个字符串(不知道是具体是什么类型，只能通过全局配置)。</p>
</blockquote>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>有了上面的配置，我们可以有两种消费消息的方式。</p>
<ol>
<li>通过<code>JmsTemplate</code>的API来主动消费。这个就不详细讲了。</li>
<li>通过<code>@JmsListener</code>来被动消费</li>
</ol>
<p>通过<code>@JmsListener</code>来实现消息消费，配置如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(containerFactory = <span class="string">"jmsListenerContainerFactory"</span>, destination = <span class="string">"hello-jms"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"############# Received message is : ["</span> + msg + <span class="string">"]*************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableJms</code>的作用是启用spring的Jms的注解驱动能力。注册了<code>JmsListenerAnnotationBeanPostProcessor</code>Bean。原理如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(JmsBootstrapConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableJms &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsBootstrapConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = JmsListenerConfigUtils.JMS_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JmsListenerAnnotationBeanPostProcessor <span class="title">jmsListenerAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">new</span> JmsListenerAnnotationBeanPostProcessor();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span>(name = JmsListenerConfigUtils.JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> JmsListenerEndpointRegistry <span class="title">defaultJmsListenerEndpointRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">new</span> JmsListenerEndpointRegistry();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JmsAnnotationDrivenConfiguration</code>该配置类非常关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EnableJms.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JmsAnnotationDrivenConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactoryConfigurer <span class="title">jmsListenerContainerFactoryConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	DefaultJmsListenerContainerFactoryConfigurer configurer = <span class="keyword">new</span> DefaultJmsListenerContainerFactoryConfigurer();</span><br><span class="line">        	configurer.setDestinationResolver(<span class="keyword">this</span>.destinationResolver.getIfUnique());</span><br><span class="line">        	configurer.setTransactionManager(<span class="keyword">this</span>.transactionManager.getIfUnique());</span><br><span class="line">        	configurer.setMessageConverter(<span class="keyword">this</span>.messageConverter.getIfUnique());</span><br><span class="line">        	configurer.setJmsProperties(<span class="keyword">this</span>.properties);</span><br><span class="line">        	<span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span></span><br><span class="line">true<span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"jmsListenerContainerFactory"</span>)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			DefaultJmsListenerContainerFactoryConfigurer configurer,</span></span></span><br><span class="line"><span class="function"><span class="params">			ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">truetrueDefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">truetrueconfigurer.configure(factory, connectionFactory);</span><br><span class="line">truetrue<span class="keyword">return</span> factory;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置JmsTemplate属性"><a href="#配置JmsTemplate属性" class="headerlink" title="配置JmsTemplate属性"></a>配置JmsTemplate属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.template.<span class="keyword">default</span>-destination=hello-jms-<span class="keyword">default</span></span><br><span class="line">spring.jms.template.delivery-mode=non_persistent</span><br><span class="line">spring.jms.template.priority=<span class="number">100</span></span><br><span class="line">spring.jms.template.qos-enabled=<span class="keyword">true</span></span><br><span class="line">spring.jms.template.time-to-live=<span class="number">50</span></span><br><span class="line"># 设置消息延迟投递时间 需要jms 2.0 支持</span><br><span class="line">#spring.jms.template.delivery-delay=1</span><br><span class="line">spring.jms.template.receive-timeout=<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="配置消费属性"><a href="#配置消费属性" class="headerlink" title="配置消费属性"></a>配置消费属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 消息消费</span><br><span class="line">spring.jms.listener.acknowledge-mode=client</span><br><span class="line">spring.jms.listener.auto-startup=<span class="keyword">true</span></span><br><span class="line">spring.jms.listener.concurrency=<span class="number">10</span></span><br><span class="line">spring.jms.listener.max-concurrency=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h3><p>通过上面的学习，我们已经能实现消息的发送和消费了。但是有一个问题就是，我们会和ActiveMQ Broker建立大量的短连接。在高并发下肯定是不可以的。通过在<code>application.properties</code>中简单配置，我们就能获得连接池能力。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.14.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 只有配置了该选项，才会启用activemq连接池功能，参见：ActiveMQConnectionFactoryConfiguration</span><br><span class="line">spring.activemq.pool.enabled=<span class="keyword">true</span></span><br><span class="line"># 配置连接池参数</span><br><span class="line">spring.activemq.pool.configuration.max-connections=<span class="number">10</span></span><br><span class="line">spring.activemq.pool.configuration.idle-timeout=<span class="number">30000</span></span><br><span class="line">spring.activemq.pool.configuration.expiry-timeout=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">spring.activemq.pool.configuration.create-connection-on-startup=<span class="keyword">false</span></span><br><span class="line">spring.activemq.pool.configuration.time-between-expiration-check-millis=<span class="number">60000</span></span><br><span class="line">spring.activemq.pool.configuration.maximum-active-session-per-connection=<span class="number">100</span></span><br><span class="line">spring.activemq.pool.configuration.reconnect-on-exception=<span class="keyword">true</span></span><br><span class="line">spring.activemq.pool.configuration.block-<span class="keyword">if</span>-session-pool-is-full=<span class="keyword">true</span></span><br><span class="line">spring.activemq.pool.configuration.block-<span class="keyword">if</span>-session-pool-is-full-timeout=<span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h4 id="连接池自动配置实现原理"><a href="#连接池自动配置实现原理" class="headerlink" title="连接池自动配置实现原理"></a>连接池自动配置实现原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(PooledConnectionFactory.class)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledConnectionFactoryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span>(destroyMethod = <span class="string">"stop"</span>)</span><br><span class="line">true<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.activemq.pool"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">true<span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.activemq.pool.configuration"</span>)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> PooledConnectionFactory <span class="title">pooledJmsConnectionFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ActiveMQProperties properties)</span> </span>&#123;</span><br><span class="line">truetruePooledConnectionFactory pooledConnectionFactory = <span class="keyword">new</span> PooledConnectionFactory(</span><br><span class="line">truetruetruetrue<span class="keyword">new</span> ActiveMQConnectionFactoryFactory(properties)</span><br><span class="line">truetruetruetruetruetrue.createConnectionFactory(ActiveMQConnectionFactory.class));</span><br><span class="line"></span><br><span class="line">truetrueActiveMQProperties.Pool pool = properties.getPool();</span><br><span class="line">truetruepooledConnectionFactory.setMaxConnections(pool.getMaxConnections());</span><br><span class="line">truetruepooledConnectionFactory.setIdleTimeout(pool.getIdleTimeout());</span><br><span class="line">truetruepooledConnectionFactory.setExpiryTimeout(pool.getExpiryTimeout());</span><br><span class="line">truetrue<span class="keyword">return</span> pooledConnectionFactory;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个实现作为参考，如果我们不想使用springboot提供的<code>ActiveMQ</code>自动配置功能，我们自己写代码配置，也能实现连接池的功能，无非就是普通的<code>ActiveMQConnectionFactoryFactory</code>进行包装而已。</p>
<p>有一个细节需要注意：前置为<code>spring.activemq.pool.configuration</code>的配置属性是如何设置到<code>PooledConnectionFactory</code>的呢？但是是通过<code>ConfigurationPropertiesBindingPostProcessor</code> 该类会处理注解<code>ConfigurationProperties</code> 指定的属性，通过反射设置到生成的Bean中（在Bean初始化前）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相关代码地址:<a href="https://github.com/leokongwq/springboot-learn" target="_blank" rel="noopener">springboot-learn</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;网上有好多介绍springboot集成activemq的文章，看了一些文章感觉比较零散，还是抽时间自己详细总结一个如何使用，需要注意哪些点。尤其是关于连接池的配置，需要重点关注，否则在消息量大的情况下会把服务器搞挂。&lt;/p&gt;
&lt;h3 id=&quot;快速配置&quot;&gt;&lt;a href=&quot;#快速配置&quot; class=&quot;headerlink&quot; title=&quot;快速配置&quot;&gt;&lt;/a&gt;快速配置&lt;/h3&gt;&lt;p&gt;如果你只是连接一个activemq集群或节点，那么配置非常简单(这也是springboot便捷的原因)。&lt;/p&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.broker-url=tcp:&lt;span class=&quot;comment&quot;&gt;//127.0.0.1:61616?connectionTimeout=3000&amp;amp;soTimeout=500&amp;amp;tcpNoDelay=true&amp;amp;jms.redeliveryPolicy.maximumRedeliveries=1&amp;amp;jms.redeliveryPolicy.initialRedeliveryDelay=10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.user=admin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.password=admin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就这么简单！有了上面的配置你就可以发送消息了(通过JmsTemplate)。这背后的原理是通过springboot提供的&lt;code&gt;ActiveMQAutoConfiguration&lt;/code&gt;来实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="activemq" scheme="https://leokongwq.github.io/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>java agent技术学习总结</title>
    <link href="https://leokongwq.github.io/2019/08/25/java-agent-summary.html"/>
    <id>https://leokongwq.github.io/2019/08/25/java-agent-summary.html</id>
    <published>2019-08-25T13:18:49.000Z</published>
    <updated>2019-12-14T03:58:15.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>JVMDI：jvm debug interface jvm 调试接口。<br>JVMPI：jvm profile interface jvm 性能分析接口。<br>JVMTI：jvm tool interface jvm 工具接口，jdk1.5引入，用来替换JVMDI和JVMPI。</p>
<h3 id="JPDA"><a href="#JPDA" class="headerlink" title="JPDA"></a>JPDA</h3><p>JPDA： <a href="http://java.sun.com/products/jpda/" target="_blank" rel="noopener">Java Platform Debugger Architecture</a> SUN 公司提供的让你在各种场景加调试运行中的Java程序的技术。</p>
<h4 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h4><ol>
<li>JPDA 是一组帮助调试Java程序的API集合。</li>
<li>JPDA 不是一个应用程序或调试工具。</li>
<li>JPDA 是一组精心设计和实现的接口和协议。</li>
<li>debugger 调试程序</li>
<li>debuggee 被调试程序</li>
</ol>
<a id="more"></a>
<h3 id="JPDA-构成"><a href="#JPDA-构成" class="headerlink" title="JPDA 构成"></a>JPDA 构成</h3><p>JPDA 由三大部分组成：</p>
<ol>
<li>JVMTI（Java Virtual Machine Tools Interface） JVMTI 定义了一个VM必须提供的调试服务。</li>
<li>JDWP（The Java Debug Wire Protocol）JDWP 定义了调试程序和被调试程序间的交互协议。 </li>
<li>JDI (Java Debug Interface) JDI在用户代码级别定义调试信息和调试请求。</li>
</ol>
<p>JPAD 架构</p>
<img src="/2019/08/25/java-agent-summary/jpda.gif">
<p>debugger 和 debuggee 之间的通讯通道由两部分组成：</p>
<ol>
<li>连接器 connector。 一个 connector 是一个 JDI 对象，表示debugger 和 debuggee之间建立的连接。JPDA 定义了debugger 和 debuggee 之间有三种连接方式：<ul>
<li>listening: debugger 监听由debuggee发送的连接请求。</li>
<li>attaching: debugger 连接到运行中debuggee上，然后进行调试数据的传输。这是使用最多的方式。</li>
<li>launching: The front-end actually launches the Java process that will run the debuggee code and the back-end.</li>
</ul>
</li>
<li>传输通道 transport。 一个 transport 定义了debugger和debuggee底层之间交换数据的方式。<br>该数据传输机制规范没有规定，可选的机制有:socket, 串口，共享内存或其他方式。 但是传输的数据格式是由JDWP规定好的。</li>
</ol>
<h3 id="JPDA-使用"><a href="#JPDA-使用" class="headerlink" title="JPDA 使用"></a>JPDA 使用</h3><p>使用JPDA，需要在JVM命令行添加如下格式的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=&lt;name1&gt;[=&lt;value1&gt;],&lt;name2&gt;[=&lt;value2&gt;]</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">-Xrunjdwp:&lt;name1&gt;[=&lt;value1&gt;],&lt;name2&gt;[=&lt;value2&gt;]</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><ul>
<li>help: 输出详细的使用信息</li>
<li>transport: 一般都是用 dt_socket。</li>
<li>server: 参数值是<code>y</code>或<code>n</code>。如果设置为<code>y</code>，则等待debugger程序来连接。否则，连接到特定地址的debugger程序。</li>
<li>address: 连接的传输地址。如果<code>server</code>参数设置为<code>n</code>，则该地址为debugger的地址。如果<code>server</code>参数设置为<code>y</code>，则在改地址等待dubugger连接。</li>
<li>timeout: 连接超时的时间，单位为毫秒。</li>
<li>suspend: 如何设置为<code>y</code>，则JVM挂起执行流程，知道dubugger连接到该debuggee JVM。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.techrepublic.com/article/debug-your-java-code-with-ease-using-jpda/" target="_blank" rel="noopener">debug-your-java-code-with-ease-using-jpda</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/" target="_blank" rel="noopener">jpda</a><br><a href="http://www.fanyilun.me/2017/07/18/%E8%B0%88%E8%B0%88Java%20Intrumentation%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">谈谈Java Intrumentation和相关应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;p&gt;JVMDI：jvm debug interface jvm 调试接口。&lt;br&gt;JVMPI：jvm profile interface jvm 性能分析接口。&lt;br&gt;JVMTI：jvm tool interface jvm 工具接口，jdk1.5引入，用来替换JVMDI和JVMPI。&lt;/p&gt;
&lt;h3 id=&quot;JPDA&quot;&gt;&lt;a href=&quot;#JPDA&quot; class=&quot;headerlink&quot; title=&quot;JPDA&quot;&gt;&lt;/a&gt;JPDA&lt;/h3&gt;&lt;p&gt;JPDA： &lt;a href=&quot;http://java.sun.com/products/jpda/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java Platform Debugger Architecture&lt;/a&gt; SUN 公司提供的让你在各种场景加调试运行中的Java程序的技术。&lt;/p&gt;
&lt;h4 id=&quot;名词解释-1&quot;&gt;&lt;a href=&quot;#名词解释-1&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;JPDA 是一组帮助调试Java程序的API集合。&lt;/li&gt;
&lt;li&gt;JPDA 不是一个应用程序或调试工具。&lt;/li&gt;
&lt;li&gt;JPDA 是一组精心设计和实现的接口和协议。&lt;/li&gt;
&lt;li&gt;debugger 调试程序&lt;/li&gt;
&lt;li&gt;debuggee 被调试程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="java" scheme="https://leokongwq.github.io/categories/java/"/>
    
    
      <category term="java agent" scheme="https://leokongwq.github.io/tags/java-agent/"/>
    
  </entry>
  
  <entry>
    <title>hystrix学习总结</title>
    <link href="https://leokongwq.github.io/2019/08/10/hystrix-summary.html"/>
    <id>https://leokongwq.github.io/2019/08/10/hystrix-summary.html</id>
    <published>2019-08-10T11:36:33.000Z</published>
    <updated>2019-08-25T13:10:50.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hystrix是什么？"><a href="#hystrix是什么？" class="headerlink" title="hystrix是什么？"></a>hystrix是什么？</h3><p>官网对hystrix的定义如下：</p>
<blockquote>
<p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p>
</blockquote>
<p>个人理解如下：</p>
<ol>
<li>首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。</li>
<li>Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。</li>
</ol>
<a id="more"></a>
<h3 id="hystrix基本用法"><a href="#hystrix基本用法" class="headerlink" title="hystrix基本用法"></a>hystrix基本用法</h3><h4 id="HystrixCommand"><a href="#HystrixCommand" class="headerlink" title="HystrixCommand"></a>HystrixCommand</h4><p>使用Hystrix最简单直接的方式就是继承<code>HystrixCommand</code>对象并复写<code>run</code>方法。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂方法HystrixCommandGroupKey.Factory.asKey</span></span><br><span class="line">        <span class="comment">// 指定CommandGroup的名称</span></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意只有非 HystrixBadRequestException 才会触发fallback    </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fallback: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).execute();</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从名字也能看出来，需要在返回值上注册一个观察者来获取结果</span></span><br><span class="line">Observable&lt;String&gt; observable = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).observe();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">Observable&lt;String&gt; stringObservable1 = helloWorldCommand.toObservable();</span><br><span class="line"><span class="comment">// 注册观察者 获取结果</span></span><br><span class="line"><span class="comment">// 先执行onNext再执行onCompleted</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"onNext: "</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">truetrue</span><br><span class="line"><span class="comment">// 只有成功才会被回调</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">true<span class="comment">// 相当于上面的onNext()</span></span><br><span class="line">true<span class="comment">// @Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">truetrueSystem.out.println(<span class="string">"call: "</span> + v);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>execute</code>方法用来同步获取执行结果（内部还是通过线程池异步执行）内部逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queue</code> 通过返回一个<code>Future</code>来异步获取结果。</p>
<p><code>observe和toObservable</code> 通过返回一个<code>Observable</code>, 需要用户注册一个回调来接收调用结果。</p>
<p><code>observe</code> 和 <code>toObservable</code>的区别是：observe 在注册回调前就已经执行服务调用，toObservable是在注册回调后才开始执行。</p>
<h4 id="HystrixObservableCommand"><a href="#HystrixObservableCommand" class="headerlink" title="HystrixObservableCommand"></a>HystrixObservableCommand</h4><p>HystrixObservableCommand 和 HystrixCommand 功能是相同的。不过HystrixObservableCommand的定位是用在全异步的环境下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloHystrixObservableCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloHystrixObservableCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"HelloHystrixObservableCommand"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;String&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return Observable.just("1", "2", "3");</span></span><br><span class="line"><span class="comment">//        return Observable.just("Hello " + name);</span></span><br><span class="line"><span class="comment">//        return Observable.from(new String[]&#123;"1", "2"&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OnSubscribe 是一个Callback， 当 Observable被注册的时候会被执行</span></span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//remote http call</span></span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 写业务逻辑，注意try-catch</span></span><br><span class="line">                    <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">                        String result = restTemplate.getForObject(<span class="string">"http://www.jiexiu.com"</span>, String.class);</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        subscriber.onNext(result);</span><br><span class="line">                        subscriber.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    subscriber.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * fallback </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">resumeWithFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; observer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                        observer.onNext(<span class="string">"fallback-jiexiu"</span>);</span><br><span class="line">                        observer.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    observer.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HelloHystrixObservableCommand observableCommand =</span><br><span class="line">                <span class="keyword">new</span> HelloHystrixObservableCommand(<span class="string">"jiexiu"</span>);</span><br><span class="line">        Observable&lt;String&gt; observable = observableCommand.construct();</span><br><span class="line">        observable.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>Hystrix中实现优雅降级有2中方式：</p>
<ol>
<li>通过在HystrixCommand中添加<code>getFallback</code>方法</li>
<li>通过在HystrixObservableCommand中添加<code>resumeWithFallback</code>方法</li>
</ol>
<h4 id="fallback-触发时机"><a href="#fallback-触发时机" class="headerlink" title="fallback 触发时机"></a>fallback 触发时机</h4><ol>
<li>run方法或construct方法执行异常（非HystrixBadRequestException异常）。</li>
<li>run方法或construct方法超时</li>
<li>线程池满了或信号量为空</li>
<li>断路器处于打开状态</li>
</ol>
<p>注意: run方法抛出的所有异常中除了<code>HystrixBadRequestException</code>异常外都会被记录为失败，触发fallback，更新断路器统计信息。</p>
<h3 id="Hystrix-隔离机制"><a href="#Hystrix-隔离机制" class="headerlink" title="Hystrix 隔离机制"></a>Hystrix 隔离机制</h3><p>Hystrix有2中实现请求故障隔离的机制。一种是利用线程池，一种是使用信号量，默认是使用线程池。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));</span></span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-ThreadPool"</span>))</span><br><span class="line">            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(<span class="number">5</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withMaximumSize(<span class="number">10</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withKeepAliveTimeMinutes(<span class="number">5</span>) <span class="comment">//默认是1，单位为分钟</span></span><br><span class="line">                    .withMaxQueueSize(<span class="number">100</span>) <span class="comment">// 默认是-1, 意味着底层使用 SynchronousQueue, 该属性不能动态修改</span></span><br><span class="line">                    .withQueueSizeRejectionThreshold(<span class="number">80</span>)</span><br><span class="line">            )</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                    .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池机制很容易理解，不同的HystrixCommandGroup底层使用不同的线程池，彼此不干扰。<br>可以通过<code>andThreadPoolKey</code>配置了线程池的名称。如果没有通过<code>andThreadPoolKey</code>来设置线程池的名称，默认使用<code>withGroupKey</code>设置的名称。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-Semaphore-ThreadPool"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                        .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">3</span>) </span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="熔断器-CircuitBreaker"><a href="#熔断器-CircuitBreaker" class="headerlink" title="熔断器 CircuitBreaker"></a>熔断器 CircuitBreaker</h3><p>通常有2</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>HystrixCommandGroupKey 需要指定，用来将不同的HystrixCommand组织起来</p>
<p>HystrixCommandKey 的默认值是 Command的类名称(不带包名)，也可以单独指定。</p>
<p>HystrixThreadPoolKey 的默认值是 HystrixCommandGroupKey。但是建议手动指定HystrixCommand执行的<code>HystrixThreadPool</code>的名称。因为同属一个Group下的Command可能需要在不同的<code>HystrixThreadPool</code>中隔离执行。</p>
<p>在fallback的处理中，如果需要调用一个远程服务获取值(e.g. 查询缓存) 那么最好使用单独的线程池来执行，否则可能由于主Command的执行线程池已经满了导致fallback不能正常工作。</p>
<img src="/2019/08/10/hystrix-summary/fallback-via-command-640.png">
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hystrix是什么？&quot;&gt;&lt;a href=&quot;#hystrix是什么？&quot; class=&quot;headerlink&quot; title=&quot;hystrix是什么？&quot;&gt;&lt;/a&gt;hystrix是什么？&lt;/h3&gt;&lt;p&gt;官网对hystrix的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人理解如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。&lt;/li&gt;
&lt;li&gt;Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hystrix" scheme="https://leokongwq.github.io/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>spring SpEL表达式</title>
    <link href="https://leokongwq.github.io/2019/04/17/spring-spel.html"/>
    <id>https://leokongwq.github.io/2019/04/17/spring-spel.html</id>
    <published>2019-04-17T02:25:27.000Z</published>
    <updated>2019-08-02T14:46:15.687Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自：<a href="https://blog.csdn.net/zhoudaxia/article/details/38174169" target="_blank" rel="noopener">https://blog.csdn.net/zhoudaxia/article/details/38174169</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1  概述"></a>1.1  概述</h3><p>　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>　　表达式语言给静态Java语言增加了动态功能。</p>
<p>　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h3 id="1-2-能干什么"><a href="#1-2-能干什么" class="headerlink" title="1.2  能干什么"></a>1.2  能干什么</h3><p>　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>　　SpEL支持如下表达式：</p>
<p>　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p>　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p>　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p>　　四、其他表达式：模板表达式。</p>
<p>　　注：SpEL表达式中的关键字是不区分大小写的。</p>
<a id="more"></a>
<h2 id="2-SpEL基础"><a href="#2-SpEL基础" class="headerlink" title="2. SpEL基础"></a>2. SpEL基础</h2><h3 id="2-1-HelloWorld"><a href="#2-1-HelloWorld" class="headerlink" title="2.1  HelloWorld"></a>2.1  HelloWorld</h3><p>首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>让我们看下代码片段吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> junit.framework.Assert;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">        Expression expression =  </span><br><span class="line">            parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);  </span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);  </span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<ol>
<li>创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</li>
<li>解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据。</li>
<li>求值：通过Expression接口的getValue方法根据上下文获得表达式值。</li>
</ol>
<p>　　是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h3 id="2-3-SpEL原理及接口"><a href="#2-3-SpEL原理及接口" class="headerlink" title="2.3  SpEL原理及接口"></a>2.3  SpEL原理及接口</h3><p>SpEL提供简单的接口从而简化用户使用，在介绍原理前让我们学习下几个概念：</p>
<p>一、表达式：表达式是表达式语言的核心，所以表达式语言都是围绕表达式进行的，从我们角度来看是“干什么”；</p>
<p>二、解析器：用于将字符串表达式解析为表达式对象，从我们角度来看是“谁来干”；</p>
<p>三、上下文：表达式对象执行的环境，该环境可能定义变量、定义自定义函数、提供类型转换等等，从我们角度看是“在哪干”；</p>
<p>四、根对象及活动上下文对象：根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象，从我们角度看是“对谁干”。</p>
<p>理解了这些概念后，让我们看下SpEL如何工作的呢，如图5-1所示</p>
<img src="/2019/04/17/spring-spel/20140727174757196.jpg">
<p>1）首先定义表达式：“1+2”；</p>
<p>2）定义解析器ExpressionParser实现，SpEL提供默认实现SpelExpressionParser；</p>
<p>　　2.1）SpelExpressionParser解析器内部使用Tokenizer类进行词法分析，即把字符串流分析为记号流，记号在SpEL使用Token类来表示；</p>
<p>　　2.2）有了记号流后，解析器便可根据记号流生成内部抽象语法树；在SpEL中语法树节点由SpelNode接口实现代表：如OpPlus表示加操作节点、IntLiteral表示int型字面量节点；使用SpelNodel实现组成了抽象语法树；</p>
<p>　　2.3）对外提供Expression接口来简化表示抽象语法树，从而隐藏内部实现细节，并提供getValue简单方法用于获取表达式值；SpEL提供默认实现为SpelExpression；</p>
<p>3）定义表达式上下文对象（可选），SpEL使用EvaluationContext接口表示上下文对象，用于设置根对象、自定义变量、自定义函数、类型转换器等，SpEL提供默认实现StandardEvaluationContext；</p>
<p>4）使用表达式对象根据上下文对象（可选）求值（调用表达式对象的getValue方法）获得结果。</p>
<p>接下来让我们看下SpEL的主要接口吧：</p>
<h4 id="ExpressionParser"><a href="#ExpressionParser" class="headerlink" title="ExpressionParser"></a>ExpressionParser</h4><p>ExpressionParser接口：表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpressionParser</span> </span>&#123;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString)</span></span>;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParserContext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#&#123;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#125;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    String template = <span class="string">"#&#123;'Hello '&#125;#&#123;'World!'&#125;"</span>;  </span><br><span class="line">    Expression expression = parser.parseExpression(template, parserContext);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此我们演示的是使用ParserContext的情况，此处定义了ParserContext实现：定义表达式是模块，表达式前缀为<code>#{”，后缀为“}</code>；使用parseExpression解析时传入的模板必须以<code>#{”开头，以“}</code>结尾，如<code>#{&#39;Hello &#39;}#{&#39;World!&#39;}</code>。</p>
<p>默认传入的字符串表达式不是模板形式，如之前演示的Hello World。</p>
<h4 id="EvaluationContext"><a href="#EvaluationContext" class="headerlink" title="EvaluationContext"></a>EvaluationContext</h4><p>EvaluationContext接口：表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。</p>
<h4 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h4><p>Expression接口：表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。</p>
<p>了解了SpEL原理及接口，接下来的事情就是SpEL语法了。</p>
<h2 id="SpEL-语法"><a href="#SpEL-语法" class="headerlink" title="SpEL 语法"></a>SpEL 语法</h2><h3 id="字面量表达式："><a href="#字面量表达式：" class="headerlink" title="字面量表达式："></a>字面量表达式：</h3><p>SpEL支持的字面量包括：字符串、数字类型（int、long、float、double）、布尔类型、null类型。</p>
<p>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = parser.parseExpression(<span class="string">"'Hello World!'"</span>).getValue(String.class);</span><br><span class="line">String str2 = parser.parseExpression(<span class="string">"\"Hello World!\""</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>
<p>数字类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = parser.parseExpression(<span class="string">"1"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> long1 = parser.parseExpression(<span class="string">"-1L"</span>).getValue(<span class="keyword">long</span>.class);</span><br><span class="line"><span class="keyword">float</span> float1 = parser.parseExpression(<span class="string">"1.1"</span>).getValue(Float.class);</span><br><span class="line"><span class="keyword">double</span> double1 = parser.parseExpression(<span class="string">"1.1E+2"</span>).getValue(<span class="keyword">double</span>.class);</span><br><span class="line"><span class="keyword">int</span> hex1 = parser.parseExpression(<span class="string">"0xa"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> hex2 = parser.parseExpression(<span class="string">"0xaL"</span>).getValue(<span class="keyword">long</span>.class);</span><br></pre></td></tr></table></figure>
<p>boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> true1 = parser.parseExpression(<span class="string">"true"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="keyword">boolean</span> false1 = parser.parseExpression(<span class="string">"false"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br></pre></td></tr></table></figure>
<p>null 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object null1 = parser.parseExpression(<span class="string">"null"</span>).getValue(Object.class);</span><br></pre></td></tr></table></figure>
<h3 id="算数运算表达式"><a href="#算数运算表达式" class="headerlink" title="算数运算表达式"></a>算数运算表达式</h3><p>算数运算表达式： SpEL支持加(+)、减(-)、乘(*)、除(/)、求余（%）、幂（^）运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"1+2-3*4/2"</span>).getValue(Integer.class);<span class="comment">//-3</span></span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"4%3"</span>).getValue(Integer.class);<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"2^3"</span>).getValue(Integer.class);<span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>　SpEL还提供求余（MOD）和除（DIV）而外两个运算符，与“%”和“/”等价，不区分大小写。</p>
</blockquote>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>关系表达式：等于（==）、不等于(!=)、大于(&gt;)、大于等于(&gt;=)、小于(&lt;)、小于等于(&lt;=)，区间（between）运算，如<code>parser.parseExpression(&quot;1&gt;2&quot;).getValue(boolean.class);</code>将返回false；而<code>parser.parseExpression(&quot;1 between {1, 2}&quot;).getValue(boolean.class);</code>将返回true。</p>
<p>between运算符右边操作数必须是列表类型，且只能包含2个元素。第一个元素为开始，第二个元素为结束，区间运算是包含边界值的，即 xxx&gt;=list.get(0) &amp;&amp; xxx&lt;=list.get(1)。</p>
<p>SpEL同样提供了等价的“EQ” 、“NE”、 “GT”、“GE”、 “LT” 、“LE”来表示等于、不等于、大于、大于等于、小于、小于等于，不区分大小写。</p>
<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>逻辑表达式：且（and）、或(or)、非(!或NOT)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String expression1 = <span class="string">"2&gt;1 and (!true or !false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result1);  </span><br><span class="line">   </span><br><span class="line">String expression2 = <span class="string">"2&gt;1 and (NOT true or NOT false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result2 = parser.parseExpression(expression2).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑运算符不支持 Java中的 &amp;&amp; 和 || 。</p>
</blockquote>
<h3 id="字符串连接及截取表达式"><a href="#字符串连接及截取表达式" class="headerlink" title="字符串连接及截取表达式"></a>字符串连接及截取表达式</h3><p>字符串连接及截取表达式：使用“+”进行字符串连接，使用“’String’[0] [index]”来截取一个字符，目前只支持截取一个，如“’Hello ‘ + ‘World!’”得到“Hello World!”；而“’Hello World!’[0]”将返回“H”。</p>
<h3 id="三目运算及Elivis运算表达式："><a href="#三目运算及Elivis运算表达式：" class="headerlink" title="三目运算及Elivis运算表达式："></a>三目运算及Elivis运算表达式：</h3><p>三目运算符 “表达式1?表达式2:表达式3”用于构造三目运算表达式，如“2&gt;1?true:false”将返回true；</p>
<p>Elivis运算符“表达式1?:表达式2”从Groovy语言引入用于简化三目运算符的，当表达式1为非null时则返回表达式1，当表达式1为null时则返回表达式2，简化了三目运算符方式“表达式1? 表达式1:表达式2”，如“null?:false”将返回false，而“true?:false”将返回true；</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>使用“str matches regex，如“’123’ matches ‘\d{3}’”将返回true；</p>
<h3 id="括号优先级表达式"><a href="#括号优先级表达式" class="headerlink" title="括号优先级表达式"></a>括号优先级表达式</h3><p>括号优先级表达式：使用“(表达式)”构造，括号里的具有高优先级。</p>
<h3 id="类相关表达式"><a href="#类相关表达式" class="headerlink" title="类相关表达式"></a>类相关表达式</h3><p>一、类类型表达式：使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>
<p>具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassTypeExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    <span class="comment">//java.lang包类访问  </span></span><br><span class="line">    Class&lt;String&gt; result1 = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);  </span><br><span class="line">    Assert.assertEquals(String.class, result1);  </span><br><span class="line">    <span class="comment">//其他包类访问  </span></span><br><span class="line">    String expression2 = <span class="string">"T(cn.javass.spring.chapter5.SpELTest)"</span>;  </span><br><span class="line">    Class&lt;String&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);</span><br><span class="line">    Assert.assertEquals(SpELTest.class, result2);  </span><br><span class="line">    <span class="comment">//类静态字段访问  </span></span><br><span class="line">    <span class="keyword">int</span> result3=parser.parseExpression(<span class="string">"T(Integer).MAX_VALUE"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(Integer.MAX_VALUE, result3);  </span><br><span class="line">    <span class="comment">//类静态方法调用  </span></span><br><span class="line">    <span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"T(Integer).parseInt('1')"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, result4);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于java.lang包里的可以直接使用“T(String)”访问；其他包必须是类全限定名；可以进行静态字段访问如“T(Integer).MAX_VALUE”；也可以进行静态方法访问如“T(Integer).parseInt(‘1’)”。<br>　<br>二、类实例化：类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructorExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"new String('haha')"</span>).getValue(String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">    Date result2 = parser.parseExpression(<span class="string">"new java.util.Date()"</span>).getValue(Date.class);  </span><br><span class="line">    Assert.assertNotNull(result2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化完全跟Java内方式一样。</p>
<p>三，instanceof表达式：SpEL支持instanceof运算符，跟Java内使用同义；如“’haha’ instanceof T(String)”将返回true。</p>
<p>四， 变量定义及引用：变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用“#variableName”引用；除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用“#root”引用根对象，使用“#this”引用当前上下文对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"#variable"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">   </span><br><span class="line">    context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">"haha"</span>);  </span><br><span class="line">    String result2 = parser.parseExpression(<span class="string">"#root"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result2);  </span><br><span class="line">    String result3 = parser.parseExpression(<span class="string">"#this"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>#variable</code>来引用在<code>EvaluationContext</code>定义的变量；除了可以引用自定义变量，还可以使用<code>#root</code>引用根对象，<code>#this</code>引用当前上下文对象，此处<code>#this</code>即根对象。</p>
<p>五、自定义函数：目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionExpression</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException, NoSuchMethodException </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    Method parseInt = Integer.class.getDeclaredMethod(<span class="string">"parseInt"</span>, String.class);  </span><br><span class="line">    context.registerFunction(<span class="string">"parseInt"</span>, parseInt);  </span><br><span class="line">    context.setVariable(<span class="string">"parseInt2"</span>, parseInt);  </span><br><span class="line">    String expression1 = <span class="string">"#parseInt('3') == #parseInt2('3')"</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(context, <span class="keyword">boolean</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, result1);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处可以看出<code>registerFunction</code>和<code>setVariable</code>都可以注册自定义函数，但是两个方法的含义不一样，推荐使用<code>registerFunction</code>方法注册自定义函数。</p>
<p>六、赋值表达式：SpEL即允许给自定义变量赋值，也允许给根对象赋值，直接使用<code>#variableName=value</code>即可赋值：</p>
<p>使用<code>#root=&#39;aaaaa&#39;</code>给根对象赋值，使用“”#this=’aaaa’”给当前上下文对象赋值，使用<code>#variable=#root</code>给自定义变量赋值，很简单。</p>
<p>七、对象属性存取及安全导航表达式：对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；SpEL还引入了Groovy语言中的安全导航运算符“(对象|属性)?.属性”，用来避免“?.”前边的表达式为null时抛出空指针异常，而是返回null；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line"><span class="comment">//1.访问root对象属性  </span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result1);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于当前上下文对象属性及方法访问，可以直接使用属性或方法名访问，比如此处根对象date属性<code>year</code>，注意此处属性名首字母不区分大小写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.安全访问  </span></span><br><span class="line">context.setRootObject(<span class="keyword">null</span>);  </span><br><span class="line">Object result3 = parser.parseExpression(<span class="string">"#root?.year"</span>).getValue(context, Object.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">null</span>, result3);</span><br></pre></td></tr></table></figure>
<p>SpEL引入了Groovy的安全导航运算符，比如此处根对象为null，所以如果访问其属性时肯定抛出空指针异常，而采用“?.”安全访问导航运算符将不抛空指针异常，而是简单的返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.给root对象属性赋值  </span></span><br><span class="line">context.setRootObject(date);  </span><br><span class="line"><span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"Year = 4"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result4);  </span><br><span class="line">parser.parseExpression(<span class="string">"Year"</span>).setValue(context, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">int</span> result5 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">5</span>, result5);</span><br></pre></td></tr></table></figure>
<p>给对象属性赋值可以采用赋值表达式或Expression接口的setValue方法赋值，而且也可以采用点缀方式赋值。</p>
<p>八、对象方法调用：对象方法调用更简单，跟Java语法一样；如“’haha’.substring(2,4)”将返回“ha”；而对于根对象可以直接调用方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"getYear()"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<p>比如根对象date方法“getYear”可以直接调用。</p>
<p>九、Bean引用：SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext();  </span><br><span class="line">    ctx.refresh();  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(ctx));  </span><br><span class="line">    Properties result1 = parser.parseExpression(<span class="string">"@systemProperties"</span>).getValue(context, Properties.class);  </span><br><span class="line">    Assert.assertEquals(System.getProperties(), result1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中我们首先初始化了一个IoC容器，ClassPathXmlApplicationContext 实现默认会把“System.getProperties()”注册为“systemProperties”Bean，因此我们使用 “@systemProperties”来引用该Bean。</p>
<h3 id="集合相关表达式"><a href="#集合相关表达式" class="headerlink" title="集合相关表达式"></a>集合相关表达式</h3><p>内联List</p>
<p>从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List，如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将返回不可修改的空List  </span></span><br><span class="line">List&lt;Integer&gt; result2 = parser.parseExpression(<span class="string">"&#123;&#125;"</span>).getValue(List.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于字面量列表也将返回不可修改的List  </span></span><br><span class="line">List&lt;Integer&gt; result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;"</span>).getValue(List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">1</span>), result1.get(<span class="number">0</span>));  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result1.set(<span class="number">0</span>, <span class="number">2</span>);  </span><br><span class="line">    <span class="comment">//不可能执行到这，对于字面量列表不可修改  </span></span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于列表中只要有一个不是字面量表达式，将只返回原始List，  </span></span><br><span class="line"><span class="comment">//不会进行不可修改处理  </span></span><br><span class="line">String expression3 = <span class="string">"&#123;&#123;1+2,2+4&#125;,&#123;3,4+4&#125;&#125;"</span>;  </span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result3 = parser.parseExpression(expression3).getValue(List.class);  </span><br><span class="line">result3.get(<span class="number">0</span>).set(<span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3.size());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/声明二维数组并初始化  </span><br><span class="line"><span class="keyword">int</span>[] result2 = parser.parseExpression(<span class="string">"new int[2]&#123;1,2&#125;"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一维数组并初始化  </span></span><br><span class="line"><span class="keyword">int</span>[] result1 = parser.parseExpression(<span class="string">"new int[1]"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<p>内联数组</p>
<p>和Java 数组定义类似，只是在定义时进行多维数组初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义多维数组但不初始化  </span></span><br><span class="line"><span class="keyword">int</span>[][][] result3 = parser.parseExpression(expression3).getValue(<span class="keyword">int</span>[][][].class);</span><br></pre></td></tr></table></figure>
<p>错误的定义多维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的定义多维数组，多维数组不能初始化  </span></span><br><span class="line">String expression4 = <span class="string">"new int[1][2][3]&#123;&#123;1&#125;&#123;2&#125;&#123;3&#125;&#125;"</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">int</span>[][][] result4 = parser.parseExpression(expression4).getValue(<span class="keyword">int</span>[][][].class);  </span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br></pre></td></tr></table></figure>
<p>集合，字典元素访问</p>
<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL内联List访问  </span></span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;[0]"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//即list.get(0)  </span></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL目前支持所有集合类型的访问  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//对于任何集合类型通过Iterator来定位元素  </span></span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL对Map字典元素访问的支持  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a']"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result3);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：集合元素访问是通过Iterator遍历来定位元素位置的。</p>
</blockquote>
<p>四、列表，字典，数组元素修改：</p>
<p>可以使用赋值表达式或Expression接口的setValue方法修改；<br>　　<br>修改数组元素值<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.修改数组元素值  </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"array"</span>, array);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"#array[1] = 3"</span>).getValue(context1, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result1);</span><br></pre></td></tr></table></figure></p>
<p>修改集合值  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.修改集合值  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1] = 3"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result2);  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection[1]"</span>).setValue(context2, <span class="number">4</span>);  </span><br><span class="line">result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result2);</span><br></pre></td></tr></table></figure>
<p>修改map元素值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.修改map元素值  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a'] = 2"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3);</span><br></pre></td></tr></table></figure>
<p>对数组修改直接对“#array[index]”赋值即可修改元素值，同理适用于集合和字典类型。</p>
<p>五、集合投影：</p>
<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.测试集合或数组  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.![#this+1]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“#this”代表每个集合或数组元素，可以使用比如“#this.property”来获取集合元素的属性，其中“#this”可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.测试字典  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">List&lt;Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.![ value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2.size());</span><br></pre></td></tr></table></figure>
<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。</p>
<p>六、集合选择：</p>
<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.集合或数组测试  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.?[#this&gt;4]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组选择，如“#collection.?[#this&gt;4]”将选择出集合元素值大于4的所有元素。选择表达式必须返回布尔类型，使用“#this”表示当前元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.字典测试  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">Map&lt;String, Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.?[#this.key != 'a']"</span>).getValue(context2, Map.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result2.size());  </span><br><span class="line">   </span><br><span class="line">List&lt;Integer&gt; result3 =  </span><br><span class="line">    parser.parseExpression(<span class="string">"#map.?[key != 'a'].![value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">3</span>), result3.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于字典选择，如“#map.?[#this.key != ‘a’]”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != ‘a’].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。</p>
<h2 id="表达式模板"><a href="#表达式模板" class="headerlink" title="表达式模板"></a>表达式模板</h2><p>模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由<code>前缀+表达式+后缀</code>形式组成，如<code>${1+2}</code>即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了。</p>
<h3 id="在Bean定义中使用EL"><a href="#在Bean定义中使用EL" class="headerlink" title="在Bean定义中使用EL"></a>在Bean定义中使用EL</h3><p>xml风格的配置</p>
<p>SpEL支持在Bean定义时注入，默认使用<code>#{SpEL表达式}</code>表示，其中“#root”根对象默认可以认为是ApplicationContext，只有ApplicationContext实现默认支持SpEL，获取根对象属性其实是获取容器中的Bean。</p>
<p>首先看下配置方式吧：<br>　　<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello'&#125;#&#123;world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;    </span><br><span class="line">&lt;bean id=<span class="string">"hello2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">    &lt;!-- 不支持嵌套的 --&gt;  </span><br><span class="line">    &lt;!--&lt;constructor-arg value=<span class="string">"#&#123;'Hello'#&#123;world&#125;&#125;"</span>/&gt;--&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + @world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>模板默认以前缀<code>#{”开头，以后缀“}</code>结尾，且不允许嵌套，如<code>#{&#39;Hello&#39;#{world}}</code>错误，如<code>#{&#39;Hello&#39; + world}</code>中“world”默认解析为Bean。当然可以使用“@bean”引用了。<br>接下来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testXmlExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el1.xml"</span>);  </span><br><span class="line">    String hello1 = ctx.getBean(<span class="string">"hello1"</span>, String.class);  </span><br><span class="line">    String hello2 = ctx.getBean(<span class="string">"hello2"</span>, String.class);  </span><br><span class="line">    String hello3 = ctx.getBean(<span class="string">"hello3"</span>, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello1);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello2);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，除了XML配置方式，Spring还提供一种注解方式@Value，接着往下看吧。</p>
<h3 id="注解风格的配置"><a href="#注解风格的配置" class="headerlink" title="注解风格的配置"></a>注解风格的配置</h3><p>基于注解风格的SpEL配置也非常简单，使用@Value注解来指定SpEL表达式，该注解可以放到字段、方法及方法参数上。</p>
<p>测试Bean类如下，使用@Value来指定SpEL表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBean</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'Hello' + world&#125;"</span>)  </span><br><span class="line">    <span class="keyword">private</span> String value;  </span><br><span class="line">    <span class="comment">//setter和getter由于篇幅省略，自己写上  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看下配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">        xsi:schemaLocation=&quot;  </span><br><span class="line">          http://www.springframework.org/schema/beans  </span><br><span class="line">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span><br><span class="line">          http://www.springframework.org/schema/context  </span><br><span class="line">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean id=&quot;world&quot; class=&quot;java.lang.String&quot;&gt;  </span><br><span class="line">       &lt;constructor-arg value=&quot;#&#123;&apos; World!&apos;&#125;&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean1&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;/&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean2&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;&gt;  </span><br><span class="line">       &lt;property name=&quot;value&quot; value=&quot;haha&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置时必须使用“<context:annotation-config>”来开启对注解的支持。<br>有了配置文件那开始测试吧：</context:annotation-config></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el2.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中“helloBean1 ”值是SpEL表达式的值，而“helloBean2”是通过setter注入的值，这说明setter注入将覆盖@Value的值。</p>
<h3 id="在Bean定义中SpEL的问题"><a href="#在Bean定义中SpEL的问题" class="headerlink" title="在Bean定义中SpEL的问题"></a>在Bean定义中SpEL的问题</h3><p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 ConfigurableListableBeanFactory的getBeanExpressionResolver方法获取BeanExpressionResolver实现，其次强制类型转换为StandardBeanExpressionResolver，其为Spring默认实现，然后改掉前缀及后缀。</p>
<p>开始测试吧，首先准备配置文件(chapter5/el3.xml)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;  </span><br><span class="line">&lt;beans  xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        xsi:schemaLocation=<span class="string">"  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">       &lt;constructor-arg value=<span class="string">"%&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>&gt;  </span><br><span class="line">       &lt;property name=<span class="string">"value"</span> value=<span class="string">"%&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件和注解风格的几乎一样，只有SpEL表达式前缀变为<code>%{</code>了，并且注册了“cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor” Bean，用于修改前缀和后缀的。</p>
<p>写测试代码测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPrefixExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el3.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"#&#123;'Hello' + world&#125;"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处helloBean1中通过@Value注入的<code>#{&#39;Hello&#39; + world}</code>结果还是<code>#{&#39;Hello&#39; + world}</code>说明不对其进行SpEL表达式求值了，而helloBean2使用<code>%{&#39;Hello&#39; + world}</code>注入，得到正确的“”Hello World!”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转载自：&lt;a href=&quot;https://blog.csdn.net/zhoudaxia/article/details/38174169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zhoudaxia/article/details/38174169&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1  概述&quot;&gt;&lt;/a&gt;1  概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1  概述&quot;&gt;&lt;/a&gt;1.1  概述&lt;/h3&gt;&lt;p&gt;　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。&lt;/p&gt;
&lt;p&gt;　　表达式语言给静态Java语言增加了动态功能。&lt;/p&gt;
&lt;p&gt;　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;/p&gt;
&lt;h3 id=&quot;1-2-能干什么&quot;&gt;&lt;a href=&quot;#1-2-能干什么&quot; class=&quot;headerlink&quot; title=&quot;1.2  能干什么&quot;&gt;&lt;/a&gt;1.2  能干什么&lt;/h3&gt;&lt;p&gt;　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。&lt;/p&gt;
&lt;p&gt;　　SpEL支持如下表达式：&lt;/p&gt;
&lt;p&gt;　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；&lt;/p&gt;
&lt;p&gt;　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；&lt;/p&gt;
&lt;p&gt;　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；&lt;/p&gt;
&lt;p&gt;　　四、其他表达式：模板表达式。&lt;/p&gt;
&lt;p&gt;　　注：SpEL表达式中的关键字是不区分大小写的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql中字段究竟该不该为null</title>
    <link href="https://leokongwq.github.io/2019/01/05/mysql-null-column.html"/>
    <id>https://leokongwq.github.io/2019/01/05/mysql-null-column.html</id>
    <published>2019-01-05T01:54:48.000Z</published>
    <updated>2019-02-15T06:44:31.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么会有许多表的字段设置为null？"><a href="#为什么会有许多表的字段设置为null？" class="headerlink" title="为什么会有许多表的字段设置为null？"></a>为什么会有许多表的字段设置为null？</h3><ol>
<li>开发中常用的建表工具创建表时字段默认可以为null。</li>
<li>开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。</li>
<li>默认为null，在插入数据时可以少很多判断</li>
</ol>
<p>针对这些问题，下面就彻底搞清楚字段该不该为null。    </p>
<h3 id="null-字段可以节省空间吗？"><a href="#null-字段可以节省空间吗？" class="headerlink" title="null 字段可以节省空间吗？"></a>null 字段可以节省空间吗？</h3><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>MySQL官方文档有如下的描述：</p>
<blockquote>
<p>For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>从上面的描述中可以知道，在MyISAM中<code>NULL</code>字段并不能完全的节省空间。</p>
<a id="more"></a>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB 表的行格式</p>
<img src="/2019/01/05/mysql-null-column/mysql_innodb_row_format.png">
<p>平时使用COMPACT格式的行较多，正对该格式，文档有如下的说明。</p>
<blockquote>
<p>The variable-length part of the record header contains a bit vector for indicating NULL columns. If the number of columns in the index that can be NULL is N, the bit vector occupies CEILING(N/8) bytes. (For example, if there are anywhere from 9 to 16 columns that can be NULL, the bit vector uses two bytes.) Columns that are NULL do not occupy space other than the bit in this vector. The variable-length part of the header also contains the lengths of variable-length columns. Each length takes one or two bytes, depending on the maximum length of the column. If all columns in the index are NOT NULL and have a fixed length, the record header has no variable-length part.</p>
</blockquote>
<p>从上面的内容可以知道，NULL列除不能节省空间，反而会增加空间。</p>
<p>MySQL考虑的是越小的行大小，在固定大小的内存中就可以更多的缓存行数据，提升性能。如果字段有值就存，没值就不存，默认值也不是保存行数据里面的。</p>
<h3 id="null-字段带来的问题"><a href="#null-字段带来的问题" class="headerlink" title="null 字段带来的问题"></a>null 字段带来的问题</h3><ol>
<li>NULL值到非NULL的更新无法做到原地更新，更容易发生页分裂，从而影响性能。</li>
<li>NULL值在<code>timestamp</code>类型下容易出问题，特别是没有启用参数<code>explicit_defaults_for_timestamp=true</code>具体见文章最后的：参考资料</li>
<li><code>NOT IN</code>、<code>!=</code> 等负向条件查询在有<code>NULL</code>值的情况下返回永远为空结果，查询容易出错</li>
</ol>
<p>1，NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</p>
<figure class="highlight sql"><figcaption><span>NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_3 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_2 <span class="keyword">values</span> (<span class="number">4</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_1"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_1"</span>),(<span class="number">1</span>,<span class="string">"zhangsan_2"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_2"</span>),(<span class="number">4</span>,<span class="string">"zhaoliu_2_2"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_3 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> table_2 <span class="keyword">where</span> user_name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_name <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">id</span>!=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>2，单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集如果name允许为null，索引不存储null值，结果集中不会包含这些记录。所以，请使用not null约束以及默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">name</span> != <span class="string">'zhaoliu_2_1'</span></span><br></pre></td></tr></table></figure>
<p>3，如果在两个字段进行拼接：比如题号+分数，首先要各字段进行非null判断，否则只要任意一个字段为空都会造成拼接的结果为null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="string">"1"</span>, <span class="literal">null</span>) <span class="keyword">from</span> dual; <span class="comment">-- 执行结果为null。</span></span><br></pre></td></tr></table></figure>
<p>4，如果有 Null column 存在的情况下，count(Null column)需要格外注意，null 值不会参与统计。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 下面的语句返回 2， 但是数据库里面有4条记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(user_name) <span class="keyword">from</span> table_3;</span><br></pre></td></tr></table></figure>
<p>5， null 字段的判断 需要使用 <code>is null</code> 或 <code>is not null</code></p>
<h3 id="NULL字段和索引"><a href="#NULL字段和索引" class="headerlink" title="NULL字段和索引"></a>NULL字段和索引</h3><h4 id="索引长度-key-len"><a href="#索引长度-key-len" class="headerlink" title="索引长度 key_len"></a>索引长度 key_len</h4><p>key_len 的计算规则和三个因素有关：数据类型、字符编码、是否为 NULL </p>
<p>key_len 62 == 20*3（utf8 3字节） + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<p>key_len 83 == 20*4（utf8mb4 4字节） +  1 (是否为 Null 的标识) + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<h3 id="null字段唯一索引"><a href="#null字段唯一索引" class="headerlink" title="null字段唯一索引"></a>null字段唯一索引</h3><p>在可以为NULL的字段上也是可以建立唯一索引的，但需要注意的是：唯一索引想要防止重复记录的功能就失效了。官方文档描述如下：</p>
<blockquote>
<p>A UNIQUE index creates a constraint such that all values in the index must be distinct. An error occurs if you try to add a new row with a key value that matches an existing row. For all engines, a UNIQUE index permits multiple NULL values for columns that can contain NULL.</p>
</blockquote>
<h3 id="null字段普通索引"><a href="#null字段普通索引" class="headerlink" title="null字段普通索引"></a>null字段普通索引</h3><p>在可以为null的字段上建立普通索引，则所有索引字段为null的索引记录都是排列在一起的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://my.oschina.net/leejun2005/blog/1342985" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/1342985</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html</a><br><a href="https://www.jianshu.com/p/d7d364745173" target="_blank" rel="noopener">https://www.jianshu.com/p/d7d364745173</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html</a><br><a href="http://mysql.taobao.org/monthly/2018/01/04/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/01/04/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;a href=&quot;#为什么会有许多表的字段设置为null？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;/a&gt;为什么会有许多表的字段设置为null？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发中常用的建表工具创建表时字段默认可以为null。&lt;/li&gt;
&lt;li&gt;开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。&lt;/li&gt;
&lt;li&gt;默认为null，在插入数据时可以少很多判断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这些问题，下面就彻底搞清楚字段该不该为null。    &lt;/p&gt;
&lt;h3 id=&quot;null-字段可以节省空间吗？&quot;&gt;&lt;a href=&quot;#null-字段可以节省空间吗？&quot; class=&quot;headerlink&quot; title=&quot;null 字段可以节省空间吗？&quot;&gt;&lt;/a&gt;null 字段可以节省空间吗？&lt;/h3&gt;&lt;h4 id=&quot;NULL&quot;&gt;&lt;a href=&quot;#NULL&quot; class=&quot;headerlink&quot; title=&quot;NULL&quot;&gt;&lt;/a&gt;NULL&lt;/h4&gt;&lt;p&gt;MySQL官方文档有如下的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的描述中可以知道，在MyISAM中&lt;code&gt;NULL&lt;/code&gt;字段并不能完全的节省空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>极客时间mysql学习笔记</title>
    <link href="https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html"/>
    <id>https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html</id>
    <published>2018-12-21T05:48:17.000Z</published>
    <updated>2019-03-12T12:02:32.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对极客时间专栏<a href="https://time.geekbang.org/column/139" target="_blank" rel="noopener">MySQL实战45讲</a> 文章内容和讨论区内容的总结。</p>
<h2 id="第一讲-基础架构：一条SQL查询语句是如何执行的？"><a href="#第一讲-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="第一讲 基础架构：一条SQL查询语句是如何执行的？"></a>第一讲 基础架构：一条SQL查询语句是如何执行的？</h2><h3 id="mysql-架构"><a href="#mysql-架构" class="headerlink" title="mysql 架构"></a>mysql 架构</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_arch.png">
<ol>
<li>MySQL 可以分为 Server 层和存储引擎层两部</li>
<li>Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。</li>
<li>存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。</li>
</ol>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ol>
<li>负责为何和客户端的TCP连接， 权限获取，验证。</li>
<li>连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。</li>
<li>通过<code>show processlits</code>查看当前所有的连接。<img src="/2018/12/21/geektime-mysql-learn/show_processlist.png"></li>
<li>如果连接在<code>wait_timeout</code>指定的时间内没有任何操作，则会被关闭。默认是8小时。</li>
<li>长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。<ul>
<li>定时关闭连接 或 执行了大的查询语句后断开连接</li>
<li>MySQL5.7以后的版本可以通过<code>mysql_reset_connection</code>重新初始化连接（不会重新验证权限）。</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ol>
<li>查询缓存可以是一个简单的KV缓存，sql语句为key，缓存的内容为值</li>
<li>只要查询语句中的表执行了更新，该表相关的所有查询缓存都会失效。</li>
<li>对于频繁更新的表，不建议开启查询缓存。</li>
<li>基础配置表建议使用查询缓存。</li>
<li>将参数<code>query_cache_type</code>的值设置为<code>demand</code>，默认不启用查询缓存，除非显示指定：<code>select SQL_CACHE * from T where...</code></li>
</ol>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>词法分析：识别出SQL中每个单词的含义，例如： <code>表名</code>,<code>字段名称</code>,<code>数据库名称</code>,<code>关键字</code>等。<br>语法分析：分析SQL语句的含义，是否满足SQL语法。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>对SQL语句进行改写优化。 </p>
<ul>
<li>索引选择</li>
<li>关联查询表的选择</li>
<li>优化器可能<code>选错索引</code>。</li>
</ul>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ol>
<li>执行器执行SQL前会检查对应的权限。</li>
<li>执行器调用引擎接口获取数据（取下一行，索引：取满足条件的下一行），并计数。该计数可能引擎真实扫描的数据行数不一致。</li>
</ol>
<h2 id="第二讲-日志系统：一条SQL更新语句是如何执行的？"><a href="#第二讲-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="第二讲 日志系统：一条SQL更新语句是如何执行的？"></a>第二讲 日志系统：一条SQL更新语句是如何执行的？</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code> 是提高MySQL写入性能的一种机制。否则每次更新都需要写磁盘，频繁写磁盘性能很差。<code>redo log</code> 减少磁盘写入次数，将单次写入转为批量顺序写入，提高性能。</p>
<p><code>redo log</code> 可以配置个数和大小，并且是循环写入的。</p>
<img src="/2018/12/21/geektime-mysql-learn/msyql_redolog.jpg">
<p><code>redo log</code>保证MySQL的<code>Crash-Safe</code>能力。</p>
<p>InnoDB 必须配置至少一组 redo log。 每组下面至少两个文件， 每个文件大小一致。默认只有一组 redo log， 共2个文件，分别是： ib_logfile0, iblogfile1。</p>
<p>innodb_log_file_size : 指定每个文件的大小<br>innodb_log_files_in_group : 每组下面文件的个数<br>innodb_mirrored_log_groups : 指定日志镜像文件组的数量，默认是1. 如果磁盘做了高可用，可以保持不变。<br>innodb_log_group_home_dir : 指定日志文件所在路径。默认值<code>./</code></p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>binlog</code> 是MySQL Server层的日志，也称为归档日志。</p>
<p><code>binlog</code> 有三种格式：statement, row, mix</p>
<p>通过<code>set sql_log_bin=0</code>来关闭binlog。</p>
<h3 id="redo-log-vs-binlog"><a href="#redo-log-vs-binlog" class="headerlink" title="redo log vs binlog"></a>redo log vs binlog</h3><ol>
<li>redo log 是InnoDB引擎特有的日志。binlog是MySQL Server层的日志，所有引擎共享。</li>
<li>redo log 是大小固定，循环写入的，会写满，binlog是追加写入的。</li>
<li>redo log 是物理日志，记录了<code>哪个数据页,做了哪些修改</code>；binlog是逻辑日志，记录了语句的原始逻辑。</li>
</ol>
<h3 id="update语句执行流程"><a href="#update语句执行流程" class="headerlink" title="update语句执行流程"></a>update语句执行流程</h3>
<p>redo log 和 binlog使用了两阶段提交，以此来保证两个日志的逻辑一致。否则会导致数据不一致。</p>
<ol>
<li>先写redo log 后（crash）写 binlog， 通过binlog恢复数据，数据丢失更新。</li>
<li>先写binlog 后写 redo log, 数据库扩容，通过binlog追主库的数据时，多了一次更新。</li>
<li>prepare 阶段，redo log 已经写入磁盘，只是状态是<code>prepare</code>。</li>
<li>commit 阶段，引擎会将redo log的状态改为<code>commit</code>。</li>
</ol>
<h3 id="innodb-flush-log-at-trx-commit-amp-sync-binlog"><a href="#innodb-flush-log-at-trx-commit-amp-sync-binlog" class="headerlink" title="innodb_flush_log_at_trx_commit &amp; sync_binlog"></a>innodb_flush_log_at_trx_commit &amp; sync_binlog</h3><p><code>innodb_flush_log_at_trx_commit</code>有三个取值：</p>
<ul>
<li>0: 表示事务提交时并不将redo log 写入文件， 等待redo log刷新线程写入文件或其它触发条件。 不能保证是事务的持久性。</li>
<li>1: 该参数设置为1，表示每次事务提交，都将redo log写入磁盘（fsync调用）。</li>
<li>2: 异步写redo log， 写入操作系统page cache， 不能保证是事务的持久性。</li>
</ul>
<p><code>sync_binlog</code> 设置为 1 表示每次事务的binlog都写入磁盘。</p>
<h3 id="优质问题："><a href="#优质问题：" class="headerlink" title="优质问题："></a>优质问题：</h3><ol>
<li>当redo log写满后，新来的事务会导致MySQL将已经更新但是未提交事务修改的内存页(脏页)写入到磁盘中。但因为这些数据其他事务不能读到，或者读到也会放弃。</li>
</ol>
<h2 id="第三讲-事务隔离：为什么你改了我还看不见？"><a href="#第三讲-事务隔离：为什么你改了我还看不见？" class="headerlink" title="第三讲 事务隔离：为什么你改了我还看不见？"></a>第三讲 事务隔离：为什么你改了我还看不见？</h2><p>多个事务并发执行时，可能出现<code>脏读</code>，<code>不可重复读</code>，<code>幻读</code>的现象，为了解决这些问题，出现两个隔离级别的概念，不同的隔离级别，解决不同的问题。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>读未提交 ： 事务的修改还没有提及，其他事务能看到修改的结果</li>
<li>读提交：一个事务的变更只有提交后才能被其他事务看见。</li>
<li>可重复读： 一个事务执行过程中看到的数据，总是和事务启动时看到的数据一致。</li>
<li>串性化：所有事务串行执行。</li>
</ul>
<h3 id="事务视图"><a href="#事务视图" class="headerlink" title="事务视图"></a>事务视图</h3><p>事务执行时会创建一个视图，数据访问时以该视图的逻辑结果为准。</p>
<ul>
<li>读提交 ：这个视图是在每个SQL语句执行前创建的</li>
<li>可重复读 ：视图在事务开始时创建</li>
</ul>
<h3 id="事务隔离实现"><a href="#事务隔离实现" class="headerlink" title="事务隔离实现"></a>事务隔离实现</h3><p>MySQL中每个记录的更新都有会记录对应的回滚操作。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_undo.png">
<ul>
<li>不同时刻启动的事务拥有不同的视图。</li>
<li>MySQL中一条记录会存在多个不同的版本，这个就是数据库的多版本并发控制MVCC。</li>
<li>事务要获取自己视图的数据值，只需要将当前值依次应用回滚日志。</li>
<li>当前系统中没有比回滚日志更早的view时，回滚日志会被删除。</li>
<li>尽量不要使用长事务，会导致回滚日志占用大量内存；mysql5.5和之前的版本中，回滚日志和数据字典一起存放在ibdata文件中，即使事务提交，回滚日志被清理，但是文件不会缩小。极端情况下需要重建库。</li>
</ul>
<h3 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h3><ol>
<li>通过 <code>begin</code> 或 <code>start transaction</code> 启动事务。</li>
<li>通过<code>set autocommit = 1</code>启用自动提交，这样每个语句执行后，MySQL自动追加一个<code>commit</code></li>
<li><code>set autocommit = 0</code> 关闭自动提交功能。这样连接始终处于一个事务中，直到显式<code>commit</code>, <code>rollback</code>，或者断开连接事务才结束。但是显示提交事务后，MySQL有马上开启了一个事务。</li>
<li>可以通过<code>infomation_schema</code>库中的<code>innodb_trx</code>表查询正在执行的事务。</li>
</ol>
<h2 id="第四五讲-深入浅出索引"><a href="#第四五讲-深入浅出索引" class="headerlink" title="第四五讲 深入浅出索引"></a>第四五讲 深入浅出索引</h2><p>所有索引的目的都是为了加速数据的查询。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>哈希索引 ， 适用与等值查询，不适用区间查询，查询最大值，最小值等</li>
<li>有序数组索引， 适用于等值查询，范围查询。因为是数组，插入，更新效率低，所以适用静态数据索引。</li>
<li>二叉搜素树索引，平衡二叉查找树查询时间复杂度：log(N)，适用于内存索引，不适合磁盘索引，因为会导致随机访问问题，并且随着数量的增大，树的高度很高，查询效率降低的很快。</li>
<li>N叉搜素树索引, B树，B+树。适配磁盘访问模式，树的高度更低，查询一个数据需要更少的磁盘访问次数。</li>
</ul>
<h3 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h3><p>InnoDB中，表数据是按照<code>主键</code>顺序以索引的形式存放，这种方式称为<code>索引组织表</code>。InnoDB使用了B+树作为索引，也就是说数据是存放在B+树种的。</p>
<p>InnoDB中，每个索引都是一个B+树。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_tree.png">
<p>上图：左边是主键索引，右边是非主键索引。</p>
<p>主键索引的叶子节点保存了<code>整行</code>数据, 主键索引也称为<code>聚簇索引</code>，非主键索引的叶子节点的内容保存了主键ID。非主键索引也称为二级索引。</p>
<h4 id="主键索引和非主键索引的查询区别？"><a href="#主键索引和非主键索引的查询区别？" class="headerlink" title="主键索引和非主键索引的查询区别？"></a>主键索引和非主键索引的查询区别？</h4><ul>
<li>主键索引查询，只需要查询主键索引树。</li>
<li>非主键查询，需要先访问二级索引，获取主键索引的值，再访问主键索引树获取数据（这里不考虑覆盖索引）。</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入，删除数据时，InnoDB需要维护主键索引非主键索引。</p>
<ol>
<li>插入数据时，如果叶子节点所在的页已经满了的话，需要开辟新的<code>页</code>，移动部分数据到新的<code>页</code>，该操作称为页分裂，会降低页的空间利用率。</li>
<li>删除数据时，如果相邻的2个<code>页</code>里面数据很少，达到某个阈值，那么就会进行页合并，提高空间利用率。</li>
</ol>
<h3 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h3><ol>
<li>尽量使用主键索引，因为少了一个查询索引树的操作，速度更快。</li>
<li>建表时，尽量定义自增主键。这样插入数据时，是顺序写入。空间利用率和写入效率都很高。如果是业务主键，那么写入就是随机的，不能利用磁盘的特性（SSD 随机写入要好很多）。</li>
<li>主键索引尽可能的小，这样普通二级索引的叶子节点也较小，整个二级索引树也很小。内存中也可以更多的缓存索引数据。</li>
<li>在表只有一个索引，该索引必须是唯一索引的情况下，可以使用业务字段作为主键索引。</li>
</ol>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引其实是索引的一种特殊类型，指的是：查询返回的字段值全部在<code>二级索引</code>上都能满足，不需要再搜素主键索引树的一种情况。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树索引支持按索引的最左前缀来定位记录。</p>
<p>下图： (name, age)是联合索引</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_left_prefix.jpg">
<p>索引项是按照索引定义中字段出现的顺序进行排序的。</p>
<ol>
<li>不只是索引定义的全部字段，只要满足最左前缀（联合索引的左前n个字段，N个字符）都可以加速查询。有了<code>(a,b)</code>就可以不定义索引:<code>a</code>， 但是如果有字段<code>b</code>的查询,可能需要单独建立字段<code>b</code>上的索引。</li>
<li>联合索引，优先考虑索引的复用率，可通过调整字段的顺序来减少需要创建索引个个数。</li>
<li>联合索引需要考虑空间。</li>
</ol>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是mysql5.6新增的一个功能。指的是使用联合索引查询时，在满足最左前缀的条件下，查询语句同时使用了联合索引的其他字段作为条件时，首先使用索引中包含的字段进行条件过滤，减少通过主键ID进行回表查询的次数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like '张 %' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>该查询可以使用(name, age)这个联合索引，在判断<code>age=10</code>这个条件时，可以使用联合索引中age字段的值进行条件过滤。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k)) <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>如果要要重建索引<code>k</code>,SQL应该怎么写？</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br></pre></td></tr></table></figure>
<p>删除主键索引和创建主键索引都会导致表的重建。 如果要重建主键索引可以通过下面的语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>下面的索引是否有问题？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>答案：（a, b）, (c) 索引都没有问题，能满足通过字段<code>a</code>,<code>a</code>和<code>b</code>，字段<code>c</code>的查询逻辑。</p>
<p>索引(c, a) 不需要（where c=x order by a），因为数据本身就是按照主键索引(a, b)排序的。</p>
<p>索引(c, b) 满足<code>where c=x order by b</code>的场景。</p>
<h2 id="第六讲全局锁和表锁"><a href="#第六讲全局锁和表锁" class="headerlink" title="第六讲全局锁和表锁"></a>第六讲全局锁和表锁</h2><p>数据库锁是用来协调数据库并发请求的。 根据锁范围分为：全局锁，表锁，行锁.</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>可以使用<code>flush tables with read lock;</code>给整个数据库添加读锁。此后：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结果），更新类事务的提交语句都会被阻塞。</p>
<p>全局锁的典型使用场景是：做整个数据库的逻辑备份。确保备份的数据满足一致性要求。</p>
<p>mysqldump 工具在备份数据库时，启动一个事务<code>添加参数：--single transaction</code>，确保拿到一致性视图，然后开启备份。但前提是存储引擎必须支持事务。</p>
<p><code>set global readonly=true;</code> 也可以让整个数据库进入只读状态，但是有如下的问题，不建议使用。</p>
<ol>
<li>使用该命令，影响面积太大。一些系统根据该变量的值来判断数据库时主库还是从库。</li>
<li><code>flush tables with read lock;</code>命令执行后，如果客户端断开连接，那么锁会被MySQL自动释放，然而<code>set global readonly=true;</code>不会自动释放锁，这样会导致业务不可用的时间变长。</li>
<li>从库上，如果用户有SUPER权限，则read only是无效的。</li>
</ol>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL有2中表级锁，一个是表锁，一个是元数据锁MDL。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁的语法是<code>lock tables a, b... read/write;</code> 通过 <code>unlock tables</code>释放锁，客户端断开连接也会释放锁。注意：<code>lock tables</code> 会同时限制本线程和其他线程的后续操作。</p>
<h3 id="MDL锁"><a href="#MDL锁" class="headerlink" title="MDL锁"></a>MDL锁</h3><p>MySQL5.5 引入。MDL表锁不需要显式加锁，它会在访问表时自动添加和释放。</p>
<ul>
<li>当执行<code>CRUD</code>操作时，加MDL读锁。 </li>
<li>当修改表结构时，加MDL写锁。</li>
<li>读锁直接不互斥，读写，写写直接互斥。</li>
<li>事务提交MDL锁才会释放。</li>
<li>获取MDL写锁时，添加超时控制。MariaDB和AliSQL支持该功能。</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>当备库用<code>–single-transaction</code> 做逻辑备份的时候，如果从主库的binlog传来一个DDL语句，从库会怎么样？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line">Q2:<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>；</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为了确保RR隔离级别，再次设置了隔离级别。</li>
<li>开启事务，获取一致性视图。</li>
<li>设置保存点sp</li>
<li>获取表结构</li>
<li>获取数据</li>
<li>回滚到保存点sp,释放MDL读锁</li>
</ol>
<ul>
<li>如果binlog在Q4语句执行前到达，则没有影响，后续获取的是最新的表结构</li>
<li>如果在时刻2前到达，则表结构被修改了。后续流程不会执行。mysqldump退出。</li>
<li>如果在时刻2和3之间到达，mysqldump占用了MDL锁，binlog被阻塞，现象就是主从延迟。直到Q6完成后才能恢复。</li>
<li>从时刻4开始，MDL锁已经释放。现象是没有影响，不过备份拿到的是DDL前的表结构。</li>
</ul>
<h2 id="第七讲-行锁功过：怎么减少行锁对性能的影响"><a href="#第七讲-行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="第七讲 行锁功过：怎么减少行锁对性能的影响"></a>第七讲 行锁功过：怎么减少行锁对性能的影响</h2><p>MySQL的行锁是在引擎层实现的。不是所有的引擎都支持行锁，MyISAM就不支持。</p>
<p>InnoDB支持行锁。行锁是在需要时获取，事务提交时释放。这也就是是MySQL的：两阶段锁协议。加锁阶段和释放锁阶段，缩放锁阶段不会再获取锁。</p>
<p>在事务中，把最容易造成锁冲突，最可能影响并发度的操作尽可能放到事务靠后的位置。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_deadlock.jpg">
<p>高并发系统中，MySQL出现死锁几乎是不可避免的。幸运的是MySQL有死锁检测机制。</p>
<p>解决死锁有两种机制：</p>
<ul>
<li>超时等待。innodb_lock_wait_timeout 参考来控制超时时间(默认50s)。</li>
<li>死锁检测。检测到发送死锁时，MySQL回滚权值较低的事务。<code>innodb_deadlock_detect</code>设置为 <code>on</code>表示开启死锁检测（默认是开启的）。</li>
</ul>
<p>超时等待太长，业务不可接受。太短可能将简单的锁等待当做死锁处理。所以建议使用死锁检测机制。</p>
<p>死锁检测时，由于每个新来的请求不能获取锁时，都会检测是否因为自己的加入导致了锁等待。当并发量很大时，非常消耗CPU，结果却发现没有死锁。</p>
<p>有两种方法来解决该问题：</p>
<ol>
<li>如果你确认业务不会发生死锁，则可以临时关闭死锁检测。</li>
<li>控制并发度。在MySQL服务端，针对相同行的更新，进行请求排队。</li>
<li>业务优化，将热点数据行拆分为多行，减少并发度。</li>
</ol>
<h3 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h3><p>如果要删除一个数据表中的前10000行数据，有如下三种方式。哪种方式更合适。</p>
<ol>
<li><code>delete from t limit 10000;</code></li>
<li>一个连接中循环20次<code>delete from t limit 500</code>;</li>
<li>20个连接同时执行<code>delete from t limit 500</code>;</li>
</ol>
<p>答案是：方法二。 方法一：会导致获取多个行锁，事务提交时才释放锁，影响并发度。方法三：人为的增加并发度，因为死锁检测逻辑，导致更多的冲突。</p>
<h2 id="第8讲：事务到底是隔离的还是不隔离的？"><a href="#第8讲：事务到底是隔离的还是不隔离的？" class="headerlink" title="第8讲：事务到底是隔离的还是不隔离的？"></a>第8讲：事务到底是隔离的还是不隔离的？</h2><p>通常事务的起点并不是<code>begin/start transaction</code>, 而是在该语句后面执行第一个操作InnoDB表的语句是开始事务。如果想要立刻开始事务，可以通过<code>start transaction with consistent snapshot;</code>.</p>
<p>MySQL中有两个视图view概念：</p>
<ol>
<li>通过查询语句创建的虚拟表</li>
<li>InnoDB实现MVCC时定义的一致性读视图 consistent read view，用于支持实现RC, RR事务隔离级别。</li>
<li>一致性读视图没有物理结构，它是用来定义事务执行期间每个事务能看到的数据规则。</li>
</ol>
<h3 id="快照在MVCC里如何工作"><a href="#快照在MVCC里如何工作" class="headerlink" title="快照在MVCC里如何工作"></a>快照在MVCC里如何工作</h3><ul>
<li>在可重复读隔离级别下，事务在启动的时候生产一个快照，并且是整个数据库的快照。</li>
<li>InnoDB里，每个事务都有一个事务ID，事务ID是系统严格按照递增顺序生成的。</li>
<li>每行数据都有多个版本，每次数据更新时，都会生成新的数据版本，并把操作更新的事务id赋值给新版本数据的事务ID，通过新版本可以找到数据的旧版本。<img src="/2018/12/21/geektime-mysql-learn/mysql_row_trx_id.png"></li>
<li>数据的其他版本可用通过每个事务的当前版本通过应用undo log来获取。</li>
<li>可重复读隔离级别下，一个事务启动时，获取了一个新的事务ID，它只认可在它之前生成的数据版本和它本身生成的数据版本。其它事务的更新生成的数据版本对它都是不可见的。</li>
<li>实现上InnoDB，在每个事务启动时，创建了一个数组，用来保存当前<code>活跃</code>的事务ID，这里活跃指的是已经启动，但是还未提交。</li>
<li>数组里面，事务ID的最小值记为<code>低水位</code>，当前系统已经创建过的事务ID的<code>最大值+1</code>记为<code>高水位</code>。这个视图数组和<code>高水位</code>共同构成事务的一致性视图。</li>
<li>数据版本的可见性规则，就是基于这个数据的row trx_id和该一致性视图的对比结果得到。</li>
</ul>
<h3 id="数据版本可见性规则"><a href="#数据版本可见性规则" class="headerlink" title="数据版本可见性规则"></a>数据版本可见性规则</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_array.png">
<p>如上图：事务启动瞬间，一个数据版本的row trx_id可能的取值有一下几种：</p>
<ol>
<li>位于绿色区间，表示这个版本是已经提交的，或者当前事务自己生成的，对当前事务可见。</li>
<li>位于红色区间，表示这个版本是未来的事务生成的，肯定不可见，这个容易理解。</li>
<li>位于黄色区间，有2中情况，<br> a. 如果row trx_id在数组中，表示该版本是未提交事务生成的。不可见。<br> b. row trx_id 不在数组中，表示这个版本是已经提交了的事务生成。可见。（当前活跃事务的ID数组是有序的，但每个元素之间的步长不是1， 中间有漏洞，漏洞里面的事务就是已经提交了的事务）</li>
</ol>
<p>一个事务视图中，除了自己的更新可见外，有其他三种情况：</p>
<ol>
<li>版本未提交，不可见。</li>
<li>版本已提交，但是在事务视图创建后提交的，不可见。</li>
<li>版本已提交，在事务视图创建前提交的，可见。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_analyze.png">
<p>如上图所示，事务A最终读取到的K值是1， 事务B最终读取到的K值是3。（autocommit=1, 隔离级别是可重复读）</p>
<p>这里需要注意的是事务B。 因为事务B的update语句是<code>当前读</code>(所有的更新都是先读后写，update会加锁)，所以会读取到事务C已经提交后的结果，事务B是在C=2的基础上进行更新，否则就丢失了事务C的更新。</p>
<p>除了update语句，加锁的select与也是当前读。</p>
<p><code>select ... for update</code> 或 <code>select .... lock in share mode</code>。</p>
<h3 id="课后题-2"><a href="#课后题-2" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, c) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_trx_update_problem.png">
<p>如果复现上图的问题，原因是什么？</p>
<p>答案：如何复现：其它事务在本事务执行更新语句前修改<code>c</code>的值并提交，因为隔离级别是RR, 那么本事务中进行select，结果还是更新前的值。但是update语句是当前读，读取的结果是其它事务更新后的值，已经不满足更新条件了，更新的结果就是上图所示的结果。如果在当前事务的update语句后面执行当前读(<code>for update</code>，<code>lock in share mode</code>)就能看到最新的值。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_can_not_update.png">
<h2 id="第9讲：普通索引和唯一索引怎么选？"><a href="#第9讲：普通索引和唯一索引怎么选？" class="headerlink" title="第9讲：普通索引和唯一索引怎么选？"></a>第9讲：普通索引和唯一索引怎么选？</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在查询中，普通索引和唯一索引的性能消耗可以忽略不计。原因在于MySQL还按页读取和写入数据的（默认的页大小是16KB），在一个数据页中查找到满足条件的记录后，如果是唯一索引，则停止搜索；如果是普通索引，则继续搜索，因为此时数据页已经在内存中，再加上OS的磁盘预读机制，大概率剩下的满足条件的数据页在内存中，查找内存的效率是很高的。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>MySQL更新数据时，如果记录所在的数据页在内存中，则直接更新。否则，在不影响数据一致性的前提下，InnoDB会将更新操作缓存在<code>change buffer</code>中，并不会立即读取磁盘上数据页然后进行更新。<code>change buffer</code>会同时保持在磁盘和内存中。后续查询需要访问这个数据页时，才会从磁盘读取数据页，然后使用<code>change buffer</code>里面的数据更新数据页的内容。将<code>change buffer</code>中的更新操作应用到原始数据页上的操作称为<code>merge</code>。</p>
<p><code>change buffer</code> 减少了磁盘访问次数，间接减少了内存占用。</p>
<p><code>change buffer</code> 使用的是<code>buffer pool</code>里面的内存。可以通过参数<code>innodb_change_buffer_max_size</code>来动态调整。</p>
<h4 id="merge的触发时机"><a href="#merge的触发时机" class="headerlink" title="merge的触发时机"></a>merge的触发时机</h4><ol>
<li>访问数据页</li>
<li>数据库正常停机</li>
<li>后台线程周期性merge</li>
</ol>
<h4 id="change-buffer-使用条件"><a href="#change-buffer-使用条件" class="headerlink" title="change buffer 使用条件"></a>change buffer 使用条件</h4><p>普通索引才能使用<code>change buffer</code>。原因在于针对唯一索引，当数据页不在内存是，更新操作（insert, update）需要读取数据页才能进行唯一性判断。普通索引直接将更新操作添加到<code>change buffer</code>即可。针对普通索引，<code>change buffer</code>减少了磁盘的随机访问，唯一索引容易引起磁盘的随机访问，造成性能下降。</p>
<p><code>change buffer</code>的作用是尽量缓存更新操作直到进行merge操作前。如果数据更新后，马上被读取，那么缓存效果会大打折扣。也就是说：<code>change buffer</code>对<code>写多读少</code>的应用更合适。相反，更新后马上读取，就会触发merge操作，随机I/O并没有减少，反而要维护<code>change buffer</code>，代价更高。</p>
<p>insert的时候，写主键是肯定不能用<code>change buffer</code>了，但是同时也会要写其它索引，而其它索引中的<code>非唯一索引</code>是可以用的这个机制的；</p>
<p><code>change buffer</code>的前身是<code>insert buffer</code>,只能对insert 操作优化；后来升级了，增加了<code>update/delete</code>的支持，名字也改叫<code>change buffer</code>。</p>
<p>一个数据行的多次更新，会在change buffer中存在多个记录。</p>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>普通索引和唯一索引在查询能力上差别微乎其微，主要区别在于更新操作，所以建议使用普通索引。</p>
<p>如果更新后马上进行读取，则考虑关闭<code>change buffer</code>。</p>
<p>实践：在线库可以使用唯一索引满足业务需求，历史备份表可以将唯一索引改为普通索引，配合较大的<code>change buffer</code>设置，可以提高备份库的写入速度。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><h4 id="带-change-buffer-写入"><a href="#带-change-buffer-写入" class="headerlink" title="带 change buffer 写入"></a>带 change buffer 写入</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_redolog_change_buffer.png"> 
<p>上面的sql做了如下操作：</p>
<ol>
<li>Page 1 在内存中，直接更新内存； </li>
<li>Page 2 没在内存中，记录insert操作到<code>change buffer</code>中。</li>
<li>将上面2个操作记录到redo log。</li>
</ol>
<h4 id="带-change-buffer-读取"><a href="#带-change-buffer-读取" class="headerlink" title="带 change buffer 读取"></a>带 change buffer 读取</h4><img src="/2018/12/21/geektime-mysql-learn/mysql_read_with_change_buffer.png"> 
<p>读取时，如果数据页在内存中，直接返回。只有数据页不在内存中，才需要读取磁盘上的数据，然后应用<code>change buffer</code>里面的操作。</p>
<p><code>redo log</code>节省的是随机写的性能消耗（转为顺序写），<code>change buffer</code>主要节省的是随机读的性能消耗。</p>
<h3 id="课后题-3"><a href="#课后题-3" class="headerlink" title="课后题"></a>课后题</h3><p><code>change buffer</code>的更新没有应用到磁盘数据页，掉电后，会不会导致<code>change buffer</code>丢失，也就是会不会导致丢失更新呢？</p>
<p>答案：不会。</p>
<p>1.<code>change buffer</code>有一部分在内存有一部分在<code>ibdata</code>.<br>做<code>purge</code>操作,应该就会把<code>change buffer</code>里相应的数据持久化到<code>ibdata</code><br>2.<code>redo log</code>里记录了数据页的修改以及<code>change buffer</code>新写入的信息<br>如果掉电,持久化的<code>change buffer</code>数据已经<code>purge</code>,不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1)<code>change buffer</code>写入,<code>redo log</code>虽然做了<code>fsync</code>但未<code>commit</code>,<code>binlog</code>未<code>fsync</code>到磁盘,这部分数据丢失<br>(2)<code>change buffer</code>写入,<code>redo log</code>写入但没有<code>commit</code>,<code>binlog</code>已经<code>fsync</code>到磁盘,先从<code>binlog</code>恢复<code>redo log</code>,再从<code>redo log</code>恢复<code>change buffer</code>。不会丢失<br>(3)<code>change buffer</code>写入,<code>redo log</code>和<code>binlog</code>都已经<code>fsync</code>, 那么直接从<code>redo log</code>里恢复。不会丢失。</p>
<h2 id="第10讲-MySQL为什么有时候会选错索引？"><a href="#第10讲-MySQL为什么有时候会选错索引？" class="headerlink" title="第10讲 MySQL为什么有时候会选错索引？"></a>第10讲 MySQL为什么有时候会选错索引？</h2><p>通常查询语句使用哪个索引是由MySQL来决定的(优化器)。但我们也可以在SQL语句强制mysql使用指定的索引。</p>
<h3 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> (FIELD1) …</span><br></pre></td></tr></table></figure>
<h3 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (FIELD1, FIELD2) …</span><br></pre></td></tr></table></figure>
<h3 id="SQL-NO-CACHE"><a href="#SQL-NO-CACHE" class="headerlink" title="SQL_NO_CACHE"></a>SQL_NO_CACHE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE field1, field2 <span class="keyword">FROM</span> TABLE1;</span><br></pre></td></tr></table></figure>
<h3 id="选错索引例子"><a href="#选错索引例子" class="headerlink" title="选错索引例子"></a>选错索引例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>；</span><br><span class="line"><span class="comment"># 插入数据的存储过程</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>分析索引使用情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure>
<p>因为<code>a</code>字段上有索引，结果是使用索引。</p>
<p>如下操作显示MySQL选择的错误的索引：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_select_error_index.png">
<p>通过SQL进行验证：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>优化器根据查询的扫描行数，是否使用临时表，是否排序等因素来综合判断，生成执行计划。</p>
<p>MySQL在执行语句前会根据统计信息来估算可能的扫描行数，这个统计信息就是索引的区分度。</p>
<p>一个索引上不同值得个数称为基数。可以通过语句<code>show index from table;</code>来查看。</p>
<p>优化器同时会考虑使用普通索引时，查询回表的代价。</p>
<h4 id="采样统计"><a href="#采样统计" class="headerlink" title="采样统计"></a>采样统计</h4><p>MySQL默认选择N个数据页，统计N个页面上的不同值，得到一个平均值。平均值 * 索引的页面数 得到这个索引的基数。数据表一直更新，当变更的行数超过<code>1/M</code>时会触发一次新的索引统计计算。</p>
<p><code>innodb_stats_persistent = on</code> 表示MySQL的统计信息会持久化保存（这时N=20,M=10），<code>off</code>表示仅保存在内存中(这时N=8,M=16)。</p>
<h3 id="选错索引处理办法"><a href="#选错索引处理办法" class="headerlink" title="选错索引处理办法"></a>选错索引处理办法</h3><ol>
<li>由于统计信息不及时和不准确，可以通过<code>analyze table table_name</code>来重新统计索引信息。</li>
<li>通过<code>force index</code>语句来强制使用指定索引。</li>
<li>修改SQL语句，引导MySQL使用正确索引（前提是不改变SQL语句的业务逻辑）。</li>
<li>新增更合适的索引，或删除误用的索引。</li>
</ol>
<h3 id="课后题-4"><a href="#课后题-4" class="headerlink" title="课后题"></a>课后题</h3><p>如果没有<code>session A</code>的配合，只有<code>session B</code> 则会看到扫描行数还是<code>10000</code>左右，原因是什么?</p>
<p>答案：因为事务隔离级别是RR, 存在Session A的情况下，事务没有提交，原来插入的数据不能被删除。之前的每行数据有2个版本，旧版本是delete前的数据，新版本是标记为<code>deleted</code>的数据。session B又插入了10w上记录，这样索引a上就有2份数据。</p>
<p>主键索引扫描行数的估计值是通过<code>show table status like &#39;table_name&#39;</code> 来获取的。</p>
<h2 id="11讲-怎么给字符串字段加索引？"><a href="#11讲-怎么给字符串字段加索引？" class="headerlink" title="11讲 - 怎么给字符串字段加索引？"></a>11讲 - 怎么给字符串字段加索引？</h2><p>字符串字段添加索引有2中方式：</p>
<ol>
<li>整个字段的值都作为索引值。</li>
<li>字符串的前N个字符作为索引值。</li>
</ol>
<p>这两种做法各有利弊。整个字段作为索引，可以减少扫描行数，但是索引较大。<br>前缀索引索引占用空间小，但是扫描行数较多。所以在实践中，可以通过调节N的值，来平衡索引的大小和扫描的行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br><span class="line"><span class="comment"># 取不同的N值，计算前缀索引的区分度。</span></span><br><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<p>使用前缀索引不能利用覆盖索引可以避免回表的优化机制，必须回表查询。</p>
<p>如果遇到前缀索引前N位区分度很小的情况下，有如下两种优化办法：</p>
<ol>
<li>倒序存储（例如身份证号，同一个地区，前6位都是相同的）。</li>
<li>对字段值进行hash,保存hash后的值，建立索引。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>倒序存储和hash，都不能进行范围查询。hash只能进行等值查询</li>
<li>倒叙存储和hash存储，插入数据和查询数据，都需要进行额外的计算（reverse , crc）。</li>
<li>和倒叙存储比较起来，hash存储方式查询效率更好。</li>
</ol>
<h2 id="12讲-为什么我的MySQL会“抖”一下？"><a href="#12讲-为什么我的MySQL会“抖”一下？" class="headerlink" title="12讲 - 为什么我的MySQL会“抖”一下？"></a>12讲 - 为什么我的MySQL会“抖”一下？</h2><p>通常的更新操作，只是更新内存数据页，写redo log，不会有大量的磁盘写入操作。这就导致磁盘数据页和内存数据页的数据不一致，这样的数据页称为<code>脏页</code>，MySQL会定时或被动触发将脏页刷新到磁盘中操作。</p>
<h3 id="刷脏页的触发时机"><a href="#刷脏页的触发时机" class="headerlink" title="刷脏页的触发时机"></a>刷脏页的触发时机</h3><p>场景一：当redo log写满了，也就是write pos 追上check point时, 如下图：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_flush_dirty_page.jpg">
<p>当check point 往前推进时，需要把推进区间内对应的脏页都写入磁盘。</p>
<p>场景二：当某个查询需要大量内存，但是内存空闲的干净页不足，此时需要把脏页写入磁盘来增加干净页。</p>
<p>场景三：系统空闲时，后台线程执行刷脏页操作。</p>
<p>场景四：MySQL停机。</p>
<p>我们在实践中需要尽量避免场景一的出现，因为此时MySQL不再执行任何更新操作。如果脏页积累的太多，会导致一次需要刷大量的脏页到磁盘，也是需要尽力避免。</p>
<h3 id="InnoDB刷脏页控制策略"><a href="#InnoDB刷脏页控制策略" class="headerlink" title="InnoDB刷脏页控制策略"></a>InnoDB刷脏页控制策略</h3><p>获取磁盘的IOPS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure>
<p>告诉InnoDB磁盘的IOPS值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_io_capacity=IOPS</span><br></pre></td></tr></table></figure>
<p>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例的上限。</p>
<p>InnoDB根据当前的脏页比例M计算出一个[0 - 100]间的数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InnoDB每次写入的redo log都有一个序号(LSN)，当前写入日志的序号和check point直接的差值记为<code>N</code>，InnoDB会根据<code>N</code>算出一个0-100间的数字，这公式记为F2(N)，算法比较复杂，<code>N</code>越大，则结果越大。</p>
<p>InnoDB根据<code>F1(M)</code>和<code>F2(N)</code>二者结果的 <code>最大值</code> * <code>innodb_io_capacity</code>的结果控制刷脏页的速度。</p>
<p>可以通过如下语句计算脏页比例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：InnoDB刷脏页的过程中，如果相邻页也是脏页，那么相邻页也会被刷到磁盘上，如果相邻页的相邻页也是脏页，也会被刷。也就是说这个过程是级联的。这会导致雪上加霜的效果。<code>innodb_flush_neighbors</code>参数就是控制这个机制的。设置为<code>0</code>表示只刷自己，为<code>1</code>。MySQL8.0默认值为<code>0</code>;</p>
</blockquote>
<h3 id="课后题-amp-讨论"><a href="#课后题-amp-讨论" class="headerlink" title="课后题&amp;讨论"></a>课后题&amp;讨论</h3><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>因内存不足导致刷脏页时，不会刷redo文件的。redo log 在重放时，如果一个数据页已经刷过的话，会被识别出来，并跳过。</p>
<h4 id="课后题-5"><a href="#课后题-5" class="headerlink" title="课后题"></a>课后题</h4><p>一个内存配置为 128GB、innodb_io_capacity=20000的高配实例，redo log设置为一个100MB的文件，会发生什么情况，原因是什么？</p>
<p>答案：因为redo log文件设置的比较小，那么redo log文件就容易写满，导致频繁刷脏页，由于磁盘的IOPS很大，监控上开起来磁盘压力不大，但是性能间歇性的不好，但是也不会降低很大，因为每次刷脏页的速度还是很快的。</p>
<h2 id="13讲-为什么表数据删掉一半，表文件大小不变？"><a href="#13讲-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13讲 - 为什么表数据删掉一半，表文件大小不变？"></a>13讲 - 为什么表数据删掉一半，表文件大小不变？</h2><p>InnoDB 8.0以前，表结构保存在<code>.frm</code>文件中，从8.0开始运行把表结构保存到系统数据表中。因为表结构文件非常小心。</p>
<h3 id="innodb-file-per-table"><a href="#innodb-file-per-table" class="headerlink" title="innodb_file_per_table"></a>innodb_file_per_table</h3><p><code>innodb_file_per_table</code>参考用来控制表数据是放到共享表空间还是独立的文件。</p>
<ul>
<li>on: 表示每个数据表独立保存一个后缀为<code>.ibd</code>的文件中。</li>
<li>off: 表示数据放到系统共享表空间中，也就是和数据字典放在一起。</li>
</ul>
<p>从MySQL5.6.6开始，默认值就是<code>on</code>。建议一直将该参数设置为<code>on</code>，除了好管理外，<code>drop table</code> 后MySQL会直接删除该文件，否则保存在共享表空间，表删除了，但是空间不会自动释放。</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_delete.png">
<p>innodb删除数据是<code>标记删除</code>。标记删除的记录占用的空间可以被复用，单记录空间的复用只限于特定范围。</p>
<p>如果一个数据页的所有数据都被标记为删除，则整个数据页都可以被复用，并可以复用到任何位置。</p>
<p>如果相邻的两个页的空间利用率都比较小，innodb会将相邻的页合并为一个页，另一个页标记为可复用。</p>
<p>由于是标记删除，所以占用的磁盘空间并不会自动释放，导致的结果就是文件很大，记录数很少，把这些可以复用而没有使用的空间称为<code>空洞</code>。</p>
<p>删除，插入记录（页分裂，分配了一个新的页，导致2个页的空间利用率很低), 更新索引上的值，都会导致空洞的产生。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_page_split.png">
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>当你想要收缩表空间时，可以新建一个结构相同的表，将老表的数据导入新表，然后重命名，并删除旧表。</p>
<p>因为新表是按照索引递增的顺序插入数据记录，数据页的空间利用率很高，磁盘占用很少。</p>
<p>可以通过<code>alter table A engine=InnoDB</code>来实现这个操作。但是需要注意的是在MySQL5.5版本前，这个操作执行过程中，老的表不能有数据更新（不能进行DML操作），否则会导致丢失更新。也就是说这个操作不是Online的。而在MySQL5.6版本引入了Online DDL，优化了该流程（原理是：导数据的过程中记录老表的变更操作到文件中，数据导完后，再应用期间的变更），可以在放心使用。</p>
<p>注意：针对较大的表，导数据过程中需要大量的CPU和I/O资源，可以选择在业务低峰期进行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inplace 方式（server 层视角）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br><span class="line"><span class="comment"># copy 拷贝方式（MySQL老版本实现方式）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>
<h3 id="online-vs-inplace"><a href="#online-vs-inplace" class="headerlink" title="online vs inplace"></a>online vs inplace</h3><ol>
<li>DDL的过程是online的，那一定就是inplace的。</li>
<li>反过来未必，也就是说inplace的DDL不一定是online的。截止到MySQL8.0，添加全文索引和空间索引就是这种情况。</li>
</ol>
<h3 id="optimize-table-vs-analyze-table-vs-alter-table-engine-innodb"><a href="#optimize-table-vs-analyze-table-vs-alter-table-engine-innodb" class="headerlink" title="optimize table vs analyze table vs alter table engine=innodb"></a>optimize table vs analyze table vs alter table engine=innodb</h3><p><code>optimize table</code> = recreate + analyze</p>
<p><code>analyze table</code> 没有重建表，只是更新索引统计信息。</p>
<p><code>alter table engine=innodb</code> 就是重建表recreate。</p>
<p><code>truncate table</code> = drop + create</p>
<h3 id="课后题-6"><a href="#课后题-6" class="headerlink" title="课后题"></a>课后题</h3><p>有没有可能执行完<code>alter table engine=innodb</code>后数据文件反而变大的情况？ 原因可能是什么？</p>
<p>答案：有的。</p>
<ol>
<li>刚进行完表的重建后再次进行重建，期间有DML操作，这些新的操作导致有空洞的产生。</li>
<li>表的重建，每个数据页不是完全满的，InnoDB会预留一部分空间。但是在数据页的合并过程中每个数据页可能是完全满的。</li>
<li>重建表后，插入一些数据占用预留空间，再次重建表，导致新增预留空间，数据文件会变大。</li>
</ol>
<h2 id="14讲-count-这么慢，我该怎么办？"><a href="#14讲-count-这么慢，我该怎么办？" class="headerlink" title="14讲 - count(*)这么慢，我该怎么办？"></a>14讲 - count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><p>不同的存储引擎实现方式不同。下文讨论的都是不加<code>where</code>条件的。</p>
<ul>
<li>MyISAM 会把表的总数保存到磁盘上，执行count(*)时直接返回</li>
<li>InnoDB 执行count(*)时，需要把数据从引擎中一行行读出来进行累加，速度较慢。</li>
</ul>
<p>InnoDB由于MVCC的原因，每个事务查询时，返回的总数都不是确定的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_count.png">
<p>InnoDB在执行<code>count(*)</code>时，也会做一点优化。主键索引树的叶子节点是数据，普通索引的叶子节点是主键值。索引普通索引比主键索引小很多。因此MySQL优化器会选择最小的索引树进行遍历获取<code>count(*)</code>的值。</p>
<p><code>show table status</code> 显示的记录数是估值，官方文档说误差在40%到50%，因此也不准确。</p>
<h3 id="如何快速计算表的记录总数"><a href="#如何快速计算表的记录总数" class="headerlink" title="如何快速计算表的记录总数"></a>如何快速计算表的记录总数</h3><ul>
<li>如果不需要完全准确的值，可以缓存表的记录数，动态更新 并 定时全表扫描更新缓存中的值。</li>
<li>通过数据库<code>独立计数表</code>进行统计，通过事务保证计数值和表记录总数的一致性。</li>
</ul>
<h3 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h3><p>count是一个聚合函数（server层实现的，这个很重要），只要参数判断不为NULL，计数值就+1</p>
<p>count(*)， count(主键)， count(1)都表示满足条件的记录总数。</p>
<p>count(字段) 表示满足条件并且该字段不为null的记录总数。</p>
<p>性能差别：</p>
<ol>
<li>server层要什么字段，引擎层就给什么字段</li>
<li>InnoDB只给必要的值</li>
<li>现在的优化器只优化了<code>count(*)</code>的语义为<code>取行数</code>，其他<code>显而易见</code>的优化并没有做。</li>
</ol>
<h4 id="count-主键"><a href="#count-主键" class="headerlink" title="count(主键)"></a>count(主键)</h4><p>InnoDB遍历表，把每一行的主键取出来返回给Server层。</p>
<h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>InnoDB遍历表，但是不取值，server层对返回的每一行，放入。<br>一个数字<code>1</code>进行判断，判断是不肯能为空的，按行累加。</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><code>count(*)</code> 并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不为NULL，按行累加。</p>
<h4 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h4><ol>
<li>如果字段定义为Not null， 从每一行中读取该字段，判断不能为null，按行累加。</li>
<li>如果字段定义为可以为NULL，那么还是需要从行中读取该字段，并判断是否为NULL，不是NULL才进行累加。</li>
</ol>
<p>综上，按照效率来说，count(字段) &lt; count(主键) &lt; count(1) ≈ count(*)</p>
<p>所以建议使用<code>count(*)</code></p>
<h2 id="15讲-日志和索引相关问题"><a href="#15讲-日志和索引相关问题" class="headerlink" title="15讲 - 日志和索引相关问题"></a>15讲 - 日志和索引相关问题</h2><p>MySQL在崩溃恢复时，是通过binlog和redo log共同判断事务应该提交还是回滚：</p>
<ol>
<li>如果redo log里面的事务是完整的，并且有commit标志，那么直接提交事务。</li>
<li>redo log里面的事务有完整的prepare，如果binlog完整，则提交事务，否则回滚事务。</li>
</ol>
<h3 id="MySQL如何知道binlog的完整性？"><a href="#MySQL如何知道binlog的完整性？" class="headerlink" title="MySQL如何知道binlog的完整性？"></a>MySQL如何知道binlog的完整性？</h3><p>一个事务的binlog是有完整格式的</p>
<ul>
<li>statement格式的binlog，最后会有<code>COMMMIT</code>.</li>
<li>row格式的binlog，最后会有一个XID event.</li>
<li>5.6.2版本后，添加了binlog-checksum参数，用来验证binlog的完整性。</li>
</ul>
<h3 id="redo-log-如何和-binlog进行关联"><a href="#redo-log-如何和-binlog进行关联" class="headerlink" title="redo log 如何和 binlog进行关联"></a>redo log 如何和 binlog进行关联</h3><p>redo log 和 binlog 有一个共同的数据字段<code>XID</code>。</p>
<h3 id="处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h3><p>binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<h3 id="如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h3><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</p>
<h3 id="不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？"></a>不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</h3><p>答案是不可以。binlog 没有能力恢复“数据页”。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_binlog_crash_safe.jpg">
<h3 id="那能不能反过来，只用-redo-log，不要-binlog？"><a href="#那能不能反过来，只用-redo-log，不要-binlog？" class="headerlink" title="那能不能反过来，只用 redo log，不要 binlog？"></a>那能不能反过来，只用 redo log，不要 binlog？</h3><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。</p>
<p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。</p>
<p>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</p>
<p>一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。</p>
<p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。</p>
<p>总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。你看，发展生态是多么重要。</p>
<h3 id="追问-7：redo-log-一般设置多大？"><a href="#追问-7：redo-log-一般设置多大？" class="headerlink" title="追问 7：redo log 一般设置多大？"></a>追问 7：redo log 一般设置多大？</h3><p>回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。</p>
<p>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。</p>
<h3 id="追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？"><a href="#追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？" class="headerlink" title="追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？"></a>追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</h3><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。</p>
<p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p>
<p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</p>
<p>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>
<h3 id="追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？"><a href="#追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？" class="headerlink" title="追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？"></a>追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</h3><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。</p>
<p>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。</p>
<p>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的 IO 消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第 22 篇文章《MySQL 有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p>
<p>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p>
<h3 id="课后题-7"><a href="#课后题-7" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">`id` int(11) NOT NULL primary key auto_increment,</span><br><span class="line">`a` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下的语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t set a=2 where id=1;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value.png"></p>
<p>仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是 2，不更新，直接返回，执行结束；</li>
<li>MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li>
<li>InnoDB 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</li>
</ol>
<p>答案：第三种。分析如下：</p>
<p>针对第一种假设：如果不更新，直接返回。那么就不会加行锁。因此可以通过如下步骤验证</p>
<ol>
<li>SessionA 开启一个事务执行update语句，不提交事务。</li>
<li>SessionB 执行同样的更新语句，如果出现Block现象，那么说明SessionA对数据加了行锁，也就是说Server层调用了InnoDB的更新接口。(<code>行锁是在InnoDB中实现的</code>)</li>
</ol>
<p>针对第二种假设：如果InnoDB没有进行数据更新，那么在RR事务隔离级别下，A和B两个事务执行同样的更新语句，B事务的更新对A事务不可见，在A事务中，更新语句前后执行查询语句，如果2次的查询结果都是2，说明InnoDB确实没有执行更新操作。如果第二次查询可以看到更新后的值，说明InnoDB执行了更新。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_1.png">
<p>如果InnoDB能肯定更新前后的值相同，它确实不会再执行更新的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_2.png">
<p>where 语句有<code>k=3</code>这个条件，更新后还是3，InnoDB确实就不进行更新了。</p>
<p>注意：虽然InnoDB执行了更新，但是对MySQL Server层来说，前后的数据并没有变，row 格式下也不会产生binlog。</p>
<h2 id="第16讲-“order-by”是怎么工作的？"><a href="#第16讲-“order-by”是怎么工作的？" class="headerlink" title="第16讲 -  “order by”是怎么工作的？"></a>第16讲 -  “order by”是怎么工作的？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>查询排序语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by.png">
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL给每个线程分配一个排序缓存(sort buffer)，针对上面的查询排序语句，MySQL从<code>city</code>索引树上查询满足条件的记录主键，回表查询<code>city,name,age</code>自动的值放入sort buffer。 最后对sort buffer中的记录按name字段进行快速排序，将排序结果的前1000条数据返回。</p>
<p><code>sort buffer</code>有大小，如果满足条件的记录在<code>sort buffer</code>把放不下，则需要使用文件排序（归并排序）。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_diagram.jpg">
<p>参数：<code>sort_buffer_size</code> 可以控制 排序缓存的大小，增大该参数的值，可以加速排序。</p>
<p>通过下面的语句来验证查询是否使用了临时文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>如果查询的结果需要返回记录的大部分字段或者或者所有字段，此时会占用大量内存，很容易导致采用文件排序，效率是低下的。MySQL针对这种情况进行了优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>这个参数是专门控制参与内存排序的数据行大小的，如果参与排序的数据行大小大于该值，那么MySQL将采用另一种排序算法：</p>
<ol>
<li>将满足条件的记录中需要参与排序的字段和主键放入sort buffer。</li>
<li>对sort buffer中的记录按name进行排序。</li>
<li>取出排序结果的前1000行，根据ID，查询主键索引树，获取要返回的字段值。</li>
</ol>

<h3 id="全字段排序-vs-rowid排序"><a href="#全字段排序-vs-rowid排序" class="headerlink" title="全字段排序 vs rowid排序"></a>全字段排序 vs rowid排序</h3><ol>
<li>MySQL倾向于使用内存排序，所以尽量使用大内存机器，避免文件排序和rowid排序(需要回表，查询慢)</li>
<li>查询语句尽量只返回需要的字段，不要<code>select *</code></li>
<li>适当调高<code>max_length_for_sort_data</code>的值。</li>
</ol>
<h3 id="避免排序"><a href="#避免排序" class="headerlink" title="避免排序"></a>避免排序</h3><p>并不是所有的order by都会排序。如果从索引树上获取的结果集本身就是有序的就可以避免排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>有了这个索引，city相同，name本身就是有序的，就避免了排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_not_need_sort.jpg">
<p>explain:</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_using_index.png">
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure>
<p>有了覆盖索引的优化，避免了回表，性能进一步提高。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index.jpg">
<p>explain结果：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index_explain.png">
<h3 id="explain-type"><a href="#explain-type" class="headerlink" title="explain type"></a>explain type</h3><p>all : 全表扫描</p>
<p>index: 使用索引，如果是覆盖索引，可以不用回表，如果没有where条件，会扫描整个索引树。</p>
<p>range: 以范围的形式扫描索引树。 </p>
<p>ref: 非唯一索引引用</p>
<p>eq_ref: 等值引用。 使用有唯一性索引查找（主键或唯一性索引）</p>
<p>const：（常量连接）被称为<code>常量</code>，这个词不好理解，不过出现 const 的话就表示发生下面两种情况：</p>
<ol>
<li>在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id=1 就肯定只有一行，只需读取一次表数据便能取得所需的结果，且表数据在分解执行计划时读取。返回值直接放在 select 语句中，类似 select 1 AS f 。可以通过 extended 选择查看内部过程：</li>
</ol>
<h3 id="explain-extra"><a href="#explain-extra" class="headerlink" title="explain extra"></a>explain extra</h3><ul>
<li><code>Using filesort</code> : 通常在使用到排序语句ORDER BY的时候，会出现该信息，表示一种排序算法，可能使用文件排序。</li>
<li><code>Using index</code> : 表示只使用了索引，不用回表，使用了覆盖索引。如果同时出现<code>Using where</code>，表示需要回表。</li>
<li><code>Using where</code>：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现<code>Using where</code>。如果type列是<code>ALL</code>或<code>index</code>，而没有出现该信息，则有可能在执行错误的查询：返回所有数据。  </li>
<li><code>Using temporary</code>：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</li>
</ul>
<h2 id="课后题-8"><a href="#课后题-8" class="headerlink" title="课后题"></a>课后题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="keyword">in</span> （<span class="string">'杭州'</span>,<span class="string">'苏州'</span>）<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>答案：拆为2次查询，应用内归并排序，取前100行。</p>
<p>如果是<code>limit 10000, 100</code>的话，解决思路也是类似的。但缺点是应用需要保存大量的数据，如果offset太大的话，客户端内存排序就不可行了（内存溢出）。</p>
<p>为了减少内存占用，可以只返回<code>id,name</code>字段数据，排序后，用ID再查询数据库获取数据。</p>
<h2 id="第17讲-如何正确地显示随机消息？"><a href="#第17讲-如何正确地显示随机消息？" class="headerlink" title="第17讲 - 如何正确地显示随机消息？"></a>第17讲 - 如何正确地显示随机消息？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure>
<p>随机排序，取前3个。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_mem_temp.png">
<p>上图表示使用了<code>内存临时表</code>，并且进行了排序。</p>
<p>由于内存临时表的回表速度非常快，MySQL此时优先选择排序是排序行越少越好，就是rowid排序。</p>
<p>上述语句的执行流程：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li>
<li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li>
<li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li>
<li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li>
<li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li>
</ol>
<p>慢查询日志分析：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span>=<span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_sort_diag.png">
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>不是所有的临时表都是内存临时表（memory引擎）。</p>
<p>参数<code>tmp_table_size</code>限制内存临时表的大小，默认是16MB。大于该值就转为磁盘临时表（默认是InnoDB引擎，可以通过<code>internal_tmp_disk_storage_engine</code>来控制， 该临时表没有显示索引）。</p>
<p>MySQL5.6引入了一个新的排序算法，优先级队列排序，其实就是堆排序。用来处理TOP(n)的情况，可以避免对整个数据进行排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_sort_heap.png">
<p>但是使用优先级队列排序的前提是：待排序的数据集不能超过<code>sort_buffer_size</code></p>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>随机算法一：</p>
<p>生成一个ID最小值和最大值之间的随机数，取大于整个值的第一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(id),min(id) into @M,@N from t ;</span><br><span class="line"><span class="keyword">set</span> @X= <span class="keyword">floor</span>((@M-@N+<span class="number">1</span>)*<span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法效率很高，因为取 max(id) 和 min(id) 都是不需要扫描索引的，而第三步的 select 也可以用索引快速定位，可以认为就只扫描了 3 行。但实际上，这个算法本身并不严格满足题目的随机要求，因为 ID 中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p>
<p>随机算法二：</p>
<p>生成一个小于数据总行数C的随机数Y，<code>limit Y , 1</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sql</span> = <span class="keyword">concat</span>(<span class="string">"select * from t limit "</span>, @Y, <span class="string">",1"</span>);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，因此这一步需要扫描 Y+1 行。再加上，第一步扫描的 C 行，总共需要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。</p>
<p>随机算法三：</p>
<p>要获取N个随机数，只需要执行N次获取随机数第Y行的操作，再获取每次的行即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y1 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y2 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y3 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y1，<span class="number">1</span>； // 在应用代码里面取 Y1、Y2、Y3 值，拼出 <span class="keyword">SQL</span> 后执行</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y2，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y3，<span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p>注意：需要注意去重问题。</p>
<h3 id="课后题-9"><a href="#课后题-9" class="headerlink" title="课后题"></a>课后题</h3><p>上面的随机算法 3 的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p>
<p>我的答案：</p>
<p>C的扫描过程可以通过单独的计数来避免，如何计数可以参考前面<code>count(*)</code>的内容。</p>
<p>Y1,Y2,Y3的扫描优化: 对Y1, Y2, Y3进行排序，假设排序后 Y1 &lt; Y2 &lt; Y3。 Y1的扫描不可避免，获取Y1+1的行ID记为min_id， 然后<code>where id &gt; min_id_1 limit (Y2 - Y1), 1</code>;</p>
<p>其他答案：</p>
<ol>
<li>对有空洞的表进行整理，消除空洞后，利用算法一。</li>
<li>老师的方法：取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，然后执行下面这条 SQL 语句：<code>mysql&gt; select * from t limit N, M-N+1;</code></li>
</ol>
<h2 id="18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><p>在 MySQL 中，有很多看上去逻辑相同，但性能却差异巨大的 SQL 语句。对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大。</p>
<h3 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `tradelog` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `operator` int(11) DEFAULT NULL,</span><br><span class="line">  `t_modified` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>查询交易记录日志表，每年7月份的总数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>
<p>这条语句会执行全表扫描或索引扫描。原因如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_func.png">
<p>month函数计算后导致无法使用索引。</p>
<p>推而广之：针对索引自动进行函数操作，结果可能破坏索引的有序性，导致不能使用索引。</p>
<p>针对该问题，下面的SQL可以解决。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where</span><br><span class="line">    -&gt; (t_modified &gt;= '2016-7-1' and t_modified&lt;'2016-8-1') or</span><br><span class="line">    -&gt; (t_modified &gt;= '2017-7-1' and t_modified&lt;'2017-8-1') or </span><br><span class="line">    -&gt; (t_modified &gt;= '2018-7-1' and t_modified&lt;'2018-8-1');</span><br></pre></td></tr></table></figure>
<p>优化器也有<code>偷懒</code>的行为, 即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 <code>select * from tradelog where id + 1 = 10000</code> 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 <code>where id = 10000 - 1</code> 才可以(这也说明，优化器会先计算<code>10000 - 1</code>表达式，通结果作为条件)。</p>
<h3 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h3><p>数字字符串和数字进行比较时，会先转为数字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">"10"</span> &gt; <span class="number">9</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment"># 结果是：1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>
<p>对索引字段执行了cast函数，优化器判断不能使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">"83126"</span>;</span><br></pre></td></tr></table></figure>
<p>上面的SQL可以使用索引，原因是优化器可以先将”83126”转为数字83126，然后进行查询，此时可以利用索引。</p>
<h3 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `trade_detail` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `trade_step` int(11) DEFAULT NULL, <span class="comment">/* 操作步骤 */</span></span><br><span class="line">  `step_info` varchar(32) DEFAULT NULL, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure>
<p>关联查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /* 语句 Q1*/</span><br></pre></td></tr></table></figure>
<p>查询trade_detail时不能使用tradeid索引的原因是2个表的字符集不同。</p>
<p>tradelog表的字符集是utf8mb4, trade_detail表是utf8。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure>
<p>有了前面的分析，我们提前将查询条件进行手动转换，这样就可以利用索引了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2;</span><br></pre></td></tr></table></figure>
<h2 id="19讲-为什么我只查一行的语句，也执行这么慢？"><a href="#19讲-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19讲 - 为什么我只查一行的语句，也执行这么慢？"></a>19讲 - 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="等待MDL锁"><a href="#等待MDL锁" class="headerlink" title="等待MDL锁"></a>等待MDL锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i)</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>查询语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>
<p>这个查询为啥慢呢？ 如果还记得MDL元数据锁的话，你就理解了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl.png">
<p>如何复现(5.7)：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl_case.png">
<p>SessionA 持有表的MDL写锁， SessionB要获取MDL读锁，只能等待。</p>
<p>解决版本是kill掉持有MDL写锁的线程。</p>
<p>但是，由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找起来很不方便。不过有了 <code>performance_schema</code> 和 <code>sys</code> 系统库以后，就方便多了。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失)</p>
<p>通过查询 <code>sys.schema_table_lock_waits</code> 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
<h3 id="等待flush"><a href="#等待flush" class="headerlink" title="等待flush"></a>等待flush</h3><p>flush 表时，查询语句需要等待flush执行完才能继续执行。</p>
<p>MySQL 里面对表做 flush 操作的用法，一般有以下两个</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br></pre></td></tr></table></figure>
<p>通常这2个语句都执行的很快，除非被其他语句阻塞。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_flush_table.png">
<p>flush被一个查询语句阻塞，进而导致我们的查询阻塞。</p>
<h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode;</span><br></pre></td></tr></table></figure>
<p>这个语句要获取一个读锁，如果这一行正在被更新，也就是说被加了写锁，那么该语句只能等待。</p>
<p>读写互斥，2个写操作也是互斥的。</p>
<p>在MySQL5.7版本，可以通过下面的语句查询锁的持有情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`'test'.'t'`\G</span><br></pre></td></tr></table></figure>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>在没有索引的字段执行查询，在数据量比较大时，查询就很慢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure>
<p>字段c长没有建索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1；</span><br></pre></td></tr></table></figure>
<p>id字段有索引，而且是快照读，按理说应该很快。但有时候可能执行的非常慢。</p>
<p>原因在于：在一个事务中，这个查询语句2次执行期间，如果该行数据被频繁更新，这样就导致unlog非常大，<br>因为是快照读，所以第二次查询需要：<code>根据当前值逐一应用undo log，直到查询到自己事务开始的版本</code>。</p>
<p>这种情况下，加锁读反而很快。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog.png">
<p>应用undo log。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog_1.png">
<h3 id="课后题-10"><a href="#课后题-10" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？</p>
<p>答案：</p>
<p>RC隔离级别：</p>
<p>所有扫描到的行都需要加锁，在返回到Server层后，会<code>提前释放</code>不满足条件的行锁。<br>原因是不需要解决幻读问题。</p>
<p>RR隔离解绑：</p>
<p>所有扫描到的行都需要加锁，行之间会添加间隙锁(gap锁)</p>
<h2 id="20讲-幻读是什么，幻读有什么问题？"><a href="#20讲-幻读是什么，幻读有什么问题？" class="headerlink" title="20讲 - 幻读是什么，幻读有什么问题？"></a>20讲 - 幻读是什么，幻读有什么问题？</h2><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/PhantomRead.png">
<h3 id="幻读定义"><a href="#幻读定义" class="headerlink" title="幻读定义"></a>幻读定义</h3><p>幻读指的是在一个事务中，前后2次查询同一个范围内的数据，第二次查询返回第一次查询没有看到的行的现象。</p>
<ol>
<li>在RR隔离级别下，普通的读是快照读，是不会看到别的事务插入的数据的。只有<code>当前读</code>才会出现幻读现象。</li>
<li>幻读仅专指<code>新插入的行</code>。</li>
</ol>
<h3 id="幻读的问题"><a href="#幻读的问题" class="headerlink" title="幻读的问题"></a>幻读的问题</h3><h3 id="语义的问题"><a href="#语义的问题" class="headerlink" title="语义的问题"></a>语义的问题</h3><p>破坏了sql语句的语义。</p>
<h4 id="数据一致性的问题"><a href="#数据一致性的问题" class="headerlink" title="数据一致性的问题"></a>数据一致性的问题</h4><img src="/2018/12/21/geektime-mysql-learn/PhantomReadConsitentProblem.png">
<p>binlog总SQL语句时序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session B</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"><span class="comment">-- session C</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"><span class="comment">-- session A</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure>
<p><em>注意</em>:事务提交时写入binlog。session A最后提交，所以最后写入binlog。</p>
<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>为了解决幻读问题，MySQL引入了间隙锁(Gap Lock)， 间隙锁锁的是2个值之间的空隙。</p>
<blockquote>
<p>跟间隙锁存在冲突关系的，是<code>往这个间隙中插入一个记录</code>这个操，两个间隙锁不冲突。<br>间隙锁和行锁合称:<code>next-key lock</code>, 每个 <code>next-key lock</code> 都是前开后闭区间<br>间隙锁的引入，导致锁定的范围更大，更容易引起死锁问题，同时影响并发度。<br>间隙锁只有在RR隔离级别下才生效，在生产环境中可以通过<code>RC</code>隔离级别 + <code>binlog format = row</code>的配置来解决数据不一致的问题。</p>
</blockquote>
<h3 id="课后题-11"><a href="#课后题-11" class="headerlink" title="课后题"></a>课后题</h3>
<p>session B 和 session C 都会阻塞，原因如下：</p>
<p>session A加的锁如下：</p>
<ol>
<li>由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</li>
<li>在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因。</li>
<li>在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 <code>select *</code>，所以会在主键 id 上加三个行锁。</li>
</ol>
<p>因此，session A 的 select 语句锁的范围就是：</p>
<ol>
<li>索引 c 上 (5, 25)；</li>
<li>主键索引上 id=10、15、20 三个行锁。</li>
</ol>
<h2 id="21-讲-为什么我只改一行的语句，锁这么多？"><a href="#21-讲-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 讲 为什么我只改一行的语句，锁这么多？"></a>21 讲 为什么我只改一行的语句，锁这么多？</h2><h3 id="加锁规则总结"><a href="#加锁规则总结" class="headerlink" title="加锁规则总结"></a>加锁规则总结</h3><h4 id="版本条件"><a href="#版本条件" class="headerlink" title="版本条件"></a>版本条件</h4><p>5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8….</p>
<h4 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h4><p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
<p>原则 2：查找过程中访问到的对象才会加锁。</p>
<p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
<p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
<p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo1.png">
<p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<p>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</p>
<p>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo2.png">
<p>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</p>
<p>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</p>
<p>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p>
<p>根据原则 2 ，<code>只有访问到的对象才会加锁</code>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</p>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>
<blockquote>
<p>需要注意，在这个例子中，<code>lock in share mode</code> 只锁覆盖索引，但是如果是 <code>for update</code> 就不一样了。 执行 <code>for update</code> 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
</blockquote>
<p>这个例子说明，<code>锁是加在索引上的</code>；同时，它给我们的指导是，如果你要用 <code>lock in share mode</code> 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 <code>select d from t where c=5 lock in share mode</code>。你可以自己验证一下效果。</p>
<h3 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure>
<p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo3.png">
<p>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</p>
<p>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo4.png">
<p>这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>
<p>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。</p>
<p>这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。</p>
<h3 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo5.png">
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h3 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6.png">
<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>
<p>这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6_1.png">
<p>这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>

<h3 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo7.png">
<p>这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。</p>
<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/bb0ad92483d71f0dcaeeef278f89cb24.png">
<p>这个例子对我们实践的指导意义就是，<code>在删除数据的时候尽量加 limit</code> 。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><p>前面的例子中，我们在分析的时候，是按照 next-key lock 的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。</p>

<p>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</p>
<p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</p>
<p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p>
<p>原因：session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。</p>
</blockquote>
<h2 id="22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><p>这些方案都是<code>剑走偏锋</code>的优化，或问题解决方案，紧急情况下可以使用。</p>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>大量的执行很少逻辑就断开的连接。导致短时间内连接数暴涨。</p>
<p><code>max_connections</code>控制总的连接数。MySQL负载很高时，再建立新的连接会加重负载，此时可以考虑下面的方法释放空闲的连接：</p>
<ol>
<li>通过<code>show processlist</code> + <code>infomation_schema.inno_trx</code>表查询空闲的连接，通过<code>kill connnection</code>关闭空闲连接。需要注意到是服务断开连接后，客户端不能马上感知，直到客户端执行下一个sql，客户端如果不进行重连就会导致问题。极端情况下可以kill掉处于事务中的空闲连接。</li>
<li>减少连接建立过程中的消耗。跳过权限验证，重启数据库，添加参数<code>–skip-grant-tables</code></li>
</ol>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><h3 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h3><ol>
<li>关闭从库的binlog功能</li>
<li>从库执行alter table, 添加索引，主从切换</li>
<li>原来的主库变为从库，进行同样的操作。</li>
</ol>
<p>平时的运维，应该优先使用<code>gh-ost</code>这个样的工具，紧急处理可以考虑上面的方案。</p>
<h3 id="SQL语句写的不好"><a href="#SQL语句写的不好" class="headerlink" title="SQL语句写的不好"></a>SQL语句写的不好</h3><p>mysql5.7提供了<code>query_rewrite</code>功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能使用索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"><span class="comment">-- 使新插入的规则生效</span></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure>
<h3 id="优化器选错索引"><a href="#优化器选错索引" class="headerlink" title="优化器选错索引"></a>优化器选错索引</h3><ol>
<li>通过上面提到的<code>query_rewrite</code>功能</li>
<li>修改SQL语句, <code>force index</code>强制使用指定的索引。</li>
</ol>
<h3 id="QPS-突增"><a href="#QPS-突增" class="headerlink" title="QPS 突增"></a>QPS 突增</h3><ol>
<li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成”select 1”返回。</li>
</ol>
<h2 id="23讲-MySQL是怎么保证数据不丢的？"><a href="#23讲-MySQL是怎么保证数据不丢的？" class="headerlink" title="23讲 - MySQL是怎么保证数据不丢的？"></a>23讲 - MySQL是怎么保证数据不丢的？</h2><h3 id="binlog写入机制"><a href="#binlog写入机制" class="headerlink" title="binlog写入机制"></a>binlog写入机制</h3><p>事务执行过程中，binlog先写入binlog cache, 事务提交时，写入binlog 文件。</p>
<p>一个事务的binlog不能被拆分写入，必须一次性写入。</p>
<p><code>binlog_cache_size</code>设置每个线程占用的binlog缓存大小。</p>
<h3 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h3><ol>
<li>sync_binlog = 0 只写入文件page cache</li>
<li>sync_binlog = 1 每次事务提交都进行fsync操作</li>
<li>sync_binlog &gt; 1(N) 每次事务提交都写文件，但是N次以后进行一次fsync</li>
</ol>
<h3 id="redo-log-写入机制"><a href="#redo-log-写入机制" class="headerlink" title="redo log 写入机制"></a>redo log 写入机制</h3><p>事务执行过程中，会不断的将redo log写入redo log cache中。</p>
<p>innodb的后台线程会每秒（<code>write + fsync</code>）或每10秒（<code>write + fsync</code>），或者当redo log cache的剩余空间小于50%时，将缓存中的日志写入文件（<code>write</code>）, 或者其他事务提交时，将未提交事务的redo log写入文件。</p>
<p>所以没有提交事务的redo log也会被写入文件, 由此可知：innodb在大事务下，提交也是非常快的。</p>
<p><code>innodb_flush_log_at_trx_commit</code>参考控制事务提交时，redo log以哪种机制写入日志文件。</p>
<ol>
<li><code>innodb_flush_log_at_trx_commit=0</code> 事务提交时，redo log保存在缓存中。</li>
<li><code>innodb_flush_log_at_trx_commit=1</code> 事务提交时，redo log写入刷新到文件。</li>
<li><code>innodb_flush_log_at_trx_commit=2</code> 事务提交时，写入page cache。</li>
</ol>
<p>redo log 和 binlog的文件写入操作遵循两阶段提交机制：当<code>innodb_flush_log_at_trx_commit=1</code><br>时，redo log 的prepare阶段就会磁盘，当binglog写入后，提交事务时，innodb不会进行fsync。</p>
<h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>LSN 是 log sequence number的缩写。它是单调递增的，用来表示redo log的一个个写入点，每次写入长度为length的redo log， LSN的值就会增加length。</p>
<p>组提交机制：三个事务都写完redo log处于prepare状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit.png">
<ol>
<li>trx 1 第一个到达，被选为leader</li>
<li>trx 1 开始写磁盘是，组内已经有3个事务了，此时LSN=160</li>
<li>trx 1 写磁盘时，保存的LSN就是160, 所有小于160的LSN都被持久到磁盘了。</li>
<li>trx2, trx3提交时，就不用再写磁盘了，直接返回。</li>
</ol>
<p>结论：</p>
<ol>
<li>一次组提交，组内成员越多，就能更好的节约磁盘IOPS。</li>
<li>并发场景下，第一个事务（Leader）执行fsync越晚，组员就越多，节约的磁盘IOPS就越多。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit_optimize.png">
<p><code>binlog_group_commit_sync_delay</code> 参数表示延迟多少微妙后才调用fsync。</p>
<p><code>binlog_group_commit_sync_no_dely</code> 参数表示累积多少次后才调用fsync。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>如果线上MySQL有I/O瓶颈，可以暂时修改这些参数，提高性能。但需要注意丢失数据的风险。</p>
<h3 id="课后题-哪些场景可以将MySQL设置为非双1模式"><a href="#课后题-哪些场景可以将MySQL设置为非双1模式" class="headerlink" title="课后题 - 哪些场景可以将MySQL设置为非双1模式"></a>课后题 - 哪些场景可以将MySQL设置为非双1模式</h3><ol>
<li>可知的业务高峰期。</li>
<li>备库延迟</li>
<li>用备份恢复主库的副本，应用binlog的过程。</li>
<li>批量数据导入。</li>
</ol>
<h2 id="24讲-MySQL是怎么保证主备一致的？"><a href="#24讲-MySQL是怎么保证主备一致的？" class="headerlink" title="24讲 - MySQL是怎么保证主备一致的？"></a>24讲 - MySQL是怎么保证主备一致的？</h2><h3 id="MySQL主备基本原理"><a href="#MySQL主备基本原理" class="headerlink" title="MySQL主备基本原理"></a>MySQL主备基本原理</h3><p>MySQL主备切换流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave.png">
<h4 id="备库设置为readonly建议"><a href="#备库设置为readonly建议" class="headerlink" title="备库设置为readonly建议"></a>备库设置为readonly建议</h4><ol>
<li>运营的统计查询需要一半在备库执行，设置为readonly可以防止误操作。</li>
<li>防止主从切换逻辑bug,导致双master。</li>
<li>用readonly判断主从角色。</li>
</ol>
<p>从库虽然是readonly，但是由于同步更新线程拥有super权限，所以readonly的设置对同步更新是无效的。</p>
<p>MySQL主备执行流程</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave_diagram.png">
<ol>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p>最新的版本：sql_thread 演化成为了多个线程。</p>
</blockquote>
<h3 id="binlog三种格式"><a href="#binlog三种格式" class="headerlink" title="binlog三种格式"></a>binlog三种格式</h3><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>记录的是原始的SQL语句。格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<p>statement 有可能导致主从数据不一致。原因在于，同样的语句，在主从库上执行时，会因为索引选择不同，导致最终的执行结果不同。</p>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<h4 id="mix-statement-row"><a href="#mix-statement-row" class="headerlink" title="mix = statement + row"></a>mix = statement + row</h4><p>statement 格式的binlog会导致主从数据不一致，优点是：占用空间小。row格式不会导致主从不一致，但是占用空间大。所有就有了mix这种格式。MySQL会自动判断SQL语句，不影响主从一致的SQL使用statement,其他的使用row格式。</p>
<h3 id="binlog-格式最佳实践"><a href="#binlog-格式最佳实践" class="headerlink" title="binlog 格式最佳实践"></a>binlog 格式最佳实践</h3><p>推荐使用<code>row</code>格式。</p>
<ol>
<li>数据恢复，binlog里面包含了所有的信息，可以恢复误操作影响的数据。</li>
<li>基于binlog进行业务消息处理。</li>
</ol>
<h3 id="查看binlog"><a href="#查看binlog" class="headerlink" title="查看binlog"></a>查看binlog</h3><p>确定正在写入的binlog文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的binlog文件</span></span><br><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000607</span><br><span class="line">         Position: 226668235</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看指定binlog文件的内容语法：</p>
<blockquote>
<p>SHOW BINLOG EVENTS [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count]</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINLOG EVENTS IN 'mysql-bin.000607'  limit 1 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   Log_name: mysql-bin.000607</span><br><span class="line">        Pos: 4</span><br><span class="line"> Event_type: Format_desc</span><br><span class="line">  Server_id: 132656183</span><br><span class="line">End_log_pos: 120</span><br><span class="line">       Info: Server ver: 5.6.26-log, Binlog ver: 4</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看远程服务器上的binlog</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -ubosstest -p -P6183 -hbj.bosstest.w.qiyi.db <span class="comment">--start-datetime='2019-01-15 16:38:00' --stop-datetime='2019-01-15 16:40:00' --read-from-remote-server -vv mysql-bin.000607 &gt; row.sql</span></span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#190115 16:53:34 server id 132656183  end_log_pos 231732483 CRC32 0x2792c369 	Table_map: `autorenew`.`boss_dut_user_new_00` mapped to number 110965745</span></span><br></pre></td></tr></table></figure>
<h3 id="循环复制"><a href="#循环复制" class="headerlink" title="循环复制"></a>循环复制</h3><p>循环复制指的是，双Master架构下，B库重放了主库A的binlog,同时产生了binlog，B库的binlog又被主库A执行的情况。</p>
<p>解决办法如下：</p>
<ol>
<li>binlog中有server_id</li>
<li>每个数据库的server_id都需要设置不同。</li>
<li>当接收到和自己server_id相同的binlog，不执行。</li>
</ol>
<h2 id="25讲-MySQL是如何保证高可用的？"><a href="#25讲-MySQL是如何保证高可用的？" class="headerlink" title="25讲 - MySQL是如何保证高可用的？"></a>25讲 - MySQL是如何保证高可用的？</h2><h3 id="查询主从延迟时间"><a href="#查询主从延迟时间" class="headerlink" title="查询主从延迟时间"></a>查询主从延迟时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<h3 id="主从延迟原因"><a href="#主从延迟原因" class="headerlink" title="主从延迟原因"></a>主从延迟原因</h3><ol>
<li>主从机器配置不对等。</li>
<li>从库压力过大（大量的查询和统计查询）。可以通过多个从库和离线统计解决</li>
<li>大事务。 事务的binlog不能拆分，大事务执行时间长，从库执行大事务耗费同样的时间，由于是单线程，主库最新的更新不能及时同步到从库。</li>
</ol>
<h3 id="主从切换-高可靠"><a href="#主从切换-高可靠" class="headerlink" title="主从切换 - 高可靠"></a>主从切换 - 高可靠</h3><p>因为主从可能存在延迟，所以直接进行切换就会导致数据不一致的情况发生。实践中为了保证数据的一致性，可以使用如下的步骤：</p>
<ol>
<li>判断从库的延迟时间小于一个阈值，例如5s.</li>
<li>把主库改为readonly。</li>
<li>等待2个库数据一致。</li>
<li>从库改为可写。</li>
<li>业务请求切换到新的主库。</li>
</ol>
<h3 id="主从切换-高可用"><a href="#主从切换-高可用" class="headerlink" title="主从切换 - 高可用"></a>主从切换 - 高可用</h3><p>有时候主从的切换不是我们能计划的。例如主库突然down机。此时，为了尽快恢复业务，必须进行切换了。只能事后进行数据一致性恢复操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL的高可用，高度依赖主从的延迟。所以实践中尽力保证主从的延迟一直保持在一个非常小的时间范围内。</p>
<h3 id="课后题-12"><a href="#课后题-12" class="headerlink" title="课后题"></a>课后题</h3><p>什么情况下，备库的主备延迟会表现为一个 45 度的线段？</p>
<p>原因是：备库的同步在这段时间完全被堵住了。</p>
<ul>
<li>一种是大事务（包括大表 DDL、一个事务操作很多行）；</li>
<li>还有一种情况比较隐蔽，就是备库起了一个长事务，比如<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后就不动了。(获取了MDL读锁)</p>
<p>这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在备库应用的时候也会被堵住（获取MDL写锁时被阻塞），也能看到这个现象。</p>
<h2 id="26讲-备库为什么会延迟好几个小时？"><a href="#26讲-备库为什么会延迟好几个小时？" class="headerlink" title="26讲 - 备库为什么会延迟好几个小时？"></a>26讲 - 备库为什么会延迟好几个小时？</h2><p>备库的延迟是机制上导致，主库是并发执行，从库只有一个线程进行重放，延迟可以说是不可避免的。为此各大公司和MySQL官方开发了并行复制功能。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_parall_binlog.png">
<ol>
<li>原来的SQL线程变为协调线程，服务事件的分发。</li>
<li>多个SQL线程进行事件执行。</li>
</ol>
<h3 id="coordinator-分发原则"><a href="#coordinator-分发原则" class="headerlink" title="coordinator 分发原则"></a>coordinator 分发原则</h3><ol>
<li>不能造成更新覆盖。更新同一行的事务必须分发到同一个worker线程。</li>
<li>同一个事务不能被拆开，必须放到同一个worker线程中。 </li>
</ol>
<h3 id="按表分发"><a href="#按表分发" class="headerlink" title="按表分发"></a>按表分发</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图 3 所示，就是按表分发的规则。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_binlog_table.png">
<p>可以看到，每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是<code>库名.表名</code>，value 是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。</p>
<h4 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h4><ol>
<li>由于事务 T 中涉及修改表 t1，而 worker_1 队列中有事务在修改表 t1，事务 T 和队列中的某个事务要修改同一个表的数据，这种情况我们说事务 T 和 worker_1 是冲突的。</li>
<li>按照这个逻辑，顺序判断事务 T 和<code>每个worker</code> 队列的冲突关系，会发现事务 T 跟 worker_2 也冲突。</li>
<li>事务 T 跟多于一个 worker 冲突，coordinator 线程就进入等待。</li>
<li>每个 worker 继续执行，同时修改 hash_table。假设 hash_table_2 里面涉及到修改表 t3 的事务先执行完成，就会从 hash_table_2 中把 db1.t3 这一项去掉。</li>
<li>这样 coordinator 会发现跟事务 T 冲突的 worker 只有 worker_1 了，因此就把它分配给 worker_1。</li>
<li>coordinator 继续读下一个中转日志，继续分配事务。</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：<code>如果两个事务没有更新相同的行，它们在备库上可以并行执行</code>。显然，这个模式要求 binlog 格式必须是 row。</p>
<p>这时候，我们判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是<code>库名 + 表名 + 唯一键的值</code>。</p>
<p>但是，这个“唯一键”只有主键 id 还是不够的，我们还需要考虑下面这种场景，表 t1 中除了主键，还有唯一索引 a：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_row_conflict.png">
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 session B 的语句先执行。这时候 id=1 的行的 a 的值还是 1，就会报唯一键冲突。</p>
<p>因此，基于行的策略，事务 hash 表中还需要考虑唯一键，即 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。</p>
<p>比如，在上面这个例子中，我要在表 t1 上执行 <code>update t1 set a=1 where id=2</code> 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p>
<p>因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
<p>可见<code>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源</code>。你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ol>
<p>但，好在这三条约束规则，本来就是 DBA 之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p>
<p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li>
<li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li>
</ol>
<p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p>
<ol>
<li>coordinator 暂时先 hold 住这个事务；</li>
<li>等待所有 worker 都执行完成，变成空队列；</li>
<li>coordinator 直接执行这个事务；</li>
<li>恢复并行模式。</li>
</ol>
<p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的 hash 表里，key 就是数据库名。</p>
<p>这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。</p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<p>但是，如果你的主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p>
<p>理论上你可以创建不同的 DB，把相同热度的表均匀分到这些不同的 DB 中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><p>在 <a href="https://time.geekbang.org/column/article/76161" target="_blank" rel="noopener">https://time.geekbang.org/column/article/76161</a> 中，我给你介绍了 redo log 组提交 (group commit) 优化， 而 MariaDB 的并行复制策略利用的就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB 是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析 binlog，并拆分到 worker”上。而 MariaDB 的这个策略，目标是“模拟主库的并行模式”。</p>
<p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在 commit 的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>如图 5 所示，假设了三组事务在主库的执行情况，你可以看到在 trx1、trx2 和 trx3 提交的时候，trx4、trx5 和 trx6 是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入 commit 状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/8fec5fb48d6095aecc80016826efbfc3.png">
<p>而按照 MariaDB 的并行复制策略，备库上的执行效果如图 6 所示。</p>
<img src="/2018/12/21/geektime-mysql-learn/8ac3799c1ff2f9833619a1624ca3e622.png">
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p>
<p>另外，这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在备库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间，只有一个 worker 线程在工作，是对资源的浪费。</p>
<p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>在 MariaDB 并行复制实现之后，官方的 MySQL5.7 版本也提供了类似的功能，由参数 slave-parallel-type 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略。不过，MySQL 5.7 这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li>
</ol>
<p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p>
<p>答案是，不能。</p>
<p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的 worker，就会出现备库跟主库不一致的情况。</p>
<p>而上面提到的 MariaDB 这个策略的核心，是“所有处于 commit”状态的事务可以并行。事务处于 commit 状态，表示已经通过了锁冲突的检验了。</p>
<p>这时候，你可以再回顾一下两阶段提交:</p>
<img src="/2018/12/21/geektime-mysql-learn/5ae7d074c34bc5bd55c82781de670c28.png">
<p>其实，不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁冲突的检验了。</p>
<p>因此，MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<p>我在第 23 篇文章，讲 binlog 的组提交的时候，介绍过两个参数：</p>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>这两个参数是用于故意拉长 binlog 从 write 到 fsync 的时间，以此减少 binlog 的写盘次数。在 MySQL 5.7 的并行复制策略里，它们可以用来制造更多的“同时处于 prepare 阶段的事务”。这样就增加了备库复制的并行度。</p>
<p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在 MySQL 5.7 处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<h3 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h3><p>在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。</p>
<p>相应地，新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p>
<ol>
<li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p>当然为了唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。</p>
<p>你可能看出来了，这跟我们前面介绍的基于 MySQL 5.5 版本的按行分发的策略是差不多的。不过，MySQL 官方的这个实现还是有很大的优势：</p>
<p>因此，MySQL 5.7.22 的并行复制策略在通用性上还是有保证的。</p>
<p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h3 id="课后题-13"><a href="#课后题-13" class="headerlink" title="课后题"></a>课后题</h3><p>如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p>
<p>这个问题的答案是，应该将这个参数设置为 WRITESET。</p>
<p>由于主库是单线程压力模式，所以每个事务的 commit_id 都不同，那么设置为 COMMIT_ORDER 模式的话，从库也只能单线程执行。</p>
<p>同样地，由于 WRITESET_SESSION 模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p>
<p>所以，应该将 binlog-transaction-dependency-tracking 设置为 WRITESET。</p>
<h2 id="27-主库出问题了，从库怎么办？"><a href="#27-主库出问题了，从库怎么办？" class="headerlink" title="27 - 主库出问题了，从库怎么办？"></a>27 - 主库出问题了，从库怎么办？</h2><p>大多数的互联网应用场景都是读多写少，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题的常用架构是：一主多从。</p>
<p>下图是典型的一主多从架构：</p>
<img src="/2018/12/21/geektime-mysql-learn/aadb3b956d1ffc13ac46515a7d619e79.png">
<p>图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<p>如下图所示，就是主库发生故障，主备切换后的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/0014f97423bd75235a9187f492fb2453.png">
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>
<p>这条命令有这么 6 个参数：</p>
<ol>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ol>
<p>那么，这里就有一个问题了，节点 B 要设置成 A’的从库，就要执行 change master 命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？</p>
<p>原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，<code>A 的位点和 A’的位点是不同的</code>。因此，从库 B 要切换的时候，就需要先经过<code>找同步位点</code>这个逻辑。</p>
<p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p>
<p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p>
<p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个<code>稍微往前</code>的，然后再通过判断<code>跳过那些在从库B上已经执行过的事务</code>。</p>
<p>一种取同步位点的方法是这样的：</p>
<ol>
<li>等待新主库 A’把中转日志（relay log）全部同步完成；</li>
<li>在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；</li>
<li>取原主库 A 故障的时刻 T；</li>
<li>用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/3471dfe4aebcccfaec0523a08cdd0ddd.png">
<p>图中，end_log_pos 后面的值“123”，表示的就是 A’这个实例，在 T 时刻写入新的 binlog 的位置。然后，我们就可以把 123 这个值作为 $master_log_pos ，用在节点 B 的 change master 命令里。</p>
<p>当然这个值并不精确。为什么呢？</p>
<p>你可以设想有这么一种情况，假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。</p>
<p>那么，这时候系统的状态是这样的：</p>
<ol>
<li>在从库 B 上，由于同步了 binlog， R 这一行已经存在；</li>
<li>在新主库 A’上， R 这一行也已经存在，日志是写在 123 这个位置之后的；</li>
<li>我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</li>
</ol>
<p>这时候，从库 B 的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p>
<p>所以：通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</p>
<p>一种做法是，主动跳过一个事务。跳过命令的写法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<p>另外一种方式是，通过设置 slave_skip_errors 参数，直接设置跳过指定的错误。</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ul>
<p>因此，我们可以把 slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p>
<p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
<p>这个背景是，我们很清楚在主备切换过程中，直接跳过 1032 和 1062 这两类错误是无损的，所以才可以这么设置 slave_skip_errors 参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<p>通过 sql_slave_skip_counter 跳过事务和通过 slave_skip_errors 忽略错误的方法，虽然都最终可以建立从库 B 和新主库 A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。</p>
<p>那么，GTID 到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p>
<p>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure>
<p>这里我需要和你说明一下，在 MySQL 的官方文档里，GTID 格式是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure>
<p>这里的 source_id 就是 server_uuid；而后面的这个 transaction_id，我觉得容易造成误导，所以我改成了 gno。为什么说使用 transaction_id 容易造成误解呢？</p>
<p>因为，在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配。</p>
<p>从效果上看，GTID 往往是连续的，因此我们用 gno 来表示更容易理解。</p>
<p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 gtid_mode=on 和 enforce_gtid_consistency=on 就可以了。</p>
<p>在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值。</p>
<ol>
<li>如果 gtid_next=automatic，代表使用默认值。这时，MySQL 就会把 server_uuid:gno 分配给这个事务。<br> a. 记录 binlog 的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;<br> b. 把这个 GTID 加入本实例的 GTID 集合。</li>
<li>如果 gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next=’current_gtid’指定为 current_gtid，那么就有两种可能：<br>a.  如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；<br>b.  如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。    </li>
</ol>
<p>注意，一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。</p>
<p>这样，每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。</p>
<p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明 GTID 的基本用法。</p>
<p>我们在实例 X 中创建一个表 t。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/28a5cab0079fb12fd5abecd92b3324c2.png">
<p>可以看到，事务的 BEGIN 之前有一条 SET @@SESSION.GTID_NEXT 命令。这时，如果实例 X 有从库，那么将 CREATE TABLE 和 insert 语句的 binlog 同步过去执行的话，执行事务之前就会先执行这两个 SET 命令， 这样被加入从库的 GTID 集合的，就是图中的这两个 GTID。</p>
<p>假设，现在这个实例 X 是另外一个实例 Y 的从库，并且此时在实例 Y 上执行了下面这条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>并且，这条语句在实例 Y 上的 GTID 是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p>
<p>那么，实例 X 作为 Y 的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例 X 的同步线程停止。这时，我们应该怎么处理呢？</p>
<p>处理方法就是，你可以执行下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next=<span class="string">'aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。如图 5 所示，就是执行完这个空事务之后的 show master status 的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/c8d3299ece7d583a3ecd1557851ed157.png">
<p>可以看到实例 X 的 Executed_Gtid_set 里面，已经加入了这个 GTID。</p>
<p>这样，我再执行 start slave 命令让同步线程执行起来的时候，虽然实例 X 上还是会继续执行实例 Y 传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例 X 的 GTID 集合中了，所以实例 X 就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<p>在上面的这个语句序列中，start slave 命令之前还有一句 set gtid_next=automatic。这句话的作用是“恢复 GTID 的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配 gno=3。</p>
<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><p>现在，我们已经理解 GTID 的概念，再一起来看看基于 GTID 的主备复制的用法。</p>
<p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>其中，master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。可以看到，前面让我们头疼不已的 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，已经不需要指定了。</p>
<p>我们把现在这个时刻，实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。接下来，我们就看看现在的主备切换逻辑。</p>
<p>我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li>实例 B 指定主库 A’，基于主备协议建立连接。</li>
<li>实例 B 把 set_b 发给主库 A’。</li>
<li>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GITD 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。<br> a.  如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；<br> b.  如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</li>
<li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。    </li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A’就拒绝把日志发给 B。</p>
<p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p>
<p>基于上面的介绍，我们再来看看引入 GTID 后，一主多从的切换场景下，主备切换是如何实现的。</p>
<p>由于不需要找位点了，所以从库 B、C、D 只需要分别执行 change master 命令指向实例 A’即可。</p>
<p>其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例 A’内部就已经自动完成了。但由于这个工作是自动的，所以对 HA 系统的开发人员来说，非常友好。</p>
<p>之后这个系统就由新主库 A’写入，主库 A’的自己生成的 binlog 中的 GTID 集合格式是：server_uuid_of_A’:1-M。</p>
<p>如果之前从库 B 的 GTID 集合格式是 server_uuid_of_A:1-N， 那么切换之后 GTID 集合的格式就变成了 server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p>
<p>当然，主库 A’之前也是 A 的备库，因此主库 A’和从库 B 的 GTID 集合是一样的。这就达到了我们预期。</p>
<h3 id="GTID-和在线-DDL"><a href="#GTID-和在线-DDL" class="headerlink" title="GTID 和在线 DDL"></a>GTID 和在线 DDL</h3><p>在《MySQL 有哪些“饮鸩止渴”提高性能的方法？》中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。   </p>
<p>当时我说，在双 M 结构下，备库执行的 DDL 语句也会传给主库，为了避免传回后对主库造成影响，要通过 set sql_log_bin=off 关掉 binlog。</p>
<p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是 binlog 并没有记录下这一个更新，是不是会导致数据和日志不一致？</p>
<p>这个问题提得非常好。当时，我在留言的回复中就引用了 GTID 来说明。今天，我再和你展开说明一下。</p>
<p>假设，这两个互为主备关系的库还是实例 X 和实例 Y，且当前主库是 X，并且都打开了 GTID 模式。这时的主备切换流程可以变成下面这样：</p>
<ol>
<li>在实例 X 上执行 stop slave。</li>
<li>在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。</li>
<li>执行完成后，查出这个 DDL 语句对应的 GTID，并记为 server_uuid_of_Y:gno。</li>
<li>到实例 X 上执行以下语句序列：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> GTID_NEXT=<span class="string">"server_uuid_of_Y:gno"</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做的目的在于，既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。 </p>
<ul>
<li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li>
</ul>
<h3 id="课后题-14"><a href="#课后题-14" class="headerlink" title="课后题"></a>课后题</h3><p>你在 GTID 模式下设置主从关系的时候，从库执行 start slave 命令后，主库发现需要的 binlog 已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p>
<p>答案如下:</p>
<ol>
<li>如果业务允许主从不一致的情况，那么可以在主库上先执行 show global variables like ‘gtid_purged’，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 reset master，再执行 set global gtid_purged =‘gtid_purged1’；最后执行 start slave，就会从主库现存的 binlog 开始同步。binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li>
<li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li>
<li>如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。</li>
<li>如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 start slave。</li>
</ol>
<h2 id="28讲-读写分离有哪些坑？"><a href="#28讲-读写分离有哪些坑？" class="headerlink" title="28讲 - 读写分离有哪些坑？"></a>28讲 - 读写分离有哪些坑？</h2><p>读写分离主要是为了分担主库的压力。有下面2中场景的架构</p>
<p>客户端直连：</p>
<img src="/2018/12/21/geektime-mysql-learn/1334b9c08b8fd837832fdb2d82e6b0aa.png">
<p>客户端通过proxy进行读写分离</p>
<img src="/2018/12/21/geektime-mysql-learn/065ef246c59019effc8384967d774318.png">
<ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</p>
<p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能 100% 避免的。</p>
<p>处理过期读的方案汇总</p>
<ul>
<li>强制走主库方案</li>
<li>sleep 方案</li>
<li>判断主备无延迟方案</li>
<li>配合 semi-sync 方案</li>
<li>等主库位点方案</li>
<li>等 GTID 方案</li>
</ul>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ul>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ul>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。</p>
<p>这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>要确保备库无延迟，通常有三种做法。</p>
<h4 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h4><p>我们知道 show slave status 结果里的 seconds_behind_master 参数的值，可以用来衡量主备延迟时间的长短。</p>
<img src="/2018/12/21/geektime-mysql-learn/00110923007513e865d7f43a124887c1.png">
<p>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
<p>seconds_behind_master 的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p>
<h4 id="对比位点确保主备无延迟："><a href="#对比位点确保主备无延迟：" class="headerlink" title="对比位点确保主备无延迟："></a>对比位点确保主备无延迟：</h4><ul>
<li>Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<h4 id="对比-GTID-集合确保主备无延迟："><a href="#对比-GTID-集合确保主备无延迟：" class="headerlink" title="对比 GTID 集合确保主备无延迟："></a>对比 GTID 集合确保主备无延迟：</h4><ul>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。    </p>
<p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p>
<p>我们现在一起来回顾下，一个事务的 binlog 在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入 binlog，并反馈给客户端；</li>
<li>binlog 被从主库发送给备库，备库收到；</li>
<li>在备库执行 binlog 完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/557445207b57d6c0f2747509d7d6619e.png">
<p>这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：</p>
<ul>
<li>trx1 和 trx2 已经传到从库，并且已经执行完成了；</li>
<li>trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ul>
<p>如果这时候你在从库 B 上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读。</p>
<p>那么，这个问题有没有办法解决呢？</p>
<p>配合 semi-sync</p>
<p>要解决这个问题，就要引入半同步复制，也就是 semi-sync replication。</p>
<p>semi-sync 做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p>在 第 25 篇文章 的评论区，有同学问到：如果主库掉电的时候，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？</p>
<p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。</p>
<p>这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ul>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ul>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p>
<p>为什么这么说呢？我们来看一下这个时序图。</p>
<img src="/2018/12/21/geektime-mysql-learn/9cf54f3e91dc8f7b8947d7d8e384aa09.png">
<p>图 5 所示，就是等待位点方案的一个 bad case。图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，图 5 中从状态 1 到状态 4，一直处于延迟一个事务的状态。</p>
<p>备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。</p>
<p>但是，其实客户端是在发完 trx1 更新后发起的 select 语句，我们只需要确保 trx1 已经执行完成就可以执行 select 语句了。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了。</p>
<p>到这里，我们小结一下，semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ul>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ul>
<p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>]);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑如下：</p>
<ul>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ul>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p>
<p>当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ul>
<p>对于图 5 中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ul>
<li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select master_pos_wait(File, Position, 1)；</li>
<li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<img src="/2018/12/21/geektime-mysql-learn/b20ae91ea46803df1b63ed683e1de357.png">
<p>这里我们假设，这条 select 查询最多在从库上等待 1 秒。那么，如果 1 秒内 master_pos_wait 返回一个大于等于 0 的整数，就确保了从库上执行的这个查询结果一定包含了 trx1 的数据。</p>
<p>步骤 5 到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p>
<p>你可能会说，如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p>
<p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><p>如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。</p>
<p>MySQL 中同样提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑是：</p>
<ul>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ul>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<p>这时，等 GTID 的执行流程就变成了：</p>
<ul>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li>
<li>如果返回值是 0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p>
<img src="/2018/12/21/geektime-mysql-learn/d521de8017297aff59db2f68170ee739.png">
<p>在上面的第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。问题是，怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？</p>
<p>你只需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可。</p>
<p>在专栏的第一篇文章中，我介绍 mysql_reset_connection 的时候，评论区有同学留言问这类接口应该怎么使用。</p>
<p>这里我再回答一下。其实，MySQL 并没有提供这类接口的 SQL 用法，是提供给程序的 API <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html</a></p>
<p>比如，为了让客户端在事务提交后，返回的 GITD 能够在客户端显示出来，我对 MySQL 客户端代码做了点修改，如下所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/973bdd8741f830acebe005cbf37a7663.png">
<p>这样，就可以看到语句执行完成，显示出 GITD 的值。</p>
<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用 mysql_session_track_get_first 这个函数。</p>
<h3 id="课后题-15"><a href="#课后题-15" class="headerlink" title="课后题"></a>课后题</h3><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等 GTID 的方案，现在你要对主库的一张大表做 DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p>
<p>答案：如果该DDL语句在主库执行了10min，那么提交后传到备库执行也需要10min。之后主库DDL后提交的事务的GTID，在备库查询时，需要等待10min才会出现，此时，所有的读请求都会路由到主库。</p>
<p>方法1：在业务低峰期进行，确保主库可以满足所有的查询压力，把所有的读请求都路由到主库上。等备库追上主库后切回来。<br>方法2：先在被库执行DDL，再将备库切换主库。</p>
<h2 id="29讲-如何判断一个数据库是不是出问题了？"><a href="#29讲-如何判断一个数据库是不是出问题了？" class="headerlink" title="29讲-如何判断一个数据库是不是出问题了？"></a>29讲-如何判断一个数据库是不是出问题了？</h2><h3 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h3><ul>
<li>主动切换</li>
<li>被动切换(HA系统发起)</li>
</ul>
<h3 id="主库健康检查"><a href="#主库健康检查" class="headerlink" title="主库健康检查"></a>主库健康检查</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select 1"></a>select 1</h4><p>只能判断MySQL进程存在</p>
<ul>
<li>innodb_thread_concurrency 控制innodb并发线程上限，超过该值的请求进入等待状态。 默认该值为0，表示不限制。</li>
<li>并发连接 != 并发查询(<code>innodb_thread_concurrency</code>)， show processlist查询的是并发连接</li>
<li>进入锁等待的线程不占用<code>innodb_thread_concurrency</code>的值。</li>
</ul>
<h4 id="查询表判断"><a href="#查询表判断" class="headerlink" title="查询表判断"></a>查询表判断</h4><p>创建一个表<code>health_check</code>，定时检查。</p>
<p>这种方法能检查因并发线程多导致系统不可用的情况。</p>
<h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>执行update语句，来判断是否有足够的磁盘来保证系统的正常运行（更新会写binlog和redo log，磁盘空间不足会导致所有的更新都阻塞）。</p>
<p>主备都需要做健康检查：</p>
<p>双M架构下，为了防止主备之间的更新冲突，<code>mysql.health_check</code>表插入多行数据，以<code>server_id</code>作为主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `health_check` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(<span class="keyword">id</span>, t_modified) <span class="keyword">values</span> (@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure>
<h3 id="外部检查的局限性"><a href="#外部检查的局限性" class="headerlink" title="外部检查的局限性"></a>外部检查的局限性</h3><p>上面提到的都是外部检查的实现方案。有一定的缺点：</p>
<ol>
<li>随机性。轮询进行健康检查，不能及时发现问题。</li>
<li>外部健康检查请求需要的资源少，能马上执行，但是其他业务请求不能正常处理。</li>
</ol>
<h3 id="内部检查"><a href="#内部检查" class="headerlink" title="内部检查"></a>内部检查</h3><p><code>performance_schema</code>里面有多个表，可以统计系统的健康状况。</p>
<h2 id="30讲-用动态的观点看加锁"><a href="#30讲-用动态的观点看加锁" class="headerlink" title="30讲 - 用动态的观点看加锁"></a>30讲 - 用动态的观点看加锁</h2><h2 id="31讲-误删数据库处理"><a href="#31讲-误删数据库处理" class="headerlink" title="31讲 - 误删数据库处理"></a>31讲 - 误删数据库处理</h2><h2 id="32讲-为什么还有kill不掉的语句"><a href="#32讲-为什么还有kill不掉的语句" class="headerlink" title="32讲 - 为什么还有kill不掉的语句"></a>32讲 - 为什么还有kill不掉的语句</h2><h2 id="33讲-我查这么多数据会不会把数据库打爆"><a href="#33讲-我查这么多数据会不会把数据库打爆" class="headerlink" title="33讲 - 我查这么多数据会不会把数据库打爆"></a>33讲 - 我查这么多数据会不会把数据库打爆</h2><h2 id="34讲-到底可不可以使用Join"><a href="#34讲-到底可不可以使用Join" class="headerlink" title="34讲 - 到底可不可以使用Join"></a>34讲 - 到底可不可以使用Join</h2><h2 id="35讲-join语句怎么优化"><a href="#35讲-join语句怎么优化" class="headerlink" title="35讲 - join语句怎么优化"></a>35讲 - join语句怎么优化</h2><h2 id="36讲-为什么临时表可以重名"><a href="#36讲-为什么临时表可以重名" class="headerlink" title="36讲 - 为什么临时表可以重名"></a>36讲 - 为什么临时表可以重名</h2><h2 id="37讲-什么时候会使用内部临时表"><a href="#37讲-什么时候会使用内部临时表" class="headerlink" title="37讲 - 什么时候会使用内部临时表"></a>37讲 - 什么时候会使用内部临时表</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>意思是取2个子查询结果的并集。</p>
<img src="/2018/12/21/geektime-mysql-learn/402cbdef84eef8f1b42201c6ec4bad4e.png">
<p><code>using temporary</code> 表示使用了临时表。</p>
<p>该语句的执行流程如下：</p>
<ol>
<li>创建一个只有一个整形字段<code>f</code>，且<code>f</code>是主键的临时表。</li>
<li>执行第一个子查询，得到1000这个值，插入到临时表中。</li>
<li>执行第二个子查询，得到1000插入临时表时，违反唯一性约束，失败，然后继续执行。</li>
<li>取第二行999，插入临时表成功。结束。</li>
<li>从临时表获取数据，返回给客户端，并删除临时表。</li>
</ol>
<p>可以看出：临时表使用来<code>暂存</code>数据的。</p>
<p>如果将<code>union</code>改为<code>union all</code>，没有去重语义，这样就依次执行子查询，将结果返回给客户端，不会使用到临时表。</p>
<img src="/2018/12/21/geektime-mysql-learn/c1e90d1d7417b484d566b95720fe3f6d.png">
<h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>该语句的逻辑是，将表中的数据按<code>1d%10</code>后的结果进行分组统计，然后按<code>m</code>的结果排序后输出。</p>
<img src="/2018/12/21/geektime-mysql-learn/3d1cb94589b6b3c4bb57b0bdfa385d98.png">
<p>从explain的结果可以知道：</p>
<ol>
<li>Using index, 表示使用了覆盖索引，选择了索引a， 不需要回表。</li>
<li>Using temporary，表示使用了临时表。</li>
<li>Using filesort，表示使用了文件排序。</li>
</ol>
<p>语句执行流程如下：</p>
<ol>
<li>创建一个临时表，包含字段 <code>m</code> 和 <code>c</code>, 主键是<code>m</code>。</li>
<li>扫描索引<code>a</code>，依次取出叶子节点上的id值，计算<code>id%10</code>的结果，记为x。</li>
<li>如果临时表中没有主键为x的行，则插入(x, 1)；如果存在，则对x行的c列加一。</li>
<li>遍历<code>索引a</code>完成后，对临时表按<code>m</code>进行排序，得到的结果输出给客户端。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/0399382169faf50fc1b354099af71954.jpg">
<p>内存临时表的排序如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/b5168d201f5a89de3b424ede2ebf3d68.jpg">
<blockquote>
<p>注意：如果不需要对结果进行排序，可以在语句后面添加<code>order by null</code>来取消排序过程。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>内存临时表的大小由<code>tmp_table_size</code>来设置(默认是16M)，如果数据量很大，不能全部保存在内存临时表中，此时就会使用磁盘临时表。磁盘临时表使用的是Innodb存储引擎。</p>
<h3 id="group-by的优化方法-索引"><a href="#group-by的优化方法-索引" class="headerlink" title="group by的优化方法 - 索引"></a>group by的优化方法 - 索引</h3><p>不论是内存临时表还是磁盘临时表，都需创建一个带有主键的临时表。</p>
<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>
<p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p>
<p>假设，现在有一个类似图 10 的这么一个数据结构，我们来看看 group by 可以怎么做。</p>
<img src="/2018/12/21/geektime-mysql-learn/5c4a581c324c1f6702f9a2c70acddd19.jpg">
<p>可以看到，如果可以确保输入的数据是有序的，那么计算 <code>group by</code> 的时候，就只需要从左到右，顺序扫描，依次累加。</p>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 <code>group by</code> 的结果，不需要临时表，也不需要再额外排序。</p>
<p>InnoDB 的索引，就可以满足这个输入有序的条件。</p>
<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="built_in">int</span> <span class="keyword">generated</span> <span class="keyword">always</span> <span class="keyword">as</span>(<span class="keyword">id</span> % <span class="number">100</span>), <span class="keyword">add</span> <span class="keyword">index</span>(z);</span><br></pre></td></tr></table></figure>
<p>这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by 语句就可以改成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>

<h3 id="group-by-优化方法-–-直接排序"><a href="#group-by-优化方法-–-直接排序" class="headerlink" title="group by 优化方法 – 直接排序"></a>group by 优化方法 – 直接排序</h3><p>如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的 group by 要怎么优化呢？</p>
<p>如果我们明明知道，一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p>
<p>在 group by 语句中加入 <code>SQL_BIG_RESULT</code> 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>
<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<p>下面语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_BIG_RESULT</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ul>
<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；    </li>
<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>
<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>基于上面的 union、union all 和 group by 语句的执行过程的分析，我们来回答文章开头的问题：MySQL 什么时候会使用内部临时表？</p>
<ul>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>
</ul>
<h2 id="38讲-都说InnoDB好，那还要不要使用Memory引擎？"><a href="#38讲-都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="38讲 - 都说InnoDB好，那还要不要使用Memory引擎？"></a>38讲 - 都说InnoDB好，那还要不要使用Memory引擎？</h2><p>Innodb引擎 </p>
<img src="/2018/12/21/geektime-mysql-learn/4e29e4f9db55ace6ab09161c68ad8c8d.jpg">
<p>Memory引擎</p>
<p>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。我们来看一下表 t1 中的数据内容。</p>
<img src="/2018/12/21/geektime-mysql-learn/dde03e92074cecba4154d30cd16a9684.jpg">
<p>可以看到，内存表的<code>数据部分以数组</code>的方式单独存放，而主键 id 索引里，存的是每个<code>数据的位置</code>。主键 id 是 <code>hash</code> 索引，可以看到索引上的 <code>key 并不是有序的</code>。</p>
<ol>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>
<li>而 Memory 引擎采用的是把数据单独存放，索引上保存<code>数据位置</code>的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>
</ol>
<p>从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<p>需要指出的是，表 t1 的这个主键索引是哈希索引，因此如果执行范围查询，比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>是用不上主键索引的，需要走全表扫描。</p>
<h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p>实际上，内存表也是支 B-Tree 索引的。在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">index</span> a_btree_index <span class="keyword">using</span> btree (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<p>这时，表 t1 的数据组织形式就变成了这样：</p>
<img src="/2018/12/21/geektime-mysql-learn/1788deca56cb83c114d8353c92e3bde3.jpg">
<p>不建议你在生产环境上使用内存表，原因如下：</p>
<ul>
<li>锁粒度问题；</li>
<li>数据持久化问题。</li>
</ul>
<h3 id="内存表的锁"><a href="#内存表的锁" class="headerlink" title="内存表的锁"></a>内存表的锁</h3><p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>
<h3 id="数据持久性问题"><a href="#数据持久性问题" class="headerlink" title="数据持久性问题"></a>数据持久性问题</h3><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p>
<p>在高可用架构下，稳定性很差，可能发生主从库的数据都被情况的异常。</p>
<p>重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>
<blockquote>
<p>建议你把普通内存表都用 InnoDB 表来代替。<br>基于内存表的特性，它的一个适用场景，就是内存临时表。内存表支持 hash 索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p>
</blockquote>
<h2 id="自增主键为什么不是连续的"><a href="#自增主键为什么不是连续的" class="headerlink" title="自增主键为什么不是连续的?"></a>自增主键为什么不是连续的?</h2><ol>
<li>不同引擎自增主键的值保存在不同的地方。</li>
<li>Memory 保存在数据文件中</li>
<li>MySQL8.0之前保存在内存中，重启会丢失。8.0开始保存在redo log 中。</li>
</ol>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><ol>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p>新的自增值生成算法是：</p>
<blockquote>
<p>从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p>
</blockquote>
<p>其中，auto_increment_offset 和 auto_increment_increment 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。</p>
<blockquote>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双 M 的主备结构里要求双写的时候，我们就可能会设置成 auto_increment_increment=2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。</p>
</blockquote>
<p>当 auto_increment_offset 和 auto_increment_increment 都是 1 的时候，新的自增值生成逻辑很简单，就是：</p>
<ul>
<li>如果准备插入的值 &gt;= 当前自增值，新的自增值就是“准备插入的值 +1”；</li>
<li>否则，自增值不变。</li>
</ul>
<h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p>假设，表 t 里面已经有了 (1,1,1) 这条记录，这时我再执行一条插入数据命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1);</li>
<li>InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；</li>
<li>将传入的行的值改成 (2,1,1);</li>
<li>将表的自增值改成 3；</li>
<li>继续执行插入数据操作，由于已经存在 c=1 的记录，所以报 Duplicate key error，语句返回。</li>
</ol>
<p>可以看到，这个表的自增值改成 3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键 c 冲突，所以 id=2 这一行并没有插入成功，<code>但也没有将自增值再改回去</code>。</p>
<blockquote>
<p>唯一键冲突是导致自增主键 id 不连续的第一种原因。<br>事务回滚也会产生类似的现象，这就是第二种原因。</p>
</blockquote>
<p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表 t 的自增值改回去呢？如果把表 t 的当前自增值从 3 改回 2，再插入新数据的时候，不就可以生成 id=2 的一行数据了吗？</p>
<p>其实，MySQL 这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看</p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<ol>
<li>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</li>
<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</li>
<li>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</li>
<li>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。</p>
<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>可以看到，自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在 MySQL 5.1 版本之前，并不是这样的。</p>
<p>在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p>
<p>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p>
<ol>
<li>这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为 1 时：<ul>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
<li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。    </li>
</ol>
<p>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是 2？</p>
<p>答案是，这么设计还是为了数据的一致性。</p>
<p>我们一起来看一下这个场景：</p>
<img src="/2018/12/21/geektime-mysql-learn/e0a69e151277de54a8262657e4ec89df.png">
<p>你可以设想一下，如果 session B 是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>你可能会说，这也没关系吧，毕竟 session B 的语义本身就没有要求表 t2 的所有行的数据都跟 session A 相同。</p>
<p>是的，从数据逻辑上看是对的。但是，如果我们现在的 binlog_format=statement，你可以设想下，binlog 会怎么记录呢？</p>
<p>由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t2 的更新日志只有两种情况：要么先记 session A 的，要么先记 session B 的。</p>
<p>但不论是哪一种，这个 binlog 拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B 这个语句执行出来，生成的结果里面，id 都是连续的。这时，这个库就发生了数据不一致。</p>
<p>原因在于原库 session B 的 insert 语句，生成的 id 不连续。这个不连续的 id，用 statement 格式的 binlog 来串行执行，是执行不出来的。</p>
<p>而要解决这个问题，有两种思路：</p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。</li>
</ol>
<p>因此，在生产上，尤其是有 insert … select 这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row. 这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>需要注意的是，我这里说的，批量插入数据，包含的语句类型是 insert … select、replace … select 和 load data 语句。</p>
<p>但是，在普通的 insert 语句里面包含多个 value 值的情况下，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为<code>不知道要预先申请多少个 id</code>。</p>
<p>既然预先不知道要申请多少个自增 id，那么一种直接的想法就是需要一个时申请一个。但如果一个 select … insert 语句要插入 10 万行数据，按照这个逻辑的话就要申请 10 万次。显然，这种申请自增 id 的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p>
<p>因此，对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ul>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>insert…select，实际上往表 t2 中插入了 4 行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了 id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。</p>
<p>由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7 就被浪费掉了。之后，再执行 insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p>
<blockquote>
<p>这是主键 id 出现自增 id 不连续的第三种原因。</p>
</blockquote>
<h3 id="课后题-16"><a href="#课后题-16" class="headerlink" title="课后题"></a>课后题</h3><p>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。</p>
<p>答案：</p>
<h2 id="40-讲-insert语句的锁为什么这么多？"><a href="#40-讲-insert语句的锁为什么这么多？" class="headerlink" title="40 讲 insert语句的锁为什么这么多？"></a>40 讲 insert语句的锁为什么这么多？</h2><h2 id="41讲-怎么快速复制一张表？"><a href="#41讲-怎么快速复制一张表？" class="headerlink" title="41讲 - 怎么快速复制一张表？"></a>41讲 - 怎么快速复制一张表？</h2><p>如果可以控制对源表的扫描行数和加锁范围很小的话，可以简单的使用<code>insert select</code> 语句实现。</p>
<p>如果需要避免对源表加锁，稳妥的解决办法是将数据保存到临时文件中，然后再写入目标表。此时有两种办法如下：</p>
<p>创建表 db1.t:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></table></figure>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>将db1.t表中的&gt;900的数据导出到文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">--add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ol>
<li>–single-transaction 意思是导出数据的是，不需要对db1.t加表锁，而是使用<code>start transaction with consitent snapshot</code>方法。</li>
<li>–add-locks 设置为0，表示在输出的文件中，不增加<code>lock tables t write</code></li>
<li>–no-create-info 表示不要导出表结构</li>
<li>–set-gtid-purged=OFF 表示不要输出和gtid相关的信息</li>
<li>–result-file 指定数据文件的路径，client表示文件位于客户端机器上。</li>
</ol>
<p>输出的文件内存是<code>insert values (...),(...)</code>格式，目的是为了加快执行速度。</p>
<p>可以通过参数<code>--skip-extended-insert</code>变为一个个的insert语句。</p>
<p>通过下面的语句将数据导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"</span><br></pre></td></tr></table></figure>
<h3 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>该语句的结果是保存在服务端的。</li>
<li>into outfile指定了文件的位置，这个位置必须受参数<code>secure_file_priv</code>限制。1，设置为empty表示不限制(不安全)。2,如果是一个表示路径的字符串，表示只能保存在这个目录。3,设置为NULL表示禁止执行该操作。</li>
<li>该命令不会帮你覆盖已经存在的文件。</li>
<li>原则上一行数据对应文本中的一行，但是字段值有换行符，文本中也会包含换行符，但是会被转义。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure>
<p>执行流程如下：</p>
<ol>
<li>打开文件，以制表符<code>\t</code>作为字段值得分隔符，以换行符<code>\n</code>作为记录之间的分隔符进行数据读取。</li>
<li>启动事务。</li>
<li>判断每一行的字段数和目标表是否相同，不相同就会报错，事务回滚。相同，构造一行数据，调用存储引擎接口写入表中。</li>
<li>重复步骤3，直到读完整个文件。提交事务。</li>
</ol>
<p>从库：</p>
<ol>
<li>主库执行完成后，将导出的文件<code>/server_tmp/t.csv</code>内容直接写入binlog。</li>
<li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li>
<li>把这个 binlog 日志传到备库。</li>
<li>备库的 apply 线程在执行这个事务日志时：<br> a. 先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；<br> b. 再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li>
</ol>
<p>整个执行流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/3a6790bc933af5ac45a75deba0f52cfd.jpg">
<p>注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。</p>
<p>也就是说，load data 命令有两种用法</p>
<ul>
<li>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</li>
<li>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。</li>
</ul>
<p>另外需要注意的是，select …into outfile 方法不会生成表结构文件, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=$secure_file_priv</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在 <code>$secure_file_priv</code> 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p>
<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>前面我们提到的 mysqldump 方法和导出 CSV 文件的方法，都是逻辑导数据的方法，也就是将数据从表 db1.t 中读出来，生成文本，然后再写入目标表 db2.t 中。</p>
<p>你可能会问，有物理导数据的方法吗？比如，直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下，是否可行呢？</p>
<p>答案是不行的。</p>
<p>因为，一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的。</p>
<p>不过，在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<p>流程如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/2407737651cdc1f5d6ade4d8907e7c05.jpg">
<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol>
<li>在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；</li>
<li>在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 t.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是对极客时间专栏&lt;a href=&quot;https://time.geekbang.org/column/139&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL实战45讲&lt;/a&gt; 文章内容和讨论区内容的总结。&lt;/p&gt;
&lt;h2 id=&quot;第一讲-基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;a href=&quot;#第一讲-基础架构：一条SQL查询语句是如何执行的？&quot; class=&quot;headerlink&quot; title=&quot;第一讲 基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;/a&gt;第一讲 基础架构：一条SQL查询语句是如何执行的？&lt;/h2&gt;&lt;h3 id=&quot;mysql-架构&quot;&gt;&lt;a href=&quot;#mysql-架构&quot; class=&quot;headerlink&quot; title=&quot;mysql 架构&quot;&gt;&lt;/a&gt;mysql 架构&lt;/h3&gt;&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/mysql_arch.png&quot;&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 可以分为 Server 层和存储引擎层两部&lt;/li&gt;
&lt;li&gt;Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。&lt;/li&gt;
&lt;li&gt;存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink&quot; title=&quot;连接器&quot;&gt;&lt;/a&gt;连接器&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;负责为何和客户端的TCP连接， 权限获取，验证。&lt;/li&gt;
&lt;li&gt;连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;show processlits&lt;/code&gt;查看当前所有的连接。&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/show_processlist.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;如果连接在&lt;code&gt;wait_timeout&lt;/code&gt;指定的时间内没有任何操作，则会被关闭。默认是8小时。&lt;/li&gt;
&lt;li&gt;长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。&lt;ul&gt;
&lt;li&gt;定时关闭连接 或 执行了大的查询语句后断开连接&lt;/li&gt;
&lt;li&gt;MySQL5.7以后的版本可以通过&lt;code&gt;mysql_reset_connection&lt;/code&gt;重新初始化连接（不会重新验证权限）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
