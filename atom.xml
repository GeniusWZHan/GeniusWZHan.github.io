<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戒修-沉迷技术的小沙弥</title>
  <subtitle>我喜欢GO</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leokongwq.github.io/"/>
  <updated>2019-08-25T13:10:50.264Z</updated>
  <id>https://leokongwq.github.io/</id>
  
  <author>
    <name>kongwenqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hystrix学习总结</title>
    <link href="https://leokongwq.github.io/2019/08/10/hystrix-summary.html"/>
    <id>https://leokongwq.github.io/2019/08/10/hystrix-summary.html</id>
    <published>2019-08-10T11:36:33.000Z</published>
    <updated>2019-08-25T13:10:50.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hystrix是什么？"><a href="#hystrix是什么？" class="headerlink" title="hystrix是什么？"></a>hystrix是什么？</h3><p>官网对hystrix的定义如下：</p>
<blockquote>
<p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p>
</blockquote>
<p>个人理解如下：</p>
<ol>
<li>首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。</li>
<li>Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。</li>
</ol>
<a id="more"></a>
<h3 id="hystrix基本用法"><a href="#hystrix基本用法" class="headerlink" title="hystrix基本用法"></a>hystrix基本用法</h3><h4 id="HystrixCommand"><a href="#HystrixCommand" class="headerlink" title="HystrixCommand"></a>HystrixCommand</h4><p>使用Hystrix最简单直接的方式就是继承<code>HystrixCommand</code>对象并复写<code>run</code>方法。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂方法HystrixCommandGroupKey.Factory.asKey</span></span><br><span class="line">        <span class="comment">// 指定CommandGroup的名称</span></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意只有非 HystrixBadRequestException 才会触发fallback    </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fallback: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).execute();</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从名字也能看出来，需要在返回值上注册一个观察者来获取结果</span></span><br><span class="line">Observable&lt;String&gt; observable = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).observe();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">Observable&lt;String&gt; stringObservable1 = helloWorldCommand.toObservable();</span><br><span class="line"><span class="comment">// 注册观察者 获取结果</span></span><br><span class="line"><span class="comment">// 先执行onNext再执行onCompleted</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"onNext: "</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">truetrue</span><br><span class="line"><span class="comment">// 只有成功才会被回调</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">true<span class="comment">// 相当于上面的onNext()</span></span><br><span class="line">true<span class="comment">// @Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">truetrueSystem.out.println(<span class="string">"call: "</span> + v);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>execute</code>方法用来同步获取执行结果（内部还是通过线程池异步执行）内部逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queue</code> 通过返回一个<code>Future</code>来异步获取结果。</p>
<p><code>observe和toObservable</code> 通过返回一个<code>Observable</code>, 需要用户注册一个回调来接收调用结果。</p>
<p><code>observe</code> 和 <code>toObservable</code>的区别是：observe 在注册回调前就已经执行服务调用，toObservable是在注册回调后才开始执行。</p>
<h4 id="HystrixObservableCommand"><a href="#HystrixObservableCommand" class="headerlink" title="HystrixObservableCommand"></a>HystrixObservableCommand</h4><p>HystrixObservableCommand 和 HystrixCommand 功能是相同的。不过HystrixObservableCommand的定位是用在全异步的环境下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloHystrixObservableCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloHystrixObservableCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"HelloHystrixObservableCommand"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;String&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return Observable.just("1", "2", "3");</span></span><br><span class="line"><span class="comment">//        return Observable.just("Hello " + name);</span></span><br><span class="line"><span class="comment">//        return Observable.from(new String[]&#123;"1", "2"&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OnSubscribe 是一个Callback， 当 Observable被注册的时候会被执行</span></span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//remote http call</span></span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 写业务逻辑，注意try-catch</span></span><br><span class="line">                    <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">                        String result = restTemplate.getForObject(<span class="string">"http://www.jiexiu.com"</span>, String.class);</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        subscriber.onNext(result);</span><br><span class="line">                        subscriber.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    subscriber.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * fallback </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">resumeWithFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; observer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                        observer.onNext(<span class="string">"fallback-jiexiu"</span>);</span><br><span class="line">                        observer.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    observer.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HelloHystrixObservableCommand observableCommand =</span><br><span class="line">                <span class="keyword">new</span> HelloHystrixObservableCommand(<span class="string">"jiexiu"</span>);</span><br><span class="line">        Observable&lt;String&gt; observable = observableCommand.construct();</span><br><span class="line">        observable.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>Hystrix中实现优雅降级有2中方式：</p>
<ol>
<li>通过在HystrixCommand中添加<code>getFallback</code>方法</li>
<li>通过在HystrixObservableCommand中添加<code>resumeWithFallback</code>方法</li>
</ol>
<h4 id="fallback-触发时机"><a href="#fallback-触发时机" class="headerlink" title="fallback 触发时机"></a>fallback 触发时机</h4><ol>
<li>run方法或construct方法执行异常（非HystrixBadRequestException异常）。</li>
<li>run方法或construct方法超时</li>
<li>线程池满了或信号量为空</li>
<li>断路器处于打开状态</li>
</ol>
<p>注意: run方法抛出的所有异常中除了<code>HystrixBadRequestException</code>异常外都会被记录为失败，触发fallback，更新断路器统计信息。</p>
<h3 id="Hystrix-隔离机制"><a href="#Hystrix-隔离机制" class="headerlink" title="Hystrix 隔离机制"></a>Hystrix 隔离机制</h3><p>Hystrix有2中实现请求故障隔离的机制。一种是利用线程池，一种是使用信号量，默认是使用线程池。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));</span></span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-ThreadPool"</span>))</span><br><span class="line">            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(<span class="number">5</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withMaximumSize(<span class="number">10</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withKeepAliveTimeMinutes(<span class="number">5</span>) <span class="comment">//默认是1，单位为分钟</span></span><br><span class="line">                    .withMaxQueueSize(<span class="number">100</span>) <span class="comment">// 默认是-1, 意味着底层使用 SynchronousQueue, 该属性不能动态修改</span></span><br><span class="line">                    .withQueueSizeRejectionThreshold(<span class="number">80</span>)</span><br><span class="line">            )</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                    .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池机制很容易理解，不同的HystrixCommandGroup底层使用不同的线程池，彼此不干扰。<br>可以通过<code>andThreadPoolKey</code>配置了线程池的名称。如果没有通过<code>andThreadPoolKey</code>来设置线程池的名称，默认使用<code>withGroupKey</code>设置的名称。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-Semaphore-ThreadPool"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                        .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">3</span>) </span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="熔断器-CircuitBreaker"><a href="#熔断器-CircuitBreaker" class="headerlink" title="熔断器 CircuitBreaker"></a>熔断器 CircuitBreaker</h3><p>通常有2</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>HystrixCommandGroupKey 需要指定，用来将不同的HystrixCommand组织起来</p>
<p>HystrixCommandKey 的默认值是 Command的类名称(不带包名)，也可以单独指定。</p>
<p>HystrixThreadPoolKey 的默认值是 HystrixCommandGroupKey。但是建议手动指定HystrixCommand执行的<code>HystrixThreadPool</code>的名称。因为同属一个Group下的Command可能需要在不同的<code>HystrixThreadPool</code>中隔离执行。</p>
<p>在fallback的处理中，如果需要调用一个远程服务获取值(e.g. 查询缓存) 那么最好使用单独的线程池来执行，否则可能由于主Command的执行线程池已经满了导致fallback不能正常工作。</p>
<img src="/2019/08/10/hystrix-summary/fallback-via-command-640.png">
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hystrix是什么？&quot;&gt;&lt;a href=&quot;#hystrix是什么？&quot; class=&quot;headerlink&quot; title=&quot;hystrix是什么？&quot;&gt;&lt;/a&gt;hystrix是什么？&lt;/h3&gt;&lt;p&gt;官网对hystrix的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人理解如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。&lt;/li&gt;
&lt;li&gt;Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hystrix" scheme="https://leokongwq.github.io/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>spring SpEL表达式</title>
    <link href="https://leokongwq.github.io/2019/04/17/spring-spel.html"/>
    <id>https://leokongwq.github.io/2019/04/17/spring-spel.html</id>
    <published>2019-04-17T02:25:27.000Z</published>
    <updated>2019-08-02T14:46:15.687Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自：<a href="https://blog.csdn.net/zhoudaxia/article/details/38174169" target="_blank" rel="noopener">https://blog.csdn.net/zhoudaxia/article/details/38174169</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1  概述"></a>1.1  概述</h3><p>　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>　　表达式语言给静态Java语言增加了动态功能。</p>
<p>　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h3 id="1-2-能干什么"><a href="#1-2-能干什么" class="headerlink" title="1.2  能干什么"></a>1.2  能干什么</h3><p>　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>　　SpEL支持如下表达式：</p>
<p>　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p>　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p>　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p>　　四、其他表达式：模板表达式。</p>
<p>　　注：SpEL表达式中的关键字是不区分大小写的。</p>
<a id="more"></a>
<h2 id="2-SpEL基础"><a href="#2-SpEL基础" class="headerlink" title="2. SpEL基础"></a>2. SpEL基础</h2><h3 id="2-1-HelloWorld"><a href="#2-1-HelloWorld" class="headerlink" title="2.1  HelloWorld"></a>2.1  HelloWorld</h3><p>首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>让我们看下代码片段吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> junit.framework.Assert;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">        Expression expression =  </span><br><span class="line">            parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);  </span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);  </span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<ol>
<li>创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</li>
<li>解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据。</li>
<li>求值：通过Expression接口的getValue方法根据上下文获得表达式值。</li>
</ol>
<p>　　是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h3 id="2-3-SpEL原理及接口"><a href="#2-3-SpEL原理及接口" class="headerlink" title="2.3  SpEL原理及接口"></a>2.3  SpEL原理及接口</h3><p>SpEL提供简单的接口从而简化用户使用，在介绍原理前让我们学习下几个概念：</p>
<p>一、表达式：表达式是表达式语言的核心，所以表达式语言都是围绕表达式进行的，从我们角度来看是“干什么”；</p>
<p>二、解析器：用于将字符串表达式解析为表达式对象，从我们角度来看是“谁来干”；</p>
<p>三、上下文：表达式对象执行的环境，该环境可能定义变量、定义自定义函数、提供类型转换等等，从我们角度看是“在哪干”；</p>
<p>四、根对象及活动上下文对象：根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象，从我们角度看是“对谁干”。</p>
<p>理解了这些概念后，让我们看下SpEL如何工作的呢，如图5-1所示</p>
<img src="/2019/04/17/spring-spel/20140727174757196.jpg">
<p>1）首先定义表达式：“1+2”；</p>
<p>2）定义解析器ExpressionParser实现，SpEL提供默认实现SpelExpressionParser；</p>
<p>　　2.1）SpelExpressionParser解析器内部使用Tokenizer类进行词法分析，即把字符串流分析为记号流，记号在SpEL使用Token类来表示；</p>
<p>　　2.2）有了记号流后，解析器便可根据记号流生成内部抽象语法树；在SpEL中语法树节点由SpelNode接口实现代表：如OpPlus表示加操作节点、IntLiteral表示int型字面量节点；使用SpelNodel实现组成了抽象语法树；</p>
<p>　　2.3）对外提供Expression接口来简化表示抽象语法树，从而隐藏内部实现细节，并提供getValue简单方法用于获取表达式值；SpEL提供默认实现为SpelExpression；</p>
<p>3）定义表达式上下文对象（可选），SpEL使用EvaluationContext接口表示上下文对象，用于设置根对象、自定义变量、自定义函数、类型转换器等，SpEL提供默认实现StandardEvaluationContext；</p>
<p>4）使用表达式对象根据上下文对象（可选）求值（调用表达式对象的getValue方法）获得结果。</p>
<p>接下来让我们看下SpEL的主要接口吧：</p>
<h4 id="ExpressionParser"><a href="#ExpressionParser" class="headerlink" title="ExpressionParser"></a>ExpressionParser</h4><p>ExpressionParser接口：表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpressionParser</span> </span>&#123;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString)</span></span>;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParserContext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#&#123;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#125;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    String template = <span class="string">"#&#123;'Hello '&#125;#&#123;'World!'&#125;"</span>;  </span><br><span class="line">    Expression expression = parser.parseExpression(template, parserContext);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此我们演示的是使用ParserContext的情况，此处定义了ParserContext实现：定义表达式是模块，表达式前缀为<code>#{”，后缀为“}</code>；使用parseExpression解析时传入的模板必须以<code>#{”开头，以“}</code>结尾，如<code>#{&#39;Hello &#39;}#{&#39;World!&#39;}</code>。</p>
<p>默认传入的字符串表达式不是模板形式，如之前演示的Hello World。</p>
<h4 id="EvaluationContext"><a href="#EvaluationContext" class="headerlink" title="EvaluationContext"></a>EvaluationContext</h4><p>EvaluationContext接口：表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。</p>
<h4 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h4><p>Expression接口：表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。</p>
<p>了解了SpEL原理及接口，接下来的事情就是SpEL语法了。</p>
<h2 id="SpEL-语法"><a href="#SpEL-语法" class="headerlink" title="SpEL 语法"></a>SpEL 语法</h2><h3 id="字面量表达式："><a href="#字面量表达式：" class="headerlink" title="字面量表达式："></a>字面量表达式：</h3><p>SpEL支持的字面量包括：字符串、数字类型（int、long、float、double）、布尔类型、null类型。</p>
<p>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = parser.parseExpression(<span class="string">"'Hello World!'"</span>).getValue(String.class);</span><br><span class="line">String str2 = parser.parseExpression(<span class="string">"\"Hello World!\""</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>
<p>数字类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = parser.parseExpression(<span class="string">"1"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> long1 = parser.parseExpression(<span class="string">"-1L"</span>).getValue(<span class="keyword">long</span>.class);</span><br><span class="line"><span class="keyword">float</span> float1 = parser.parseExpression(<span class="string">"1.1"</span>).getValue(Float.class);</span><br><span class="line"><span class="keyword">double</span> double1 = parser.parseExpression(<span class="string">"1.1E+2"</span>).getValue(<span class="keyword">double</span>.class);</span><br><span class="line"><span class="keyword">int</span> hex1 = parser.parseExpression(<span class="string">"0xa"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> hex2 = parser.parseExpression(<span class="string">"0xaL"</span>).getValue(<span class="keyword">long</span>.class);</span><br></pre></td></tr></table></figure>
<p>boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> true1 = parser.parseExpression(<span class="string">"true"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="keyword">boolean</span> false1 = parser.parseExpression(<span class="string">"false"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br></pre></td></tr></table></figure>
<p>null 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object null1 = parser.parseExpression(<span class="string">"null"</span>).getValue(Object.class);</span><br></pre></td></tr></table></figure>
<h3 id="算数运算表达式"><a href="#算数运算表达式" class="headerlink" title="算数运算表达式"></a>算数运算表达式</h3><p>算数运算表达式： SpEL支持加(+)、减(-)、乘(*)、除(/)、求余（%）、幂（^）运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"1+2-3*4/2"</span>).getValue(Integer.class);<span class="comment">//-3</span></span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"4%3"</span>).getValue(Integer.class);<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"2^3"</span>).getValue(Integer.class);<span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>　SpEL还提供求余（MOD）和除（DIV）而外两个运算符，与“%”和“/”等价，不区分大小写。</p>
</blockquote>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>关系表达式：等于（==）、不等于(!=)、大于(&gt;)、大于等于(&gt;=)、小于(&lt;)、小于等于(&lt;=)，区间（between）运算，如<code>parser.parseExpression(&quot;1&gt;2&quot;).getValue(boolean.class);</code>将返回false；而<code>parser.parseExpression(&quot;1 between {1, 2}&quot;).getValue(boolean.class);</code>将返回true。</p>
<p>between运算符右边操作数必须是列表类型，且只能包含2个元素。第一个元素为开始，第二个元素为结束，区间运算是包含边界值的，即 xxx&gt;=list.get(0) &amp;&amp; xxx&lt;=list.get(1)。</p>
<p>SpEL同样提供了等价的“EQ” 、“NE”、 “GT”、“GE”、 “LT” 、“LE”来表示等于、不等于、大于、大于等于、小于、小于等于，不区分大小写。</p>
<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>逻辑表达式：且（and）、或(or)、非(!或NOT)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String expression1 = <span class="string">"2&gt;1 and (!true or !false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result1);  </span><br><span class="line">   </span><br><span class="line">String expression2 = <span class="string">"2&gt;1 and (NOT true or NOT false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result2 = parser.parseExpression(expression2).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑运算符不支持 Java中的 &amp;&amp; 和 || 。</p>
</blockquote>
<h3 id="字符串连接及截取表达式"><a href="#字符串连接及截取表达式" class="headerlink" title="字符串连接及截取表达式"></a>字符串连接及截取表达式</h3><p>字符串连接及截取表达式：使用“+”进行字符串连接，使用“’String’[0] [index]”来截取一个字符，目前只支持截取一个，如“’Hello ‘ + ‘World!’”得到“Hello World!”；而“’Hello World!’[0]”将返回“H”。</p>
<h3 id="三目运算及Elivis运算表达式："><a href="#三目运算及Elivis运算表达式：" class="headerlink" title="三目运算及Elivis运算表达式："></a>三目运算及Elivis运算表达式：</h3><p>三目运算符 “表达式1?表达式2:表达式3”用于构造三目运算表达式，如“2&gt;1?true:false”将返回true；</p>
<p>Elivis运算符“表达式1?:表达式2”从Groovy语言引入用于简化三目运算符的，当表达式1为非null时则返回表达式1，当表达式1为null时则返回表达式2，简化了三目运算符方式“表达式1? 表达式1:表达式2”，如“null?:false”将返回false，而“true?:false”将返回true；</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>使用“str matches regex，如“’123’ matches ‘\d{3}’”将返回true；</p>
<h3 id="括号优先级表达式"><a href="#括号优先级表达式" class="headerlink" title="括号优先级表达式"></a>括号优先级表达式</h3><p>括号优先级表达式：使用“(表达式)”构造，括号里的具有高优先级。</p>
<h3 id="类相关表达式"><a href="#类相关表达式" class="headerlink" title="类相关表达式"></a>类相关表达式</h3><p>一、类类型表达式：使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>
<p>具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassTypeExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    <span class="comment">//java.lang包类访问  </span></span><br><span class="line">    Class&lt;String&gt; result1 = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);  </span><br><span class="line">    Assert.assertEquals(String.class, result1);  </span><br><span class="line">    <span class="comment">//其他包类访问  </span></span><br><span class="line">    String expression2 = <span class="string">"T(cn.javass.spring.chapter5.SpELTest)"</span>;  </span><br><span class="line">    Class&lt;String&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);</span><br><span class="line">    Assert.assertEquals(SpELTest.class, result2);  </span><br><span class="line">    <span class="comment">//类静态字段访问  </span></span><br><span class="line">    <span class="keyword">int</span> result3=parser.parseExpression(<span class="string">"T(Integer).MAX_VALUE"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(Integer.MAX_VALUE, result3);  </span><br><span class="line">    <span class="comment">//类静态方法调用  </span></span><br><span class="line">    <span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"T(Integer).parseInt('1')"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, result4);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于java.lang包里的可以直接使用“T(String)”访问；其他包必须是类全限定名；可以进行静态字段访问如“T(Integer).MAX_VALUE”；也可以进行静态方法访问如“T(Integer).parseInt(‘1’)”。<br>　<br>二、类实例化：类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructorExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"new String('haha')"</span>).getValue(String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">    Date result2 = parser.parseExpression(<span class="string">"new java.util.Date()"</span>).getValue(Date.class);  </span><br><span class="line">    Assert.assertNotNull(result2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化完全跟Java内方式一样。</p>
<p>三，instanceof表达式：SpEL支持instanceof运算符，跟Java内使用同义；如“’haha’ instanceof T(String)”将返回true。</p>
<p>四， 变量定义及引用：变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用“#variableName”引用；除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用“#root”引用根对象，使用“#this”引用当前上下文对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"#variable"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">   </span><br><span class="line">    context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">"haha"</span>);  </span><br><span class="line">    String result2 = parser.parseExpression(<span class="string">"#root"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result2);  </span><br><span class="line">    String result3 = parser.parseExpression(<span class="string">"#this"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>#variable</code>来引用在<code>EvaluationContext</code>定义的变量；除了可以引用自定义变量，还可以使用<code>#root</code>引用根对象，<code>#this</code>引用当前上下文对象，此处<code>#this</code>即根对象。</p>
<p>五、自定义函数：目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionExpression</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException, NoSuchMethodException </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    Method parseInt = Integer.class.getDeclaredMethod(<span class="string">"parseInt"</span>, String.class);  </span><br><span class="line">    context.registerFunction(<span class="string">"parseInt"</span>, parseInt);  </span><br><span class="line">    context.setVariable(<span class="string">"parseInt2"</span>, parseInt);  </span><br><span class="line">    String expression1 = <span class="string">"#parseInt('3') == #parseInt2('3')"</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(context, <span class="keyword">boolean</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, result1);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处可以看出<code>registerFunction</code>和<code>setVariable</code>都可以注册自定义函数，但是两个方法的含义不一样，推荐使用<code>registerFunction</code>方法注册自定义函数。</p>
<p>六、赋值表达式：SpEL即允许给自定义变量赋值，也允许给根对象赋值，直接使用<code>#variableName=value</code>即可赋值：</p>
<p>使用<code>#root=&#39;aaaaa&#39;</code>给根对象赋值，使用“”#this=’aaaa’”给当前上下文对象赋值，使用<code>#variable=#root</code>给自定义变量赋值，很简单。</p>
<p>七、对象属性存取及安全导航表达式：对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；SpEL还引入了Groovy语言中的安全导航运算符“(对象|属性)?.属性”，用来避免“?.”前边的表达式为null时抛出空指针异常，而是返回null；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line"><span class="comment">//1.访问root对象属性  </span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result1);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于当前上下文对象属性及方法访问，可以直接使用属性或方法名访问，比如此处根对象date属性<code>year</code>，注意此处属性名首字母不区分大小写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.安全访问  </span></span><br><span class="line">context.setRootObject(<span class="keyword">null</span>);  </span><br><span class="line">Object result3 = parser.parseExpression(<span class="string">"#root?.year"</span>).getValue(context, Object.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">null</span>, result3);</span><br></pre></td></tr></table></figure>
<p>SpEL引入了Groovy的安全导航运算符，比如此处根对象为null，所以如果访问其属性时肯定抛出空指针异常，而采用“?.”安全访问导航运算符将不抛空指针异常，而是简单的返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.给root对象属性赋值  </span></span><br><span class="line">context.setRootObject(date);  </span><br><span class="line"><span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"Year = 4"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result4);  </span><br><span class="line">parser.parseExpression(<span class="string">"Year"</span>).setValue(context, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">int</span> result5 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">5</span>, result5);</span><br></pre></td></tr></table></figure>
<p>给对象属性赋值可以采用赋值表达式或Expression接口的setValue方法赋值，而且也可以采用点缀方式赋值。</p>
<p>八、对象方法调用：对象方法调用更简单，跟Java语法一样；如“’haha’.substring(2,4)”将返回“ha”；而对于根对象可以直接调用方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"getYear()"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<p>比如根对象date方法“getYear”可以直接调用。</p>
<p>九、Bean引用：SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext();  </span><br><span class="line">    ctx.refresh();  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(ctx));  </span><br><span class="line">    Properties result1 = parser.parseExpression(<span class="string">"@systemProperties"</span>).getValue(context, Properties.class);  </span><br><span class="line">    Assert.assertEquals(System.getProperties(), result1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中我们首先初始化了一个IoC容器，ClassPathXmlApplicationContext 实现默认会把“System.getProperties()”注册为“systemProperties”Bean，因此我们使用 “@systemProperties”来引用该Bean。</p>
<h3 id="集合相关表达式"><a href="#集合相关表达式" class="headerlink" title="集合相关表达式"></a>集合相关表达式</h3><p>内联List</p>
<p>从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List，如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将返回不可修改的空List  </span></span><br><span class="line">List&lt;Integer&gt; result2 = parser.parseExpression(<span class="string">"&#123;&#125;"</span>).getValue(List.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于字面量列表也将返回不可修改的List  </span></span><br><span class="line">List&lt;Integer&gt; result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;"</span>).getValue(List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">1</span>), result1.get(<span class="number">0</span>));  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result1.set(<span class="number">0</span>, <span class="number">2</span>);  </span><br><span class="line">    <span class="comment">//不可能执行到这，对于字面量列表不可修改  </span></span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于列表中只要有一个不是字面量表达式，将只返回原始List，  </span></span><br><span class="line"><span class="comment">//不会进行不可修改处理  </span></span><br><span class="line">String expression3 = <span class="string">"&#123;&#123;1+2,2+4&#125;,&#123;3,4+4&#125;&#125;"</span>;  </span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result3 = parser.parseExpression(expression3).getValue(List.class);  </span><br><span class="line">result3.get(<span class="number">0</span>).set(<span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3.size());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/声明二维数组并初始化  </span><br><span class="line"><span class="keyword">int</span>[] result2 = parser.parseExpression(<span class="string">"new int[2]&#123;1,2&#125;"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一维数组并初始化  </span></span><br><span class="line"><span class="keyword">int</span>[] result1 = parser.parseExpression(<span class="string">"new int[1]"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<p>内联数组</p>
<p>和Java 数组定义类似，只是在定义时进行多维数组初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义多维数组但不初始化  </span></span><br><span class="line"><span class="keyword">int</span>[][][] result3 = parser.parseExpression(expression3).getValue(<span class="keyword">int</span>[][][].class);</span><br></pre></td></tr></table></figure>
<p>错误的定义多维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的定义多维数组，多维数组不能初始化  </span></span><br><span class="line">String expression4 = <span class="string">"new int[1][2][3]&#123;&#123;1&#125;&#123;2&#125;&#123;3&#125;&#125;"</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">int</span>[][][] result4 = parser.parseExpression(expression4).getValue(<span class="keyword">int</span>[][][].class);  </span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br></pre></td></tr></table></figure>
<p>集合，字典元素访问</p>
<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL内联List访问  </span></span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;[0]"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//即list.get(0)  </span></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL目前支持所有集合类型的访问  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//对于任何集合类型通过Iterator来定位元素  </span></span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL对Map字典元素访问的支持  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a']"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result3);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：集合元素访问是通过Iterator遍历来定位元素位置的。</p>
</blockquote>
<p>四、列表，字典，数组元素修改：</p>
<p>可以使用赋值表达式或Expression接口的setValue方法修改；<br>　　<br>修改数组元素值<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.修改数组元素值  </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"array"</span>, array);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"#array[1] = 3"</span>).getValue(context1, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result1);</span><br></pre></td></tr></table></figure></p>
<p>修改集合值  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.修改集合值  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1] = 3"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result2);  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection[1]"</span>).setValue(context2, <span class="number">4</span>);  </span><br><span class="line">result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result2);</span><br></pre></td></tr></table></figure>
<p>修改map元素值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.修改map元素值  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a'] = 2"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3);</span><br></pre></td></tr></table></figure>
<p>对数组修改直接对“#array[index]”赋值即可修改元素值，同理适用于集合和字典类型。</p>
<p>五、集合投影：</p>
<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.测试集合或数组  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.![#this+1]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“#this”代表每个集合或数组元素，可以使用比如“#this.property”来获取集合元素的属性，其中“#this”可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.测试字典  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">List&lt;Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.![ value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2.size());</span><br></pre></td></tr></table></figure>
<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。</p>
<p>六、集合选择：</p>
<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.集合或数组测试  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.?[#this&gt;4]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组选择，如“#collection.?[#this&gt;4]”将选择出集合元素值大于4的所有元素。选择表达式必须返回布尔类型，使用“#this”表示当前元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.字典测试  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">Map&lt;String, Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.?[#this.key != 'a']"</span>).getValue(context2, Map.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result2.size());  </span><br><span class="line">   </span><br><span class="line">List&lt;Integer&gt; result3 =  </span><br><span class="line">    parser.parseExpression(<span class="string">"#map.?[key != 'a'].![value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">3</span>), result3.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于字典选择，如“#map.?[#this.key != ‘a’]”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != ‘a’].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。</p>
<h2 id="表达式模板"><a href="#表达式模板" class="headerlink" title="表达式模板"></a>表达式模板</h2><p>模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由<code>前缀+表达式+后缀</code>形式组成，如<code>${1+2}</code>即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了。</p>
<h3 id="在Bean定义中使用EL"><a href="#在Bean定义中使用EL" class="headerlink" title="在Bean定义中使用EL"></a>在Bean定义中使用EL</h3><p>xml风格的配置</p>
<p>SpEL支持在Bean定义时注入，默认使用<code>#{SpEL表达式}</code>表示，其中“#root”根对象默认可以认为是ApplicationContext，只有ApplicationContext实现默认支持SpEL，获取根对象属性其实是获取容器中的Bean。</p>
<p>首先看下配置方式吧：<br>　　<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello'&#125;#&#123;world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;    </span><br><span class="line">&lt;bean id=<span class="string">"hello2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">    &lt;!-- 不支持嵌套的 --&gt;  </span><br><span class="line">    &lt;!--&lt;constructor-arg value=<span class="string">"#&#123;'Hello'#&#123;world&#125;&#125;"</span>/&gt;--&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + @world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>模板默认以前缀<code>#{”开头，以后缀“}</code>结尾，且不允许嵌套，如<code>#{&#39;Hello&#39;#{world}}</code>错误，如<code>#{&#39;Hello&#39; + world}</code>中“world”默认解析为Bean。当然可以使用“@bean”引用了。<br>接下来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testXmlExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el1.xml"</span>);  </span><br><span class="line">    String hello1 = ctx.getBean(<span class="string">"hello1"</span>, String.class);  </span><br><span class="line">    String hello2 = ctx.getBean(<span class="string">"hello2"</span>, String.class);  </span><br><span class="line">    String hello3 = ctx.getBean(<span class="string">"hello3"</span>, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello1);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello2);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，除了XML配置方式，Spring还提供一种注解方式@Value，接着往下看吧。</p>
<h3 id="注解风格的配置"><a href="#注解风格的配置" class="headerlink" title="注解风格的配置"></a>注解风格的配置</h3><p>基于注解风格的SpEL配置也非常简单，使用@Value注解来指定SpEL表达式，该注解可以放到字段、方法及方法参数上。</p>
<p>测试Bean类如下，使用@Value来指定SpEL表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBean</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'Hello' + world&#125;"</span>)  </span><br><span class="line">    <span class="keyword">private</span> String value;  </span><br><span class="line">    <span class="comment">//setter和getter由于篇幅省略，自己写上  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看下配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">        xsi:schemaLocation=&quot;  </span><br><span class="line">          http://www.springframework.org/schema/beans  </span><br><span class="line">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span><br><span class="line">          http://www.springframework.org/schema/context  </span><br><span class="line">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean id=&quot;world&quot; class=&quot;java.lang.String&quot;&gt;  </span><br><span class="line">       &lt;constructor-arg value=&quot;#&#123;&apos; World!&apos;&#125;&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean1&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;/&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean2&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;&gt;  </span><br><span class="line">       &lt;property name=&quot;value&quot; value=&quot;haha&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置时必须使用“<context:annotation-config>”来开启对注解的支持。<br>有了配置文件那开始测试吧：</context:annotation-config></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el2.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中“helloBean1 ”值是SpEL表达式的值，而“helloBean2”是通过setter注入的值，这说明setter注入将覆盖@Value的值。</p>
<h3 id="在Bean定义中SpEL的问题"><a href="#在Bean定义中SpEL的问题" class="headerlink" title="在Bean定义中SpEL的问题"></a>在Bean定义中SpEL的问题</h3><p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 ConfigurableListableBeanFactory的getBeanExpressionResolver方法获取BeanExpressionResolver实现，其次强制类型转换为StandardBeanExpressionResolver，其为Spring默认实现，然后改掉前缀及后缀。</p>
<p>开始测试吧，首先准备配置文件(chapter5/el3.xml)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;  </span><br><span class="line">&lt;beans  xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        xsi:schemaLocation=<span class="string">"  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">       &lt;constructor-arg value=<span class="string">"%&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>&gt;  </span><br><span class="line">       &lt;property name=<span class="string">"value"</span> value=<span class="string">"%&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件和注解风格的几乎一样，只有SpEL表达式前缀变为<code>%{</code>了，并且注册了“cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor” Bean，用于修改前缀和后缀的。</p>
<p>写测试代码测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPrefixExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el3.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"#&#123;'Hello' + world&#125;"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处helloBean1中通过@Value注入的<code>#{&#39;Hello&#39; + world}</code>结果还是<code>#{&#39;Hello&#39; + world}</code>说明不对其进行SpEL表达式求值了，而helloBean2使用<code>%{&#39;Hello&#39; + world}</code>注入，得到正确的“”Hello World!”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转载自：&lt;a href=&quot;https://blog.csdn.net/zhoudaxia/article/details/38174169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zhoudaxia/article/details/38174169&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1  概述&quot;&gt;&lt;/a&gt;1  概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1  概述&quot;&gt;&lt;/a&gt;1.1  概述&lt;/h3&gt;&lt;p&gt;　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。&lt;/p&gt;
&lt;p&gt;　　表达式语言给静态Java语言增加了动态功能。&lt;/p&gt;
&lt;p&gt;　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;/p&gt;
&lt;h3 id=&quot;1-2-能干什么&quot;&gt;&lt;a href=&quot;#1-2-能干什么&quot; class=&quot;headerlink&quot; title=&quot;1.2  能干什么&quot;&gt;&lt;/a&gt;1.2  能干什么&lt;/h3&gt;&lt;p&gt;　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。&lt;/p&gt;
&lt;p&gt;　　SpEL支持如下表达式：&lt;/p&gt;
&lt;p&gt;　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；&lt;/p&gt;
&lt;p&gt;　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；&lt;/p&gt;
&lt;p&gt;　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；&lt;/p&gt;
&lt;p&gt;　　四、其他表达式：模板表达式。&lt;/p&gt;
&lt;p&gt;　　注：SpEL表达式中的关键字是不区分大小写的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql中字段究竟该不该为null</title>
    <link href="https://leokongwq.github.io/2019/01/05/mysql-null-column.html"/>
    <id>https://leokongwq.github.io/2019/01/05/mysql-null-column.html</id>
    <published>2019-01-05T01:54:48.000Z</published>
    <updated>2019-02-15T06:44:31.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么会有许多表的字段设置为null？"><a href="#为什么会有许多表的字段设置为null？" class="headerlink" title="为什么会有许多表的字段设置为null？"></a>为什么会有许多表的字段设置为null？</h3><ol>
<li>开发中常用的建表工具创建表时字段默认可以为null。</li>
<li>开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。</li>
<li>默认为null，在插入数据时可以少很多判断</li>
</ol>
<p>针对这些问题，下面就彻底搞清楚字段该不该为null。    </p>
<h3 id="null-字段可以节省空间吗？"><a href="#null-字段可以节省空间吗？" class="headerlink" title="null 字段可以节省空间吗？"></a>null 字段可以节省空间吗？</h3><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>MySQL官方文档有如下的描述：</p>
<blockquote>
<p>For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>从上面的描述中可以知道，在MyISAM中<code>NULL</code>字段并不能完全的节省空间。</p>
<a id="more"></a>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB 表的行格式</p>
<img src="/2019/01/05/mysql-null-column/mysql_innodb_row_format.png">
<p>平时使用COMPACT格式的行较多，正对该格式，文档有如下的说明。</p>
<blockquote>
<p>The variable-length part of the record header contains a bit vector for indicating NULL columns. If the number of columns in the index that can be NULL is N, the bit vector occupies CEILING(N/8) bytes. (For example, if there are anywhere from 9 to 16 columns that can be NULL, the bit vector uses two bytes.) Columns that are NULL do not occupy space other than the bit in this vector. The variable-length part of the header also contains the lengths of variable-length columns. Each length takes one or two bytes, depending on the maximum length of the column. If all columns in the index are NOT NULL and have a fixed length, the record header has no variable-length part.</p>
</blockquote>
<p>从上面的内容可以知道，NULL列除不能节省空间，反而会增加空间。</p>
<p>MySQL考虑的是越小的行大小，在固定大小的内存中就可以更多的缓存行数据，提升性能。如果字段有值就存，没值就不存，默认值也不是保存行数据里面的。</p>
<h3 id="null-字段带来的问题"><a href="#null-字段带来的问题" class="headerlink" title="null 字段带来的问题"></a>null 字段带来的问题</h3><ol>
<li>NULL值到非NULL的更新无法做到原地更新，更容易发生页分裂，从而影响性能。</li>
<li>NULL值在<code>timestamp</code>类型下容易出问题，特别是没有启用参数<code>explicit_defaults_for_timestamp=true</code>具体见文章最后的：参考资料</li>
<li><code>NOT IN</code>、<code>!=</code> 等负向条件查询在有<code>NULL</code>值的情况下返回永远为空结果，查询容易出错</li>
</ol>
<p>1，NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</p>
<figure class="highlight sql"><figcaption><span>NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_3 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_2 <span class="keyword">values</span> (<span class="number">4</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_1"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_1"</span>),(<span class="number">1</span>,<span class="string">"zhangsan_2"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_2"</span>),(<span class="number">4</span>,<span class="string">"zhaoliu_2_2"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_3 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> table_2 <span class="keyword">where</span> user_name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_name <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">id</span>!=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>2，单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集如果name允许为null，索引不存储null值，结果集中不会包含这些记录。所以，请使用not null约束以及默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">name</span> != <span class="string">'zhaoliu_2_1'</span></span><br></pre></td></tr></table></figure>
<p>3，如果在两个字段进行拼接：比如题号+分数，首先要各字段进行非null判断，否则只要任意一个字段为空都会造成拼接的结果为null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="string">"1"</span>, <span class="literal">null</span>) <span class="keyword">from</span> dual; <span class="comment">-- 执行结果为null。</span></span><br></pre></td></tr></table></figure>
<p>4，如果有 Null column 存在的情况下，count(Null column)需要格外注意，null 值不会参与统计。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 下面的语句返回 2， 但是数据库里面有4条记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(user_name) <span class="keyword">from</span> table_3;</span><br></pre></td></tr></table></figure>
<p>5， null 字段的判断 需要使用 <code>is null</code> 或 <code>is not null</code></p>
<h3 id="NULL字段和索引"><a href="#NULL字段和索引" class="headerlink" title="NULL字段和索引"></a>NULL字段和索引</h3><h4 id="索引长度-key-len"><a href="#索引长度-key-len" class="headerlink" title="索引长度 key_len"></a>索引长度 key_len</h4><p>key_len 的计算规则和三个因素有关：数据类型、字符编码、是否为 NULL </p>
<p>key_len 62 == 20*3（utf8 3字节） + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<p>key_len 83 == 20*4（utf8mb4 4字节） +  1 (是否为 Null 的标识) + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<h3 id="null字段唯一索引"><a href="#null字段唯一索引" class="headerlink" title="null字段唯一索引"></a>null字段唯一索引</h3><p>在可以为NULL的字段上也是可以建立唯一索引的，但需要注意的是：唯一索引想要防止重复记录的功能就失效了。官方文档描述如下：</p>
<blockquote>
<p>A UNIQUE index creates a constraint such that all values in the index must be distinct. An error occurs if you try to add a new row with a key value that matches an existing row. For all engines, a UNIQUE index permits multiple NULL values for columns that can contain NULL.</p>
</blockquote>
<h3 id="null字段普通索引"><a href="#null字段普通索引" class="headerlink" title="null字段普通索引"></a>null字段普通索引</h3><p>在可以为null的字段上建立普通索引，则所有索引字段为null的索引记录都是排列在一起的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://my.oschina.net/leejun2005/blog/1342985" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/1342985</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html</a><br><a href="https://www.jianshu.com/p/d7d364745173" target="_blank" rel="noopener">https://www.jianshu.com/p/d7d364745173</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html</a><br><a href="http://mysql.taobao.org/monthly/2018/01/04/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/01/04/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;a href=&quot;#为什么会有许多表的字段设置为null？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;/a&gt;为什么会有许多表的字段设置为null？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发中常用的建表工具创建表时字段默认可以为null。&lt;/li&gt;
&lt;li&gt;开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。&lt;/li&gt;
&lt;li&gt;默认为null，在插入数据时可以少很多判断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这些问题，下面就彻底搞清楚字段该不该为null。    &lt;/p&gt;
&lt;h3 id=&quot;null-字段可以节省空间吗？&quot;&gt;&lt;a href=&quot;#null-字段可以节省空间吗？&quot; class=&quot;headerlink&quot; title=&quot;null 字段可以节省空间吗？&quot;&gt;&lt;/a&gt;null 字段可以节省空间吗？&lt;/h3&gt;&lt;h4 id=&quot;NULL&quot;&gt;&lt;a href=&quot;#NULL&quot; class=&quot;headerlink&quot; title=&quot;NULL&quot;&gt;&lt;/a&gt;NULL&lt;/h4&gt;&lt;p&gt;MySQL官方文档有如下的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的描述中可以知道，在MyISAM中&lt;code&gt;NULL&lt;/code&gt;字段并不能完全的节省空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>极客时间mysql学习笔记</title>
    <link href="https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html"/>
    <id>https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html</id>
    <published>2018-12-21T05:48:17.000Z</published>
    <updated>2019-03-12T12:02:32.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对极客时间专栏<a href="https://time.geekbang.org/column/139" target="_blank" rel="noopener">MySQL实战45讲</a> 文章内容和讨论区内容的总结。</p>
<h2 id="第一讲-基础架构：一条SQL查询语句是如何执行的？"><a href="#第一讲-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="第一讲 基础架构：一条SQL查询语句是如何执行的？"></a>第一讲 基础架构：一条SQL查询语句是如何执行的？</h2><h3 id="mysql-架构"><a href="#mysql-架构" class="headerlink" title="mysql 架构"></a>mysql 架构</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_arch.png">
<ol>
<li>MySQL 可以分为 Server 层和存储引擎层两部</li>
<li>Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。</li>
<li>存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。</li>
</ol>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ol>
<li>负责为何和客户端的TCP连接， 权限获取，验证。</li>
<li>连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。</li>
<li>通过<code>show processlits</code>查看当前所有的连接。<img src="/2018/12/21/geektime-mysql-learn/show_processlist.png"></li>
<li>如果连接在<code>wait_timeout</code>指定的时间内没有任何操作，则会被关闭。默认是8小时。</li>
<li>长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。<ul>
<li>定时关闭连接 或 执行了大的查询语句后断开连接</li>
<li>MySQL5.7以后的版本可以通过<code>mysql_reset_connection</code>重新初始化连接（不会重新验证权限）。</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ol>
<li>查询缓存可以是一个简单的KV缓存，sql语句为key，缓存的内容为值</li>
<li>只要查询语句中的表执行了更新，该表相关的所有查询缓存都会失效。</li>
<li>对于频繁更新的表，不建议开启查询缓存。</li>
<li>基础配置表建议使用查询缓存。</li>
<li>将参数<code>query_cache_type</code>的值设置为<code>demand</code>，默认不启用查询缓存，除非显示指定：<code>select SQL_CACHE * from T where...</code></li>
</ol>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>词法分析：识别出SQL中每个单词的含义，例如： <code>表名</code>,<code>字段名称</code>,<code>数据库名称</code>,<code>关键字</code>等。<br>语法分析：分析SQL语句的含义，是否满足SQL语法。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>对SQL语句进行改写优化。 </p>
<ul>
<li>索引选择</li>
<li>关联查询表的选择</li>
<li>优化器可能<code>选错索引</code>。</li>
</ul>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ol>
<li>执行器执行SQL前会检查对应的权限。</li>
<li>执行器调用引擎接口获取数据（取下一行，索引：取满足条件的下一行），并计数。该计数可能引擎真实扫描的数据行数不一致。</li>
</ol>
<h2 id="第二讲-日志系统：一条SQL更新语句是如何执行的？"><a href="#第二讲-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="第二讲 日志系统：一条SQL更新语句是如何执行的？"></a>第二讲 日志系统：一条SQL更新语句是如何执行的？</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code> 是提高MySQL写入性能的一种机制。否则每次更新都需要写磁盘，频繁写磁盘性能很差。<code>redo log</code> 减少磁盘写入次数，将单次写入转为批量顺序写入，提高性能。</p>
<p><code>redo log</code> 可以配置个数和大小，并且是循环写入的。</p>
<img src="/2018/12/21/geektime-mysql-learn/msyql_redolog.jpg">
<p><code>redo log</code>保证MySQL的<code>Crash-Safe</code>能力。</p>
<p>InnoDB 必须配置至少一组 redo log。 每组下面至少两个文件， 每个文件大小一致。默认只有一组 redo log， 共2个文件，分别是： ib_logfile0, iblogfile1。</p>
<p>innodb_log_file_size : 指定每个文件的大小<br>innodb_log_files_in_group : 每组下面文件的个数<br>innodb_mirrored_log_groups : 指定日志镜像文件组的数量，默认是1. 如果磁盘做了高可用，可以保持不变。<br>innodb_log_group_home_dir : 指定日志文件所在路径。默认值<code>./</code></p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>binlog</code> 是MySQL Server层的日志，也称为归档日志。</p>
<p><code>binlog</code> 有三种格式：statement, row, mix</p>
<p>通过<code>set sql_log_bin=0</code>来关闭binlog。</p>
<h3 id="redo-log-vs-binlog"><a href="#redo-log-vs-binlog" class="headerlink" title="redo log vs binlog"></a>redo log vs binlog</h3><ol>
<li>redo log 是InnoDB引擎特有的日志。binlog是MySQL Server层的日志，所有引擎共享。</li>
<li>redo log 是大小固定，循环写入的，会写满，binlog是追加写入的。</li>
<li>redo log 是物理日志，记录了<code>哪个数据页,做了哪些修改</code>；binlog是逻辑日志，记录了语句的原始逻辑。</li>
</ol>
<h3 id="update语句执行流程"><a href="#update语句执行流程" class="headerlink" title="update语句执行流程"></a>update语句执行流程</h3>
<p>redo log 和 binlog使用了两阶段提交，以此来保证两个日志的逻辑一致。否则会导致数据不一致。</p>
<ol>
<li>先写redo log 后（crash）写 binlog， 通过binlog恢复数据，数据丢失更新。</li>
<li>先写binlog 后写 redo log, 数据库扩容，通过binlog追主库的数据时，多了一次更新。</li>
<li>prepare 阶段，redo log 已经写入磁盘，只是状态是<code>prepare</code>。</li>
<li>commit 阶段，引擎会将redo log的状态改为<code>commit</code>。</li>
</ol>
<h3 id="innodb-flush-log-at-trx-commit-amp-sync-binlog"><a href="#innodb-flush-log-at-trx-commit-amp-sync-binlog" class="headerlink" title="innodb_flush_log_at_trx_commit &amp; sync_binlog"></a>innodb_flush_log_at_trx_commit &amp; sync_binlog</h3><p><code>innodb_flush_log_at_trx_commit</code>有三个取值：</p>
<ul>
<li>0: 表示事务提交时并不将redo log 写入文件， 等待redo log刷新线程写入文件或其它触发条件。 不能保证是事务的持久性。</li>
<li>1: 该参数设置为1，表示每次事务提交，都将redo log写入磁盘（fsync调用）。</li>
<li>2: 异步写redo log， 写入操作系统page cache， 不能保证是事务的持久性。</li>
</ul>
<p><code>sync_binlog</code> 设置为 1 表示每次事务的binlog都写入磁盘。</p>
<h3 id="优质问题："><a href="#优质问题：" class="headerlink" title="优质问题："></a>优质问题：</h3><ol>
<li>当redo log写满后，新来的事务会导致MySQL将已经更新但是未提交事务修改的内存页(脏页)写入到磁盘中。但因为这些数据其他事务不能读到，或者读到也会放弃。</li>
</ol>
<h2 id="第三讲-事务隔离：为什么你改了我还看不见？"><a href="#第三讲-事务隔离：为什么你改了我还看不见？" class="headerlink" title="第三讲 事务隔离：为什么你改了我还看不见？"></a>第三讲 事务隔离：为什么你改了我还看不见？</h2><p>多个事务并发执行时，可能出现<code>脏读</code>，<code>不可重复读</code>，<code>幻读</code>的现象，为了解决这些问题，出现两个隔离级别的概念，不同的隔离级别，解决不同的问题。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>读未提交 ： 事务的修改还没有提及，其他事务能看到修改的结果</li>
<li>读提交：一个事务的变更只有提交后才能被其他事务看见。</li>
<li>可重复读： 一个事务执行过程中看到的数据，总是和事务启动时看到的数据一致。</li>
<li>串性化：所有事务串行执行。</li>
</ul>
<h3 id="事务视图"><a href="#事务视图" class="headerlink" title="事务视图"></a>事务视图</h3><p>事务执行时会创建一个视图，数据访问时以该视图的逻辑结果为准。</p>
<ul>
<li>读提交 ：这个视图是在每个SQL语句执行前创建的</li>
<li>可重复读 ：视图在事务开始时创建</li>
</ul>
<h3 id="事务隔离实现"><a href="#事务隔离实现" class="headerlink" title="事务隔离实现"></a>事务隔离实现</h3><p>MySQL中每个记录的更新都有会记录对应的回滚操作。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_undo.png">
<ul>
<li>不同时刻启动的事务拥有不同的视图。</li>
<li>MySQL中一条记录会存在多个不同的版本，这个就是数据库的多版本并发控制MVCC。</li>
<li>事务要获取自己视图的数据值，只需要将当前值依次应用回滚日志。</li>
<li>当前系统中没有比回滚日志更早的view时，回滚日志会被删除。</li>
<li>尽量不要使用长事务，会导致回滚日志占用大量内存；mysql5.5和之前的版本中，回滚日志和数据字典一起存放在ibdata文件中，即使事务提交，回滚日志被清理，但是文件不会缩小。极端情况下需要重建库。</li>
</ul>
<h3 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h3><ol>
<li>通过 <code>begin</code> 或 <code>start transaction</code> 启动事务。</li>
<li>通过<code>set autocommit = 1</code>启用自动提交，这样每个语句执行后，MySQL自动追加一个<code>commit</code></li>
<li><code>set autocommit = 0</code> 关闭自动提交功能。这样连接始终处于一个事务中，直到显式<code>commit</code>, <code>rollback</code>，或者断开连接事务才结束。但是显示提交事务后，MySQL有马上开启了一个事务。</li>
<li>可以通过<code>infomation_schema</code>库中的<code>innodb_trx</code>表查询正在执行的事务。</li>
</ol>
<h2 id="第四五讲-深入浅出索引"><a href="#第四五讲-深入浅出索引" class="headerlink" title="第四五讲 深入浅出索引"></a>第四五讲 深入浅出索引</h2><p>所有索引的目的都是为了加速数据的查询。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>哈希索引 ， 适用与等值查询，不适用区间查询，查询最大值，最小值等</li>
<li>有序数组索引， 适用于等值查询，范围查询。因为是数组，插入，更新效率低，所以适用静态数据索引。</li>
<li>二叉搜素树索引，平衡二叉查找树查询时间复杂度：log(N)，适用于内存索引，不适合磁盘索引，因为会导致随机访问问题，并且随着数量的增大，树的高度很高，查询效率降低的很快。</li>
<li>N叉搜素树索引, B树，B+树。适配磁盘访问模式，树的高度更低，查询一个数据需要更少的磁盘访问次数。</li>
</ul>
<h3 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h3><p>InnoDB中，表数据是按照<code>主键</code>顺序以索引的形式存放，这种方式称为<code>索引组织表</code>。InnoDB使用了B+树作为索引，也就是说数据是存放在B+树种的。</p>
<p>InnoDB中，每个索引都是一个B+树。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_tree.png">
<p>上图：左边是主键索引，右边是非主键索引。</p>
<p>主键索引的叶子节点保存了<code>整行</code>数据, 主键索引也称为<code>聚簇索引</code>，非主键索引的叶子节点的内容保存了主键ID。非主键索引也称为二级索引。</p>
<h4 id="主键索引和非主键索引的查询区别？"><a href="#主键索引和非主键索引的查询区别？" class="headerlink" title="主键索引和非主键索引的查询区别？"></a>主键索引和非主键索引的查询区别？</h4><ul>
<li>主键索引查询，只需要查询主键索引树。</li>
<li>非主键查询，需要先访问二级索引，获取主键索引的值，再访问主键索引树获取数据（这里不考虑覆盖索引）。</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入，删除数据时，InnoDB需要维护主键索引非主键索引。</p>
<ol>
<li>插入数据时，如果叶子节点所在的页已经满了的话，需要开辟新的<code>页</code>，移动部分数据到新的<code>页</code>，该操作称为页分裂，会降低页的空间利用率。</li>
<li>删除数据时，如果相邻的2个<code>页</code>里面数据很少，达到某个阈值，那么就会进行页合并，提高空间利用率。</li>
</ol>
<h3 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h3><ol>
<li>尽量使用主键索引，因为少了一个查询索引树的操作，速度更快。</li>
<li>建表时，尽量定义自增主键。这样插入数据时，是顺序写入。空间利用率和写入效率都很高。如果是业务主键，那么写入就是随机的，不能利用磁盘的特性（SSD 随机写入要好很多）。</li>
<li>主键索引尽可能的小，这样普通二级索引的叶子节点也较小，整个二级索引树也很小。内存中也可以更多的缓存索引数据。</li>
<li>在表只有一个索引，该索引必须是唯一索引的情况下，可以使用业务字段作为主键索引。</li>
</ol>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引其实是索引的一种特殊类型，指的是：查询返回的字段值全部在<code>二级索引</code>上都能满足，不需要再搜素主键索引树的一种情况。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树索引支持按索引的最左前缀来定位记录。</p>
<p>下图： (name, age)是联合索引</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_left_prefix.jpg">
<p>索引项是按照索引定义中字段出现的顺序进行排序的。</p>
<ol>
<li>不只是索引定义的全部字段，只要满足最左前缀（联合索引的左前n个字段，N个字符）都可以加速查询。有了<code>(a,b)</code>就可以不定义索引:<code>a</code>， 但是如果有字段<code>b</code>的查询,可能需要单独建立字段<code>b</code>上的索引。</li>
<li>联合索引，优先考虑索引的复用率，可通过调整字段的顺序来减少需要创建索引个个数。</li>
<li>联合索引需要考虑空间。</li>
</ol>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是mysql5.6新增的一个功能。指的是使用联合索引查询时，在满足最左前缀的条件下，查询语句同时使用了联合索引的其他字段作为条件时，首先使用索引中包含的字段进行条件过滤，减少通过主键ID进行回表查询的次数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like '张 %' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>该查询可以使用(name, age)这个联合索引，在判断<code>age=10</code>这个条件时，可以使用联合索引中age字段的值进行条件过滤。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k)) <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>如果要要重建索引<code>k</code>,SQL应该怎么写？</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br></pre></td></tr></table></figure>
<p>删除主键索引和创建主键索引都会导致表的重建。 如果要重建主键索引可以通过下面的语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>下面的索引是否有问题？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>答案：（a, b）, (c) 索引都没有问题，能满足通过字段<code>a</code>,<code>a</code>和<code>b</code>，字段<code>c</code>的查询逻辑。</p>
<p>索引(c, a) 不需要（where c=x order by a），因为数据本身就是按照主键索引(a, b)排序的。</p>
<p>索引(c, b) 满足<code>where c=x order by b</code>的场景。</p>
<h2 id="第六讲全局锁和表锁"><a href="#第六讲全局锁和表锁" class="headerlink" title="第六讲全局锁和表锁"></a>第六讲全局锁和表锁</h2><p>数据库锁是用来协调数据库并发请求的。 根据锁范围分为：全局锁，表锁，行锁.</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>可以使用<code>flush tables with read lock;</code>给整个数据库添加读锁。此后：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结果），更新类事务的提交语句都会被阻塞。</p>
<p>全局锁的典型使用场景是：做整个数据库的逻辑备份。确保备份的数据满足一致性要求。</p>
<p>mysqldump 工具在备份数据库时，启动一个事务<code>添加参数：--single transaction</code>，确保拿到一致性视图，然后开启备份。但前提是存储引擎必须支持事务。</p>
<p><code>set global readonly=true;</code> 也可以让整个数据库进入只读状态，但是有如下的问题，不建议使用。</p>
<ol>
<li>使用该命令，影响面积太大。一些系统根据该变量的值来判断数据库时主库还是从库。</li>
<li><code>flush tables with read lock;</code>命令执行后，如果客户端断开连接，那么锁会被MySQL自动释放，然而<code>set global readonly=true;</code>不会自动释放锁，这样会导致业务不可用的时间变长。</li>
<li>从库上，如果用户有SUPER权限，则read only是无效的。</li>
</ol>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL有2中表级锁，一个是表锁，一个是元数据锁MDL。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁的语法是<code>lock tables a, b... read/write;</code> 通过 <code>unlock tables</code>释放锁，客户端断开连接也会释放锁。注意：<code>lock tables</code> 会同时限制本线程和其他线程的后续操作。</p>
<h3 id="MDL锁"><a href="#MDL锁" class="headerlink" title="MDL锁"></a>MDL锁</h3><p>MySQL5.5 引入。MDL表锁不需要显式加锁，它会在访问表时自动添加和释放。</p>
<ul>
<li>当执行<code>CRUD</code>操作时，加MDL读锁。 </li>
<li>当修改表结构时，加MDL写锁。</li>
<li>读锁直接不互斥，读写，写写直接互斥。</li>
<li>事务提交MDL锁才会释放。</li>
<li>获取MDL写锁时，添加超时控制。MariaDB和AliSQL支持该功能。</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>当备库用<code>–single-transaction</code> 做逻辑备份的时候，如果从主库的binlog传来一个DDL语句，从库会怎么样？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line">Q2:<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>；</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为了确保RR隔离级别，再次设置了隔离级别。</li>
<li>开启事务，获取一致性视图。</li>
<li>设置保存点sp</li>
<li>获取表结构</li>
<li>获取数据</li>
<li>回滚到保存点sp,释放MDL读锁</li>
</ol>
<ul>
<li>如果binlog在Q4语句执行前到达，则没有影响，后续获取的是最新的表结构</li>
<li>如果在时刻2前到达，则表结构被修改了。后续流程不会执行。mysqldump退出。</li>
<li>如果在时刻2和3之间到达，mysqldump占用了MDL锁，binlog被阻塞，现象就是主从延迟。直到Q6完成后才能恢复。</li>
<li>从时刻4开始，MDL锁已经释放。现象是没有影响，不过备份拿到的是DDL前的表结构。</li>
</ul>
<h2 id="第七讲-行锁功过：怎么减少行锁对性能的影响"><a href="#第七讲-行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="第七讲 行锁功过：怎么减少行锁对性能的影响"></a>第七讲 行锁功过：怎么减少行锁对性能的影响</h2><p>MySQL的行锁是在引擎层实现的。不是所有的引擎都支持行锁，MyISAM就不支持。</p>
<p>InnoDB支持行锁。行锁是在需要时获取，事务提交时释放。这也就是是MySQL的：两阶段锁协议。加锁阶段和释放锁阶段，缩放锁阶段不会再获取锁。</p>
<p>在事务中，把最容易造成锁冲突，最可能影响并发度的操作尽可能放到事务靠后的位置。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_deadlock.jpg">
<p>高并发系统中，MySQL出现死锁几乎是不可避免的。幸运的是MySQL有死锁检测机制。</p>
<p>解决死锁有两种机制：</p>
<ul>
<li>超时等待。innodb_lock_wait_timeout 参考来控制超时时间(默认50s)。</li>
<li>死锁检测。检测到发送死锁时，MySQL回滚权值较低的事务。<code>innodb_deadlock_detect</code>设置为 <code>on</code>表示开启死锁检测（默认是开启的）。</li>
</ul>
<p>超时等待太长，业务不可接受。太短可能将简单的锁等待当做死锁处理。所以建议使用死锁检测机制。</p>
<p>死锁检测时，由于每个新来的请求不能获取锁时，都会检测是否因为自己的加入导致了锁等待。当并发量很大时，非常消耗CPU，结果却发现没有死锁。</p>
<p>有两种方法来解决该问题：</p>
<ol>
<li>如果你确认业务不会发生死锁，则可以临时关闭死锁检测。</li>
<li>控制并发度。在MySQL服务端，针对相同行的更新，进行请求排队。</li>
<li>业务优化，将热点数据行拆分为多行，减少并发度。</li>
</ol>
<h3 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h3><p>如果要删除一个数据表中的前10000行数据，有如下三种方式。哪种方式更合适。</p>
<ol>
<li><code>delete from t limit 10000;</code></li>
<li>一个连接中循环20次<code>delete from t limit 500</code>;</li>
<li>20个连接同时执行<code>delete from t limit 500</code>;</li>
</ol>
<p>答案是：方法二。 方法一：会导致获取多个行锁，事务提交时才释放锁，影响并发度。方法三：人为的增加并发度，因为死锁检测逻辑，导致更多的冲突。</p>
<h2 id="第8讲：事务到底是隔离的还是不隔离的？"><a href="#第8讲：事务到底是隔离的还是不隔离的？" class="headerlink" title="第8讲：事务到底是隔离的还是不隔离的？"></a>第8讲：事务到底是隔离的还是不隔离的？</h2><p>通常事务的起点并不是<code>begin/start transaction</code>, 而是在该语句后面执行第一个操作InnoDB表的语句是开始事务。如果想要立刻开始事务，可以通过<code>start transaction with consistent snapshot;</code>.</p>
<p>MySQL中有两个视图view概念：</p>
<ol>
<li>通过查询语句创建的虚拟表</li>
<li>InnoDB实现MVCC时定义的一致性读视图 consistent read view，用于支持实现RC, RR事务隔离级别。</li>
<li>一致性读视图没有物理结构，它是用来定义事务执行期间每个事务能看到的数据规则。</li>
</ol>
<h3 id="快照在MVCC里如何工作"><a href="#快照在MVCC里如何工作" class="headerlink" title="快照在MVCC里如何工作"></a>快照在MVCC里如何工作</h3><ul>
<li>在可重复读隔离级别下，事务在启动的时候生产一个快照，并且是整个数据库的快照。</li>
<li>InnoDB里，每个事务都有一个事务ID，事务ID是系统严格按照递增顺序生成的。</li>
<li>每行数据都有多个版本，每次数据更新时，都会生成新的数据版本，并把操作更新的事务id赋值给新版本数据的事务ID，通过新版本可以找到数据的旧版本。<img src="/2018/12/21/geektime-mysql-learn/mysql_row_trx_id.png"></li>
<li>数据的其他版本可用通过每个事务的当前版本通过应用undo log来获取。</li>
<li>可重复读隔离级别下，一个事务启动时，获取了一个新的事务ID，它只认可在它之前生成的数据版本和它本身生成的数据版本。其它事务的更新生成的数据版本对它都是不可见的。</li>
<li>实现上InnoDB，在每个事务启动时，创建了一个数组，用来保存当前<code>活跃</code>的事务ID，这里活跃指的是已经启动，但是还未提交。</li>
<li>数组里面，事务ID的最小值记为<code>低水位</code>，当前系统已经创建过的事务ID的<code>最大值+1</code>记为<code>高水位</code>。这个视图数组和<code>高水位</code>共同构成事务的一致性视图。</li>
<li>数据版本的可见性规则，就是基于这个数据的row trx_id和该一致性视图的对比结果得到。</li>
</ul>
<h3 id="数据版本可见性规则"><a href="#数据版本可见性规则" class="headerlink" title="数据版本可见性规则"></a>数据版本可见性规则</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_array.png">
<p>如上图：事务启动瞬间，一个数据版本的row trx_id可能的取值有一下几种：</p>
<ol>
<li>位于绿色区间，表示这个版本是已经提交的，或者当前事务自己生成的，对当前事务可见。</li>
<li>位于红色区间，表示这个版本是未来的事务生成的，肯定不可见，这个容易理解。</li>
<li>位于黄色区间，有2中情况，<br> a. 如果row trx_id在数组中，表示该版本是未提交事务生成的。不可见。<br> b. row trx_id 不在数组中，表示这个版本是已经提交了的事务生成。可见。（当前活跃事务的ID数组是有序的，但每个元素之间的步长不是1， 中间有漏洞，漏洞里面的事务就是已经提交了的事务）</li>
</ol>
<p>一个事务视图中，除了自己的更新可见外，有其他三种情况：</p>
<ol>
<li>版本未提交，不可见。</li>
<li>版本已提交，但是在事务视图创建后提交的，不可见。</li>
<li>版本已提交，在事务视图创建前提交的，可见。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_analyze.png">
<p>如上图所示，事务A最终读取到的K值是1， 事务B最终读取到的K值是3。（autocommit=1, 隔离级别是可重复读）</p>
<p>这里需要注意的是事务B。 因为事务B的update语句是<code>当前读</code>(所有的更新都是先读后写，update会加锁)，所以会读取到事务C已经提交后的结果，事务B是在C=2的基础上进行更新，否则就丢失了事务C的更新。</p>
<p>除了update语句，加锁的select与也是当前读。</p>
<p><code>select ... for update</code> 或 <code>select .... lock in share mode</code>。</p>
<h3 id="课后题-2"><a href="#课后题-2" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, c) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_trx_update_problem.png">
<p>如果复现上图的问题，原因是什么？</p>
<p>答案：如何复现：其它事务在本事务执行更新语句前修改<code>c</code>的值并提交，因为隔离级别是RR, 那么本事务中进行select，结果还是更新前的值。但是update语句是当前读，读取的结果是其它事务更新后的值，已经不满足更新条件了，更新的结果就是上图所示的结果。如果在当前事务的update语句后面执行当前读(<code>for update</code>，<code>lock in share mode</code>)就能看到最新的值。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_can_not_update.png">
<h2 id="第9讲：普通索引和唯一索引怎么选？"><a href="#第9讲：普通索引和唯一索引怎么选？" class="headerlink" title="第9讲：普通索引和唯一索引怎么选？"></a>第9讲：普通索引和唯一索引怎么选？</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在查询中，普通索引和唯一索引的性能消耗可以忽略不计。原因在于MySQL还按页读取和写入数据的（默认的页大小是16KB），在一个数据页中查找到满足条件的记录后，如果是唯一索引，则停止搜索；如果是普通索引，则继续搜索，因为此时数据页已经在内存中，再加上OS的磁盘预读机制，大概率剩下的满足条件的数据页在内存中，查找内存的效率是很高的。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>MySQL更新数据时，如果记录所在的数据页在内存中，则直接更新。否则，在不影响数据一致性的前提下，InnoDB会将更新操作缓存在<code>change buffer</code>中，并不会立即读取磁盘上数据页然后进行更新。<code>change buffer</code>会同时保持在磁盘和内存中。后续查询需要访问这个数据页时，才会从磁盘读取数据页，然后使用<code>change buffer</code>里面的数据更新数据页的内容。将<code>change buffer</code>中的更新操作应用到原始数据页上的操作称为<code>merge</code>。</p>
<p><code>change buffer</code> 减少了磁盘访问次数，间接减少了内存占用。</p>
<p><code>change buffer</code> 使用的是<code>buffer pool</code>里面的内存。可以通过参数<code>innodb_change_buffer_max_size</code>来动态调整。</p>
<h4 id="merge的触发时机"><a href="#merge的触发时机" class="headerlink" title="merge的触发时机"></a>merge的触发时机</h4><ol>
<li>访问数据页</li>
<li>数据库正常停机</li>
<li>后台线程周期性merge</li>
</ol>
<h4 id="change-buffer-使用条件"><a href="#change-buffer-使用条件" class="headerlink" title="change buffer 使用条件"></a>change buffer 使用条件</h4><p>普通索引才能使用<code>change buffer</code>。原因在于针对唯一索引，当数据页不在内存是，更新操作（insert, update）需要读取数据页才能进行唯一性判断。普通索引直接将更新操作添加到<code>change buffer</code>即可。针对普通索引，<code>change buffer</code>减少了磁盘的随机访问，唯一索引容易引起磁盘的随机访问，造成性能下降。</p>
<p><code>change buffer</code>的作用是尽量缓存更新操作直到进行merge操作前。如果数据更新后，马上被读取，那么缓存效果会大打折扣。也就是说：<code>change buffer</code>对<code>写多读少</code>的应用更合适。相反，更新后马上读取，就会触发merge操作，随机I/O并没有减少，反而要维护<code>change buffer</code>，代价更高。</p>
<p>insert的时候，写主键是肯定不能用<code>change buffer</code>了，但是同时也会要写其它索引，而其它索引中的<code>非唯一索引</code>是可以用的这个机制的；</p>
<p><code>change buffer</code>的前身是<code>insert buffer</code>,只能对insert 操作优化；后来升级了，增加了<code>update/delete</code>的支持，名字也改叫<code>change buffer</code>。</p>
<p>一个数据行的多次更新，会在change buffer中存在多个记录。</p>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>普通索引和唯一索引在查询能力上差别微乎其微，主要区别在于更新操作，所以建议使用普通索引。</p>
<p>如果更新后马上进行读取，则考虑关闭<code>change buffer</code>。</p>
<p>实践：在线库可以使用唯一索引满足业务需求，历史备份表可以将唯一索引改为普通索引，配合较大的<code>change buffer</code>设置，可以提高备份库的写入速度。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><h4 id="带-change-buffer-写入"><a href="#带-change-buffer-写入" class="headerlink" title="带 change buffer 写入"></a>带 change buffer 写入</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_redolog_change_buffer.png"> 
<p>上面的sql做了如下操作：</p>
<ol>
<li>Page 1 在内存中，直接更新内存； </li>
<li>Page 2 没在内存中，记录insert操作到<code>change buffer</code>中。</li>
<li>将上面2个操作记录到redo log。</li>
</ol>
<h4 id="带-change-buffer-读取"><a href="#带-change-buffer-读取" class="headerlink" title="带 change buffer 读取"></a>带 change buffer 读取</h4><img src="/2018/12/21/geektime-mysql-learn/mysql_read_with_change_buffer.png"> 
<p>读取时，如果数据页在内存中，直接返回。只有数据页不在内存中，才需要读取磁盘上的数据，然后应用<code>change buffer</code>里面的操作。</p>
<p><code>redo log</code>节省的是随机写的性能消耗（转为顺序写），<code>change buffer</code>主要节省的是随机读的性能消耗。</p>
<h3 id="课后题-3"><a href="#课后题-3" class="headerlink" title="课后题"></a>课后题</h3><p><code>change buffer</code>的更新没有应用到磁盘数据页，掉电后，会不会导致<code>change buffer</code>丢失，也就是会不会导致丢失更新呢？</p>
<p>答案：不会。</p>
<p>1.<code>change buffer</code>有一部分在内存有一部分在<code>ibdata</code>.<br>做<code>purge</code>操作,应该就会把<code>change buffer</code>里相应的数据持久化到<code>ibdata</code><br>2.<code>redo log</code>里记录了数据页的修改以及<code>change buffer</code>新写入的信息<br>如果掉电,持久化的<code>change buffer</code>数据已经<code>purge</code>,不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1)<code>change buffer</code>写入,<code>redo log</code>虽然做了<code>fsync</code>但未<code>commit</code>,<code>binlog</code>未<code>fsync</code>到磁盘,这部分数据丢失<br>(2)<code>change buffer</code>写入,<code>redo log</code>写入但没有<code>commit</code>,<code>binlog</code>已经<code>fsync</code>到磁盘,先从<code>binlog</code>恢复<code>redo log</code>,再从<code>redo log</code>恢复<code>change buffer</code>。不会丢失<br>(3)<code>change buffer</code>写入,<code>redo log</code>和<code>binlog</code>都已经<code>fsync</code>, 那么直接从<code>redo log</code>里恢复。不会丢失。</p>
<h2 id="第10讲-MySQL为什么有时候会选错索引？"><a href="#第10讲-MySQL为什么有时候会选错索引？" class="headerlink" title="第10讲 MySQL为什么有时候会选错索引？"></a>第10讲 MySQL为什么有时候会选错索引？</h2><p>通常查询语句使用哪个索引是由MySQL来决定的(优化器)。但我们也可以在SQL语句强制mysql使用指定的索引。</p>
<h3 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> (FIELD1) …</span><br></pre></td></tr></table></figure>
<h3 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (FIELD1, FIELD2) …</span><br></pre></td></tr></table></figure>
<h3 id="SQL-NO-CACHE"><a href="#SQL-NO-CACHE" class="headerlink" title="SQL_NO_CACHE"></a>SQL_NO_CACHE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE field1, field2 <span class="keyword">FROM</span> TABLE1;</span><br></pre></td></tr></table></figure>
<h3 id="选错索引例子"><a href="#选错索引例子" class="headerlink" title="选错索引例子"></a>选错索引例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>；</span><br><span class="line"><span class="comment"># 插入数据的存储过程</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>分析索引使用情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure>
<p>因为<code>a</code>字段上有索引，结果是使用索引。</p>
<p>如下操作显示MySQL选择的错误的索引：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_select_error_index.png">
<p>通过SQL进行验证：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>优化器根据查询的扫描行数，是否使用临时表，是否排序等因素来综合判断，生成执行计划。</p>
<p>MySQL在执行语句前会根据统计信息来估算可能的扫描行数，这个统计信息就是索引的区分度。</p>
<p>一个索引上不同值得个数称为基数。可以通过语句<code>show index from table;</code>来查看。</p>
<p>优化器同时会考虑使用普通索引时，查询回表的代价。</p>
<h4 id="采样统计"><a href="#采样统计" class="headerlink" title="采样统计"></a>采样统计</h4><p>MySQL默认选择N个数据页，统计N个页面上的不同值，得到一个平均值。平均值 * 索引的页面数 得到这个索引的基数。数据表一直更新，当变更的行数超过<code>1/M</code>时会触发一次新的索引统计计算。</p>
<p><code>innodb_stats_persistent = on</code> 表示MySQL的统计信息会持久化保存（这时N=20,M=10），<code>off</code>表示仅保存在内存中(这时N=8,M=16)。</p>
<h3 id="选错索引处理办法"><a href="#选错索引处理办法" class="headerlink" title="选错索引处理办法"></a>选错索引处理办法</h3><ol>
<li>由于统计信息不及时和不准确，可以通过<code>analyze table table_name</code>来重新统计索引信息。</li>
<li>通过<code>force index</code>语句来强制使用指定索引。</li>
<li>修改SQL语句，引导MySQL使用正确索引（前提是不改变SQL语句的业务逻辑）。</li>
<li>新增更合适的索引，或删除误用的索引。</li>
</ol>
<h3 id="课后题-4"><a href="#课后题-4" class="headerlink" title="课后题"></a>课后题</h3><p>如果没有<code>session A</code>的配合，只有<code>session B</code> 则会看到扫描行数还是<code>10000</code>左右，原因是什么?</p>
<p>答案：因为事务隔离级别是RR, 存在Session A的情况下，事务没有提交，原来插入的数据不能被删除。之前的每行数据有2个版本，旧版本是delete前的数据，新版本是标记为<code>deleted</code>的数据。session B又插入了10w上记录，这样索引a上就有2份数据。</p>
<p>主键索引扫描行数的估计值是通过<code>show table status like &#39;table_name&#39;</code> 来获取的。</p>
<h2 id="11讲-怎么给字符串字段加索引？"><a href="#11讲-怎么给字符串字段加索引？" class="headerlink" title="11讲 - 怎么给字符串字段加索引？"></a>11讲 - 怎么给字符串字段加索引？</h2><p>字符串字段添加索引有2中方式：</p>
<ol>
<li>整个字段的值都作为索引值。</li>
<li>字符串的前N个字符作为索引值。</li>
</ol>
<p>这两种做法各有利弊。整个字段作为索引，可以减少扫描行数，但是索引较大。<br>前缀索引索引占用空间小，但是扫描行数较多。所以在实践中，可以通过调节N的值，来平衡索引的大小和扫描的行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br><span class="line"><span class="comment"># 取不同的N值，计算前缀索引的区分度。</span></span><br><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<p>使用前缀索引不能利用覆盖索引可以避免回表的优化机制，必须回表查询。</p>
<p>如果遇到前缀索引前N位区分度很小的情况下，有如下两种优化办法：</p>
<ol>
<li>倒序存储（例如身份证号，同一个地区，前6位都是相同的）。</li>
<li>对字段值进行hash,保存hash后的值，建立索引。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>倒序存储和hash，都不能进行范围查询。hash只能进行等值查询</li>
<li>倒叙存储和hash存储，插入数据和查询数据，都需要进行额外的计算（reverse , crc）。</li>
<li>和倒叙存储比较起来，hash存储方式查询效率更好。</li>
</ol>
<h2 id="12讲-为什么我的MySQL会“抖”一下？"><a href="#12讲-为什么我的MySQL会“抖”一下？" class="headerlink" title="12讲 - 为什么我的MySQL会“抖”一下？"></a>12讲 - 为什么我的MySQL会“抖”一下？</h2><p>通常的更新操作，只是更新内存数据页，写redo log，不会有大量的磁盘写入操作。这就导致磁盘数据页和内存数据页的数据不一致，这样的数据页称为<code>脏页</code>，MySQL会定时或被动触发将脏页刷新到磁盘中操作。</p>
<h3 id="刷脏页的触发时机"><a href="#刷脏页的触发时机" class="headerlink" title="刷脏页的触发时机"></a>刷脏页的触发时机</h3><p>场景一：当redo log写满了，也就是write pos 追上check point时, 如下图：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_flush_dirty_page.jpg">
<p>当check point 往前推进时，需要把推进区间内对应的脏页都写入磁盘。</p>
<p>场景二：当某个查询需要大量内存，但是内存空闲的干净页不足，此时需要把脏页写入磁盘来增加干净页。</p>
<p>场景三：系统空闲时，后台线程执行刷脏页操作。</p>
<p>场景四：MySQL停机。</p>
<p>我们在实践中需要尽量避免场景一的出现，因为此时MySQL不再执行任何更新操作。如果脏页积累的太多，会导致一次需要刷大量的脏页到磁盘，也是需要尽力避免。</p>
<h3 id="InnoDB刷脏页控制策略"><a href="#InnoDB刷脏页控制策略" class="headerlink" title="InnoDB刷脏页控制策略"></a>InnoDB刷脏页控制策略</h3><p>获取磁盘的IOPS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure>
<p>告诉InnoDB磁盘的IOPS值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_io_capacity=IOPS</span><br></pre></td></tr></table></figure>
<p>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例的上限。</p>
<p>InnoDB根据当前的脏页比例M计算出一个[0 - 100]间的数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InnoDB每次写入的redo log都有一个序号(LSN)，当前写入日志的序号和check point直接的差值记为<code>N</code>，InnoDB会根据<code>N</code>算出一个0-100间的数字，这公式记为F2(N)，算法比较复杂，<code>N</code>越大，则结果越大。</p>
<p>InnoDB根据<code>F1(M)</code>和<code>F2(N)</code>二者结果的 <code>最大值</code> * <code>innodb_io_capacity</code>的结果控制刷脏页的速度。</p>
<p>可以通过如下语句计算脏页比例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：InnoDB刷脏页的过程中，如果相邻页也是脏页，那么相邻页也会被刷到磁盘上，如果相邻页的相邻页也是脏页，也会被刷。也就是说这个过程是级联的。这会导致雪上加霜的效果。<code>innodb_flush_neighbors</code>参数就是控制这个机制的。设置为<code>0</code>表示只刷自己，为<code>1</code>。MySQL8.0默认值为<code>0</code>;</p>
</blockquote>
<h3 id="课后题-amp-讨论"><a href="#课后题-amp-讨论" class="headerlink" title="课后题&amp;讨论"></a>课后题&amp;讨论</h3><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>因内存不足导致刷脏页时，不会刷redo文件的。redo log 在重放时，如果一个数据页已经刷过的话，会被识别出来，并跳过。</p>
<h4 id="课后题-5"><a href="#课后题-5" class="headerlink" title="课后题"></a>课后题</h4><p>一个内存配置为 128GB、innodb_io_capacity=20000的高配实例，redo log设置为一个100MB的文件，会发生什么情况，原因是什么？</p>
<p>答案：因为redo log文件设置的比较小，那么redo log文件就容易写满，导致频繁刷脏页，由于磁盘的IOPS很大，监控上开起来磁盘压力不大，但是性能间歇性的不好，但是也不会降低很大，因为每次刷脏页的速度还是很快的。</p>
<h2 id="13讲-为什么表数据删掉一半，表文件大小不变？"><a href="#13讲-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13讲 - 为什么表数据删掉一半，表文件大小不变？"></a>13讲 - 为什么表数据删掉一半，表文件大小不变？</h2><p>InnoDB 8.0以前，表结构保存在<code>.frm</code>文件中，从8.0开始运行把表结构保存到系统数据表中。因为表结构文件非常小心。</p>
<h3 id="innodb-file-per-table"><a href="#innodb-file-per-table" class="headerlink" title="innodb_file_per_table"></a>innodb_file_per_table</h3><p><code>innodb_file_per_table</code>参考用来控制表数据是放到共享表空间还是独立的文件。</p>
<ul>
<li>on: 表示每个数据表独立保存一个后缀为<code>.ibd</code>的文件中。</li>
<li>off: 表示数据放到系统共享表空间中，也就是和数据字典放在一起。</li>
</ul>
<p>从MySQL5.6.6开始，默认值就是<code>on</code>。建议一直将该参数设置为<code>on</code>，除了好管理外，<code>drop table</code> 后MySQL会直接删除该文件，否则保存在共享表空间，表删除了，但是空间不会自动释放。</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_delete.png">
<p>innodb删除数据是<code>标记删除</code>。标记删除的记录占用的空间可以被复用，单记录空间的复用只限于特定范围。</p>
<p>如果一个数据页的所有数据都被标记为删除，则整个数据页都可以被复用，并可以复用到任何位置。</p>
<p>如果相邻的两个页的空间利用率都比较小，innodb会将相邻的页合并为一个页，另一个页标记为可复用。</p>
<p>由于是标记删除，所以占用的磁盘空间并不会自动释放，导致的结果就是文件很大，记录数很少，把这些可以复用而没有使用的空间称为<code>空洞</code>。</p>
<p>删除，插入记录（页分裂，分配了一个新的页，导致2个页的空间利用率很低), 更新索引上的值，都会导致空洞的产生。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_page_split.png">
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>当你想要收缩表空间时，可以新建一个结构相同的表，将老表的数据导入新表，然后重命名，并删除旧表。</p>
<p>因为新表是按照索引递增的顺序插入数据记录，数据页的空间利用率很高，磁盘占用很少。</p>
<p>可以通过<code>alter table A engine=InnoDB</code>来实现这个操作。但是需要注意的是在MySQL5.5版本前，这个操作执行过程中，老的表不能有数据更新（不能进行DML操作），否则会导致丢失更新。也就是说这个操作不是Online的。而在MySQL5.6版本引入了Online DDL，优化了该流程（原理是：导数据的过程中记录老表的变更操作到文件中，数据导完后，再应用期间的变更），可以在放心使用。</p>
<p>注意：针对较大的表，导数据过程中需要大量的CPU和I/O资源，可以选择在业务低峰期进行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inplace 方式（server 层视角）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br><span class="line"><span class="comment"># copy 拷贝方式（MySQL老版本实现方式）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>
<h3 id="online-vs-inplace"><a href="#online-vs-inplace" class="headerlink" title="online vs inplace"></a>online vs inplace</h3><ol>
<li>DDL的过程是online的，那一定就是inplace的。</li>
<li>反过来未必，也就是说inplace的DDL不一定是online的。截止到MySQL8.0，添加全文索引和空间索引就是这种情况。</li>
</ol>
<h3 id="optimize-table-vs-analyze-table-vs-alter-table-engine-innodb"><a href="#optimize-table-vs-analyze-table-vs-alter-table-engine-innodb" class="headerlink" title="optimize table vs analyze table vs alter table engine=innodb"></a>optimize table vs analyze table vs alter table engine=innodb</h3><p><code>optimize table</code> = recreate + analyze</p>
<p><code>analyze table</code> 没有重建表，只是更新索引统计信息。</p>
<p><code>alter table engine=innodb</code> 就是重建表recreate。</p>
<p><code>truncate table</code> = drop + create</p>
<h3 id="课后题-6"><a href="#课后题-6" class="headerlink" title="课后题"></a>课后题</h3><p>有没有可能执行完<code>alter table engine=innodb</code>后数据文件反而变大的情况？ 原因可能是什么？</p>
<p>答案：有的。</p>
<ol>
<li>刚进行完表的重建后再次进行重建，期间有DML操作，这些新的操作导致有空洞的产生。</li>
<li>表的重建，每个数据页不是完全满的，InnoDB会预留一部分空间。但是在数据页的合并过程中每个数据页可能是完全满的。</li>
<li>重建表后，插入一些数据占用预留空间，再次重建表，导致新增预留空间，数据文件会变大。</li>
</ol>
<h2 id="14讲-count-这么慢，我该怎么办？"><a href="#14讲-count-这么慢，我该怎么办？" class="headerlink" title="14讲 - count(*)这么慢，我该怎么办？"></a>14讲 - count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><p>不同的存储引擎实现方式不同。下文讨论的都是不加<code>where</code>条件的。</p>
<ul>
<li>MyISAM 会把表的总数保存到磁盘上，执行count(*)时直接返回</li>
<li>InnoDB 执行count(*)时，需要把数据从引擎中一行行读出来进行累加，速度较慢。</li>
</ul>
<p>InnoDB由于MVCC的原因，每个事务查询时，返回的总数都不是确定的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_count.png">
<p>InnoDB在执行<code>count(*)</code>时，也会做一点优化。主键索引树的叶子节点是数据，普通索引的叶子节点是主键值。索引普通索引比主键索引小很多。因此MySQL优化器会选择最小的索引树进行遍历获取<code>count(*)</code>的值。</p>
<p><code>show table status</code> 显示的记录数是估值，官方文档说误差在40%到50%，因此也不准确。</p>
<h3 id="如何快速计算表的记录总数"><a href="#如何快速计算表的记录总数" class="headerlink" title="如何快速计算表的记录总数"></a>如何快速计算表的记录总数</h3><ul>
<li>如果不需要完全准确的值，可以缓存表的记录数，动态更新 并 定时全表扫描更新缓存中的值。</li>
<li>通过数据库<code>独立计数表</code>进行统计，通过事务保证计数值和表记录总数的一致性。</li>
</ul>
<h3 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h3><p>count是一个聚合函数（server层实现的，这个很重要），只要参数判断不为NULL，计数值就+1</p>
<p>count(*)， count(主键)， count(1)都表示满足条件的记录总数。</p>
<p>count(字段) 表示满足条件并且该字段不为null的记录总数。</p>
<p>性能差别：</p>
<ol>
<li>server层要什么字段，引擎层就给什么字段</li>
<li>InnoDB只给必要的值</li>
<li>现在的优化器只优化了<code>count(*)</code>的语义为<code>取行数</code>，其他<code>显而易见</code>的优化并没有做。</li>
</ol>
<h4 id="count-主键"><a href="#count-主键" class="headerlink" title="count(主键)"></a>count(主键)</h4><p>InnoDB遍历表，把每一行的主键取出来返回给Server层。</p>
<h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>InnoDB遍历表，但是不取值，server层对返回的每一行，放入。<br>一个数字<code>1</code>进行判断，判断是不肯能为空的，按行累加。</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><code>count(*)</code> 并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不为NULL，按行累加。</p>
<h4 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h4><ol>
<li>如果字段定义为Not null， 从每一行中读取该字段，判断不能为null，按行累加。</li>
<li>如果字段定义为可以为NULL，那么还是需要从行中读取该字段，并判断是否为NULL，不是NULL才进行累加。</li>
</ol>
<p>综上，按照效率来说，count(字段) &lt; count(主键) &lt; count(1) ≈ count(*)</p>
<p>所以建议使用<code>count(*)</code></p>
<h2 id="15讲-日志和索引相关问题"><a href="#15讲-日志和索引相关问题" class="headerlink" title="15讲 - 日志和索引相关问题"></a>15讲 - 日志和索引相关问题</h2><p>MySQL在崩溃恢复时，是通过binlog和redo log共同判断事务应该提交还是回滚：</p>
<ol>
<li>如果redo log里面的事务是完整的，并且有commit标志，那么直接提交事务。</li>
<li>redo log里面的事务有完整的prepare，如果binlog完整，则提交事务，否则回滚事务。</li>
</ol>
<h3 id="MySQL如何知道binlog的完整性？"><a href="#MySQL如何知道binlog的完整性？" class="headerlink" title="MySQL如何知道binlog的完整性？"></a>MySQL如何知道binlog的完整性？</h3><p>一个事务的binlog是有完整格式的</p>
<ul>
<li>statement格式的binlog，最后会有<code>COMMMIT</code>.</li>
<li>row格式的binlog，最后会有一个XID event.</li>
<li>5.6.2版本后，添加了binlog-checksum参数，用来验证binlog的完整性。</li>
</ul>
<h3 id="redo-log-如何和-binlog进行关联"><a href="#redo-log-如何和-binlog进行关联" class="headerlink" title="redo log 如何和 binlog进行关联"></a>redo log 如何和 binlog进行关联</h3><p>redo log 和 binlog 有一个共同的数据字段<code>XID</code>。</p>
<h3 id="处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h3><p>binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<h3 id="如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h3><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</p>
<h3 id="不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？"></a>不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</h3><p>答案是不可以。binlog 没有能力恢复“数据页”。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_binlog_crash_safe.jpg">
<h3 id="那能不能反过来，只用-redo-log，不要-binlog？"><a href="#那能不能反过来，只用-redo-log，不要-binlog？" class="headerlink" title="那能不能反过来，只用 redo log，不要 binlog？"></a>那能不能反过来，只用 redo log，不要 binlog？</h3><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。</p>
<p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。</p>
<p>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</p>
<p>一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。</p>
<p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。</p>
<p>总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。你看，发展生态是多么重要。</p>
<h3 id="追问-7：redo-log-一般设置多大？"><a href="#追问-7：redo-log-一般设置多大？" class="headerlink" title="追问 7：redo log 一般设置多大？"></a>追问 7：redo log 一般设置多大？</h3><p>回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。</p>
<p>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。</p>
<h3 id="追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？"><a href="#追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？" class="headerlink" title="追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？"></a>追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</h3><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。</p>
<p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p>
<p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</p>
<p>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>
<h3 id="追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？"><a href="#追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？" class="headerlink" title="追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？"></a>追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</h3><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。</p>
<p>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。</p>
<p>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的 IO 消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第 22 篇文章《MySQL 有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p>
<p>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p>
<h3 id="课后题-7"><a href="#课后题-7" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">`id` int(11) NOT NULL primary key auto_increment,</span><br><span class="line">`a` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下的语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t set a=2 where id=1;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value.png"></p>
<p>仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是 2，不更新，直接返回，执行结束；</li>
<li>MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li>
<li>InnoDB 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</li>
</ol>
<p>答案：第三种。分析如下：</p>
<p>针对第一种假设：如果不更新，直接返回。那么就不会加行锁。因此可以通过如下步骤验证</p>
<ol>
<li>SessionA 开启一个事务执行update语句，不提交事务。</li>
<li>SessionB 执行同样的更新语句，如果出现Block现象，那么说明SessionA对数据加了行锁，也就是说Server层调用了InnoDB的更新接口。(<code>行锁是在InnoDB中实现的</code>)</li>
</ol>
<p>针对第二种假设：如果InnoDB没有进行数据更新，那么在RR事务隔离级别下，A和B两个事务执行同样的更新语句，B事务的更新对A事务不可见，在A事务中，更新语句前后执行查询语句，如果2次的查询结果都是2，说明InnoDB确实没有执行更新操作。如果第二次查询可以看到更新后的值，说明InnoDB执行了更新。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_1.png">
<p>如果InnoDB能肯定更新前后的值相同，它确实不会再执行更新的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_2.png">
<p>where 语句有<code>k=3</code>这个条件，更新后还是3，InnoDB确实就不进行更新了。</p>
<p>注意：虽然InnoDB执行了更新，但是对MySQL Server层来说，前后的数据并没有变，row 格式下也不会产生binlog。</p>
<h2 id="第16讲-“order-by”是怎么工作的？"><a href="#第16讲-“order-by”是怎么工作的？" class="headerlink" title="第16讲 -  “order by”是怎么工作的？"></a>第16讲 -  “order by”是怎么工作的？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>查询排序语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by.png">
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL给每个线程分配一个排序缓存(sort buffer)，针对上面的查询排序语句，MySQL从<code>city</code>索引树上查询满足条件的记录主键，回表查询<code>city,name,age</code>自动的值放入sort buffer。 最后对sort buffer中的记录按name字段进行快速排序，将排序结果的前1000条数据返回。</p>
<p><code>sort buffer</code>有大小，如果满足条件的记录在<code>sort buffer</code>把放不下，则需要使用文件排序（归并排序）。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_diagram.jpg">
<p>参数：<code>sort_buffer_size</code> 可以控制 排序缓存的大小，增大该参数的值，可以加速排序。</p>
<p>通过下面的语句来验证查询是否使用了临时文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>如果查询的结果需要返回记录的大部分字段或者或者所有字段，此时会占用大量内存，很容易导致采用文件排序，效率是低下的。MySQL针对这种情况进行了优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>这个参数是专门控制参与内存排序的数据行大小的，如果参与排序的数据行大小大于该值，那么MySQL将采用另一种排序算法：</p>
<ol>
<li>将满足条件的记录中需要参与排序的字段和主键放入sort buffer。</li>
<li>对sort buffer中的记录按name进行排序。</li>
<li>取出排序结果的前1000行，根据ID，查询主键索引树，获取要返回的字段值。</li>
</ol>

<h3 id="全字段排序-vs-rowid排序"><a href="#全字段排序-vs-rowid排序" class="headerlink" title="全字段排序 vs rowid排序"></a>全字段排序 vs rowid排序</h3><ol>
<li>MySQL倾向于使用内存排序，所以尽量使用大内存机器，避免文件排序和rowid排序(需要回表，查询慢)</li>
<li>查询语句尽量只返回需要的字段，不要<code>select *</code></li>
<li>适当调高<code>max_length_for_sort_data</code>的值。</li>
</ol>
<h3 id="避免排序"><a href="#避免排序" class="headerlink" title="避免排序"></a>避免排序</h3><p>并不是所有的order by都会排序。如果从索引树上获取的结果集本身就是有序的就可以避免排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>有了这个索引，city相同，name本身就是有序的，就避免了排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_not_need_sort.jpg">
<p>explain:</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_using_index.png">
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure>
<p>有了覆盖索引的优化，避免了回表，性能进一步提高。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index.jpg">
<p>explain结果：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index_explain.png">
<h3 id="explain-type"><a href="#explain-type" class="headerlink" title="explain type"></a>explain type</h3><p>all : 全表扫描</p>
<p>index: 使用索引，如果是覆盖索引，可以不用回表，如果没有where条件，会扫描整个索引树。</p>
<p>range: 以范围的形式扫描索引树。 </p>
<p>ref: 非唯一索引引用</p>
<p>eq_ref: 等值引用。 使用有唯一性索引查找（主键或唯一性索引）</p>
<p>const：（常量连接）被称为<code>常量</code>，这个词不好理解，不过出现 const 的话就表示发生下面两种情况：</p>
<ol>
<li>在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id=1 就肯定只有一行，只需读取一次表数据便能取得所需的结果，且表数据在分解执行计划时读取。返回值直接放在 select 语句中，类似 select 1 AS f 。可以通过 extended 选择查看内部过程：</li>
</ol>
<h3 id="explain-extra"><a href="#explain-extra" class="headerlink" title="explain extra"></a>explain extra</h3><ul>
<li><code>Using filesort</code> : 通常在使用到排序语句ORDER BY的时候，会出现该信息，表示一种排序算法，可能使用文件排序。</li>
<li><code>Using index</code> : 表示只使用了索引，不用回表，使用了覆盖索引。如果同时出现<code>Using where</code>，表示需要回表。</li>
<li><code>Using where</code>：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现<code>Using where</code>。如果type列是<code>ALL</code>或<code>index</code>，而没有出现该信息，则有可能在执行错误的查询：返回所有数据。  </li>
<li><code>Using temporary</code>：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</li>
</ul>
<h2 id="课后题-8"><a href="#课后题-8" class="headerlink" title="课后题"></a>课后题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="keyword">in</span> （<span class="string">'杭州'</span>,<span class="string">'苏州'</span>）<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>答案：拆为2次查询，应用内归并排序，取前100行。</p>
<p>如果是<code>limit 10000, 100</code>的话，解决思路也是类似的。但缺点是应用需要保存大量的数据，如果offset太大的话，客户端内存排序就不可行了（内存溢出）。</p>
<p>为了减少内存占用，可以只返回<code>id,name</code>字段数据，排序后，用ID再查询数据库获取数据。</p>
<h2 id="第17讲-如何正确地显示随机消息？"><a href="#第17讲-如何正确地显示随机消息？" class="headerlink" title="第17讲 - 如何正确地显示随机消息？"></a>第17讲 - 如何正确地显示随机消息？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure>
<p>随机排序，取前3个。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_mem_temp.png">
<p>上图表示使用了<code>内存临时表</code>，并且进行了排序。</p>
<p>由于内存临时表的回表速度非常快，MySQL此时优先选择排序是排序行越少越好，就是rowid排序。</p>
<p>上述语句的执行流程：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li>
<li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li>
<li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li>
<li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li>
<li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li>
</ol>
<p>慢查询日志分析：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span>=<span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_sort_diag.png">
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>不是所有的临时表都是内存临时表（memory引擎）。</p>
<p>参数<code>tmp_table_size</code>限制内存临时表的大小，默认是16MB。大于该值就转为磁盘临时表（默认是InnoDB引擎，可以通过<code>internal_tmp_disk_storage_engine</code>来控制， 该临时表没有显示索引）。</p>
<p>MySQL5.6引入了一个新的排序算法，优先级队列排序，其实就是堆排序。用来处理TOP(n)的情况，可以避免对整个数据进行排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_sort_heap.png">
<p>但是使用优先级队列排序的前提是：待排序的数据集不能超过<code>sort_buffer_size</code></p>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>随机算法一：</p>
<p>生成一个ID最小值和最大值之间的随机数，取大于整个值的第一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(id),min(id) into @M,@N from t ;</span><br><span class="line"><span class="keyword">set</span> @X= <span class="keyword">floor</span>((@M-@N+<span class="number">1</span>)*<span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法效率很高，因为取 max(id) 和 min(id) 都是不需要扫描索引的，而第三步的 select 也可以用索引快速定位，可以认为就只扫描了 3 行。但实际上，这个算法本身并不严格满足题目的随机要求，因为 ID 中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p>
<p>随机算法二：</p>
<p>生成一个小于数据总行数C的随机数Y，<code>limit Y , 1</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sql</span> = <span class="keyword">concat</span>(<span class="string">"select * from t limit "</span>, @Y, <span class="string">",1"</span>);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，因此这一步需要扫描 Y+1 行。再加上，第一步扫描的 C 行，总共需要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。</p>
<p>随机算法三：</p>
<p>要获取N个随机数，只需要执行N次获取随机数第Y行的操作，再获取每次的行即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y1 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y2 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y3 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y1，<span class="number">1</span>； // 在应用代码里面取 Y1、Y2、Y3 值，拼出 <span class="keyword">SQL</span> 后执行</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y2，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y3，<span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p>注意：需要注意去重问题。</p>
<h3 id="课后题-9"><a href="#课后题-9" class="headerlink" title="课后题"></a>课后题</h3><p>上面的随机算法 3 的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p>
<p>我的答案：</p>
<p>C的扫描过程可以通过单独的计数来避免，如何计数可以参考前面<code>count(*)</code>的内容。</p>
<p>Y1,Y2,Y3的扫描优化: 对Y1, Y2, Y3进行排序，假设排序后 Y1 &lt; Y2 &lt; Y3。 Y1的扫描不可避免，获取Y1+1的行ID记为min_id， 然后<code>where id &gt; min_id_1 limit (Y2 - Y1), 1</code>;</p>
<p>其他答案：</p>
<ol>
<li>对有空洞的表进行整理，消除空洞后，利用算法一。</li>
<li>老师的方法：取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，然后执行下面这条 SQL 语句：<code>mysql&gt; select * from t limit N, M-N+1;</code></li>
</ol>
<h2 id="18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><p>在 MySQL 中，有很多看上去逻辑相同，但性能却差异巨大的 SQL 语句。对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大。</p>
<h3 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `tradelog` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `operator` int(11) DEFAULT NULL,</span><br><span class="line">  `t_modified` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>查询交易记录日志表，每年7月份的总数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>
<p>这条语句会执行全表扫描或索引扫描。原因如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_func.png">
<p>month函数计算后导致无法使用索引。</p>
<p>推而广之：针对索引自动进行函数操作，结果可能破坏索引的有序性，导致不能使用索引。</p>
<p>针对该问题，下面的SQL可以解决。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where</span><br><span class="line">    -&gt; (t_modified &gt;= '2016-7-1' and t_modified&lt;'2016-8-1') or</span><br><span class="line">    -&gt; (t_modified &gt;= '2017-7-1' and t_modified&lt;'2017-8-1') or </span><br><span class="line">    -&gt; (t_modified &gt;= '2018-7-1' and t_modified&lt;'2018-8-1');</span><br></pre></td></tr></table></figure>
<p>优化器也有<code>偷懒</code>的行为, 即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 <code>select * from tradelog where id + 1 = 10000</code> 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 <code>where id = 10000 - 1</code> 才可以(这也说明，优化器会先计算<code>10000 - 1</code>表达式，通结果作为条件)。</p>
<h3 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h3><p>数字字符串和数字进行比较时，会先转为数字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">"10"</span> &gt; <span class="number">9</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment"># 结果是：1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>
<p>对索引字段执行了cast函数，优化器判断不能使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">"83126"</span>;</span><br></pre></td></tr></table></figure>
<p>上面的SQL可以使用索引，原因是优化器可以先将”83126”转为数字83126，然后进行查询，此时可以利用索引。</p>
<h3 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `trade_detail` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `trade_step` int(11) DEFAULT NULL, <span class="comment">/* 操作步骤 */</span></span><br><span class="line">  `step_info` varchar(32) DEFAULT NULL, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure>
<p>关联查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /* 语句 Q1*/</span><br></pre></td></tr></table></figure>
<p>查询trade_detail时不能使用tradeid索引的原因是2个表的字符集不同。</p>
<p>tradelog表的字符集是utf8mb4, trade_detail表是utf8。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure>
<p>有了前面的分析，我们提前将查询条件进行手动转换，这样就可以利用索引了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2;</span><br></pre></td></tr></table></figure>
<h2 id="19讲-为什么我只查一行的语句，也执行这么慢？"><a href="#19讲-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19讲 - 为什么我只查一行的语句，也执行这么慢？"></a>19讲 - 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="等待MDL锁"><a href="#等待MDL锁" class="headerlink" title="等待MDL锁"></a>等待MDL锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i)</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>查询语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>
<p>这个查询为啥慢呢？ 如果还记得MDL元数据锁的话，你就理解了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl.png">
<p>如何复现(5.7)：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl_case.png">
<p>SessionA 持有表的MDL写锁， SessionB要获取MDL读锁，只能等待。</p>
<p>解决版本是kill掉持有MDL写锁的线程。</p>
<p>但是，由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找起来很不方便。不过有了 <code>performance_schema</code> 和 <code>sys</code> 系统库以后，就方便多了。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失)</p>
<p>通过查询 <code>sys.schema_table_lock_waits</code> 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
<h3 id="等待flush"><a href="#等待flush" class="headerlink" title="等待flush"></a>等待flush</h3><p>flush 表时，查询语句需要等待flush执行完才能继续执行。</p>
<p>MySQL 里面对表做 flush 操作的用法，一般有以下两个</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br></pre></td></tr></table></figure>
<p>通常这2个语句都执行的很快，除非被其他语句阻塞。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_flush_table.png">
<p>flush被一个查询语句阻塞，进而导致我们的查询阻塞。</p>
<h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode;</span><br></pre></td></tr></table></figure>
<p>这个语句要获取一个读锁，如果这一行正在被更新，也就是说被加了写锁，那么该语句只能等待。</p>
<p>读写互斥，2个写操作也是互斥的。</p>
<p>在MySQL5.7版本，可以通过下面的语句查询锁的持有情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`'test'.'t'`\G</span><br></pre></td></tr></table></figure>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>在没有索引的字段执行查询，在数据量比较大时，查询就很慢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure>
<p>字段c长没有建索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1；</span><br></pre></td></tr></table></figure>
<p>id字段有索引，而且是快照读，按理说应该很快。但有时候可能执行的非常慢。</p>
<p>原因在于：在一个事务中，这个查询语句2次执行期间，如果该行数据被频繁更新，这样就导致unlog非常大，<br>因为是快照读，所以第二次查询需要：<code>根据当前值逐一应用undo log，直到查询到自己事务开始的版本</code>。</p>
<p>这种情况下，加锁读反而很快。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog.png">
<p>应用undo log。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog_1.png">
<h3 id="课后题-10"><a href="#课后题-10" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？</p>
<p>答案：</p>
<p>RC隔离级别：</p>
<p>所有扫描到的行都需要加锁，在返回到Server层后，会<code>提前释放</code>不满足条件的行锁。<br>原因是不需要解决幻读问题。</p>
<p>RR隔离解绑：</p>
<p>所有扫描到的行都需要加锁，行之间会添加间隙锁(gap锁)</p>
<h2 id="20讲-幻读是什么，幻读有什么问题？"><a href="#20讲-幻读是什么，幻读有什么问题？" class="headerlink" title="20讲 - 幻读是什么，幻读有什么问题？"></a>20讲 - 幻读是什么，幻读有什么问题？</h2><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/PhantomRead.png">
<h3 id="幻读定义"><a href="#幻读定义" class="headerlink" title="幻读定义"></a>幻读定义</h3><p>幻读指的是在一个事务中，前后2次查询同一个范围内的数据，第二次查询返回第一次查询没有看到的行的现象。</p>
<ol>
<li>在RR隔离级别下，普通的读是快照读，是不会看到别的事务插入的数据的。只有<code>当前读</code>才会出现幻读现象。</li>
<li>幻读仅专指<code>新插入的行</code>。</li>
</ol>
<h3 id="幻读的问题"><a href="#幻读的问题" class="headerlink" title="幻读的问题"></a>幻读的问题</h3><h3 id="语义的问题"><a href="#语义的问题" class="headerlink" title="语义的问题"></a>语义的问题</h3><p>破坏了sql语句的语义。</p>
<h4 id="数据一致性的问题"><a href="#数据一致性的问题" class="headerlink" title="数据一致性的问题"></a>数据一致性的问题</h4><img src="/2018/12/21/geektime-mysql-learn/PhantomReadConsitentProblem.png">
<p>binlog总SQL语句时序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session B</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"><span class="comment">-- session C</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"><span class="comment">-- session A</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure>
<p><em>注意</em>:事务提交时写入binlog。session A最后提交，所以最后写入binlog。</p>
<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>为了解决幻读问题，MySQL引入了间隙锁(Gap Lock)， 间隙锁锁的是2个值之间的空隙。</p>
<blockquote>
<p>跟间隙锁存在冲突关系的，是<code>往这个间隙中插入一个记录</code>这个操，两个间隙锁不冲突。<br>间隙锁和行锁合称:<code>next-key lock</code>, 每个 <code>next-key lock</code> 都是前开后闭区间<br>间隙锁的引入，导致锁定的范围更大，更容易引起死锁问题，同时影响并发度。<br>间隙锁只有在RR隔离级别下才生效，在生产环境中可以通过<code>RC</code>隔离级别 + <code>binlog format = row</code>的配置来解决数据不一致的问题。</p>
</blockquote>
<h3 id="课后题-11"><a href="#课后题-11" class="headerlink" title="课后题"></a>课后题</h3>
<p>session B 和 session C 都会阻塞，原因如下：</p>
<p>session A加的锁如下：</p>
<ol>
<li>由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</li>
<li>在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因。</li>
<li>在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 <code>select *</code>，所以会在主键 id 上加三个行锁。</li>
</ol>
<p>因此，session A 的 select 语句锁的范围就是：</p>
<ol>
<li>索引 c 上 (5, 25)；</li>
<li>主键索引上 id=10、15、20 三个行锁。</li>
</ol>
<h2 id="21-讲-为什么我只改一行的语句，锁这么多？"><a href="#21-讲-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 讲 为什么我只改一行的语句，锁这么多？"></a>21 讲 为什么我只改一行的语句，锁这么多？</h2><h3 id="加锁规则总结"><a href="#加锁规则总结" class="headerlink" title="加锁规则总结"></a>加锁规则总结</h3><h4 id="版本条件"><a href="#版本条件" class="headerlink" title="版本条件"></a>版本条件</h4><p>5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8….</p>
<h4 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h4><p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
<p>原则 2：查找过程中访问到的对象才会加锁。</p>
<p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
<p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
<p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo1.png">
<p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<p>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</p>
<p>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo2.png">
<p>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</p>
<p>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</p>
<p>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p>
<p>根据原则 2 ，<code>只有访问到的对象才会加锁</code>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</p>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>
<blockquote>
<p>需要注意，在这个例子中，<code>lock in share mode</code> 只锁覆盖索引，但是如果是 <code>for update</code> 就不一样了。 执行 <code>for update</code> 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
</blockquote>
<p>这个例子说明，<code>锁是加在索引上的</code>；同时，它给我们的指导是，如果你要用 <code>lock in share mode</code> 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 <code>select d from t where c=5 lock in share mode</code>。你可以自己验证一下效果。</p>
<h3 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure>
<p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo3.png">
<p>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</p>
<p>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo4.png">
<p>这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>
<p>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。</p>
<p>这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。</p>
<h3 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo5.png">
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h3 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6.png">
<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>
<p>这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6_1.png">
<p>这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>

<h3 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo7.png">
<p>这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。</p>
<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/bb0ad92483d71f0dcaeeef278f89cb24.png">
<p>这个例子对我们实践的指导意义就是，<code>在删除数据的时候尽量加 limit</code> 。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><p>前面的例子中，我们在分析的时候，是按照 next-key lock 的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。</p>

<p>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</p>
<p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</p>
<p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p>
<p>原因：session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。</p>
</blockquote>
<h2 id="22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><p>这些方案都是<code>剑走偏锋</code>的优化，或问题解决方案，紧急情况下可以使用。</p>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>大量的执行很少逻辑就断开的连接。导致短时间内连接数暴涨。</p>
<p><code>max_connections</code>控制总的连接数。MySQL负载很高时，再建立新的连接会加重负载，此时可以考虑下面的方法释放空闲的连接：</p>
<ol>
<li>通过<code>show processlist</code> + <code>infomation_schema.inno_trx</code>表查询空闲的连接，通过<code>kill connnection</code>关闭空闲连接。需要注意到是服务断开连接后，客户端不能马上感知，直到客户端执行下一个sql，客户端如果不进行重连就会导致问题。极端情况下可以kill掉处于事务中的空闲连接。</li>
<li>减少连接建立过程中的消耗。跳过权限验证，重启数据库，添加参数<code>–skip-grant-tables</code></li>
</ol>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><h3 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h3><ol>
<li>关闭从库的binlog功能</li>
<li>从库执行alter table, 添加索引，主从切换</li>
<li>原来的主库变为从库，进行同样的操作。</li>
</ol>
<p>平时的运维，应该优先使用<code>gh-ost</code>这个样的工具，紧急处理可以考虑上面的方案。</p>
<h3 id="SQL语句写的不好"><a href="#SQL语句写的不好" class="headerlink" title="SQL语句写的不好"></a>SQL语句写的不好</h3><p>mysql5.7提供了<code>query_rewrite</code>功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能使用索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"><span class="comment">-- 使新插入的规则生效</span></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure>
<h3 id="优化器选错索引"><a href="#优化器选错索引" class="headerlink" title="优化器选错索引"></a>优化器选错索引</h3><ol>
<li>通过上面提到的<code>query_rewrite</code>功能</li>
<li>修改SQL语句, <code>force index</code>强制使用指定的索引。</li>
</ol>
<h3 id="QPS-突增"><a href="#QPS-突增" class="headerlink" title="QPS 突增"></a>QPS 突增</h3><ol>
<li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成”select 1”返回。</li>
</ol>
<h2 id="23讲-MySQL是怎么保证数据不丢的？"><a href="#23讲-MySQL是怎么保证数据不丢的？" class="headerlink" title="23讲 - MySQL是怎么保证数据不丢的？"></a>23讲 - MySQL是怎么保证数据不丢的？</h2><h3 id="binlog写入机制"><a href="#binlog写入机制" class="headerlink" title="binlog写入机制"></a>binlog写入机制</h3><p>事务执行过程中，binlog先写入binlog cache, 事务提交时，写入binlog 文件。</p>
<p>一个事务的binlog不能被拆分写入，必须一次性写入。</p>
<p><code>binlog_cache_size</code>设置每个线程占用的binlog缓存大小。</p>
<h3 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h3><ol>
<li>sync_binlog = 0 只写入文件page cache</li>
<li>sync_binlog = 1 每次事务提交都进行fsync操作</li>
<li>sync_binlog &gt; 1(N) 每次事务提交都写文件，但是N次以后进行一次fsync</li>
</ol>
<h3 id="redo-log-写入机制"><a href="#redo-log-写入机制" class="headerlink" title="redo log 写入机制"></a>redo log 写入机制</h3><p>事务执行过程中，会不断的将redo log写入redo log cache中。</p>
<p>innodb的后台线程会每秒（<code>write + fsync</code>）或每10秒（<code>write + fsync</code>），或者当redo log cache的剩余空间小于50%时，将缓存中的日志写入文件（<code>write</code>）, 或者其他事务提交时，将未提交事务的redo log写入文件。</p>
<p>所以没有提交事务的redo log也会被写入文件, 由此可知：innodb在大事务下，提交也是非常快的。</p>
<p><code>innodb_flush_log_at_trx_commit</code>参考控制事务提交时，redo log以哪种机制写入日志文件。</p>
<ol>
<li><code>innodb_flush_log_at_trx_commit=0</code> 事务提交时，redo log保存在缓存中。</li>
<li><code>innodb_flush_log_at_trx_commit=1</code> 事务提交时，redo log写入刷新到文件。</li>
<li><code>innodb_flush_log_at_trx_commit=2</code> 事务提交时，写入page cache。</li>
</ol>
<p>redo log 和 binlog的文件写入操作遵循两阶段提交机制：当<code>innodb_flush_log_at_trx_commit=1</code><br>时，redo log 的prepare阶段就会磁盘，当binglog写入后，提交事务时，innodb不会进行fsync。</p>
<h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>LSN 是 log sequence number的缩写。它是单调递增的，用来表示redo log的一个个写入点，每次写入长度为length的redo log， LSN的值就会增加length。</p>
<p>组提交机制：三个事务都写完redo log处于prepare状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit.png">
<ol>
<li>trx 1 第一个到达，被选为leader</li>
<li>trx 1 开始写磁盘是，组内已经有3个事务了，此时LSN=160</li>
<li>trx 1 写磁盘时，保存的LSN就是160, 所有小于160的LSN都被持久到磁盘了。</li>
<li>trx2, trx3提交时，就不用再写磁盘了，直接返回。</li>
</ol>
<p>结论：</p>
<ol>
<li>一次组提交，组内成员越多，就能更好的节约磁盘IOPS。</li>
<li>并发场景下，第一个事务（Leader）执行fsync越晚，组员就越多，节约的磁盘IOPS就越多。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit_optimize.png">
<p><code>binlog_group_commit_sync_delay</code> 参数表示延迟多少微妙后才调用fsync。</p>
<p><code>binlog_group_commit_sync_no_dely</code> 参数表示累积多少次后才调用fsync。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>如果线上MySQL有I/O瓶颈，可以暂时修改这些参数，提高性能。但需要注意丢失数据的风险。</p>
<h3 id="课后题-哪些场景可以将MySQL设置为非双1模式"><a href="#课后题-哪些场景可以将MySQL设置为非双1模式" class="headerlink" title="课后题 - 哪些场景可以将MySQL设置为非双1模式"></a>课后题 - 哪些场景可以将MySQL设置为非双1模式</h3><ol>
<li>可知的业务高峰期。</li>
<li>备库延迟</li>
<li>用备份恢复主库的副本，应用binlog的过程。</li>
<li>批量数据导入。</li>
</ol>
<h2 id="24讲-MySQL是怎么保证主备一致的？"><a href="#24讲-MySQL是怎么保证主备一致的？" class="headerlink" title="24讲 - MySQL是怎么保证主备一致的？"></a>24讲 - MySQL是怎么保证主备一致的？</h2><h3 id="MySQL主备基本原理"><a href="#MySQL主备基本原理" class="headerlink" title="MySQL主备基本原理"></a>MySQL主备基本原理</h3><p>MySQL主备切换流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave.png">
<h4 id="备库设置为readonly建议"><a href="#备库设置为readonly建议" class="headerlink" title="备库设置为readonly建议"></a>备库设置为readonly建议</h4><ol>
<li>运营的统计查询需要一半在备库执行，设置为readonly可以防止误操作。</li>
<li>防止主从切换逻辑bug,导致双master。</li>
<li>用readonly判断主从角色。</li>
</ol>
<p>从库虽然是readonly，但是由于同步更新线程拥有super权限，所以readonly的设置对同步更新是无效的。</p>
<p>MySQL主备执行流程</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave_diagram.png">
<ol>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p>最新的版本：sql_thread 演化成为了多个线程。</p>
</blockquote>
<h3 id="binlog三种格式"><a href="#binlog三种格式" class="headerlink" title="binlog三种格式"></a>binlog三种格式</h3><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>记录的是原始的SQL语句。格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<p>statement 有可能导致主从数据不一致。原因在于，同样的语句，在主从库上执行时，会因为索引选择不同，导致最终的执行结果不同。</p>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<h4 id="mix-statement-row"><a href="#mix-statement-row" class="headerlink" title="mix = statement + row"></a>mix = statement + row</h4><p>statement 格式的binlog会导致主从数据不一致，优点是：占用空间小。row格式不会导致主从不一致，但是占用空间大。所有就有了mix这种格式。MySQL会自动判断SQL语句，不影响主从一致的SQL使用statement,其他的使用row格式。</p>
<h3 id="binlog-格式最佳实践"><a href="#binlog-格式最佳实践" class="headerlink" title="binlog 格式最佳实践"></a>binlog 格式最佳实践</h3><p>推荐使用<code>row</code>格式。</p>
<ol>
<li>数据恢复，binlog里面包含了所有的信息，可以恢复误操作影响的数据。</li>
<li>基于binlog进行业务消息处理。</li>
</ol>
<h3 id="查看binlog"><a href="#查看binlog" class="headerlink" title="查看binlog"></a>查看binlog</h3><p>确定正在写入的binlog文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的binlog文件</span></span><br><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000607</span><br><span class="line">         Position: 226668235</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看指定binlog文件的内容语法：</p>
<blockquote>
<p>SHOW BINLOG EVENTS [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count]</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINLOG EVENTS IN 'mysql-bin.000607'  limit 1 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   Log_name: mysql-bin.000607</span><br><span class="line">        Pos: 4</span><br><span class="line"> Event_type: Format_desc</span><br><span class="line">  Server_id: 132656183</span><br><span class="line">End_log_pos: 120</span><br><span class="line">       Info: Server ver: 5.6.26-log, Binlog ver: 4</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看远程服务器上的binlog</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -ubosstest -p -P6183 -hbj.bosstest.w.qiyi.db <span class="comment">--start-datetime='2019-01-15 16:38:00' --stop-datetime='2019-01-15 16:40:00' --read-from-remote-server -vv mysql-bin.000607 &gt; row.sql</span></span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#190115 16:53:34 server id 132656183  end_log_pos 231732483 CRC32 0x2792c369 	Table_map: `autorenew`.`boss_dut_user_new_00` mapped to number 110965745</span></span><br></pre></td></tr></table></figure>
<h3 id="循环复制"><a href="#循环复制" class="headerlink" title="循环复制"></a>循环复制</h3><p>循环复制指的是，双Master架构下，B库重放了主库A的binlog,同时产生了binlog，B库的binlog又被主库A执行的情况。</p>
<p>解决办法如下：</p>
<ol>
<li>binlog中有server_id</li>
<li>每个数据库的server_id都需要设置不同。</li>
<li>当接收到和自己server_id相同的binlog，不执行。</li>
</ol>
<h2 id="25讲-MySQL是如何保证高可用的？"><a href="#25讲-MySQL是如何保证高可用的？" class="headerlink" title="25讲 - MySQL是如何保证高可用的？"></a>25讲 - MySQL是如何保证高可用的？</h2><h3 id="查询主从延迟时间"><a href="#查询主从延迟时间" class="headerlink" title="查询主从延迟时间"></a>查询主从延迟时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<h3 id="主从延迟原因"><a href="#主从延迟原因" class="headerlink" title="主从延迟原因"></a>主从延迟原因</h3><ol>
<li>主从机器配置不对等。</li>
<li>从库压力过大（大量的查询和统计查询）。可以通过多个从库和离线统计解决</li>
<li>大事务。 事务的binlog不能拆分，大事务执行时间长，从库执行大事务耗费同样的时间，由于是单线程，主库最新的更新不能及时同步到从库。</li>
</ol>
<h3 id="主从切换-高可靠"><a href="#主从切换-高可靠" class="headerlink" title="主从切换 - 高可靠"></a>主从切换 - 高可靠</h3><p>因为主从可能存在延迟，所以直接进行切换就会导致数据不一致的情况发生。实践中为了保证数据的一致性，可以使用如下的步骤：</p>
<ol>
<li>判断从库的延迟时间小于一个阈值，例如5s.</li>
<li>把主库改为readonly。</li>
<li>等待2个库数据一致。</li>
<li>从库改为可写。</li>
<li>业务请求切换到新的主库。</li>
</ol>
<h3 id="主从切换-高可用"><a href="#主从切换-高可用" class="headerlink" title="主从切换 - 高可用"></a>主从切换 - 高可用</h3><p>有时候主从的切换不是我们能计划的。例如主库突然down机。此时，为了尽快恢复业务，必须进行切换了。只能事后进行数据一致性恢复操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL的高可用，高度依赖主从的延迟。所以实践中尽力保证主从的延迟一直保持在一个非常小的时间范围内。</p>
<h3 id="课后题-12"><a href="#课后题-12" class="headerlink" title="课后题"></a>课后题</h3><p>什么情况下，备库的主备延迟会表现为一个 45 度的线段？</p>
<p>原因是：备库的同步在这段时间完全被堵住了。</p>
<ul>
<li>一种是大事务（包括大表 DDL、一个事务操作很多行）；</li>
<li>还有一种情况比较隐蔽，就是备库起了一个长事务，比如<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后就不动了。(获取了MDL读锁)</p>
<p>这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在备库应用的时候也会被堵住（获取MDL写锁时被阻塞），也能看到这个现象。</p>
<h2 id="26讲-备库为什么会延迟好几个小时？"><a href="#26讲-备库为什么会延迟好几个小时？" class="headerlink" title="26讲 - 备库为什么会延迟好几个小时？"></a>26讲 - 备库为什么会延迟好几个小时？</h2><p>备库的延迟是机制上导致，主库是并发执行，从库只有一个线程进行重放，延迟可以说是不可避免的。为此各大公司和MySQL官方开发了并行复制功能。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_parall_binlog.png">
<ol>
<li>原来的SQL线程变为协调线程，服务事件的分发。</li>
<li>多个SQL线程进行事件执行。</li>
</ol>
<h3 id="coordinator-分发原则"><a href="#coordinator-分发原则" class="headerlink" title="coordinator 分发原则"></a>coordinator 分发原则</h3><ol>
<li>不能造成更新覆盖。更新同一行的事务必须分发到同一个worker线程。</li>
<li>同一个事务不能被拆开，必须放到同一个worker线程中。 </li>
</ol>
<h3 id="按表分发"><a href="#按表分发" class="headerlink" title="按表分发"></a>按表分发</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图 3 所示，就是按表分发的规则。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_binlog_table.png">
<p>可以看到，每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是<code>库名.表名</code>，value 是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。</p>
<h4 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h4><ol>
<li>由于事务 T 中涉及修改表 t1，而 worker_1 队列中有事务在修改表 t1，事务 T 和队列中的某个事务要修改同一个表的数据，这种情况我们说事务 T 和 worker_1 是冲突的。</li>
<li>按照这个逻辑，顺序判断事务 T 和<code>每个worker</code> 队列的冲突关系，会发现事务 T 跟 worker_2 也冲突。</li>
<li>事务 T 跟多于一个 worker 冲突，coordinator 线程就进入等待。</li>
<li>每个 worker 继续执行，同时修改 hash_table。假设 hash_table_2 里面涉及到修改表 t3 的事务先执行完成，就会从 hash_table_2 中把 db1.t3 这一项去掉。</li>
<li>这样 coordinator 会发现跟事务 T 冲突的 worker 只有 worker_1 了，因此就把它分配给 worker_1。</li>
<li>coordinator 继续读下一个中转日志，继续分配事务。</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：<code>如果两个事务没有更新相同的行，它们在备库上可以并行执行</code>。显然，这个模式要求 binlog 格式必须是 row。</p>
<p>这时候，我们判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是<code>库名 + 表名 + 唯一键的值</code>。</p>
<p>但是，这个“唯一键”只有主键 id 还是不够的，我们还需要考虑下面这种场景，表 t1 中除了主键，还有唯一索引 a：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_row_conflict.png">
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 session B 的语句先执行。这时候 id=1 的行的 a 的值还是 1，就会报唯一键冲突。</p>
<p>因此，基于行的策略，事务 hash 表中还需要考虑唯一键，即 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。</p>
<p>比如，在上面这个例子中，我要在表 t1 上执行 <code>update t1 set a=1 where id=2</code> 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p>
<p>因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
<p>可见<code>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源</code>。你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ol>
<p>但，好在这三条约束规则，本来就是 DBA 之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p>
<p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li>
<li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li>
</ol>
<p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p>
<ol>
<li>coordinator 暂时先 hold 住这个事务；</li>
<li>等待所有 worker 都执行完成，变成空队列；</li>
<li>coordinator 直接执行这个事务；</li>
<li>恢复并行模式。</li>
</ol>
<p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的 hash 表里，key 就是数据库名。</p>
<p>这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。</p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<p>但是，如果你的主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p>
<p>理论上你可以创建不同的 DB，把相同热度的表均匀分到这些不同的 DB 中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><p>在 <a href="https://time.geekbang.org/column/article/76161" target="_blank" rel="noopener">https://time.geekbang.org/column/article/76161</a> 中，我给你介绍了 redo log 组提交 (group commit) 优化， 而 MariaDB 的并行复制策略利用的就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB 是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析 binlog，并拆分到 worker”上。而 MariaDB 的这个策略，目标是“模拟主库的并行模式”。</p>
<p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在 commit 的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>如图 5 所示，假设了三组事务在主库的执行情况，你可以看到在 trx1、trx2 和 trx3 提交的时候，trx4、trx5 和 trx6 是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入 commit 状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/8fec5fb48d6095aecc80016826efbfc3.png">
<p>而按照 MariaDB 的并行复制策略，备库上的执行效果如图 6 所示。</p>
<img src="/2018/12/21/geektime-mysql-learn/8ac3799c1ff2f9833619a1624ca3e622.png">
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p>
<p>另外，这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在备库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间，只有一个 worker 线程在工作，是对资源的浪费。</p>
<p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>在 MariaDB 并行复制实现之后，官方的 MySQL5.7 版本也提供了类似的功能，由参数 slave-parallel-type 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略。不过，MySQL 5.7 这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li>
</ol>
<p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p>
<p>答案是，不能。</p>
<p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的 worker，就会出现备库跟主库不一致的情况。</p>
<p>而上面提到的 MariaDB 这个策略的核心，是“所有处于 commit”状态的事务可以并行。事务处于 commit 状态，表示已经通过了锁冲突的检验了。</p>
<p>这时候，你可以再回顾一下两阶段提交:</p>
<img src="/2018/12/21/geektime-mysql-learn/5ae7d074c34bc5bd55c82781de670c28.png">
<p>其实，不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁冲突的检验了。</p>
<p>因此，MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<p>我在第 23 篇文章，讲 binlog 的组提交的时候，介绍过两个参数：</p>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>这两个参数是用于故意拉长 binlog 从 write 到 fsync 的时间，以此减少 binlog 的写盘次数。在 MySQL 5.7 的并行复制策略里，它们可以用来制造更多的“同时处于 prepare 阶段的事务”。这样就增加了备库复制的并行度。</p>
<p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在 MySQL 5.7 处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<h3 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h3><p>在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。</p>
<p>相应地，新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p>
<ol>
<li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p>当然为了唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。</p>
<p>你可能看出来了，这跟我们前面介绍的基于 MySQL 5.5 版本的按行分发的策略是差不多的。不过，MySQL 官方的这个实现还是有很大的优势：</p>
<p>因此，MySQL 5.7.22 的并行复制策略在通用性上还是有保证的。</p>
<p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h3 id="课后题-13"><a href="#课后题-13" class="headerlink" title="课后题"></a>课后题</h3><p>如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p>
<p>这个问题的答案是，应该将这个参数设置为 WRITESET。</p>
<p>由于主库是单线程压力模式，所以每个事务的 commit_id 都不同，那么设置为 COMMIT_ORDER 模式的话，从库也只能单线程执行。</p>
<p>同样地，由于 WRITESET_SESSION 模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p>
<p>所以，应该将 binlog-transaction-dependency-tracking 设置为 WRITESET。</p>
<h2 id="27-主库出问题了，从库怎么办？"><a href="#27-主库出问题了，从库怎么办？" class="headerlink" title="27 - 主库出问题了，从库怎么办？"></a>27 - 主库出问题了，从库怎么办？</h2><p>大多数的互联网应用场景都是读多写少，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题的常用架构是：一主多从。</p>
<p>下图是典型的一主多从架构：</p>
<img src="/2018/12/21/geektime-mysql-learn/aadb3b956d1ffc13ac46515a7d619e79.png">
<p>图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<p>如下图所示，就是主库发生故障，主备切换后的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/0014f97423bd75235a9187f492fb2453.png">
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>
<p>这条命令有这么 6 个参数：</p>
<ol>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ol>
<p>那么，这里就有一个问题了，节点 B 要设置成 A’的从库，就要执行 change master 命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？</p>
<p>原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，<code>A 的位点和 A’的位点是不同的</code>。因此，从库 B 要切换的时候，就需要先经过<code>找同步位点</code>这个逻辑。</p>
<p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p>
<p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p>
<p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个<code>稍微往前</code>的，然后再通过判断<code>跳过那些在从库B上已经执行过的事务</code>。</p>
<p>一种取同步位点的方法是这样的：</p>
<ol>
<li>等待新主库 A’把中转日志（relay log）全部同步完成；</li>
<li>在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；</li>
<li>取原主库 A 故障的时刻 T；</li>
<li>用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/3471dfe4aebcccfaec0523a08cdd0ddd.png">
<p>图中，end_log_pos 后面的值“123”，表示的就是 A’这个实例，在 T 时刻写入新的 binlog 的位置。然后，我们就可以把 123 这个值作为 $master_log_pos ，用在节点 B 的 change master 命令里。</p>
<p>当然这个值并不精确。为什么呢？</p>
<p>你可以设想有这么一种情况，假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。</p>
<p>那么，这时候系统的状态是这样的：</p>
<ol>
<li>在从库 B 上，由于同步了 binlog， R 这一行已经存在；</li>
<li>在新主库 A’上， R 这一行也已经存在，日志是写在 123 这个位置之后的；</li>
<li>我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</li>
</ol>
<p>这时候，从库 B 的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p>
<p>所以：通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</p>
<p>一种做法是，主动跳过一个事务。跳过命令的写法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<p>另外一种方式是，通过设置 slave_skip_errors 参数，直接设置跳过指定的错误。</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ul>
<p>因此，我们可以把 slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p>
<p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
<p>这个背景是，我们很清楚在主备切换过程中，直接跳过 1032 和 1062 这两类错误是无损的，所以才可以这么设置 slave_skip_errors 参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<p>通过 sql_slave_skip_counter 跳过事务和通过 slave_skip_errors 忽略错误的方法，虽然都最终可以建立从库 B 和新主库 A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。</p>
<p>那么，GTID 到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p>
<p>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure>
<p>这里我需要和你说明一下，在 MySQL 的官方文档里，GTID 格式是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure>
<p>这里的 source_id 就是 server_uuid；而后面的这个 transaction_id，我觉得容易造成误导，所以我改成了 gno。为什么说使用 transaction_id 容易造成误解呢？</p>
<p>因为，在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配。</p>
<p>从效果上看，GTID 往往是连续的，因此我们用 gno 来表示更容易理解。</p>
<p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 gtid_mode=on 和 enforce_gtid_consistency=on 就可以了。</p>
<p>在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值。</p>
<ol>
<li>如果 gtid_next=automatic，代表使用默认值。这时，MySQL 就会把 server_uuid:gno 分配给这个事务。<br> a. 记录 binlog 的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;<br> b. 把这个 GTID 加入本实例的 GTID 集合。</li>
<li>如果 gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next=’current_gtid’指定为 current_gtid，那么就有两种可能：<br>a.  如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；<br>b.  如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。    </li>
</ol>
<p>注意，一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。</p>
<p>这样，每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。</p>
<p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明 GTID 的基本用法。</p>
<p>我们在实例 X 中创建一个表 t。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/28a5cab0079fb12fd5abecd92b3324c2.png">
<p>可以看到，事务的 BEGIN 之前有一条 SET @@SESSION.GTID_NEXT 命令。这时，如果实例 X 有从库，那么将 CREATE TABLE 和 insert 语句的 binlog 同步过去执行的话，执行事务之前就会先执行这两个 SET 命令， 这样被加入从库的 GTID 集合的，就是图中的这两个 GTID。</p>
<p>假设，现在这个实例 X 是另外一个实例 Y 的从库，并且此时在实例 Y 上执行了下面这条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>并且，这条语句在实例 Y 上的 GTID 是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p>
<p>那么，实例 X 作为 Y 的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例 X 的同步线程停止。这时，我们应该怎么处理呢？</p>
<p>处理方法就是，你可以执行下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next=<span class="string">'aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。如图 5 所示，就是执行完这个空事务之后的 show master status 的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/c8d3299ece7d583a3ecd1557851ed157.png">
<p>可以看到实例 X 的 Executed_Gtid_set 里面，已经加入了这个 GTID。</p>
<p>这样，我再执行 start slave 命令让同步线程执行起来的时候，虽然实例 X 上还是会继续执行实例 Y 传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例 X 的 GTID 集合中了，所以实例 X 就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<p>在上面的这个语句序列中，start slave 命令之前还有一句 set gtid_next=automatic。这句话的作用是“恢复 GTID 的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配 gno=3。</p>
<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><p>现在，我们已经理解 GTID 的概念，再一起来看看基于 GTID 的主备复制的用法。</p>
<p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>其中，master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。可以看到，前面让我们头疼不已的 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，已经不需要指定了。</p>
<p>我们把现在这个时刻，实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。接下来，我们就看看现在的主备切换逻辑。</p>
<p>我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li>实例 B 指定主库 A’，基于主备协议建立连接。</li>
<li>实例 B 把 set_b 发给主库 A’。</li>
<li>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GITD 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。<br> a.  如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；<br> b.  如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</li>
<li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。    </li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A’就拒绝把日志发给 B。</p>
<p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p>
<p>基于上面的介绍，我们再来看看引入 GTID 后，一主多从的切换场景下，主备切换是如何实现的。</p>
<p>由于不需要找位点了，所以从库 B、C、D 只需要分别执行 change master 命令指向实例 A’即可。</p>
<p>其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例 A’内部就已经自动完成了。但由于这个工作是自动的，所以对 HA 系统的开发人员来说，非常友好。</p>
<p>之后这个系统就由新主库 A’写入，主库 A’的自己生成的 binlog 中的 GTID 集合格式是：server_uuid_of_A’:1-M。</p>
<p>如果之前从库 B 的 GTID 集合格式是 server_uuid_of_A:1-N， 那么切换之后 GTID 集合的格式就变成了 server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p>
<p>当然，主库 A’之前也是 A 的备库，因此主库 A’和从库 B 的 GTID 集合是一样的。这就达到了我们预期。</p>
<h3 id="GTID-和在线-DDL"><a href="#GTID-和在线-DDL" class="headerlink" title="GTID 和在线 DDL"></a>GTID 和在线 DDL</h3><p>在《MySQL 有哪些“饮鸩止渴”提高性能的方法？》中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。   </p>
<p>当时我说，在双 M 结构下，备库执行的 DDL 语句也会传给主库，为了避免传回后对主库造成影响，要通过 set sql_log_bin=off 关掉 binlog。</p>
<p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是 binlog 并没有记录下这一个更新，是不是会导致数据和日志不一致？</p>
<p>这个问题提得非常好。当时，我在留言的回复中就引用了 GTID 来说明。今天，我再和你展开说明一下。</p>
<p>假设，这两个互为主备关系的库还是实例 X 和实例 Y，且当前主库是 X，并且都打开了 GTID 模式。这时的主备切换流程可以变成下面这样：</p>
<ol>
<li>在实例 X 上执行 stop slave。</li>
<li>在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。</li>
<li>执行完成后，查出这个 DDL 语句对应的 GTID，并记为 server_uuid_of_Y:gno。</li>
<li>到实例 X 上执行以下语句序列：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> GTID_NEXT=<span class="string">"server_uuid_of_Y:gno"</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做的目的在于，既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。 </p>
<ul>
<li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li>
</ul>
<h3 id="课后题-14"><a href="#课后题-14" class="headerlink" title="课后题"></a>课后题</h3><p>你在 GTID 模式下设置主从关系的时候，从库执行 start slave 命令后，主库发现需要的 binlog 已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p>
<p>答案如下:</p>
<ol>
<li>如果业务允许主从不一致的情况，那么可以在主库上先执行 show global variables like ‘gtid_purged’，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 reset master，再执行 set global gtid_purged =‘gtid_purged1’；最后执行 start slave，就会从主库现存的 binlog 开始同步。binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li>
<li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li>
<li>如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。</li>
<li>如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 start slave。</li>
</ol>
<h2 id="28讲-读写分离有哪些坑？"><a href="#28讲-读写分离有哪些坑？" class="headerlink" title="28讲 - 读写分离有哪些坑？"></a>28讲 - 读写分离有哪些坑？</h2><p>读写分离主要是为了分担主库的压力。有下面2中场景的架构</p>
<p>客户端直连：</p>
<img src="/2018/12/21/geektime-mysql-learn/1334b9c08b8fd837832fdb2d82e6b0aa.png">
<p>客户端通过proxy进行读写分离</p>
<img src="/2018/12/21/geektime-mysql-learn/065ef246c59019effc8384967d774318.png">
<ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</p>
<p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能 100% 避免的。</p>
<p>处理过期读的方案汇总</p>
<ul>
<li>强制走主库方案</li>
<li>sleep 方案</li>
<li>判断主备无延迟方案</li>
<li>配合 semi-sync 方案</li>
<li>等主库位点方案</li>
<li>等 GTID 方案</li>
</ul>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ul>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ul>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。</p>
<p>这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>要确保备库无延迟，通常有三种做法。</p>
<h4 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h4><p>我们知道 show slave status 结果里的 seconds_behind_master 参数的值，可以用来衡量主备延迟时间的长短。</p>
<img src="/2018/12/21/geektime-mysql-learn/00110923007513e865d7f43a124887c1.png">
<p>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
<p>seconds_behind_master 的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p>
<h4 id="对比位点确保主备无延迟："><a href="#对比位点确保主备无延迟：" class="headerlink" title="对比位点确保主备无延迟："></a>对比位点确保主备无延迟：</h4><ul>
<li>Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<h4 id="对比-GTID-集合确保主备无延迟："><a href="#对比-GTID-集合确保主备无延迟：" class="headerlink" title="对比 GTID 集合确保主备无延迟："></a>对比 GTID 集合确保主备无延迟：</h4><ul>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。    </p>
<p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p>
<p>我们现在一起来回顾下，一个事务的 binlog 在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入 binlog，并反馈给客户端；</li>
<li>binlog 被从主库发送给备库，备库收到；</li>
<li>在备库执行 binlog 完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/557445207b57d6c0f2747509d7d6619e.png">
<p>这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：</p>
<ul>
<li>trx1 和 trx2 已经传到从库，并且已经执行完成了；</li>
<li>trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ul>
<p>如果这时候你在从库 B 上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读。</p>
<p>那么，这个问题有没有办法解决呢？</p>
<p>配合 semi-sync</p>
<p>要解决这个问题，就要引入半同步复制，也就是 semi-sync replication。</p>
<p>semi-sync 做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p>在 第 25 篇文章 的评论区，有同学问到：如果主库掉电的时候，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？</p>
<p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。</p>
<p>这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ul>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ul>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p>
<p>为什么这么说呢？我们来看一下这个时序图。</p>
<img src="/2018/12/21/geektime-mysql-learn/9cf54f3e91dc8f7b8947d7d8e384aa09.png">
<p>图 5 所示，就是等待位点方案的一个 bad case。图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，图 5 中从状态 1 到状态 4，一直处于延迟一个事务的状态。</p>
<p>备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。</p>
<p>但是，其实客户端是在发完 trx1 更新后发起的 select 语句，我们只需要确保 trx1 已经执行完成就可以执行 select 语句了。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了。</p>
<p>到这里，我们小结一下，semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ul>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ul>
<p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>]);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑如下：</p>
<ul>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ul>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p>
<p>当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ul>
<p>对于图 5 中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ul>
<li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select master_pos_wait(File, Position, 1)；</li>
<li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<img src="/2018/12/21/geektime-mysql-learn/b20ae91ea46803df1b63ed683e1de357.png">
<p>这里我们假设，这条 select 查询最多在从库上等待 1 秒。那么，如果 1 秒内 master_pos_wait 返回一个大于等于 0 的整数，就确保了从库上执行的这个查询结果一定包含了 trx1 的数据。</p>
<p>步骤 5 到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p>
<p>你可能会说，如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p>
<p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><p>如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。</p>
<p>MySQL 中同样提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑是：</p>
<ul>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ul>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<p>这时，等 GTID 的执行流程就变成了：</p>
<ul>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li>
<li>如果返回值是 0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p>
<img src="/2018/12/21/geektime-mysql-learn/d521de8017297aff59db2f68170ee739.png">
<p>在上面的第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。问题是，怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？</p>
<p>你只需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可。</p>
<p>在专栏的第一篇文章中，我介绍 mysql_reset_connection 的时候，评论区有同学留言问这类接口应该怎么使用。</p>
<p>这里我再回答一下。其实，MySQL 并没有提供这类接口的 SQL 用法，是提供给程序的 API <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html</a></p>
<p>比如，为了让客户端在事务提交后，返回的 GITD 能够在客户端显示出来，我对 MySQL 客户端代码做了点修改，如下所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/973bdd8741f830acebe005cbf37a7663.png">
<p>这样，就可以看到语句执行完成，显示出 GITD 的值。</p>
<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用 mysql_session_track_get_first 这个函数。</p>
<h3 id="课后题-15"><a href="#课后题-15" class="headerlink" title="课后题"></a>课后题</h3><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等 GTID 的方案，现在你要对主库的一张大表做 DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p>
<p>答案：如果该DDL语句在主库执行了10min，那么提交后传到备库执行也需要10min。之后主库DDL后提交的事务的GTID，在备库查询时，需要等待10min才会出现，此时，所有的读请求都会路由到主库。</p>
<p>方法1：在业务低峰期进行，确保主库可以满足所有的查询压力，把所有的读请求都路由到主库上。等备库追上主库后切回来。<br>方法2：先在被库执行DDL，再将备库切换主库。</p>
<h2 id="29讲-如何判断一个数据库是不是出问题了？"><a href="#29讲-如何判断一个数据库是不是出问题了？" class="headerlink" title="29讲-如何判断一个数据库是不是出问题了？"></a>29讲-如何判断一个数据库是不是出问题了？</h2><h3 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h3><ul>
<li>主动切换</li>
<li>被动切换(HA系统发起)</li>
</ul>
<h3 id="主库健康检查"><a href="#主库健康检查" class="headerlink" title="主库健康检查"></a>主库健康检查</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select 1"></a>select 1</h4><p>只能判断MySQL进程存在</p>
<ul>
<li>innodb_thread_concurrency 控制innodb并发线程上限，超过该值的请求进入等待状态。 默认该值为0，表示不限制。</li>
<li>并发连接 != 并发查询(<code>innodb_thread_concurrency</code>)， show processlist查询的是并发连接</li>
<li>进入锁等待的线程不占用<code>innodb_thread_concurrency</code>的值。</li>
</ul>
<h4 id="查询表判断"><a href="#查询表判断" class="headerlink" title="查询表判断"></a>查询表判断</h4><p>创建一个表<code>health_check</code>，定时检查。</p>
<p>这种方法能检查因并发线程多导致系统不可用的情况。</p>
<h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>执行update语句，来判断是否有足够的磁盘来保证系统的正常运行（更新会写binlog和redo log，磁盘空间不足会导致所有的更新都阻塞）。</p>
<p>主备都需要做健康检查：</p>
<p>双M架构下，为了防止主备之间的更新冲突，<code>mysql.health_check</code>表插入多行数据，以<code>server_id</code>作为主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `health_check` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(<span class="keyword">id</span>, t_modified) <span class="keyword">values</span> (@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure>
<h3 id="外部检查的局限性"><a href="#外部检查的局限性" class="headerlink" title="外部检查的局限性"></a>外部检查的局限性</h3><p>上面提到的都是外部检查的实现方案。有一定的缺点：</p>
<ol>
<li>随机性。轮询进行健康检查，不能及时发现问题。</li>
<li>外部健康检查请求需要的资源少，能马上执行，但是其他业务请求不能正常处理。</li>
</ol>
<h3 id="内部检查"><a href="#内部检查" class="headerlink" title="内部检查"></a>内部检查</h3><p><code>performance_schema</code>里面有多个表，可以统计系统的健康状况。</p>
<h2 id="30讲-用动态的观点看加锁"><a href="#30讲-用动态的观点看加锁" class="headerlink" title="30讲 - 用动态的观点看加锁"></a>30讲 - 用动态的观点看加锁</h2><h2 id="31讲-误删数据库处理"><a href="#31讲-误删数据库处理" class="headerlink" title="31讲 - 误删数据库处理"></a>31讲 - 误删数据库处理</h2><h2 id="32讲-为什么还有kill不掉的语句"><a href="#32讲-为什么还有kill不掉的语句" class="headerlink" title="32讲 - 为什么还有kill不掉的语句"></a>32讲 - 为什么还有kill不掉的语句</h2><h2 id="33讲-我查这么多数据会不会把数据库打爆"><a href="#33讲-我查这么多数据会不会把数据库打爆" class="headerlink" title="33讲 - 我查这么多数据会不会把数据库打爆"></a>33讲 - 我查这么多数据会不会把数据库打爆</h2><h2 id="34讲-到底可不可以使用Join"><a href="#34讲-到底可不可以使用Join" class="headerlink" title="34讲 - 到底可不可以使用Join"></a>34讲 - 到底可不可以使用Join</h2><h2 id="35讲-join语句怎么优化"><a href="#35讲-join语句怎么优化" class="headerlink" title="35讲 - join语句怎么优化"></a>35讲 - join语句怎么优化</h2><h2 id="36讲-为什么临时表可以重名"><a href="#36讲-为什么临时表可以重名" class="headerlink" title="36讲 - 为什么临时表可以重名"></a>36讲 - 为什么临时表可以重名</h2><h2 id="37讲-什么时候会使用内部临时表"><a href="#37讲-什么时候会使用内部临时表" class="headerlink" title="37讲 - 什么时候会使用内部临时表"></a>37讲 - 什么时候会使用内部临时表</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>意思是取2个子查询结果的并集。</p>
<img src="/2018/12/21/geektime-mysql-learn/402cbdef84eef8f1b42201c6ec4bad4e.png">
<p><code>using temporary</code> 表示使用了临时表。</p>
<p>该语句的执行流程如下：</p>
<ol>
<li>创建一个只有一个整形字段<code>f</code>，且<code>f</code>是主键的临时表。</li>
<li>执行第一个子查询，得到1000这个值，插入到临时表中。</li>
<li>执行第二个子查询，得到1000插入临时表时，违反唯一性约束，失败，然后继续执行。</li>
<li>取第二行999，插入临时表成功。结束。</li>
<li>从临时表获取数据，返回给客户端，并删除临时表。</li>
</ol>
<p>可以看出：临时表使用来<code>暂存</code>数据的。</p>
<p>如果将<code>union</code>改为<code>union all</code>，没有去重语义，这样就依次执行子查询，将结果返回给客户端，不会使用到临时表。</p>
<img src="/2018/12/21/geektime-mysql-learn/c1e90d1d7417b484d566b95720fe3f6d.png">
<h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>该语句的逻辑是，将表中的数据按<code>1d%10</code>后的结果进行分组统计，然后按<code>m</code>的结果排序后输出。</p>
<img src="/2018/12/21/geektime-mysql-learn/3d1cb94589b6b3c4bb57b0bdfa385d98.png">
<p>从explain的结果可以知道：</p>
<ol>
<li>Using index, 表示使用了覆盖索引，选择了索引a， 不需要回表。</li>
<li>Using temporary，表示使用了临时表。</li>
<li>Using filesort，表示使用了文件排序。</li>
</ol>
<p>语句执行流程如下：</p>
<ol>
<li>创建一个临时表，包含字段 <code>m</code> 和 <code>c</code>, 主键是<code>m</code>。</li>
<li>扫描索引<code>a</code>，依次取出叶子节点上的id值，计算<code>id%10</code>的结果，记为x。</li>
<li>如果临时表中没有主键为x的行，则插入(x, 1)；如果存在，则对x行的c列加一。</li>
<li>遍历<code>索引a</code>完成后，对临时表按<code>m</code>进行排序，得到的结果输出给客户端。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/0399382169faf50fc1b354099af71954.jpg">
<p>内存临时表的排序如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/b5168d201f5a89de3b424ede2ebf3d68.jpg">
<blockquote>
<p>注意：如果不需要对结果进行排序，可以在语句后面添加<code>order by null</code>来取消排序过程。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>内存临时表的大小由<code>tmp_table_size</code>来设置(默认是16M)，如果数据量很大，不能全部保存在内存临时表中，此时就会使用磁盘临时表。磁盘临时表使用的是Innodb存储引擎。</p>
<h3 id="group-by的优化方法-索引"><a href="#group-by的优化方法-索引" class="headerlink" title="group by的优化方法 - 索引"></a>group by的优化方法 - 索引</h3><p>不论是内存临时表还是磁盘临时表，都需创建一个带有主键的临时表。</p>
<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>
<p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p>
<p>假设，现在有一个类似图 10 的这么一个数据结构，我们来看看 group by 可以怎么做。</p>
<img src="/2018/12/21/geektime-mysql-learn/5c4a581c324c1f6702f9a2c70acddd19.jpg">
<p>可以看到，如果可以确保输入的数据是有序的，那么计算 <code>group by</code> 的时候，就只需要从左到右，顺序扫描，依次累加。</p>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 <code>group by</code> 的结果，不需要临时表，也不需要再额外排序。</p>
<p>InnoDB 的索引，就可以满足这个输入有序的条件。</p>
<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="built_in">int</span> <span class="keyword">generated</span> <span class="keyword">always</span> <span class="keyword">as</span>(<span class="keyword">id</span> % <span class="number">100</span>), <span class="keyword">add</span> <span class="keyword">index</span>(z);</span><br></pre></td></tr></table></figure>
<p>这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by 语句就可以改成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>

<h3 id="group-by-优化方法-–-直接排序"><a href="#group-by-优化方法-–-直接排序" class="headerlink" title="group by 优化方法 – 直接排序"></a>group by 优化方法 – 直接排序</h3><p>如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的 group by 要怎么优化呢？</p>
<p>如果我们明明知道，一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p>
<p>在 group by 语句中加入 <code>SQL_BIG_RESULT</code> 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>
<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<p>下面语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_BIG_RESULT</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ul>
<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；    </li>
<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>
<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>基于上面的 union、union all 和 group by 语句的执行过程的分析，我们来回答文章开头的问题：MySQL 什么时候会使用内部临时表？</p>
<ul>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>
</ul>
<h2 id="38讲-都说InnoDB好，那还要不要使用Memory引擎？"><a href="#38讲-都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="38讲 - 都说InnoDB好，那还要不要使用Memory引擎？"></a>38讲 - 都说InnoDB好，那还要不要使用Memory引擎？</h2><p>Innodb引擎 </p>
<img src="/2018/12/21/geektime-mysql-learn/4e29e4f9db55ace6ab09161c68ad8c8d.jpg">
<p>Memory引擎</p>
<p>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。我们来看一下表 t1 中的数据内容。</p>
<img src="/2018/12/21/geektime-mysql-learn/dde03e92074cecba4154d30cd16a9684.jpg">
<p>可以看到，内存表的<code>数据部分以数组</code>的方式单独存放，而主键 id 索引里，存的是每个<code>数据的位置</code>。主键 id 是 <code>hash</code> 索引，可以看到索引上的 <code>key 并不是有序的</code>。</p>
<ol>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>
<li>而 Memory 引擎采用的是把数据单独存放，索引上保存<code>数据位置</code>的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>
</ol>
<p>从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<p>需要指出的是，表 t1 的这个主键索引是哈希索引，因此如果执行范围查询，比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>是用不上主键索引的，需要走全表扫描。</p>
<h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p>实际上，内存表也是支 B-Tree 索引的。在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">index</span> a_btree_index <span class="keyword">using</span> btree (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<p>这时，表 t1 的数据组织形式就变成了这样：</p>
<img src="/2018/12/21/geektime-mysql-learn/1788deca56cb83c114d8353c92e3bde3.jpg">
<p>不建议你在生产环境上使用内存表，原因如下：</p>
<ul>
<li>锁粒度问题；</li>
<li>数据持久化问题。</li>
</ul>
<h3 id="内存表的锁"><a href="#内存表的锁" class="headerlink" title="内存表的锁"></a>内存表的锁</h3><p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>
<h3 id="数据持久性问题"><a href="#数据持久性问题" class="headerlink" title="数据持久性问题"></a>数据持久性问题</h3><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p>
<p>在高可用架构下，稳定性很差，可能发生主从库的数据都被情况的异常。</p>
<p>重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>
<blockquote>
<p>建议你把普通内存表都用 InnoDB 表来代替。<br>基于内存表的特性，它的一个适用场景，就是内存临时表。内存表支持 hash 索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p>
</blockquote>
<h2 id="自增主键为什么不是连续的"><a href="#自增主键为什么不是连续的" class="headerlink" title="自增主键为什么不是连续的?"></a>自增主键为什么不是连续的?</h2><ol>
<li>不同引擎自增主键的值保存在不同的地方。</li>
<li>Memory 保存在数据文件中</li>
<li>MySQL8.0之前保存在内存中，重启会丢失。8.0开始保存在redo log 中。</li>
</ol>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><ol>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p>新的自增值生成算法是：</p>
<blockquote>
<p>从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p>
</blockquote>
<p>其中，auto_increment_offset 和 auto_increment_increment 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。</p>
<blockquote>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双 M 的主备结构里要求双写的时候，我们就可能会设置成 auto_increment_increment=2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。</p>
</blockquote>
<p>当 auto_increment_offset 和 auto_increment_increment 都是 1 的时候，新的自增值生成逻辑很简单，就是：</p>
<ul>
<li>如果准备插入的值 &gt;= 当前自增值，新的自增值就是“准备插入的值 +1”；</li>
<li>否则，自增值不变。</li>
</ul>
<h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p>假设，表 t 里面已经有了 (1,1,1) 这条记录，这时我再执行一条插入数据命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1);</li>
<li>InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；</li>
<li>将传入的行的值改成 (2,1,1);</li>
<li>将表的自增值改成 3；</li>
<li>继续执行插入数据操作，由于已经存在 c=1 的记录，所以报 Duplicate key error，语句返回。</li>
</ol>
<p>可以看到，这个表的自增值改成 3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键 c 冲突，所以 id=2 这一行并没有插入成功，<code>但也没有将自增值再改回去</code>。</p>
<blockquote>
<p>唯一键冲突是导致自增主键 id 不连续的第一种原因。<br>事务回滚也会产生类似的现象，这就是第二种原因。</p>
</blockquote>
<p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表 t 的自增值改回去呢？如果把表 t 的当前自增值从 3 改回 2，再插入新数据的时候，不就可以生成 id=2 的一行数据了吗？</p>
<p>其实，MySQL 这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看</p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<ol>
<li>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</li>
<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</li>
<li>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</li>
<li>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。</p>
<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>可以看到，自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在 MySQL 5.1 版本之前，并不是这样的。</p>
<p>在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p>
<p>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p>
<ol>
<li>这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为 1 时：<ul>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
<li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。    </li>
</ol>
<p>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是 2？</p>
<p>答案是，这么设计还是为了数据的一致性。</p>
<p>我们一起来看一下这个场景：</p>
<img src="/2018/12/21/geektime-mysql-learn/e0a69e151277de54a8262657e4ec89df.png">
<p>你可以设想一下，如果 session B 是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>你可能会说，这也没关系吧，毕竟 session B 的语义本身就没有要求表 t2 的所有行的数据都跟 session A 相同。</p>
<p>是的，从数据逻辑上看是对的。但是，如果我们现在的 binlog_format=statement，你可以设想下，binlog 会怎么记录呢？</p>
<p>由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t2 的更新日志只有两种情况：要么先记 session A 的，要么先记 session B 的。</p>
<p>但不论是哪一种，这个 binlog 拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B 这个语句执行出来，生成的结果里面，id 都是连续的。这时，这个库就发生了数据不一致。</p>
<p>原因在于原库 session B 的 insert 语句，生成的 id 不连续。这个不连续的 id，用 statement 格式的 binlog 来串行执行，是执行不出来的。</p>
<p>而要解决这个问题，有两种思路：</p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。</li>
</ol>
<p>因此，在生产上，尤其是有 insert … select 这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row. 这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>需要注意的是，我这里说的，批量插入数据，包含的语句类型是 insert … select、replace … select 和 load data 语句。</p>
<p>但是，在普通的 insert 语句里面包含多个 value 值的情况下，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为<code>不知道要预先申请多少个 id</code>。</p>
<p>既然预先不知道要申请多少个自增 id，那么一种直接的想法就是需要一个时申请一个。但如果一个 select … insert 语句要插入 10 万行数据，按照这个逻辑的话就要申请 10 万次。显然，这种申请自增 id 的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p>
<p>因此，对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ul>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>insert…select，实际上往表 t2 中插入了 4 行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了 id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。</p>
<p>由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7 就被浪费掉了。之后，再执行 insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p>
<blockquote>
<p>这是主键 id 出现自增 id 不连续的第三种原因。</p>
</blockquote>
<h3 id="课后题-16"><a href="#课后题-16" class="headerlink" title="课后题"></a>课后题</h3><p>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。</p>
<p>答案：</p>
<h2 id="40-讲-insert语句的锁为什么这么多？"><a href="#40-讲-insert语句的锁为什么这么多？" class="headerlink" title="40 讲 insert语句的锁为什么这么多？"></a>40 讲 insert语句的锁为什么这么多？</h2><h2 id="41讲-怎么快速复制一张表？"><a href="#41讲-怎么快速复制一张表？" class="headerlink" title="41讲 - 怎么快速复制一张表？"></a>41讲 - 怎么快速复制一张表？</h2><p>如果可以控制对源表的扫描行数和加锁范围很小的话，可以简单的使用<code>insert select</code> 语句实现。</p>
<p>如果需要避免对源表加锁，稳妥的解决办法是将数据保存到临时文件中，然后再写入目标表。此时有两种办法如下：</p>
<p>创建表 db1.t:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></table></figure>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>将db1.t表中的&gt;900的数据导出到文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">--add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ol>
<li>–single-transaction 意思是导出数据的是，不需要对db1.t加表锁，而是使用<code>start transaction with consitent snapshot</code>方法。</li>
<li>–add-locks 设置为0，表示在输出的文件中，不增加<code>lock tables t write</code></li>
<li>–no-create-info 表示不要导出表结构</li>
<li>–set-gtid-purged=OFF 表示不要输出和gtid相关的信息</li>
<li>–result-file 指定数据文件的路径，client表示文件位于客户端机器上。</li>
</ol>
<p>输出的文件内存是<code>insert values (...),(...)</code>格式，目的是为了加快执行速度。</p>
<p>可以通过参数<code>--skip-extended-insert</code>变为一个个的insert语句。</p>
<p>通过下面的语句将数据导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"</span><br></pre></td></tr></table></figure>
<h3 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>该语句的结果是保存在服务端的。</li>
<li>into outfile指定了文件的位置，这个位置必须受参数<code>secure_file_priv</code>限制。1，设置为empty表示不限制(不安全)。2,如果是一个表示路径的字符串，表示只能保存在这个目录。3,设置为NULL表示禁止执行该操作。</li>
<li>该命令不会帮你覆盖已经存在的文件。</li>
<li>原则上一行数据对应文本中的一行，但是字段值有换行符，文本中也会包含换行符，但是会被转义。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure>
<p>执行流程如下：</p>
<ol>
<li>打开文件，以制表符<code>\t</code>作为字段值得分隔符，以换行符<code>\n</code>作为记录之间的分隔符进行数据读取。</li>
<li>启动事务。</li>
<li>判断每一行的字段数和目标表是否相同，不相同就会报错，事务回滚。相同，构造一行数据，调用存储引擎接口写入表中。</li>
<li>重复步骤3，直到读完整个文件。提交事务。</li>
</ol>
<p>从库：</p>
<ol>
<li>主库执行完成后，将导出的文件<code>/server_tmp/t.csv</code>内容直接写入binlog。</li>
<li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li>
<li>把这个 binlog 日志传到备库。</li>
<li>备库的 apply 线程在执行这个事务日志时：<br> a. 先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；<br> b. 再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li>
</ol>
<p>整个执行流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/3a6790bc933af5ac45a75deba0f52cfd.jpg">
<p>注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。</p>
<p>也就是说，load data 命令有两种用法</p>
<ul>
<li>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</li>
<li>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。</li>
</ul>
<p>另外需要注意的是，select …into outfile 方法不会生成表结构文件, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=$secure_file_priv</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在 <code>$secure_file_priv</code> 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p>
<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>前面我们提到的 mysqldump 方法和导出 CSV 文件的方法，都是逻辑导数据的方法，也就是将数据从表 db1.t 中读出来，生成文本，然后再写入目标表 db2.t 中。</p>
<p>你可能会问，有物理导数据的方法吗？比如，直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下，是否可行呢？</p>
<p>答案是不行的。</p>
<p>因为，一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的。</p>
<p>不过，在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<p>流程如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/2407737651cdc1f5d6ade4d8907e7c05.jpg">
<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol>
<li>在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；</li>
<li>在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 t.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是对极客时间专栏&lt;a href=&quot;https://time.geekbang.org/column/139&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL实战45讲&lt;/a&gt; 文章内容和讨论区内容的总结。&lt;/p&gt;
&lt;h2 id=&quot;第一讲-基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;a href=&quot;#第一讲-基础架构：一条SQL查询语句是如何执行的？&quot; class=&quot;headerlink&quot; title=&quot;第一讲 基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;/a&gt;第一讲 基础架构：一条SQL查询语句是如何执行的？&lt;/h2&gt;&lt;h3 id=&quot;mysql-架构&quot;&gt;&lt;a href=&quot;#mysql-架构&quot; class=&quot;headerlink&quot; title=&quot;mysql 架构&quot;&gt;&lt;/a&gt;mysql 架构&lt;/h3&gt;&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/mysql_arch.png&quot;&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 可以分为 Server 层和存储引擎层两部&lt;/li&gt;
&lt;li&gt;Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。&lt;/li&gt;
&lt;li&gt;存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink&quot; title=&quot;连接器&quot;&gt;&lt;/a&gt;连接器&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;负责为何和客户端的TCP连接， 权限获取，验证。&lt;/li&gt;
&lt;li&gt;连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;show processlits&lt;/code&gt;查看当前所有的连接。&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/show_processlist.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;如果连接在&lt;code&gt;wait_timeout&lt;/code&gt;指定的时间内没有任何操作，则会被关闭。默认是8小时。&lt;/li&gt;
&lt;li&gt;长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。&lt;ul&gt;
&lt;li&gt;定时关闭连接 或 执行了大的查询语句后断开连接&lt;/li&gt;
&lt;li&gt;MySQL5.7以后的版本可以通过&lt;code&gt;mysql_reset_connection&lt;/code&gt;重新初始化连接（不会重新验证权限）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>极客时间-算法-学习总结</title>
    <link href="https://leokongwq.github.io/2018/12/17/geektime-algo-summary.html"/>
    <id>https://leokongwq.github.io/2018/12/17/geektime-algo-summary.html</id>
    <published>2018-12-17T01:05:50.000Z</published>
    <updated>2019-03-11T08:27:05.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统高效地学习数据结构与算法"><a href="#系统高效地学习数据结构与算法" class="headerlink" title="系统高效地学习数据结构与算法"></a>系统高效地学习数据结构与算法</h2><h3 id="什么是数据结构？什么是算法"><a href="#什么是数据结构？什么是算法" class="headerlink" title="什么是数据结构？什么是算法?"></a>什么是数据结构？什么是算法?</h3><p>广义定义：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p>
<p>狭义定义：指的就是著名的数据结构和算法实现（大多数相关书籍里面内容），比如数组，队列，栈，链表，快速排序，二分查找等。</p>
<h3 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h3><p>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<a id="more"></a>
<h3 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h3><p>必须掌握一个数据结构与算法中最重要的概念——复杂度分析。</p>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量<code>效率</code>和<code>资源消耗</code>的方法，这就是复杂度分析方法。</p>
<p>数据结构和算法图示：</p>
<img src="/2018/12/17/geektime-algo-summary/algo-summary.jpg">
<p>对于非算法工程师来说，并不需要掌握图里面的所有知识点，要学会找重点来学习。作者总结了如下20个常用的数据结构和算法：</p>
<p>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。<br>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法，动态规划，字符串匹配算法。</p>
<p>每种数据结构和算法的学习重点：</p>
<ul>
<li>来历</li>
<li>自身的特点</li>
<li>适合解决的问题</li>
<li>实际的应用场景</li>
</ul>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><ul>
<li>边学边练，适度刷题</li>
<li>多问，多思考，多互动</li>
<li>设立目标，贵在坚持</li>
<li>反复迭代，不断沉淀</li>
</ul>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>复杂度分析用来解决算法的执行效率和空间占用情况的，这里的空间占用，指的是内存空间的占用。</p>
<h3 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h3><p>通过统计和监控确实可以分析算法的执行效率和资源消耗。该方法被称为<code>事后分析法</code>，但是它有一定的局限性。</p>
<ol>
<li>测试结果非常依赖测试环境。</li>
<li>测试结果受数据规模的影响较大。</li>
</ol>
<h3 id="大O复杂度分析法"><a href="#大O复杂度分析法" class="headerlink" title="大O复杂度分析法"></a>大O复杂度分析法</h3><blockquote>
<p>T(n) = O(f(n))</p>
</blockquote>
<ul>
<li>n表示数据规模</li>
<li>T(n)表示代码执行时间</li>
<li>f(n)表示每行代码执行时间总和</li>
</ul>
<p>大<code>O</code>时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<code>代码执行时间随数据规模增长的变化趋势</code>， 所以也称为<code>渐进时间复杂度（asymptotic time complexity）</code>。</p>
<p>当数据规模<code>n</code>很大时，公式中的<code>低阶</code>、<code>常量</code>、<code>系数</code>三部分并不左右增长趋势，所以都可以忽略。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol>
<li>只关注循环次数最多的代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li>
</ol>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img src="/2018/12/17/geektime-algo-summary/comon_time_complex.jpg">
<h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p><code>O(1)</code>只是常量级时间复杂度的表示，只要算法的执行时间不随着数据规模增加而增加，那么时间复杂度就是<code>O(1)</code>。</p>
<h4 id="O-m-n-和-O-m-n"><a href="#O-m-n-和-O-m-n" class="headerlink" title="O(m + n) 和 O(m * n)"></a>O(m + n) 和 O(m * n)</h4><p><code>O(m + n)</code>表示算法的时间复杂度是由2个数据规模决定的，<code>事前不能确定n和m的大小关系</code>, 所以不能简单的省略其中任何一个（加法法则失效）。但是乘法法则依然起作用。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度表示<code>算法的使用的存储空间随数据规模增长的变化趋势</code>， 所以也称为<code>渐进空间复杂度（asymptotic space complexity）</code>。</p>
<p>常见的空间复杂度有：<code>O(1)</code>, <code>O(n)</code>, <code>O(n2)</code>，像 <code>O(logN)</code>和<code>O(NlogN)</code>比较少见。</p>
<h3 id="最好，最坏时间复杂度"><a href="#最好，最坏时间复杂度" class="headerlink" title="最好，最坏时间复杂度"></a>最好，最坏时间复杂度</h3><p>最好（best case time complexity），最坏（worst case time complexity），平均（average case time complexity）时间复杂度表示算法在不同情况下的执行效率。</p>
<h3 id="平均-情况时间复杂度"><a href="#平均-情况时间复杂度" class="headerlink" title="平均 情况时间复杂度"></a>平均 情况时间复杂度</h3><p><code>加权平均值</code>也称为<code>期望值</code></p>
<p><code>平均情况时间复杂度</code> 也称为：<code>加权平均时间复杂度</code> 或 <code>期望时间复杂度</code></p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>摊还分析(平摊分析)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统高效地学习数据结构与算法&quot;&gt;&lt;a href=&quot;#系统高效地学习数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;系统高效地学习数据结构与算法&quot;&gt;&lt;/a&gt;系统高效地学习数据结构与算法&lt;/h2&gt;&lt;h3 id=&quot;什么是数据结构？什么是算法&quot;&gt;&lt;a href=&quot;#什么是数据结构？什么是算法&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构？什么是算法?&quot;&gt;&lt;/a&gt;什么是数据结构？什么是算法?&lt;/h3&gt;&lt;p&gt;广义定义：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。&lt;/p&gt;
&lt;p&gt;狭义定义：指的就是著名的数据结构和算法实现（大多数相关书籍里面内容），比如数组，队列，栈，链表，快速排序，二分查找等。&lt;/p&gt;
&lt;h3 id=&quot;数据结构和算法的关系&quot;&gt;&lt;a href=&quot;#数据结构和算法的关系&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法的关系&quot;&gt;&lt;/a&gt;数据结构和算法的关系&lt;/h3&gt;&lt;p&gt;数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://leokongwq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mockito学习总结</title>
    <link href="https://leokongwq.github.io/2018/12/06/mockito-learn.html"/>
    <id>https://leokongwq.github.io/2018/12/06/mockito-learn.html</id>
    <published>2018-12-06T06:33:01.000Z</published>
    <updated>2018-12-06T09:10:42.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发工作中，单元测试时必不可少的一环。而在编写单元测试代码中，你肯定会遇到依赖的服务，接口和一些运行环境中的对象无法构造的情况。此时你就需要一个功能强大的mock框架，让它来帮你完成这些功能，而<a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito</a>就是Java开发环境中一个功能强大的Mock框架。类似的还有powermock, easymock等。</p>
<p>本文是对以往工作中使用到Mockito的一些功能做一次总结，方便以后翻看，并帮助需要使用Mockito的人。</p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Mockito不需要安装，根据不同的项目管理工具（maven, gradle）引入Mockito的依赖即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.10.19&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建Mock对象"><a href="#创建Mock对象" class="headerlink" title="创建Mock对象"></a>创建Mock对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest  mockedRequest = Mockito.mock(HttpServletRequest.class);</span><br></pre></td></tr></table></figure>
<h3 id="mock对象方法"><a href="#mock对象方法" class="headerlink" title="mock对象方法"></a>mock对象方法</h3><h4 id="mock方法方法返回值"><a href="#mock方法方法返回值" class="headerlink" title="mock方法方法返回值"></a>mock方法方法返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(mockedRequest.getHeader(<span class="string">"X-Forwarded-For"</span>)).thenReturn(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="mock方法异常"><a href="#mock方法异常" class="headerlink" title="mock方法异常"></a>mock方法异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn();</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> IndexOutOfBoundsException());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:0</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//抛异常</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//输出null, 这是因为get(999)没有被mock</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure>
<h3 id="mock对象行为测试。"><a href="#mock对象行为测试。" class="headerlink" title="mock对象行为测试。"></a>mock对象行为测试。</h3><p>Mockito 会追踪 Mock 对象的所用方法调用和调用方法时所传递的参数，可以通过 <code>verify()</code>来测试mock对象行为。例如方法是否被调用，方法被调用的次数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.add(<span class="string">"two"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line">when(mockedList.size()).thenReturn(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(mockedList.size(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add("one") 执行被调用一次，否则会抛异常</span></span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"one"</span>);</span><br><span class="line"><span class="comment">//add("two") 被调用恰好一次，否则会抛异常</span></span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"two"</span>);</span><br><span class="line"><span class="comment">//add("three times") 被调用恰好三次，否则会抛异常</span></span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line"><span class="comment">//isEmpty 从来没有被调用过</span></span><br><span class="line">verify(mockedList, never()).isEmpty();</span><br></pre></td></tr></table></figure>
<h3 id="方法调用顺序测试"><a href="#方法调用顺序测试" class="headerlink" title="方法调用顺序测试"></a>方法调用顺序测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; firstMock = mock(List.class);</span><br><span class="line">List&lt;String&gt; secondMock = mock(List.class);</span><br><span class="line"></span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called second"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called third"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果mock方法的调用顺序和InOrder中verify的顺序不同，那么测试将执行失败。 */</span></span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"><span class="comment">//验证firstMock是否调用了2次add("was called first")，如果把2修改为3则会抛异常</span></span><br><span class="line">inOrder.verify(firstMock, times(<span class="number">2</span>)).add(<span class="string">"was called first"</span>);</span><br><span class="line"><span class="comment">//验证 secondMock是否分别调用add("was called second")，add("was called third")一次</span></span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called third"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为在secondMock.add("was called third")之后已经没有多余的方法调用了。</span></span><br><span class="line">inOrder.verifyNoMoreInteractions();<span class="comment">// 表示此方法调用后再没有多余的交互</span></span><br></pre></td></tr></table></figure>
<h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><p>Mockito使用<code>equals()</code>方法验证参数值。 当需要更加灵活的验证方式时，可以使用参数匹配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Mockito内置的 anyInt() 参数匹配器</span></span><br><span class="line"> when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用自定义的参数匹配器</span></span><br><span class="line"> when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//输出：element</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//you can also verify using an argument matcher</span></span><br><span class="line"> verify(mockedList).get(anyInt());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//argument matchers can also be written as Java 8 Lambdas</span></span><br><span class="line"> verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h3 id="自定义Answer接口"><a href="#自定义Answer接口" class="headerlink" title="自定义Answer接口"></a>自定义Answer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; mock = mock(List.class);</span><br><span class="line">when(mock.get(<span class="number">4</span>)).thenAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        Integer num = (Integer) args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(mock.get(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="mock-void-方法"><a href="#mock-void-方法" class="headerlink" title="mock void 方法"></a>mock <code>void</code> 方法</h3><p>doReturn()|doThrow()| doAnswer()|doNothing()|doCallRealMethod()</p>
<h4 id="doThrow"><a href="#doThrow" class="headerlink" title="doThrow"></a>doThrow</h4><p>当需要mock一个返回值是void的方法，调用该方法返回异常的情况，使用doThrow</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure>
<h4 id="doReturn"><a href="#doReturn" class="headerlink" title="doReturn"></a>doReturn</h4><p>有些特殊情况下，不能直接使用<code>when(...).thenReturn</code>，此时只能使用<code>doReturn</code>了。</p>
<h5 id="When-spying-real-objects-and-calling-real-methods-on-a-spy-brings-side-effects"><a href="#When-spying-real-objects-and-calling-real-methods-on-a-spy-brings-side-effects" class="headerlink" title="When spying real objects and calling real methods on a spy brings side effects"></a>When spying real objects and calling real methods on a spy brings side effects</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Overriding-a-previous-exception-stubbing"><a href="#Overriding-a-previous-exception-stubbing" class="headerlink" title="Overriding a previous exception-stubbing:"></a>Overriding a previous exception-stubbing:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when(mock.foo()).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.</span></span><br><span class="line">when(mock.foo()).thenReturn(<span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">"bar"</span>).when(mock).foo();</span><br></pre></td></tr></table></figure>
<h5 id="doAnswer"><a href="#doAnswer" class="headerlink" title="doAnswer"></a>doAnswer</h5><p>Use doAnswer() when you want to stub a void method with generic Answer.<br>Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets…</p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">          Object[] args = invocation.getArguments();</span><br><span class="line">          Mock mock = invocation.getMock();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;&#125;)</span><br><span class="line">  .when(mock).someMethod();</span><br></pre></td></tr></table></figure>
<h5 id="doNothing"><a href="#doNothing" class="headerlink" title="doNothing"></a>doNothing</h5><p>Use doNothing() for setting void methods to do nothing. Beware that void methods on mocks do nothing by default! However, there are rare situations when doNothing() comes handy:</p>
<ul>
<li>Stubbing consecutive calls on a void method:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">doNothing().</span><br><span class="line">doThrow(<span class="keyword">new</span> RuntimeException())</span><br><span class="line">.when(mock).someVoidMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//does nothing the first time:</span></span><br><span class="line">mock.someVoidMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throws RuntimeException the next time:</span></span><br><span class="line">mock.someVoidMethod();</span><br></pre></td></tr></table></figure>
<ul>
<li>When you spy real objects and you want the void method to do nothing:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//let's make clear() do nothing</span></span><br><span class="line">doNothing().when(spy).clear();</span><br><span class="line"></span><br><span class="line">spy.add(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear() does nothing, so the list still contains "one"</span></span><br><span class="line">spy.clear();</span><br></pre></td></tr></table></figure>
<h5 id="doCallRealMethod"><a href="#doCallRealMethod" class="headerlink" title="doCallRealMethod"></a>doCallRealMethod</h5><p>当需要调用真是对象的方法时，使用<code>doCallRealMethod</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callRealMethodTest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Jerry jerry = mock(Jerry.class);  </span><br><span class="line">  </span><br><span class="line">    doCallRealMethod().when(jerry).goHome();  </span><br><span class="line">    doCallRealMethod().when(jerry).doSomeThingB();  </span><br><span class="line">  </span><br><span class="line">    jerry.goHome();  </span><br><span class="line">  </span><br><span class="line">    verify(jerry).doSomeThingA();  </span><br><span class="line">    verify(jerry).doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jerry</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        doSomeThingA();  </span><br><span class="line">        doSomeThingB();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// real invoke it.  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingB</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"good day"</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// auto mock method by mockito  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingA</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"you should not see this message."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看出Jerry是一个mock对象， goHome()和doSomeThingB()是使用了实际调用技术，而doSomeThingA()被mockito执行了默认的answer行为（这里是个void方法，so，什么也不干）。</p>
<h3 id="Mock-简化mock对象的创建"><a href="#Mock-简化mock对象的创建" class="headerlink" title="@Mock 简化mock对象的创建"></a>@Mock 简化mock对象的创建</h3><p>Mockito提供了注解<code>@Mock</code>来简化Mock对象的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManagerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ArticleManager manager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 需要在单元测试方法前执行</span></span><br><span class="line">        MockitoAnnotations.initMocks(testClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spy真实对象"><a href="#spy真实对象" class="headerlink" title="spy真实对象"></a>spy真实对象</h3><p>可以创建真实对象的spy对象。当代用spy对象的方法时，真实对象的方法会被调用（如果被调用的方法没有被mock的话）。</p>
<p>spy对象可以被用在部分mock场景下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以mock部分方法调用</span></span><br><span class="line">when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using the spy calls *real* methods</span></span><br><span class="line">spy.add(<span class="string">"one"</span>);</span><br><span class="line">spy.add(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：one</span></span><br><span class="line">System.out.println(spy.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size() 返回100</span></span><br><span class="line">System.out.println(spy.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//optionally, you can verify</span></span><br><span class="line">verify(spy).add(<span class="string">"one"</span>);</span><br><span class="line">verify(spy).add(<span class="string">"two"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://heipark.iteye.com/blog/1496603" target="_blank" rel="noopener">https://heipark.iteye.com/blog/1496603</a><br><a href="http://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html" target="_blank" rel="noopener">http://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发工作中，单元测试时必不可少的一环。而在编写单元测试代码中，你肯定会遇到依赖的服务，接口和一些运行环境中的对象无法构造的情况。此时你就需要一个功能强大的mock框架，让它来帮你完成这些功能，而&lt;a href=&quot;https://site.mockito.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mockito&lt;/a&gt;就是Java开发环境中一个功能强大的Mock框架。类似的还有powermock, easymock等。&lt;/p&gt;
&lt;p&gt;本文是对以往工作中使用到Mockito的一些功能做一次总结，方便以后翻看，并帮助需要使用Mockito的人。&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="https://leokongwq.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="mockito" scheme="https://leokongwq.github.io/tags/mockito/"/>
    
  </entry>
  
  <entry>
    <title>mysql profile 学习笔记</title>
    <link href="https://leokongwq.github.io/2018/11/24/mysql-show-profile.html"/>
    <id>https://leokongwq.github.io/2018/11/24/mysql-show-profile.html</id>
    <published>2018-11-24T04:55:54.000Z</published>
    <updated>2018-11-24T05:43:42.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql-profile-简介"><a href="#mysql-profile-简介" class="headerlink" title="mysql profile 简介"></a>mysql profile 简介</h3><p><code>show profile</code> 和 <code>show profiles</code>语句，可以用来显示SQL语句执行期间各种资源的使用信息。</p>
<blockquote>
<p>注意：<br>这些语句从版本<code>5.6.7</code>开始就不建议使用了，并且可能在下一个release版本中删除。后续可以通过<code>Performance Schema</code>来替代这些语句。具体可以参考:<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema-query-profiling.html" target="_blank" rel="noopener">Profiling Using Performance Schema</a>。</p>
</blockquote>
<h3 id="show-profiles"><a href="#show-profiles" class="headerlink" title="show profiles"></a>show profiles</h3><p><code>show profiles</code> 展示了服务器最近收到的语句列表。 列表的大小可以通过调整<code>profiling_history_size</code>来调整，默认大小是<code>15</code>，最大值是<code>100</code>。如果设置为0，则和关闭profile功能是一样的。</p>
<p>举个例子：</p>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                     |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line">|        1 | 0.00020000 | <span class="keyword">SET</span> <span class="keyword">global</span> profiling = <span class="number">1</span>                                                  |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00054500</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00046600</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00063500</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><h4 id="profile-语法"><a href="#profile-语法" class="headerlink" title="profile 语法"></a>profile 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] ... ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>: &#123;</span><br><span class="line">    <span class="keyword">ALL</span></span><br><span class="line">  | <span class="keyword">BLOCK</span> IO</span><br><span class="line">  | <span class="keyword">CONTEXT</span> SWITCHES</span><br><span class="line">  | CPU</span><br><span class="line">  | IPC</span><br><span class="line">  | <span class="keyword">MEMORY</span></span><br><span class="line">  | PAGE FAULTS</span><br><span class="line">  | <span class="keyword">SOURCE</span></span><br><span class="line">  | SWAPS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>show profile</code> 可以显示一个SQL语句的详细信息。如果不带<code>for query n</code>字句，输出的结果是最近一条语句的相关信息。如果包含<code>for query n</code>字句，则<code>show profile</code>显示语句<code>n</code>的相关信息。 这里的<code>n</code>是<code>show profiles</code>数据结果里面<code>Query_ID</code>列的值。</p>
<p>默认情况下<code>show profile</code>只显示<code>Status</code>和<code>Duration</code>列。<code>Status</code>列的值和<code>SHOW PROCESSLIST</code>输出结果里面的列<code>Status</code>的值类似，但有一点小的区别，具体可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/thread-information.html" target="_blank" rel="noopener">Section 8.14, “Examining Thread Information”</a></p>
<p>可以通过指定<code>type</code>值来获取你关心的信息。</p>
<ul>
<li>ALL 展示所有信息</li>
<li>BLOCK IO 展示阻塞的输入输出操作的个数</li>
<li>CONTEXT SWITCHES 展示主动和被动的上下文切换次数。</li>
<li>CPU 展会用户和系统的CPU使用次数。</li>
<li>IPC 展示消息发送和接收的次数</li>
<li>MEMORY 暂时没有实现</li>
<li>PAGE FAULTS 展示发生缺页错误次数。</li>
<li>SOURCE 展示源代码中的函数名称，以及函数发生的文件的名称和行号</li>
<li>SWAPS 展示发生内存<code>swap</code>的次数。</li>
</ul>
<h3 id="查看并开启profile"><a href="#查看并开启profile" class="headerlink" title="查看并开启profile"></a>查看并开启profile</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure>
<p>上面的语句执行结果展示了是否开启了profile功能。默认是关闭的。</p>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling = <span class="number">1</span>;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> profiling = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>可以通过执行一些sql语句，然后通过profile来查看这些语句的执行情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br></pre></td></tr></table></figure>
<p>执行profile分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILE CPU FOR QUERY 7;</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line">| Status         | Duration | CPU_user | CPU_system |</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line">| starting       | 0.003667 | 0.000094 |   0.000977 |</span><br><span class="line">| query <span class="keyword">end</span>      | <span class="number">0.000015</span> | <span class="number">0.000009</span> |   <span class="number">0.000007</span> |</span><br><span class="line">| closing <span class="keyword">tables</span> | <span class="number">0.000007</span> | <span class="number">0.000004</span> |   <span class="number">0.000001</span> |</span><br><span class="line">| freeing items  | <span class="number">0.000019</span> | <span class="number">0.000009</span> |   <span class="number">0.000010</span> |</span><br><span class="line">| cleaning up    | <span class="number">0.000032</span> | <span class="number">0.000020</span> |   <span class="number">0.000013</span> |</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mysql-profile-简介&quot;&gt;&lt;a href=&quot;#mysql-profile-简介&quot; class=&quot;headerlink&quot; title=&quot;mysql profile 简介&quot;&gt;&lt;/a&gt;mysql profile 简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;show profile&lt;/code&gt; 和 &lt;code&gt;show profiles&lt;/code&gt;语句，可以用来显示SQL语句执行期间各种资源的使用信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;这些语句从版本&lt;code&gt;5.6.7&lt;/code&gt;开始就不建议使用了，并且可能在下一个release版本中删除。后续可以通过&lt;code&gt;Performance Schema&lt;/code&gt;来替代这些语句。具体可以参考:&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/performance-schema-query-profiling.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Profiling Using Performance Schema&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;show-profiles&quot;&gt;&lt;a href=&quot;#show-profiles&quot; class=&quot;headerlink&quot; title=&quot;show profiles&quot;&gt;&lt;/a&gt;show profiles&lt;/h3&gt;&lt;p&gt;&lt;code&gt;show profiles&lt;/code&gt; 展示了服务器最近收到的语句列表。 列表的大小可以通过调整&lt;code&gt;profiling_history_size&lt;/code&gt;来调整，默认大小是&lt;code&gt;15&lt;/code&gt;，最大值是&lt;code&gt;100&lt;/code&gt;。如果设置为0，则和关闭profile功能是一样的。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://leokongwq.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate超时引发的血案</title>
    <link href="https://leokongwq.github.io/2018/11/21/springboot-resttempate-timout.html"/>
    <id>https://leokongwq.github.io/2018/11/21/springboot-resttempate-timout.html</id>
    <published>2018-11-21T15:01:05.000Z</published>
    <updated>2018-11-21T15:48:09.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近线上出了一次故障，收银台系统所有服务全部假死。订单量瞬时下降，造成很大损失。</p>
<p>故障总结，导致问题的原因有两方面：</p>
<ol>
<li>数据库慢查询</li>
<li>RestTemplate超时时间设置不生效。</li>
<li>spring-web不同版本设置RestTemplate方式不完全一样。</li>
</ol>
<a id="more"></a>
<h3 id="默认超时设置"><a href="#默认超时设置" class="headerlink" title="默认超时设置"></a>默认超时设置</h3><p>默认情况下是没有超时设置的，此时超时依赖两方面：</p>
<ol>
<li>依赖TCP连接本身的超时时间（tcp空闲连接，超过一定时间，连接会被关闭）。</li>
<li>请求所经过的网络节点的超时时间。e.g. 中间经过nginx, nginx默认读取后端服务的超时时间是60s，所以超时时间在60s左右（日志显示稍微大一点，不会大很多）。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight java"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    Map responseObject = restTemplate.getForObject(url, Map.class);</span><br><span class="line">    System.out.println(responseObject);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Assert.assertNotNull(e);</span><br><span class="line">    System.out.println(<span class="string">"timeout = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<p><code>RestTemplate</code> 继承自 <code>HttpAccessor</code>, 默认使用的<code>ClientHttpRequestFactory</code>是<code>SimpleClientHttpRequestFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Logger available to subclasses.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClientHttpRequestFactory</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CHUNK_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> Proxy proxy;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequestBody = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> chunkSize = DEFAULT_CHUNK_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接和读取超时都是 -1, 也就是没有超时设置。</span></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> connectTimeout = -<span class="number">1</span>;</span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> readTimeout = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们使用<code>RestTemplate</code>该如何设置超时时间呢？ </p>
<h3 id="RestTemplate超时设置"><a href="#RestTemplate超时设置" class="headerlink" title="RestTemplate超时设置"></a>RestTemplate超时设置</h3><p>由上面的代码我们了解到，超时设置其实应该通过内部的<code>ClientHttpRequestFactory</code>来设置的。</p>
<p>所以就可以通过给<code>RestTemplate</code>设置一个我们自己创建的，设置了超时时间的<code>ClientHttpRequestFactory</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimpleClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">clientHttpRequestFactory.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">clientHttpRequestFactory.setReadTimeout(<span class="number">50</span>);</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line">clientHttpRequestFactory.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">clientHttpRequestFactory.setReadTimeout(<span class="number">50</span>);</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br></pre></td></tr></table></figure>
<p>但是要注意的是: <code>HttpComponentsClientHttpRequestFactory</code> 底层使用了apache的<code>HttpClient</code>，超时时间的设置其实是针对它进行设置的。</p>
<figure class="highlight java"><figcaption><span>HttpComponentsClientHttpRequestFactory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL_CONNECTIONS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CONNECTIONS_PER_ROUTE = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//默认读取超时 60s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_READ_TIMEOUT_MILLISECONDS = (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the connection timeout for the underlying HttpClient.</span></span><br><span class="line"><span class="comment"> * A timeout value of 0 specifies an infinite timeout.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the timeout value in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">trueAssert.isTrue(timeout &gt;= <span class="number">0</span>, <span class="string">"Timeout must be a non-negative value"</span>);</span><br><span class="line">truegetHttpClient().getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，如果就通过上面提到的方式设置超时时间，那么我们的应用就不用有超时问题，也不会发生故障了。</p>
<p>但问题就发生在，公司内部使用的组件，不是通过<code>HttpComponentsClientHttpRequestFactory</code>设置超时时间，而是通过设置<code>HttpComponentsClientHttpRequestFactory</code>内部的<code>HttpClient</code>设置的超时时间，并且设置了<code>HttpClient</code> 使用的 <code>HttpClientConnectionManager</code>，从而导致了问题的发生。</p>
<h3 id="问题代码-amp-测试"><a href="#问题代码-amp-测试" class="headerlink" title="问题代码&amp;测试"></a>问题代码&amp;测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRestTemplateWithRequestFactoryWithoutTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置超时时间， 设置/不设置ConnectionManager</span></span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">                .setDefaultRequestConfig(getRequestConfig())</span><br><span class="line">                .setDefaultSocketConfig(getSocketConfig())</span><br><span class="line">                .setConnectionManager(<span class="keyword">new</span> PoolingHttpClientConnectionManager(<span class="number">3</span>, TimeUnit.MINUTES))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        restTemplate.setRequestFactory(requestFactory);</span><br><span class="line"></span><br><span class="line">        Map responseObject = restTemplate.getForObject(QUERY_USER_RENEW_URL, Map.class);</span><br><span class="line">        System.out.println(responseObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Assert.assertNotNull(e);</span><br><span class="line">        System.out.println(<span class="string">"timeout = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><h4 id="spring-web-版本-3-2-0"><a href="#spring-web-版本-3-2-0" class="headerlink" title="spring-web 版本 3.2.0"></a>spring-web 版本 3.2.0</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<h4 id="spring-web-版本-4-0-9-RELEASE"><a href="#spring-web-版本-4-0-9-RELEASE" class="headerlink" title="spring-web 版本 4.0.9.RELEASE"></a>spring-web 版本 4.0.9.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时不生效 （qiyue-store 就是这样问题）</li>
</ol>
<h4 id="spring-web-版本-4-3-0-RELEASE"><a href="#spring-web-版本-4-3-0-RELEASE" class="headerlink" title="spring-web 版本 4.3.0.RELEASE"></a>spring-web 版本 4.3.0.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<h4 id="spring-web-版本-4-3-11-RELEASE"><a href="#spring-web-版本-4-3-11-RELEASE" class="headerlink" title="spring-web 版本 4.3.11.RELEASE"></a>spring-web 版本 4.3.11.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的 proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<p>其实问题就在与不同的版本中<code>HttpComponentsClientHttpRequestFactory.createRequest</code>方法的实现逻辑不同。如何不同，自己查看。😁</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>超时设置至关重要。外部依赖接口调用可以通过Hystrix进行包装。</li>
<li>任何参数的设置都需要验证是否可以正常工作，可以加入到测试环节中，方便在不同的依赖版本中进行验证。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近线上出了一次故障，收银台系统所有服务全部假死。订单量瞬时下降，造成很大损失。&lt;/p&gt;
&lt;p&gt;故障总结，导致问题的原因有两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库慢查询&lt;/li&gt;
&lt;li&gt;RestTemplate超时时间设置不生效。&lt;/li&gt;
&lt;li&gt;spring-web不同版本设置RestTemplate方式不完全一样。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="RestTemplate" scheme="https://leokongwq.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>springboot 之 Servlet3 web组件</title>
    <link href="https://leokongwq.github.io/2018/11/17/springboot-servlet3-component.html"/>
    <id>https://leokongwq.github.io/2018/11/17/springboot-servlet3-component.html</id>
    <published>2018-11-17T03:32:28.000Z</published>
    <updated>2018-11-17T03:44:26.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://jcp.org/en/jsr/detail?id=315" target="_blank" rel="noopener">Servlet3.0</a> 规范新增了很多注解，例如：<code>@WebFilter</code>, <code>@WebServlet</code>, <code>@WebListener</code>, 可以帮助我们简化Web应用的开发，不在使用繁琐的xml配置。</p>
<p>但是在SpringBoot环境和支持Servlet3.0规范的容器下使用有些许的区别。</p>
<a id="more"></a>
<h3 id="springboot环境下使用Servlet3-0注解"><a href="#springboot环境下使用Servlet3-0注解" class="headerlink" title="springboot环境下使用Servlet3.0注解"></a>springboot环境下使用Servlet3.0注解</h3><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"authServlet"</span>, urlPatterns = &#123;<span class="string">"/abc"</span>&#125;, loadOnStartup=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AuthServlet init"</span>);</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getOutputStream().write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : jiexiu</span></span><br><span class="line"><span class="comment"> * DateTime: 2018/3/7 下午10:32</span></span><br><span class="line"><span class="comment"> * Mail:leokongwq@gmail.com   </span></span><br><span class="line"><span class="comment"> * Description: desc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AuthFilter init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(request.getLocalName());</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Application-启动类"><a href="#Application-启动类" class="headerlink" title="Application 启动类"></a>Application 启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(BookServiceApplication.class, args);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="@ServletComponentScan"></a>@ServletComponentScan</h3><p><code>@ServletComponentScan</code>这个注解很重要，它告诉SpringBoot从哪里加载Servlet组件。</p>
<p>如果不加该注解，则在SpringBoot内置的Servlet容器中不能正常加载注解指定的组件。</p>
<p>原因参见：<a href="https://github.com/spring-projects/spring-boot/issues/2290" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues/2290</a></p>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p><code>@ServletComponentScan</code>注解是被 <code>ServletComponentRegisteringPostProcessor</code>进行处理的。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServletComponentRegisteringPostProcessor</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;ServletComponentHandler&gt; HANDLERS;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;ServletComponentHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebServletHandler());</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebFilterHandler());</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebListenerHandler());</span><br><span class="line">        HANDLERS = Collections.unmodifiableList(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanPackage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ClassPathScanningCandidateComponentProvider componentProvider, </span></span></span><br><span class="line"><span class="function"><span class="params">      String packageToScan)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (ServletComponentHandler handler : HANDLERS) &#123;</span><br><span class="line">            handler.handle(((ScannedGenericBeanDefinition) candidate),</span><br><span class="line">              (BeanDefinitionRegistry) <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Servlet3.0&lt;/a&gt; 规范新增了很多注解，例如：&lt;code&gt;@WebFilter&lt;/code&gt;, &lt;code&gt;@WebServlet&lt;/code&gt;, &lt;code&gt;@WebListener&lt;/code&gt;, 可以帮助我们简化Web应用的开发，不在使用繁琐的xml配置。&lt;/p&gt;
&lt;p&gt;但是在SpringBoot环境和支持Servlet3.0规范的容器下使用有些许的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="servlet3" scheme="https://leokongwq.github.io/tags/servlet3/"/>
    
  </entry>
  
  <entry>
    <title>springboot 之 ConfigurationProperties</title>
    <link href="https://leokongwq.github.io/2018/11/16/springboot-ConfigurationProperties.html"/>
    <id>https://leokongwq.github.io/2018/11/16/springboot-ConfigurationProperties.html</id>
    <published>2018-11-16T14:49:59.000Z</published>
    <updated>2018-11-21T15:01:26.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>ConfigurationProperties</code> 是SpringBoot引入的一个和外部配置文件相关的注解类。它可以帮助我们更好的使用外置的配置文件属性。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreNestedProperties</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exceptionIfInvalid</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="prefix-amp-value"><a href="#prefix-amp-value" class="headerlink" title="prefix &amp; value"></a>prefix &amp; value</h4><p>prefix 属性可以指定配置文件中配置项的前缀，如此，相同前缀的配置项就可以统一解析。</p>
<h4 id="ignoreInvalidFields"><a href="#ignoreInvalidFields" class="headerlink" title="ignoreInvalidFields"></a>ignoreInvalidFields</h4><p>是否忽略不可用的字段，默认为<code>false</code>， 当配置项不能被正确转化为Java类的字段值时，会抛出异常。</p>
<h4 id="ignoreNestedProperties"><a href="#ignoreNestedProperties" class="headerlink" title="ignoreNestedProperties"></a>ignoreNestedProperties</h4><p>是否忽略嵌套属性，默认为<code>false</code>， </p>
<h4 id="ignoreUnknownFields"><a href="#ignoreUnknownFields" class="headerlink" title="ignoreUnknownFields"></a>ignoreUnknownFields</h4><p>是否忽略Java类不存在的字段，默认值为<code>true</code>。</p>
<h4 id="exceptionIfInvalid"><a href="#exceptionIfInvalid" class="headerlink" title="exceptionIfInvalid"></a>exceptionIfInvalid</h4><p>如果Java类加了注解<code>@Validated</code>，并且校验失败了，是否抛出异常。默认<code>true</code></p>
<h3 id="属性注入到Java类"><a href="#属性注入到Java类" class="headerlink" title="属性注入到Java类"></a>属性注入到Java类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:configprops.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigProperties</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Length</span>(max = <span class="number">4</span>, min = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">private</span> String authMethod;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// standard getters and setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">1025</span>)</span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">65536</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]&#123;2,6&#125;$"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> Credentials credentials;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; defaultRecipients;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; additionalHeaders;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认属性配置从<code>application.properties</code>文件中获取，也可以通过<code>@PropertySource</code>指定。</p>
<p><code>@Configuration</code>注解不可缺少。</p>
<p>资源文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#Simple properties</span><br><span class="line">mail.host=mailer<span class="meta">@mail</span>.com</span><br><span class="line">mail.port=<span class="number">9000</span></span><br><span class="line">mail.from=mailer<span class="meta">@mail</span>.com</span><br><span class="line"> </span><br><span class="line">#List properties</span><br><span class="line">mail.defaultRecipients[<span class="number">0</span>]=admin<span class="meta">@mail</span>.com</span><br><span class="line">mail.defaultRecipients[<span class="number">1</span>]=owner<span class="meta">@mail</span>.com</span><br><span class="line"> </span><br><span class="line">#Map Properties</span><br><span class="line">mail.additionalHeaders.redelivery=<span class="keyword">true</span></span><br><span class="line">mail.additionalHeaders.secure=<span class="keyword">true</span></span><br><span class="line"> </span><br><span class="line">#Object properties</span><br><span class="line">mail.credentials.username=john</span><br><span class="line">mail.credentials.password=password</span><br><span class="line">mail.credentials.authMethod=SHA1</span><br></pre></td></tr></table></figure>
<h4 id="内嵌类属性"><a href="#内嵌类属性" class="headerlink" title="内嵌类属性"></a>内嵌类属性</h4><p><code>mail.credentials.username</code>可以注入到内嵌属性<code>credentials</code>中</p>
<h4 id="列表字段"><a href="#列表字段" class="headerlink" title="列表字段"></a>列表字段</h4><p><code>mail.defaultRecipients[0]</code> 可以注入到类的列表(数组页可以)属性中。</p>
<h4 id="map字段"><a href="#map字段" class="headerlink" title="map字段"></a>map字段</h4><p><code>mail.additionalHeaders.redelivery</code> 格式的配置项也可以注入到<code>Map</code>类型的属性中。</p>
<h3 id="通过-ConfigurationProperties-Bean注解在配置类的bean定义方法上"><a href="#通过-ConfigurationProperties-Bean注解在配置类的bean定义方法上" class="headerlink" title="通过@ConfigurationProperties + @Bean注解在配置类的bean定义方法上"></a>通过@ConfigurationProperties + @Bean注解在配置类的bean定义方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigProperties <span class="title">mailConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConfigurationProperties-EnableConfigurationProperties"><a href="#ConfigurationProperties-EnableConfigurationProperties" class="headerlink" title="@ConfigurationProperties + @EnableConfigurationProperties"></a>@ConfigurationProperties + @EnableConfigurationProperties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h3><p>可以给属性类上加入<code>javax.validation.constraints.*</code>中的注解，来对配置项进行校验。配合<code>exceptionIfInvalid</code>可以更早的发现问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ConfigurationProperties&lt;/code&gt; 是SpringBoot引入的一个和外部配置文件相关的注解类。它可以帮助我们更好的使用外置的配置文件属性。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink&quot; title=&quot;源码解析&quot;&gt;&lt;/a&gt;源码解析&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(&amp;#123; ElementType.TYPE, ElementType.METHOD &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; ConfigurationProperties &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;prefix&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreInvalidFields&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreNestedProperties&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreUnknownFields&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Deprecated&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exceptionIfInvalid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="译" scheme="https://leokongwq.github.io/tags/%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK8环境下使用struts2</title>
    <link href="https://leokongwq.github.io/2018/11/07/struts2-with-jdk8.html"/>
    <id>https://leokongwq.github.io/2018/11/07/struts2-with-jdk8.html</id>
    <published>2018-11-07T14:07:54.000Z</published>
    <updated>2018-11-07T15:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近将组内项目的部署环境进行了一次升级。将JDK1.7S升级为1.8，Resin替换为Tomcat。在升级替换的过程中遇到了一些问题。特记录再次，希望能帮助有同样需求的朋友。</p>
<a id="more"></a>
<h3 id="Struts2-和-JDK8"><a href="#Struts2-和-JDK8" class="headerlink" title="Struts2 和 JDK8"></a>Struts2 和 JDK8</h3><p>项目中使用的<code>Struts2</code>版本是<code>2.3.35</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Struts2里面依赖<code>xwork-core</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts.xwork<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xwork-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>xwork-core</code>依赖<code>asm-*</code></p>
<p>问题来了!</p>
<p>低版本的<code>ASM</code>不能在JDK1.8环境中使用。如果强行使用，会导致一些奇怪的问题。</p>
<p>例如：</p>
<ol>
<li>只有一部分<code>Action</code>类可以正常被Struts2加载并处理http请求。某些在JDK1.7环境下可以正常工作的<code>Action</code>不能在JDK1.8下使用。原来可以访问的接口，现在是<code>404</code>。</li>
</ol>
<p>具体问题出在：</p>
<figure class="highlight java"><figcaption><span>DefaultClassFinder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readClassDef</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!className.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">       className = className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       URL resource = classLoaderInterface.getResource(className);</span><br><span class="line">       <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">           InputStream in = resource.openStream();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ClassReader classReader = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">               classReader.accept(<span class="keyword">new</span> InfoBuildingVisitor(<span class="keyword">this</span>), ClassReader.SKIP_DEBUG);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               in.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> XWorkException(<span class="string">"Could not load "</span> + className);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> XWorkException(<span class="string">"Could not load "</span> + className, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码就因为使用了低版本的<code>ASM</code>导致类解析失败(<code>IndexOutOfBoundsException</code>)。</p>
<h4 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h4><p>最简单方便的解决版本就是升级Struts2的版本到<code>2.5.x</code>。新版本将<code>xwork</code>依赖直接合并到<code>struts2-core</code>中了。而且使用了<code>ASM 5.X</code>版本，支持JDK8。</p>
<h4 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h4><p>使用Struts2官方提供的一个插件。具体用法如下：</p>
<hr>
<p>在项目中加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-java8-support-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>排除ASM依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts.xwork<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xwork-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Struts2-版本升级问题"><a href="#Struts2-版本升级问题" class="headerlink" title="Struts2 版本升级问题"></a>Struts2 版本升级问题</h3><h4 id="标签库不兼容"><a href="#标签库不兼容" class="headerlink" title="标签库不兼容"></a>标签库不兼容</h4><p>众所周知，Struts2框架的安全问题很多，建议升级到最新版本<code>2.5.x</code>。</p>
<p>但是2.5.x版本的Struts2提供的<strong>标签库</strong>和低版本的不兼容。这就会导致原有的<strong>JSP页面不能正常渲染</strong>。</p>
<p>当然了，如果你的项目里面没有使用Struts2替换的标签，这个问题可以忽略了。</p>
<h4 id="核心类拦截器变化"><a href="#核心类拦截器变化" class="headerlink" title="核心类拦截器变化"></a>核心类拦截器变化</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter </span></span><br><span class="line"><span class="comment">之前的核心过滤器全类名会有个ng  ,struts2.5核心过滤器没有这个</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="aspectjweaver"><a href="#aspectjweaver" class="headerlink" title="aspectjweaver"></a>aspectjweaver</h3><p>我们项目使用的版本是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>升级JDK1.8以后，需要同时升级该jar的版本到<code>1.8.13</code>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/gh670011677/article/details/75019003" target="_blank" rel="noopener">Struts2.5配置</a></p>
<p><a href="https://struts.apache.org/plugins/java-8-support/" target="_blank" rel="noopener">Java 8 Support Plugin</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/WW/Struts+2.3+to+2.5+migration" target="_blank" rel="noopener">Struts+2.3+to+2.5+migration</a></p>
<p><a href="https://stackoverflow.com/questions/41307863/what-is-the-difference-between-struts-2-3-x-and-struts-2-5-x" target="_blank" rel="noopener">what-is-the-difference-between-struts-2-3-x-and-struts-2-5-x</a></p>
<p><a href="https://asm.ow2.io/versions.html" target="_blank" rel="noopener">ASM-VERSIONS</a></p>
<p><a href="https://nosec.org/home/detail/1755.html" target="_blank" rel="noopener">Struts2最新RCE漏洞S2-057</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近将组内项目的部署环境进行了一次升级。将JDK1.7S升级为1.8，Resin替换为Tomcat。在升级替换的过程中遇到了一些问题。特记录再次，希望能帮助有同样需求的朋友。&lt;/p&gt;
    
    </summary>
    
    
      <category term="struts2" scheme="https://leokongwq.github.io/tags/struts2/"/>
    
      <category term="JDK8" scheme="https://leokongwq.github.io/tags/JDK8/"/>
    
  </entry>
  
  <entry>
    <title>maven加速</title>
    <link href="https://leokongwq.github.io/2018/11/03/how-to-make-maven-faster.html"/>
    <id>https://leokongwq.github.io/2018/11/03/how-to-make-maven-faster.html</id>
    <published>2018-11-03T04:42:36.000Z</published>
    <updated>2018-11-03T04:58:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于网络原因，国内访问maven中央仓库速度很慢。编译大型Maven项目时速度很慢。此时可以通过公用的或私有的镜像站来进行加速。</p>
<a id="more"></a>
<h3 id="国内Maven镜像站点"><a href="#国内Maven镜像站点" class="headerlink" title="国内Maven镜像站点"></a>国内Maven镜像站点</h3><h4 id="aliyun"><a href="#aliyun" class="headerlink" title="aliyun"></a>aliyun</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;  </span><br><span class="line">      &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">      &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">      &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span></span><br><span class="line">      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<h4 id="oschina"><a href="#oschina" class="headerlink" title="oschina"></a>oschina</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;    </span><br><span class="line">    &lt;id&gt;CN&lt;/id&gt;  </span><br><span class="line">    &lt;name&gt;OSChina Central&lt;/name&gt;         </span><br><span class="line">    &lt;url&gt;http:<span class="comment">//maven.oschina.net/content/groups/public/&lt;/url&gt;  </span></span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>
<h3 id="setting-xml-配置"><a href="#setting-xml-配置" class="headerlink" title="setting.xml 配置"></a>setting.xml 配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">    &lt;!-- 作为中央仓库的镜像 --&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">    &lt;!-- 私有， 公司内部使用 --&gt;</span><br><span class="line">    &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;nexus-mine&lt;/id&gt;</span><br><span class="line">      &lt;name&gt;Nexus mine&lt;/name&gt;</span><br><span class="line">      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;http:<span class="comment">//xx.xx.xx.xx/nexus/content/groups/public&lt;/url&gt;</span></span><br><span class="line">    &lt;/mirror&gt;</span><br><span class="line">  &lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>
<h3 id="mirrorOf-配置"><a href="#mirrorOf-配置" class="headerlink" title="mirrorOf 配置"></a>mirrorOf 配置</h3><p><code>mirrorOf</code> 用来指定该镜像针对的仓库。用法如下：</p>
<ul>
<li><code>*</code> 匹配所有仓库</li>
<li><code>external:*</code> 匹配除了本机和基于文件的所有外部构建地址。</li>
<li><code>repo,repo1</code> 匹配仓库<code>repo</code>和<code>repo1</code></li>
<li><code>*,!repo1</code> 除了仓库<code>repo1</code>匹配所有</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://maven.apache.org/guides/mini/guide-mirror-settings.html" target="_blank" rel="noopener">guide-mirror-settings</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;由于网络原因，国内访问maven中央仓库速度很慢。编译大型Maven项目时速度很慢。此时可以通过公用的或私有的镜像站来进行加速。&lt;/p&gt;
    
    </summary>
    
    
      <category term="maven" scheme="https://leokongwq.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>consul 命令介绍</title>
    <link href="https://leokongwq.github.io/2018/07/29/consul-command-intro.html"/>
    <id>https://leokongwq.github.io/2018/07/29/consul-command-intro.html</id>
    <published>2018-07-28T16:25:40.000Z</published>
    <updated>2018-07-29T07:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="consul-命令用法"><a href="#consul-命令用法" class="headerlink" title="consul 命令用法"></a>consul 命令用法</h2><p>安装完consul后，通过在控制台直接实现<code>consul</code>命令了解consul命令行的用法，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">Available commands are:</span><br><span class="line">agent          Runs a Consul agent</span><br><span class="line">catalog        Interact with the catalog</span><br><span class="line">event          Fire a new event</span><br><span class="line">exec           Executes a command on Consul nodes</span><br><span class="line">force-leave    Forces a member of the cluster to enter the "left" state</span><br><span class="line">info           Provides debugging information for operators.</span><br><span class="line">join           Tell Consul agent to join cluster</span><br><span class="line">keygen         Generates a new encryption key</span><br><span class="line">keyring        Manages gossip layer encryption keys</span><br><span class="line">kv             Interact with the key-value store</span><br><span class="line">leave          Gracefully leaves the Consul cluster and shuts down</span><br><span class="line">lock           Execute a command holding a lock</span><br><span class="line">maint          Controls node or service maintenance mode</span><br><span class="line">members        Lists the members of a Consul cluster</span><br><span class="line">monitor        Stream logs from a Consul agent</span><br><span class="line">operator       Provides cluster-level tools for Consul operators</span><br><span class="line">reload         Triggers the agent to reload configuration files</span><br><span class="line">rtt            Estimates network round trip time between nodes</span><br><span class="line">snapshot       Saves, restores and inspects snapshots of Consul server state</span><br><span class="line">validate       Validate config files/directories</span><br><span class="line">version        Prints the Consul version</span><br><span class="line">watch          Watch for changes in Consul</span><br></pre></td></tr></table></figure>
<p>如上所示， consul提供的命令很多，下面就逐个学习下每个命令的作用和用法。</p>
<a id="more"></a>
<h2 id="agent"><a href="#agent" class="headerlink" title="agent"></a>agent</h2><p><code>agent</code> 命令的作用是启动一个<code>consul</code> 进程， 该进程的具体作用和该命令的参数有关。</p>
<p>通过 <code>consul agent --help</code> 可以获取该命令的详细用法</p>
<h3 id="datacenter"><a href="#datacenter" class="headerlink" title="datacenter"></a>datacenter</h3><p>该参数指定该<code>agent</code>所在的数据中心名称。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-datacenter=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="advertise"><a href="#advertise" class="headerlink" title="advertise"></a>advertise</h3><p>该参数用来设置<code>advertise</code>所使用的地址。默认值和<code>-bind</code>指定的地址一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-advertise=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="advertise-wan"><a href="#advertise-wan" class="headerlink" title="advertise-wan"></a>advertise-wan</h3><p>设置广域网环境的的<code>advertise</code>地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-advertise-wan=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="bind"><a href="#bind" class="headerlink" title="-bind"></a>-bind</h3><p>设置集群通信所使用的IP地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bind=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="bootstrap"><a href="#bootstrap" class="headerlink" title="bootstrap"></a>bootstrap</h3><p>将Server设置为<code>boostrap</code>模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bootstrap</span><br></pre></td></tr></table></figure>
<h3 id="bootstrap-expect"><a href="#bootstrap-expect" class="headerlink" title="bootstrap-expect"></a>bootstrap-expect</h3><p>将Server设置为<code>expect boostrap</code>模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-bootstrap-expect=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>设置客户端访问所使用的IP地址。 该地址可用于RPC, DNS,HTTP,HTTPS通信使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-client=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="config-dir"><a href="#config-dir" class="headerlink" title="config-dir"></a>config-dir</h3><p>设置配置文件所在的目录的路径。consul会读取该目录下所有以<code>.json</code>结尾的文件作为配置文件，并且以文件名字典序来应用这些配置文件。</p>
<p>该参数可以多次使用，来指定多个配置文件目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-config-dir=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="config-file"><a href="#config-file" class="headerlink" title="config-file"></a>config-file</h3><p>指定配置文件路径，可以多次多次使用，用来指定多个配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-config-file=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="config-format"><a href="#config-format" class="headerlink" title="config-format"></a>config-format</h3><p>设置配置文件的格式。 <code>json</code>或<code>hcl</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-config-format=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="data-dir"><a href="#data-dir" class="headerlink" title="data-dir"></a>data-dir</h3><p>设置保存<code>agent</code>状态数据的目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-data-dir=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="dev"><a href="#dev" class="headerlink" title="dev"></a>dev</h3><p>该<code>agent</code>以开发模式运行。会输出详细的日子信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dev</span><br></pre></td></tr></table></figure>
<h3 id="disable-host-node-id"><a href="#disable-host-node-id" class="headerlink" title="disable-host-node-id"></a>disable-host-node-id</h3><p>该该选项设置为true, 则consul不会使用所在主机的信息生成集群结点id。 从而每次都生成一个随机值。<br>建议不要开始该选项。默认的结点id将会是主机名<code>hostname</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-disable-host-node-id</span><br></pre></td></tr></table></figure>
<h3 id="disable-keyring-file"><a href="#disable-keyring-file" class="headerlink" title="disable-keyring-file"></a>disable-keyring-file</h3><p>禁止将<code>keyring</code>备份到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-disable-keyring-file</span><br></pre></td></tr></table></figure>
<h3 id="dns-port"><a href="#dns-port" class="headerlink" title="dns-port"></a>dns-port</h3><p>设置DNS 查询所使用的端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dns-port=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>DNS 接口所使用的域名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-domain=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="enable-script-checks"><a href="#enable-script-checks" class="headerlink" title="enable-script-checks"></a>enable-script-checks</h3><p>启用健康检测脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-enable-script-checks</span><br></pre></td></tr></table></figure>
<h3 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt"></a>encrypt</h3><p>提供<code>gossip</code>广播加密数据所使用的key.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-encrypt=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="hcl"><a href="#hcl" class="headerlink" title="hcl"></a>hcl</h3><p><code>hcl</code> 配置片段。 可以多次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-hcl=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="http-port"><a href="#http-port" class="headerlink" title="http-port"></a>http-port</h3><p>设置http API 服务监听的端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-http-port=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>设置该<code>agent</code>启动时加入所在集群的成员IP地址。可以多次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-join=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="join-wan"><a href="#join-wan" class="headerlink" title="join-wan"></a>join-wan</h3><p>设置该<code>agent</code>启动时加入所在跨IDC集群的成员IP地址。可以多次使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-join-wan=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="log-level"><a href="#log-level" class="headerlink" title="log-level"></a>log-level</h3><p>设置<code>agent</code>的日志输出级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-log-level=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><p>设置该结点在集群中的名称，必须唯一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-node=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="node-id"><a href="#node-id" class="headerlink" title="node-id"></a>node-id</h3><p>设置该结点在集群中永恒的ID，默认是一个随机生成的值，并保存的数据目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-node-id=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="node-meta"><a href="#node-meta" class="headerlink" title="node-meta"></a>node-meta</h3><p>给该结点设置元数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-node-meta=&lt;key:value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="non-voting-server"><a href="#non-voting-server" class="headerlink" title="non-voting-server"></a>non-voting-server</h3><p>该选项使该Server不参于Raft协议的选举流程，仅仅进行数据同步。这样角色的结点主要用来扩展consul集群的读能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-non-voting-server</span><br></pre></td></tr></table></figure>
<h3 id="pid-file"><a href="#pid-file" class="headerlink" title="pid-file"></a>pid-file</h3><p>指定保存pid的文件路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-pid-file=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>设置协议版本。默认使用最新版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-protocol=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="raft-protocol"><a href="#raft-protocol" class="headerlink" title="raft-protocol"></a>raft-protocol</h3><p>设置Raft协议的版本。默认使用最新版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-raft-protocol=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="recursor"><a href="#recursor" class="headerlink" title="recursor"></a>recursor</h3><p>上游DNS服务器的地址。可以多次使用，指定多个地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-recursor=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="rejoin"><a href="#rejoin" class="headerlink" title="rejoin"></a>rejoin</h3><p>忽略上次的离开，并尝试从新加入集群。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rejoin</span><br></pre></td></tr></table></figure>
<h3 id="retry-interval"><a href="#retry-interval" class="headerlink" title="retry-interval"></a>retry-interval</h3><p>每次尝试重试加入集群的重试时间间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-interval=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="retry-interval-wan"><a href="#retry-interval-wan" class="headerlink" title="retry-interval-wan"></a>retry-interval-wan</h3><p>同样用来指定加入集群的重试时间间隔，不过针对的广域网。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-interval-wan=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="retry-join"><a href="#retry-join" class="headerlink" title="retry-join"></a>retry-join</h3><p>Address of an agent to join at start time with retries enabled. Can<br>be specified multiple times.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-join=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="retry-join-wan"><a href="#retry-join-wan" class="headerlink" title="retry-join-wan"></a>retry-join-wan</h3><p>Address of an agent to join -wan at start time with retries<br>enabled. Can be specified multiple times.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-join-wan=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="retry-max"><a href="#retry-max" class="headerlink" title="retry-max"></a>retry-max</h3><p>设置重试的最大次数。默认值是<code>0</code>, 意味着一直进行尝试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-max=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="retry-max-wan"><a href="#retry-max-wan" class="headerlink" title="retry-max-wan"></a>retry-max-wan</h3><p>设置重试的最大次数。针对的是广域网。默认值是<code>0</code>, 意味着一直进行尝试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-retry-max-wan=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="segment"><a href="#segment" class="headerlink" title="segment"></a>segment</h3><p>(企业级版本才有的功能) 设置加入的网络段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-segment=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="serf-lan-bind"><a href="#serf-lan-bind" class="headerlink" title="serf-lan-bind"></a>serf-lan-bind</h3><p>Address to bind Serf LAN listeners to.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-serf-lan-bind=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="serf-wan-bind"><a href="#serf-wan-bind" class="headerlink" title="serf-wan-bind"></a>serf-wan-bind</h3><p>Address to bind Serf WAN listeners to.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-serf-wan-bind=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="server"><a href="#server" class="headerlink" title="-server"></a>-server</h3><p>以<code>server</code>模式启动，默认是<code>client</code></p>
<h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>将日志输出到syslog.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-syslog</span><br></pre></td></tr></table></figure>
<h3 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h3><p>启用consul内置的静态wei UI服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ui</span><br></pre></td></tr></table></figure>
<h3 id="ui-dir"><a href="#ui-dir" class="headerlink" title="ui-dir"></a>ui-dir</h3><p>指定包含web界面的资源目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ui-dir=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h2 id="catalog"><a href="#catalog" class="headerlink" title="catalog"></a>catalog</h2><p>此命令具有与Consul目录交互的子命令。该目录不应与代理混淆，尽管API和回应可能类似。</p>
<p>以下是一些简单示例，并提供了更详细的示例在子命令或文档中。</p>
<p>列出所有数据中心</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul catalog datacenters</span><br></pre></td></tr></table></figure>
<p>列出所有结点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul catalog nodes</span><br></pre></td></tr></table></figure>
<p>列出所有服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul catalog services</span><br></pre></td></tr></table></figure>
<h2 id="event"><a href="#event" class="headerlink" title="event"></a>event</h2><p>跨数据中心发布自定义用户事件。 必须提供事件名称，但事件的内容是可选的。 </p>
<p>支持通过正则表达式，节点名称，服务名称，或标签进行过滤。</p>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>事件的名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-name=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h3 id="node-1"><a href="#node-1" class="headerlink" title="node"></a>node</h3><p>用来指定通过正则表达式过滤的节点名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-node=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>用来指定通过正则表达式过滤的服务名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-service=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>用来指定通过正则表达式过滤的服务的标签名称。必须和<code>-service</code>选项一起使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-tag=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>在远程Consul节点上执行命令。 节点的响应内容可以通过正则表达式进行过滤。</p>
<p>可用的选项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-node=&lt;string&gt;</span><br><span class="line"></span><br><span class="line">Regular expression to filter on node names.</span><br><span class="line"></span><br><span class="line">-prefix=&lt;string&gt;</span><br><span class="line"></span><br><span class="line">Prefix in the KV store to use for request data.</span><br><span class="line"></span><br><span class="line">-service=&lt;string&gt;</span><br><span class="line"></span><br><span class="line">Regular expression to filter on service instances.</span><br><span class="line"></span><br><span class="line">-shell</span><br><span class="line"></span><br><span class="line">Use a shell to run the command.</span><br><span class="line"></span><br><span class="line">-tag=&lt;string&gt;</span><br><span class="line"></span><br><span class="line">Regular expression to filter on service tags. Must be used with</span><br><span class="line">-service.</span><br><span class="line"></span><br><span class="line">-verbose</span><br><span class="line"></span><br><span class="line">Enables verbose output.</span><br><span class="line"></span><br><span class="line">-wait=&lt;duration&gt;</span><br><span class="line"></span><br><span class="line">Period to wait with no responses before terminating execution.</span><br><span class="line"></span><br><span class="line">-wait-repl=&lt;duration&gt;</span><br><span class="line"></span><br><span class="line">Period to wait for replication before firing event. This is an</span><br><span class="line">optimization to allow stale reads to be performed.</span><br></pre></td></tr></table></figure>
<h2 id="leave"><a href="#leave" class="headerlink" title="leave"></a>leave</h2><p>将一个结点优雅进入<code>leave</code>状态，并关闭。</p>
<h2 id="force-leave"><a href="#force-leave" class="headerlink" title="force-leave"></a>force-leave</h2><p>强制一个集群的节点进入<code>left</code>状态。</p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>提供操作命令的调试信息。</p>
<h2 id="join-1"><a href="#join-1" class="headerlink" title="join"></a>join</h2><p>使一个运行中的agent加入到集群中。</p>
<h3 id="wan"><a href="#wan" class="headerlink" title="wan"></a>wan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-wan</span><br></pre></td></tr></table></figure>
<h2 id="keygen"><a href="#keygen" class="headerlink" title="keygen"></a>keygen</h2><p>生成一个新的加密用的key，用来供agent对网络流量就行加密。  </p>
<h2 id="keyring"><a href="#keyring" class="headerlink" title="keyring"></a>keyring</h2><p>管理用来加密<code>gossip</code>消息的秘钥。<code>Gossip</code>加密是可以选的。当启用<code>Gossip</code>加密，该命令可以用来检查集群中处于激活状态下的加密key，添加新的key，删除老的key。把这些功能结合起来，就可以实现不破坏集群的前提下，更新加密秘钥的功能。</p>
<p>该命令提供的所有操作都只能在<code>Server</code>模式的结点上执行， 并且影响范围包括<code>LAN</code>和<code>WAN</code>。</p>
<p>当所有结点正确返回时，该命令输出:0, 否则其他任何情况都输出1。</p>
<p>该命令的选项如下：</p>
<h3 id="install"><a href="#install" class="headerlink" title="install"></a>install</h3><p>安装一个新的秘钥，并广播到集群的所有结点中。秘钥的格式是base64的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-install=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出所有正在集群中使用的秘钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-list</span><br></pre></td></tr></table></figure>
<h3 id="relay-factor"><a href="#relay-factor" class="headerlink" title="relay-factor"></a>relay-factor</h3><p>Setting this to a non-zero value will cause nodes to relay their<br>response to the operation through this many randomly-chosen other<br>nodes in the cluster. The maximum allowed value is 5.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-relay-factor=&lt;int&gt;</span><br></pre></td></tr></table></figure>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>从集群中删除秘钥。 该操作只能针对哪些当前不是主秘钥的秘钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-remove=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><p>Change the primary encryption key, which is used to encrypt<br>messages. The key must already be installed before this operation<br>can succeed.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-use=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h2 id="kv"><a href="#kv" class="headerlink" title="kv"></a>kv</h2><p>该命令包含一些操作Consul K-V 存储的子命令。</p>
<p>下面是一些简单的例子：</p>
<p>创建或更新一个名称为<code>redis/config/connections</code>，值为5的键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul kv put redis/config/connections 5</span><br></pre></td></tr></table></figure>
<p>获取该键值对的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul kv get redis/config/connections</span><br></pre></td></tr></table></figure>
<p>获取该键值对的详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul kv get -detailed redis/config/connections</span><br></pre></td></tr></table></figure>
<p>删除该键值对</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul kv delete redis/config/connections</span><br></pre></td></tr></table></figure>
<h3 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h3><p>delete    Removes data from the KV store<br>export    Exports a tree from the KV store as JSON<br>get       Retrieves or lists data from the KV store<br>import    Imports a tree stored as JSON to the KV store<br>put       Sets or updates data in the KV store</p>
<h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>Acquires a lock or semaphore at a given path, and invokes a child process<br>when successful. The child process can assume the lock is held while it<br>executes. If the lock is lost or communication is disrupted the child<br>process will be sent a SIGTERM signal and given time to gracefully exit.<br>After the grace period expires the process will be hard terminated.</p>
<p>For Consul agents on Windows, the child process is always hard terminated<br>with a SIGKILL, since Windows has no POSIX compatible notion for SIGTERM.</p>
<p>When -n=1, only a single lock holder or leader exists providing mutual<br>exclusion. Setting a higher value switches to a semaphore allowing multiple<br>holders to coordinate.</p>
<p>The prefix provided must have write privileges.</p>
<h2 id="maint"><a href="#maint" class="headerlink" title="maint"></a>maint</h2><p>该命令的作用是将节点或服务置于维护模式。在维护模式下，无论通过DNS查询还是HTTP接口，都不再返回节点或服务的信息。命令有效地将其从可用池中取出节点。该命令的执行原理是通过注册节点或服务的健康检查来完成的。</p>
<p>为节点或服务启用维护模式时，你可以选择指定一个字符串来表明原因。该字符串将出现在“Notes”字段中<br>对节点或注册的重要健康检查服务。如果没有提供原因，将使用默认值。</p>
<p>维护模式是持久的，并且会在agent重启启动的时候恢复。 因此，在将给定节点或服务将被放回可以池中之前需要禁用维护模式。</p>
<p>默认情况下，我们将一个节点作为一个整体进行操作。通过指定<code>-service</code>参数，可以操作具体的服务。</p>
<p>如果没有给出参数，将显示agent的维护状态。如果当前没有任何维护，则返回空白。</p>
<h3 id="disable"><a href="#disable" class="headerlink" title="disable"></a>disable</h3><p>禁用维护模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-disable</span><br></pre></td></tr></table></figure>
<h3 id="enable"><a href="#enable" class="headerlink" title="enable"></a>enable</h3><p>启用维护模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-enable</span><br></pre></td></tr></table></figure>
<h3 id="reason"><a href="#reason" class="headerlink" title="reason"></a>reason</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-reason=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<p>指定本次操作的原因描述信息</p>
<h3 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h3><p>指定操作的服务ID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-service=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<h2 id="members"><a href="#members" class="headerlink" title="members"></a>members</h2><p>该命令的作用是：输出集群成员信息</p>
<p>可用的参数有：</p>
<h3 id="detailed"><a href="#detailed" class="headerlink" title="-detailed"></a>-detailed</h3><p>输出更详细的节点信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">consul members -detailed</span><br><span class="line">Node   Address         Status  Tags</span><br><span class="line">bogon  127.0.0.1:8301  alive   build=1.0.2:b55059f,dc=dc1,id=fc1742c4-d97b-8a5b-ff3c-ab11941e2fea,port=8300,raft_vsn=3,role=consul,segment=&lt;all&gt;,vsn=2,vsn_max=3,vsn_min=2,wan_join_port=8302</span><br></pre></td></tr></table></figure>
<h3 id="segment-1"><a href="#segment-1" class="headerlink" title="segment"></a>segment</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-segment=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<p>企业级版本才有的功能。 可以只输出所属segment的结点信息。</p>
<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-status=&lt;string&gt;</span><br></pre></td></tr></table></figure>
<p>根据状态进行过滤需要输出的结点。</p>
<h3 id="wan-1"><a href="#wan-1" class="headerlink" title="wan"></a>wan</h3><p>如果agent允许在server模式下，该选项可以输出其它在<code>WAN</code>广域网的节点信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-wan</span><br></pre></td></tr></table></figure>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>显示Consul agent 的最近日志消息，并连接到agent，实时输出agent上日志消息。 而且可以通过参数来指定需要查看的日志级别。默认输出的是DEBUG级别的日志。</p>
<h2 id="operator"><a href="#operator" class="headerlink" title="operator"></a>operator</h2><p>该命令提供了Consul集群级别的操作能力， 在使用时需要非常小心。使用不当有可能造成，节点数据过期或数据丢失。</p>
<p>子命令如下：</p>
<h3 id="autopilot"><a href="#autopilot" class="headerlink" title="autopilot"></a>autopilot</h3><p><code>autopilot</code> 命令用于与Consul的<code>autopilot</code>子系统进行交互。 该命令可用于查看或修改当前配置。</p>
<h4 id="get-config"><a href="#get-config" class="headerlink" title="get-config"></a>get-config</h4><p>显示当前的自动驾驶仪配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">consul operator autopilot get-config</span><br><span class="line">CleanupDeadServers = true</span><br><span class="line">LastContactThreshold = 200ms</span><br><span class="line">MaxTrailingLogs = 250</span><br><span class="line">ServerStabilizationTime = 10s</span><br><span class="line">RedundancyZoneTag = &quot;&quot;</span><br><span class="line">DisableUpgradeMigration = false</span><br><span class="line">UpgradeVersionTag = &quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="set-config"><a href="#set-config" class="headerlink" title="set-config"></a>set-config</h4><p>修改当前的自动驾驶仪配置</p>
<h3 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h3><h4 id="list-peers"><a href="#list-peers" class="headerlink" title="list-peers"></a>list-peers</h4><p>Display the current Raft peer configuration</p>
<h4 id="remove-peer"><a href="#remove-peer" class="headerlink" title="remove-peer"></a>remove-peer</h4><p>Remove a Consul server from the Raft configuration</p>
<h2 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h2><p>该命令的作用是重新加载配置文件，以此来替代<code>SIGHUP</code>信号。</p>
<h2 id="rtt"><a href="#rtt" class="headerlink" title="rtt"></a>rtt</h2><p><code>rtt</code>命令的用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: consul rtt [options] node1 [node2]</span><br></pre></td></tr></table></figure>
<p>该命令的作用是：预估2个结点间一次通信的耗时状况的。至少需要提供一个节点名称。如果只提供了一个节点的名称，<br>则第二个结点的名称默认就是agent所在的结点名称。</p>
<blockquote>
<p>需要注意的是：这些节点名称和<code>consul members</code>输出中的结点名称相同，不是一个IP地址。</p>
</blockquote>
<p>默认情况下，都是假设2个节点在同一个数据中心内，并使用局域网的网络协调器。如果有<code>-wan</code>参数，那么使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consul rtt -wan bogon.dc1</span><br><span class="line">Estimated bogon.dc1 &lt;-&gt; bogon.dc1 rtt: 0.020 ms (using WAN coordinates)</span><br></pre></td></tr></table></figure>
<p>节点的名称后面需要添加所属数据中心的名称。</p>
<p>该命令不能用来测量局域网和广域网2个节点间的网络通信耗时，因为他们位于不同的<code>gossip</code>域。</p>
<p>该命令可以使用的参数如下：</p>
<h3 id="ca-file"><a href="#ca-file" class="headerlink" title="ca-file"></a>ca-file</h3><p>指定TLS通信是使用的<code>CA</code>文件。 该选项的值也可以通过环境变量<code>CONSUL_CACERT</code>的值获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ca-file=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ca-path"><a href="#ca-path" class="headerlink" title="ca-path"></a>ca-path</h3><p>指定TLS通信是使用的<code>CA</code>文件所在的目录。 该选项的值也可以通过环境变量<code>CONSUL_CAPATH</code>的值获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-ca-path=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="client-cert"><a href="#client-cert" class="headerlink" title="client-cert"></a>client-cert</h3><p>指定在使用TLS进行通信时，并且启用了<code>verify_incoming</code>功能时，客户端所使用的证书文件，<br>也可以通过环境变量<code>CONSUL_CLIENT_CERT</code> 来指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-client-cert=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="client-key"><a href="#client-key" class="headerlink" title="client-key"></a>client-key</h3><p>指定在使用TLS进行通信时，并且启用了<code>verify_incoming</code>功能时，客户端所使用的key文件。也可以通过环境变量<code>CONSUL_CLIENT_KEY</code> 来指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-client-key=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="http-addr"><a href="#http-addr" class="headerlink" title="http-addr"></a>http-addr</h3><p>指定提供http服务的Consul agent 的IP地址和端口号。也可以通过环境变量<code>CONSUL_HTTP_ADDR</code>的值来指定。</p>
<p>默认的值是：<code>http://127.0.0.1:8500</code>。 也可以通过设置环境变量<code>CONSUL_HTTP_SSL=true</code>来启用https进行通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-http-addr=&lt;address&gt;</span><br></pre></td></tr></table></figure>
<h3 id="tls-server-name"><a href="#tls-server-name" class="headerlink" title="tls-server-name"></a>tls-server-name</h3><p>指定当通过TLS进行通信时作为<code>SNI</code>主机的服务器名称。也可以通过<code>CONSUL_TLS_SERVER_NAME</code>环境变量来指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-tls-server-name=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-token=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<p>指定请求中使用的ACL token的值。也可以通过环境变量<code>CONSUL_HTTP_TOKEN</code>来指定。如果没有指定，则使用通过http 访问Consul agent 所使用的token值。</p>
<h3 id="wan-2"><a href="#wan-2" class="headerlink" title="wan"></a>wan</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-wan</span><br></pre></td></tr></table></figure>
<p>使用广域网协调器来替代局域网协调器。</p>
<h2 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h2><p>该命令包含一些子命令，作用是保存，重新加载 或在故障恢复时检查 Consul Server 的状态。</p>
<p>这些操作都是原子性的，保存当前时间点 包括<code>键/值条目</code>，<code>服务目录</code>，<code>准备好的查询</code>，<code>会话和ACL</code>信息的快照。</p>
<p>如果启用了<code>ACLS</code>功能，那么在使用这些子命令时，需要提供管理token来进行快照的操作。</p>
<h3 id="创建一个快照"><a href="#创建一个快照" class="headerlink" title="创建一个快照"></a>创建一个快照</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ consul snapshot save backup.snap</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">### 从快照中恢复</span><br></pre></td></tr></table></figure>
<p>$ consul snapshot restore backup.snap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先启动一个没有任何数据的agent,然后执行该命令，加载指定的快照信息。</span><br><span class="line"></span><br><span class="line">### 检查快照信息</span><br></pre></td></tr></table></figure></p>
<p>$ consul snapshot inspect backup.snap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出：</span><br></pre></td></tr></table></figure></p>
<p>leo@bogon consul snapshot inspect a.snap<br>ID           2-110-1532832078752<br>Size         1175<br>Index        110<br>Term         2<br>Version      1<br>```</p>
<p>可以允许一个Consul agent, 每小时保存一次快照信息。 不过该功能只有企业级版本才有。</p>
<h2 id="validate"><a href="#validate" class="headerlink" title="validate"></a>validate</h2><p>校验consul配置文件，或配置文件目录下配置文件的正确性</p>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>打印consul的版本</p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;consul-命令用法&quot;&gt;&lt;a href=&quot;#consul-命令用法&quot; class=&quot;headerlink&quot; title=&quot;consul 命令用法&quot;&gt;&lt;/a&gt;consul 命令用法&lt;/h2&gt;&lt;p&gt;安装完consul后，通过在控制台直接实现&lt;code&gt;consul&lt;/code&gt;命令了解consul命令行的用法，输出如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Usage: consul [--version] [--help] &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Available commands are:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;agent          Runs a Consul agent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;catalog        Interact with the catalog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;event          Fire a new event&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exec           Executes a command on Consul nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;force-leave    Forces a member of the cluster to enter the &quot;left&quot; state&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;info           Provides debugging information for operators.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;join           Tell Consul agent to join cluster&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;keygen         Generates a new encryption key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;keyring        Manages gossip layer encryption keys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kv             Interact with the key-value store&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;leave          Gracefully leaves the Consul cluster and shuts down&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lock           Execute a command holding a lock&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;maint          Controls node or service maintenance mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;members        Lists the members of a Consul cluster&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;monitor        Stream logs from a Consul agent&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator       Provides cluster-level tools for Consul operators&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reload         Triggers the agent to reload configuration files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rtt            Estimates network round trip time between nodes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;snapshot       Saves, restores and inspects snapshots of Consul server state&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;validate       Validate config files/directories&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;version        Prints the Consul version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;watch          Watch for changes in Consul&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上所示， consul提供的命令很多，下面就逐个学习下每个命令的作用和用法。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://leokongwq.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="consul" scheme="https://leokongwq.github.io/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>servlet如何正确处理302跳转</title>
    <link href="https://leokongwq.github.io/2018/07/15/how-to-process-302-in-j2ee-correctly.html"/>
    <id>https://leokongwq.github.io/2018/07/15/how-to-process-302-in-j2ee-correctly.html</id>
    <published>2018-07-15T02:08:31.000Z</published>
    <updated>2018-11-03T04:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某天，将线上的resin容器替换为tomcat．　过了一段时间发现有个接口处理失败，提示异常．查看应用日志发现如下的日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caused by: javax.servlet.ServletException: java.lang.IllegalStateException: Cannot create a session after the response has been committed</span><br><span class="line">        at org.apache.jsp.WEB_002dINF.content.order.page.error_jsp._jspService(error_jsp.java:<span class="number">293</span>) ~[na:na]</span><br><span class="line">        at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:<span class="number">70</span>) ~[jasper.jar:<span class="number">8.5</span>.12]</span><br><span class="line">        at javax.servlet.http.HttpServlet.service(HttpServlet.java:<span class="number">742</span>) ~[servlet-api.jar:na]</span><br><span class="line">        at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:<span class="number">443</span>) ~[jasper.jar:<span class="number">8.5</span>.12]</span><br><span class="line">        ... <span class="number">38</span> common frames omitted</span><br></pre></td></tr></table></figure>
<p>查询相关接口的代码发现，代码对<code>302</code>跳转的逻辑处理有问题，具体如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Actions</span>(value = &#123;</span><br><span class="line">            <span class="meta">@Action</span>(value = <span class="string">"dopay"</span>, results = &#123;<span class="meta">@Result</span>(name = ERROR, location = <span class="string">"/WEB-INF/content/order/page/error.jsp"</span>)&#125;),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="meta">@ActionMonitor</span>(value = <span class="string">"pay.doPay"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doPay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">        String _result = dealWapClient(params);</span><br><span class="line">        <span class="comment">// 问题之所在，　当dealWapClient处理成功时，返回值就是null</span></span><br><span class="line">        <span class="comment">// 此时，返回ERROR， Struts2会继续执行，渲染错误页面(客户端就能看到错误页面了)</span></span><br><span class="line">        <span class="comment">// tomcat 能看到，　resin下看不到，原因下面分析</span></span><br><span class="line">        <span class="keyword">if</span> (_result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dealWapClient</span><span class="params">(Map&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">        redirect(returnParams, returnUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="302跳转解释"><a href="#302跳转解释" class="headerlink" title="302跳转解释"></a>302跳转解释</h3><p>关于302临时跳转的详细解释可以参考<a href="https://zh.wikipedia.org/wiki/HTTP_302" target="_blank" rel="noopener">HTTP_302</a>.<br>也可以参考RFC规范<a href="http://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3986.txt</a><br>再次就不再赘述．</p>
<h3 id="servlet-api对302处理的规定"><a href="#servlet-api对302处理的规定" class="headerlink" title="servlet　api对302处理的规定"></a>servlet　api对302处理的规定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sends a temporary redirect response to the client using the</span></span><br><span class="line"><span class="comment">* specified redirect location URL and clears the buffer. The buffer will</span></span><br><span class="line"><span class="comment">* be replaced with the data set by this method. Calling this method sets the</span></span><br><span class="line"><span class="comment">* status code to &#123;<span class="doctag">@link</span> #SC_FOUND&#125; 302 (Found).</span></span><br><span class="line"><span class="comment">* This method can accept relative URLs;the servlet container must convert</span></span><br><span class="line"><span class="comment">* the relative URL to an absolute URL</span></span><br><span class="line"><span class="comment">* before sending the response to the client. If the location is relative </span></span><br><span class="line"><span class="comment">* without a leading '/' the container interprets it as relative to</span></span><br><span class="line"><span class="comment">* the current request URI. If the location is relative with a leading</span></span><br><span class="line"><span class="comment">* '/' the container interprets it as relative to the servlet container root.</span></span><br><span class="line"><span class="comment">* If the location is relative with two leading '/' the container interprets</span></span><br><span class="line"><span class="comment">* it as a network-path reference (see</span></span><br><span class="line"><span class="comment">* &lt;a href="http://www.ietf.org/rfc/rfc3986.txt"&gt;</span></span><br><span class="line"><span class="comment">* RFC 3986: Uniform Resource Identifier (URI): Generic Syntax&lt;/a&gt;, section 4.2</span></span><br><span class="line"><span class="comment">* &amp;quot;Relative Reference&amp;quot;).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;If the response has already been committed, this method throws </span></span><br><span class="line"><span class="comment">* an IllegalStateException.</span></span><br><span class="line"><span class="comment">* After using this method, the response should be considered</span></span><br><span class="line"><span class="comment">* to be committed and should not be written to.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>		location	the redirect location URL</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span>	IOException	If an input or output exception occurs</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span>	IllegalStateException	If the response was committed or</span></span><br><span class="line"><span class="comment">*              if a partial URL is given and cannot be converted into a valid URL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>翻译过来意思就是： 通过该方法告诉客户端临时重定向到一个指定的URL，并且清空缓存区，之前还没有发送到客户端的数据．<br>并使用该方法设置的数据填充缓存区．<br>该方法设置http响应的状态码为302.<br>如果重定向的地址为相对地址，该方法内部会将相对地址转为绝对地址．　<br>如果response已经committed，再次调用该方法会抛出<code>IllegalStateException</code>异常.<br>调用该方法后，　response对象的状态应该是<code>committed</code>，并且不应该再写入数据．</p>
</blockquote>
<p>servlet-api已经详细说明了该方法的用法和需要注意的事项．但是不同的servlet容器在实现机制上可能不尽相同．<br>项目中发现的问题主要有两个原因：</p>
<ol>
<li>代码有bug．这个是主要原因．</li>
<li>servlet容器实现不同．</li>
</ol>
<p>下面就分析下该方法在resin和tomcat中实现的细节：</p>
<h3 id="resin对302的处理"><a href="#resin对302的处理" class="headerlink" title="resin对302的处理"></a>resin对302的处理</h3><p>在resin中，<code>HttpServletResponse</code>接口的实现类是<code>HttpServletResponseImpl</code>．代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCauchoResponse</span> <span class="keyword">implements</span> <span class="title">CauchoResponse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CauchoResponse</span> <span class="keyword">extends</span> <span class="title">HttpServletResponse</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletResponseImpl</span> <span class="keyword">extends</span> <span class="title">AbstractCauchoResponse</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">CauchoResponse</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sends a redirect to the browser.  If the URL is relative, it gets</span></span><br><span class="line"><span class="comment">   * combined with the current url.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url the possibly relative url to send to the browser</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCommitted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(L.l(<span class="string">"Can't sendRedirect() after data has committed to the client."</span>));</span><br><span class="line"></span><br><span class="line">    _responseStream.clearBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// server/10c4</span></span><br><span class="line">    <span class="comment">// reset();</span></span><br><span class="line">    resetBuffer();</span><br><span class="line"></span><br><span class="line">    setStatus(SC_MOVED_TEMPORARILY);</span><br><span class="line"></span><br><span class="line">    String encoding = getCharacterEncoding();</span><br><span class="line">    <span class="keyword">boolean</span> isLatin1 = <span class="string">"iso-8859-1"</span>.equals(encoding);</span><br><span class="line">    </span><br><span class="line">    String path = encodeAbsoluteRedirect(url);</span><br><span class="line"></span><br><span class="line">    setHeader(<span class="string">"Location"</span>, path);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isLatin1)</span><br><span class="line">      setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=iso-8859-1"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      setHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/html; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    String msg = <span class="string">"The URL has moved &lt;a href=\""</span> + path + <span class="string">"\"&gt;here&lt;/a&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The data is required for some WAP devices that can't handle an</span></span><br><span class="line">    <span class="comment">// empty response.</span></span><br><span class="line">    <span class="keyword">if</span> (_writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _writer.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ServletOutputStream out = getOutputStream();</span><br><span class="line">      out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// closeConnection();</span></span><br><span class="line"></span><br><span class="line">    _request.saveSession(); <span class="comment">// #503</span></span><br><span class="line">    <span class="comment">// 非常重要，这个就是resion和tomcat的不同之处．</span></span><br><span class="line">    <span class="comment">// 已经关闭了，肯定不能再写入数据．</span></span><br><span class="line">    close();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// tck - jsp include</span></span><br><span class="line">    AbstractHttpResponse response = _response;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">      response.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resin处理`<span class="number">302</span>`方式其实非常简单，步骤如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 清空缓存区内容并进行重置</span><br><span class="line"><span class="number">2</span>. 设置<span class="number">302</span>状态码</span><br><span class="line"><span class="number">3</span>. 设置`Location`　和　`Content-Type` 响应头</span><br><span class="line"><span class="number">4</span>. 写响应体数据</span><br><span class="line"><span class="number">5</span>. 保存session</span><br><span class="line"><span class="number">6</span>. 关闭连接</span><br><span class="line"></span><br><span class="line">整个处理流程非常简单明了．</span><br><span class="line"></span><br><span class="line">### tomcat对302的处理</span><br><span class="line"></span><br><span class="line">在tomcat中，`HttpServletResponse`接口的实现类是`ResponseFacade`．该类指示一个Facade,</span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">```java ResponseFacade</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseFacade</span> <span class="keyword">implements</span> <span class="title">HttpServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCommitted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException</span><br><span class="line">                (sm.getString(<span class="string">"coyoteResponse.sendRedirect.ise"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setAppCommitted(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        response.sendRedirect(location);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的处理由<code>Response</code>来进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> <span class="keyword">implements</span> <span class="title">HttpServletResponse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Send a temporary redirect to the specified redirect location URL.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> location Location URL to redirect to</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IllegalStateException if this response has</span></span><br><span class="line"><span class="comment">    *  already been committed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span> IOException if an input/output error occurs</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        sendRedirect(location, SC_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal method that allows a redirect to be sent with a status other</span></span><br><span class="line"><span class="comment">     * than &#123;<span class="doctag">@link</span> HttpServletResponse#SC_FOUND&#125; (302). No attempt is made to</span></span><br><span class="line"><span class="comment">     * validate the status code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location Location URL to redirect to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status HTTP status code that will be sent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException an IO exception occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRedirect</span><span class="params">(String location, <span class="keyword">int</span> status)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCommitted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">"coyoteResponse.sendRedirect.ise"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ignore any call from an included servlet</span></span><br><span class="line">        <span class="keyword">if</span> (included) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空缓存区内容并进行重置</span></span><br><span class="line">        resetBuffer(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a temporary redirect to the specified location</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String locationUri;</span><br><span class="line">            <span class="comment">// Relative redirects require HTTP/1.1</span></span><br><span class="line">            <span class="keyword">if</span> (getRequest().getCoyoteRequest().getSupportsRelativeRedirects() &amp;&amp;</span><br><span class="line">                    getContext().getUseRelativeRedirects()) &#123;</span><br><span class="line">                locationUri = location;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                locationUri = toAbsolute(location);</span><br><span class="line">            &#125;</span><br><span class="line">            setStatus(status);</span><br><span class="line">            setHeader(<span class="string">"Location"</span>, locationUri);</span><br><span class="line">            <span class="comment">//　这里有个小魔法</span></span><br><span class="line">            <span class="keyword">if</span> (getContext().getSendRedirectBody()) &#123;</span><br><span class="line">                PrintWriter writer = getWriter();</span><br><span class="line">                writer.print(sm.getString(<span class="string">"coyoteResponse.sendRedirect.note"</span>,</span><br><span class="line">                        Escape.htmlElementContent(locationUri)));</span><br><span class="line">                flushBuffer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"response.sendRedirectFail"</span>, location), e);</span><br><span class="line">            setStatus(SC_NOT_FOUND);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置缓存区的suspended标志位　</span></span><br><span class="line">        <span class="comment">// 从应用视图的角度看，该响应已经结束了． 但其实连接并没有关闭.</span></span><br><span class="line">        setSuspended(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tomcat处理<code>302</code>步骤如下：</p>
<ol>
<li>清空缓存区内容并进行重置</li>
<li>设置302状态码</li>
<li>设置<code>Location</code> 响应头</li>
<li>写响应体数据</li>
<li>保存session</li>
<li>关闭连接</li>
</ol>
<h4 id="tomcat-context配置"><a href="#tomcat-context配置" class="headerlink" title="tomcat context配置"></a>tomcat context配置</h4><p>详细配置项参考:<a href="https://tomcat.apache.org/tomcat-7.0-doc/config/context.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-7.0-doc/config/context.html</a></p>
<p>其中和302处理相关的一个配置项为:<code>sendRedirectBody</code>,文档解释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If <span class="keyword">true</span>, redirect responses will include a <span class="keyword">short</span> response body that includes details of the redirect as recommended by RFC <span class="number">2616</span>. This is disabled by <span class="keyword">default</span> since including a response body may cause problems <span class="keyword">for</span> some application component such as compression filters.</span><br></pre></td></tr></table></figure>
<p>根据<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC 2616</a>规范，302跳转是可以带有响应体数据的(resin就按规范进行了实现).　tomcat默认处理是不带的，原因是可能与其它组件冲突，例如压缩组件.</p>
<p>如果将<code>sendRedirectBody</code>的值设为true,则tomcat在处理302时，在写完响应体数据后，会执行缓存区的刷新，客户端能收到对应的响应头数据，完成跳转，且不会应为后续继续写数据导致客户端不能正常跳转.</p>
<p>因为默认是false,导致302响应头数据没有及时发送给客户端，在<code>sendRedirect</code>后如果应用发生了异常，则已经设置了的302响应码会被500所替代，客户端不能正常跳转．</p>
<p>###　tomcat　<code>sendRedirect</code>后不能跳转的逻辑分析</p>
<p>tomcat　处理请求的流程一部分流程如下：</p>
<p><code>StandardHostValve</code> -&gt; <code>StandardContextValve</code> -&gt; <code>StandardWrapperValve</code></p>
<p>请求入口由<code>StandardWrapperValve</code>处理，　结束还是需要<code>StandardHostValve</code>来处理．</p>
<figure class="highlight java"><figcaption><span>StandardWrapperValve</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a servlet instance to process this request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        </span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//　当请求发送异常时, 已经设置的302状态码此时变为500</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">(Request request, Response response,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Throwable exception)</span> </span>&#123;</span><br><span class="line">        request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, exception);</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        response.setError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StandardHostValve　处理逻辑</p>
<figure class="highlight java"><figcaption><span>StandardHostValve</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 省略代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!asyncAtStart || asyncDispatching) &#123;</span><br><span class="line">                context.getPipeline().getFirst().invoke(request, response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Make sure this request/response is here because an error</span></span><br><span class="line">                <span class="comment">// report is required.</span></span><br><span class="line">                <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(sm.getString(<span class="string">"standardHost.asyncStateError"</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            container.getLogger().error(<span class="string">"Exception Processing "</span> + request.getRequestURI(), t);</span><br><span class="line">            <span class="comment">// If a new error occurred while trying to report a previous</span></span><br><span class="line">            <span class="comment">// error allow the original error to be reported.</span></span><br><span class="line">            <span class="keyword">if</span> (!response.isErrorReportRequired()) &#123;</span><br><span class="line">                request.setAttribute(RequestDispatcher.ERROR_EXCEPTION, t);</span><br><span class="line">                throwable(request, response, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在sendRedirect方法设置的suspended标志位此时又被置为false</span></span><br><span class="line">        <span class="comment">// 也就是说　response由可以使用了．这就是resin和tomcat设计实现的不同        </span></span><br><span class="line">        <span class="comment">// Now that the request/response pair is back under container</span></span><br><span class="line">        <span class="comment">// control lift the suspension so that the error handling can</span></span><br><span class="line">        <span class="comment">// complete and/or the container can flush any remaining data</span></span><br><span class="line">        response.setSuspended(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Throwable t = (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Protect against NPEs if the context was destroyed during a</span></span><br><span class="line">        <span class="comment">// long running request.</span></span><br><span class="line">        <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Look for (and render if found) an application level error page</span></span><br><span class="line">        <span class="keyword">if</span> (response.isErrorReportRequired()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                throwable(request, response, t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.isAsync() &amp;&amp; !asyncAtStart) &#123;</span><br><span class="line">            context.fireRequestDestroyEvent(request.getRequest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Access a session (if present) to update last accessed time, based</span></span><br><span class="line">        <span class="comment">// on a strict interpretation of the specification</span></span><br><span class="line">        <span class="keyword">if</span> (ACCESS_SESSION) &#123;</span><br><span class="line">            request.getSession(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.unbind(Globals.IS_SECURITY_ENABLED, MY_CLASSLOADER);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>线上替换应用组件，尤其是底层的应用软件需要非常注意．不可全量替换．一定要逐步替换．虽然已经在测试环境，线上灰度替换了一台机器，<br>但是因为访问量小，导致问题发现的比较晚，直至大批量替换才发现问题．　还有就是：同一个规范，但不同的实现细节还是有差异．</li>
<li>应用开发一定需要遵守API规范，否则会导致奇怪问题的发生．好多人总是说遇到的问题多，踩坑多，那是因为你从来不仔细阅读相关api规范文档或官方文档．不遵守规范导致的问题能叫坑吗？</li>
<li>在使用任何一项技术时，优先查询官方文档．不要随手google或baidu．　实话说，网上的文章质量参差不齐，难免找到理解错误的文档．</li>
<li>养成阅读源代码的习惯，好处不言而喻．如果３年前没有读过tomcat6的源代码，今天排查起来问题就非常困难了.</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zh.wikipedia.org/wiki/HTTP_302" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/HTTP_302</a><br><a href="https://tools.ietf.org/html/rfc2616#section-10.3.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2616#section-10.3.3</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;某天，将线上的resin容器替换为tomcat．　过了一段时间发现有个接口处理失败，提示异常．查看应用日志发现如下的日志：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: javax.servlet.ServletException: java.lang.IllegalStateException: Cannot create a session after the response has been committed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at org.apache.jsp.WEB_002dINF.content.order.page.error_jsp._jspService(error_jsp.java:&lt;span class=&quot;number&quot;&gt;293&lt;/span&gt;) ~[na:na]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:&lt;span class=&quot;number&quot;&gt;70&lt;/span&gt;) ~[jasper.jar:&lt;span class=&quot;number&quot;&gt;8.5&lt;/span&gt;.12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at javax.servlet.http.HttpServlet.service(HttpServlet.java:&lt;span class=&quot;number&quot;&gt;742&lt;/span&gt;) ~[servlet-api.jar:na]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:&lt;span class=&quot;number&quot;&gt;443&lt;/span&gt;) ~[jasper.jar:&lt;span class=&quot;number&quot;&gt;8.5&lt;/span&gt;.12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ... &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt; common frames omitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查询相关接口的代码发现，代码对&lt;code&gt;302&lt;/code&gt;跳转的逻辑处理有问题，具体如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="https://leokongwq.github.io/tags/web/"/>
    
      <category term="tomcat" scheme="https://leokongwq.github.io/tags/tomcat/"/>
    
      <category term="resin" scheme="https://leokongwq.github.io/tags/resin/"/>
    
  </entry>
  
  <entry>
    <title>consul之acl配置</title>
    <link href="https://leokongwq.github.io/2018/07/08/consul-acl.html"/>
    <id>https://leokongwq.github.io/2018/07/08/consul-acl.html</id>
    <published>2018-07-08T15:08:31.000Z</published>
    <updated>2018-11-03T04:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="acl-datacenter"><a href="#acl-datacenter" class="headerlink" title="acl_datacenter"></a>acl_datacenter</h3><p>该配置项指定了对ACL信息具有权威性的数据中心。 必须提供它才能启用ACL。 所有Server实例和数据中心必须就ACL数据中心达成一致。<br>必须在整个集群的Server节点上设置该配置项。但是针对API来说，如果要使客户端的请求能被正确转发，那么也需要在客户端节点设置。<br>在Consul 0.8及更高版本中，还可以启用代理级别的ACL。 有关详细信息，请参阅<a href="https://www.consul.io/docs/guides/acl.html" target="_blank" rel="noopener">ACL指南</a>。</p>
<h3 id="acl-default-policy"><a href="#acl-default-policy" class="headerlink" title="acl_default_policy"></a>acl_default_policy</h3><p>该配置项可选的值为<code>allow</code>和<code>deny</code>。默认值为’allow’。默认的策略控制token在没有匹配的规则时的行为。<br>在<code>allow</code>模式下，ACL规则是一个黑名单：任何没有被禁止的操作都是可以执行的。<br>在<code>deny</code>模式下，ACL规则是一个白名单，任何没有明确指定的操作都是被禁止的。</p>
<blockquote>
<p>注意：该配置项只有在配置了<code>acl_datacenter</code>后才起作用</p>
</blockquote>
<a id="more"></a>
<h3 id="acl-down-policy"><a href="#acl-down-policy" class="headerlink" title="acl_down_policy"></a>acl_down_policy</h3><p>该配置项可选的值为<code>allow</code>，<code>deny</code>或<code>extend-cache</code>，　默认值是<code>extend-cache</code>。假如不能从<code>acl_datacenter</code>或<code>Leader</code>节点获取一个token的acl信息，则该配置项指定的策略被使用。</p>
<ul>
<li><code>allow</code>模式下，所有的操作都允许。 </li>
<li><code>deny</code>模式下，所有的操作都被禁止。 </li>
<li><code>extend-cache</code>模式下,使用缓存的 ACL规则并忽略这些规则的过期时间。如果一个不可缓存的ＡＣＬ的规则被使用，则当作<code>deny</code>策略来处理。</li>
</ul>
<h3 id="acl-master-token"><a href="#acl-master-token" class="headerlink" title="acl_master_token"></a>acl_master_token</h3><p>该配置项只能用在<code>acl_datacenter</code>中的Server节点上。 如果该令牌不存在，则将使用管理级权限创建该令牌。 它允许操作员使用众所周知的令牌ID来引导ACL系统。</p>
<p>仅当服务器获得集群领导时才安装acl_master_token。 如果要安装或更改acl_master_token，请在所有服务器的配置中为acl_master_token设置新值。 完成此操作后，重新启动当前领导者以强制进行领导者选举。 如果未提供acl_master_token，则服务器不会创建主令牌。 提供值时，它可以是任何字符串值。 使用UUID可以确保它看起来与其他令牌相同，但并不是绝对必要的。</p>
<h3 id="acl-agent-master-token"><a href="#acl-agent-master-token" class="headerlink" title="acl_agent_master_token"></a>acl_agent_master_token</h3><p>用作特殊访问 token，在配置它的每个 agent 上具有 agent ACL 策略 write 特权。 只有当 Consul server 不可用于解析 ACL token 时， 此 tokone 才应由运维人员在服务中断期间使用。 应用程序应在正常操作期间使用常规 ACL token。该配置项从版本<code>0.7.2</code>开始使用，并且只有当配置项<code>acl_enforce_version_8</code>设置为true时才起作用。更多信息参考<a href="https://www.consul.io/docs/guides/acl.html#acl-agent-master-token" target="_blank" rel="noopener"> ACL Agent Master Token </a></p>
<h3 id="acl-agent-token"><a href="#acl-agent-token" class="headerlink" title="acl_agent_token"></a>acl_agent_token</h3><p>由客户端和<code>Server</code>节点执行内部操作使用。如果没有设置该配置项的值，则<code>acl_token</code>配置项的被使用。该配置项从版本<code>0.7.2</code>开始使用。</p>
<p>此令牌必须至少具有对其将注册的节点名称的写访问权，以便设置目录中的任何节点级信息，例如元数据或节点的标记地址。 使用此令牌还有其他地方，请参阅<a href="https://www.consul.io/docs/guides/acl.html#acl-agent-token" target="_blank" rel="noopener">ACL代理令牌</a>以获取更多详细信息。</p>
<h3 id="acl-enforce-version-8"><a href="#acl-enforce-version-8" class="headerlink" title="acl_enforce_version_8"></a>acl_enforce_version_8</h3><p>用于客户端和服务器，以确定是否应在Consul 0.8之前预览新的ACL策略。 在Consul 0.7.2中添加，在0.8之前的Consul版本中默认为false，在Consul 0.8及更高版本中默认为true。 通过在实施开始之前允许策略到位，这有助于简化向新ACL功能的过渡。 有关详细信息，请参阅ACL指南。</p>
<h3 id="acl-replication-token"><a href="#acl-replication-token" class="headerlink" title="acl_replication_token"></a>acl_replication_token</h3><p>仅用于运行Consul 0.7或更高版本的<code>acl_datacenter</code>之外的服务器。 提供时，这将启用使用此令牌进行ACL复制，以检索ACL并将其复制到非权威的本地数据中心。 在Consul 0.9.1和更高版本中，您可以使用<code>enable_acl_replication</code>启用ACL复制，然后稍后使用每个服务器上的代理令牌API设置令牌。 如果在配置文件中设置了<code>acl_replication_token</code> ，它将自动将<code>enable_acl_replication</code>设置为true以实现向后兼容性。</p>
<p>如果存在影响权威数据中心的分区或其他中断，并且<code>acl_down_policy</code>设置为<code>extend-cache</code>，则可以在中断期间使用复制的ACL集解析不在缓存中的令牌。 有关更多详细信息，请参阅<a href="https://www.consul.io/docs/guides/acl.html#replication" target="_blank" rel="noopener">ACL指南复制部分</a>。</p>
<h3 id="acl-token"><a href="#acl-token" class="headerlink" title="acl_token"></a>acl_token</h3><p>如果设置了该配置项，代理将在向Consul服务器发出请求时使用此令牌。 客户端可以通过提供<code>？token</code>查询参数，基于每个请求覆盖此令牌。 如果未提供，则使用映射到“匿名”ACL策略的空标记。</p>
<h3 id="acl-ttl"><a href="#acl-ttl" class="headerlink" title="acl_ttl"></a>acl_ttl</h3><p>用于控制ACL缓存的过期时间。 默认是30秒。 此设置会对性能产生重大影响：减少它会导致更频繁的刷新，增加它会减少刷新次数。 但是，由于缓存未被主动失效，因此ACL策略可能会过时到TTL值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;配置项&quot;&gt;&lt;a href=&quot;#配置项&quot; class=&quot;headerlink&quot; title=&quot;配置项&quot;&gt;&lt;/a&gt;配置项&lt;/h2&gt;&lt;h3 id=&quot;acl-datacenter&quot;&gt;&lt;a href=&quot;#acl-datacenter&quot; class=&quot;headerlink&quot; title=&quot;acl_datacenter&quot;&gt;&lt;/a&gt;acl_datacenter&lt;/h3&gt;&lt;p&gt;该配置项指定了对ACL信息具有权威性的数据中心。 必须提供它才能启用ACL。 所有Server实例和数据中心必须就ACL数据中心达成一致。&lt;br&gt;必须在整个集群的Server节点上设置该配置项。但是针对API来说，如果要使客户端的请求能被正确转发，那么也需要在客户端节点设置。&lt;br&gt;在Consul 0.8及更高版本中，还可以启用代理级别的ACL。 有关详细信息，请参阅&lt;a href=&quot;https://www.consul.io/docs/guides/acl.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ACL指南&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;acl-default-policy&quot;&gt;&lt;a href=&quot;#acl-default-policy&quot; class=&quot;headerlink&quot; title=&quot;acl_default_policy&quot;&gt;&lt;/a&gt;acl_default_policy&lt;/h3&gt;&lt;p&gt;该配置项可选的值为&lt;code&gt;allow&lt;/code&gt;和&lt;code&gt;deny&lt;/code&gt;。默认值为’allow’。默认的策略控制token在没有匹配的规则时的行为。&lt;br&gt;在&lt;code&gt;allow&lt;/code&gt;模式下，ACL规则是一个黑名单：任何没有被禁止的操作都是可以执行的。&lt;br&gt;在&lt;code&gt;deny&lt;/code&gt;模式下，ACL规则是一个白名单，任何没有明确指定的操作都是被禁止的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：该配置项只有在配置了&lt;code&gt;acl_datacenter&lt;/code&gt;后才起作用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="consul" scheme="https://leokongwq.github.io/tags/consul/"/>
    
  </entry>
  
  <entry>
    <title>springcloud服务注册之consul</title>
    <link href="https://leokongwq.github.io/2018/07/08/spring-cloud-consul.html"/>
    <id>https://leokongwq.github.io/2018/07/08/spring-cloud-consul.html</id>
    <published>2018-07-08T05:28:16.000Z</published>
    <updated>2018-07-09T02:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用springcloud构建微服务，除了可以使用eureka来实现服务注册和发现外，springcloud对consul也提供了良好的支持。本文就简单介绍下使用springcloud和consul实现服务注册和发现。</p>
<h3 id="consul安装"><a href="#consul安装" class="headerlink" title="consul安装"></a>consul安装</h3><p>consul的安装非常简单，只需要在官网<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">下载</a>对应平台的安装文件即可。</p>
<p>具体安装步骤参考<a href="https://www.consul.io/intro/getting-started/install.html" target="_blank" rel="noopener">install</a></p>
<a id="more"></a>
<h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><h4 id="maven-配置"><a href="#maven-配置" class="headerlink" title="maven 配置"></a>maven 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="相关注解配置"><a href="#相关注解配置" class="headerlink" title="相关注解配置"></a>相关注解配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(Application.class, args);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="application-properties配置"><a href="#application-properties配置" class="headerlink" title="application.properties配置"></a>application.properties配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#默认就是true</span><br><span class="line">spring.cloud.consul.enabled=<span class="keyword">true</span></span><br><span class="line">spring.cloud.consul.host=<span class="number">127.0</span>.0.1</span><br><span class="line">spring.cloud.consul.port=<span class="number">8500</span></span><br><span class="line">#默认就是true</span><br><span class="line">spring.cloud.consul.discovery.enabled=<span class="keyword">true</span></span><br><span class="line">#服务名</span><br><span class="line">spring.cloud.consul.discovery.serviceName=$&#123;spring.application.name&#125;</span><br><span class="line">#服务注册实例名</span><br><span class="line">spring.cloud.consul.discovery.instanceId=$&#123;spring.application.name&#125;-$&#123;spring.cloud.client.ipAddress&#125;-$&#123;server.port&#125;</span><br><span class="line">#服务所在的主机名</span><br><span class="line">spring.cloud.consul.discovery.hostname=$&#123;spring.cloud.client.ipAddress&#125;</span><br><span class="line">#服务所在的端口</span><br><span class="line">spring.cloud.consul.discovery.port=$&#123;server.port&#125;</span><br><span class="line">#服务的健康检查url</span><br><span class="line">spring.cloud.consul.discovery.healthCheckUrl=http:<span class="comment">//localhost:$&#123;server.port&#125;/</span></span><br><span class="line">spring.cloud.consul.discovery.healthCheckInterval=<span class="number">10</span>s</span><br><span class="line">spring.cloud.consul.discovery.healthCheckTimeout=<span class="number">10</span>s</span><br><span class="line">spring.cloud.consul.discovery.healthCheckPath=/</span><br><span class="line">spring.cloud.consul.discovery.tags=dev,dev1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>healthCheckUrl 是consul检查应用健康状态的地址，可以选择一个自定义地址， 也可以使用<code>actuator</code>提供的<code>/health</code>地址。需要注意的是：如果你使用<code>actuator</code>提供的<code>/health</code>地址，则需要确保返回的json注解中的<code>status</code>字段为<code>UP</code>。也就是说<code>actuator</code>实施健康检查的所有组件的健康状态都必须是<code>UP</code>状态，有一个不是，则整个返回界都就是<code>DOWN</code>状态。</p>
</blockquote>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>properties文件配置和服务注册端都是一致的。Spring的java Bean配置也基本相同。</p>
<h4 id="maven-配置-1"><a href="#maven-配置-1" class="headerlink" title="maven 配置"></a>maven 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="java-Bean-配置"><a href="#java-Bean-配置" class="headerlink" title="java Bean 配置"></a>java Bean 配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//启动负载均衡功能</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务调用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"addServiceFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//url格式为服务名 + 请求的URI</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://bookservice/add?a=10&amp;b=20"</span>, String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addServiceFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;使用springcloud构建微服务，除了可以使用eureka来实现服务注册和发现外，springcloud对consul也提供了良好的支持。本文就简单介绍下使用springcloud和consul实现服务注册和发现。&lt;/p&gt;
&lt;h3 id=&quot;consul安装&quot;&gt;&lt;a href=&quot;#consul安装&quot; class=&quot;headerlink&quot; title=&quot;consul安装&quot;&gt;&lt;/a&gt;consul安装&lt;/h3&gt;&lt;p&gt;consul的安装非常简单，只需要在官网&lt;a href=&quot;https://www.consul.io/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;下载&lt;/a&gt;对应平台的安装文件即可。&lt;/p&gt;
&lt;p&gt;具体安装步骤参考&lt;a href=&quot;https://www.consul.io/intro/getting-started/install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;install&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://leokongwq.github.io/categories/web/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
      <category term="springcloud" scheme="https://leokongwq.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ 延迟消息</title>
    <link href="https://leokongwq.github.io/2018/06/27/activemq-deleyQueue.html"/>
    <id>https://leokongwq.github.io/2018/06/27/activemq-deleyQueue.html</id>
    <published>2018-06-27T15:08:31.000Z</published>
    <updated>2018-11-03T04:40:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有非常多的业务场景需要用到延迟消息功能。例如：订单待支付提醒，订单超时取消等。但并不是所有的消息中间件都支持延迟消息的功能，为了实现延迟消息，各路大神也是创造了很多的方案。<br>我们的系统使用的是ActiveMQ，ActiveMQ从版本<code>5.4</code>开始提供了持久化的延迟消息功能。下文就ActiveMQ提供的延迟消息功能进行介绍。</p>
<h3 id="启用ActiveMQ定时消息功能"><a href="#启用ActiveMQ定时消息功能" class="headerlink" title="启用ActiveMQ定时消息功能"></a>启用ActiveMQ定时消息功能</h3><p>为了使用ActiveMQ的延迟消息功能，我们需要修改ActiveMQ的配置文件<code>activemq.xml</code>，<br>在broker节点上添加<code>schedulerSupport=&quot;true&quot;</code>，如下所示:</p>
<a id="more"></a>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">broker</span> <span class="attr">xmlns</span>=<span class="string">"http://activemq.apache.org/schema/core"</span> <span class="attr">schedulerSupport</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">broker</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建延迟消息并发送"><a href="#创建延迟消息并发送" class="headerlink" title="创建延迟消息并发送"></a>创建延迟消息并发送</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jmsTemplate.send(orderCreatedTopic, session -&gt; &#123;</span><br><span class="line">trueMapMessage orderCreatedMsg = session.createMapMessage();</span><br><span class="line">trueorderCreatedMsg.setString(<span class="string">"orderCode"</span>, orderCode);</span><br><span class="line">true<span class="comment">//延迟10分钟进行投递</span></span><br><span class="line">true<span class="keyword">long</span> time = <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">trueorderCreatedMsg.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, time);</span><br><span class="line">true<span class="keyword">return</span> orderCreatedMsg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="延时消息属性总结"><a href="#延时消息属性总结" class="headerlink" title="延时消息属性总结"></a>延时消息属性总结</h3><p>ActiveM提供了很多高级的延时消息配置属性，解释如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>　AMQ_SCHEDULED_DELAY</td>
<td>long</td>
<td>broker在投递该消息前等待的毫秒数</td>
</tr>
<tr>
<td>　AMQ_SCHEDULED_PERIOD</td>
<td>long</td>
<td>每次重新投递该消息的时间间隔</td>
</tr>
<tr>
<td>　AMQ_SCHEDULED_REPEAT</td>
<td>int</td>
<td>重复投递该消息的次数</td>
</tr>
<tr>
<td>　AMQ_SCHEDULED_CRON　</td>
<td>String</td>
<td>使用一个cron表达式来表示消息投递的策略</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MessageProducer producer = session.createProducer(destination);</span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"test msg"</span>);</span><br><span class="line">message.setStringProperty(ScheduledMessage.AMQ_SCHEDULED_CRON, <span class="string">"0 * * * *"</span>);</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, <span class="number">1000</span>);</span><br><span class="line">message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, <span class="number">1000</span>);</span><br><span class="line">message.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, <span class="number">9</span>);</span><br><span class="line">producer.send(message);</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://activemq.apache.org/delay-and-schedule-message-delivery.html" target="_blank" rel="noopener">http://activemq.apache.org/delay-and-schedule-message-delivery.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有非常多的业务场景需要用到延迟消息功能。例如：订单待支付提醒，订单超时取消等。但并不是所有的消息中间件都支持延迟消息的功能，为了实现延迟消息，各路大神也是创造了很多的方案。&lt;br&gt;我们的系统使用的是ActiveMQ，ActiveMQ从版本&lt;code&gt;5.4&lt;/code&gt;开始提供了持久化的延迟消息功能。下文就ActiveMQ提供的延迟消息功能进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;启用ActiveMQ定时消息功能&quot;&gt;&lt;a href=&quot;#启用ActiveMQ定时消息功能&quot; class=&quot;headerlink&quot; title=&quot;启用ActiveMQ定时消息功能&quot;&gt;&lt;/a&gt;启用ActiveMQ定时消息功能&lt;/h3&gt;&lt;p&gt;为了使用ActiveMQ的延迟消息功能，我们需要修改ActiveMQ的配置文件&lt;code&gt;activemq.xml&lt;/code&gt;，&lt;br&gt;在broker节点上添加&lt;code&gt;schedulerSupport=&amp;quot;true&amp;quot;&lt;/code&gt;，如下所示:&lt;/p&gt;
    
    </summary>
    
      <category term="消息中间件" scheme="https://leokongwq.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="ActiveMQ" scheme="https://leokongwq.github.io/tags/ActiveMQ/"/>
    
      <category term="MQ" scheme="https://leokongwq.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper使用之curator</title>
    <link href="https://leokongwq.github.io/2018/06/17/zookeeper-curator.html"/>
    <id>https://leokongwq.github.io/2018/06/17/zookeeper-curator.html</id>
    <published>2018-06-17T10:26:10.000Z</published>
    <updated>2018-06-24T13:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Apache <a href="http://curator.apache.org/" target="_blank" rel="noopener">Curator</a>是Netflix开源的操作Zookeeper的，功能非常强大的客户端。提供了很多非常好用的功能来帮助我们构建分布式应用。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>Curator 提供的分布式锁分为以下三类：</p>
<ul>
<li>可重入公平锁 InterProcessMutex</li>
<li>不可重入的非公平锁 InterProcessSemaphoreMutex</li>
<li>可重入的读写锁 InterProcessReadWriteLock</li>
<li>锁集合 InterProcessMultiLock</li>
</ul>
<a id="more"></a>
<h3 id="InterProcessMutex"><a href="#InterProcessMutex" class="headerlink" title="InterProcessMutex"></a>InterProcessMutex</h3><p>Curator提供了<code>InterProcessMutex</code>来实现该功能。样例代码如下：</p>
<figure class="highlight java"><figcaption><span>InterProcessMutex</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁</span></span><br><span class="line">InterProcessLock lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">lock.acquire(<span class="number">1</span>，TimeUnit.SECONDS)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//业务代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现原理分析：</p>
<p><code>InterProcessMutex</code>通过创建一个 Zookeeper 临时，顺序结点来实现锁的公平获取，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="keyword">null</span>) ) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Lost connection while trying to acquire lock: "</span> + basePath);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note on concurrency: a given lockData instance</span></span><br><span class="line"><span class="comment">      can be only acted on by a single thread so locking isn't necessary</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//下面的代码实现：可重入性。</span></span><br><span class="line">   Thread currentThread = Thread.currentThread();</span><br><span class="line">   LockData lockData = threadData.get(currentThread);</span><br><span class="line">   <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// re-entering </span></span><br><span class="line">       lockData.lockCount.incrementAndGet();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建：临时，顺序结点 </span></span><br><span class="line">   String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">   <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )</span><br><span class="line">   &#123;</span><br><span class="line">       LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">       threadData.put(currentThread, newLockData);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建：临时，顺序结点 </p>
<figure class="highlight java"><figcaption><span>LockInternals.attemptLock</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">while</span> ( !isDone )</span><br><span class="line">   &#123;</span><br><span class="line">       isDone = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;   </span><br><span class="line">           <span class="comment">// 通过LockInternalsDriver创建Zookeeper结点</span></span><br><span class="line">           ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">           <span class="comment">// 判断是否获取了锁， 其实就是判定该线程创建的临时结点的顺序是否最小</span></span><br><span class="line">           hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// gets thrown by StandardLockInternalsDriver when it can't find the lock node</span></span><br><span class="line">           <span class="comment">// this can happen when the session expires, etc. So, if the retry allows, just try it all again</span></span><br><span class="line">           <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )</span><br><span class="line">           &#123;</span><br><span class="line">               isDone = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span>     haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span>     doDelete = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> )</span><br><span class="line">       &#123;</span><br><span class="line">           client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 循环来获取锁</span></span><br><span class="line">       <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//获取所有的排序后的子节点列表（升序排列） </span></span><br><span class="line">           List&lt;String&gt;        children = getSortedChildren();</span><br><span class="line">           String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line">           <span class="comment">// 判断该进程或线程创建的子节点：sequenceNodeName 是否是第一个</span></span><br><span class="line">           PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">           <span class="keyword">if</span> ( predicateResults.getsTheLock() )</span><br><span class="line">           &#123;</span><br><span class="line">               haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line">                <span class="comment">// JVM 进程能同步，</span></span><br><span class="line">               <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">try</span> </span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span></span><br><span class="line">                       client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                       <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )</span><br><span class="line">                       &#123;</span><br><span class="line">                           millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                           startMillis = System.currentTimeMillis();</span><br><span class="line">                           <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                           &#123;</span><br><span class="line">                               doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                            <span class="comment">// 线程超时等待</span></span><br><span class="line">                           wait(millisToWait);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                          <span class="comment">// 线程等待(需要其它线程唤醒，其它线程在释放锁时会进行唤醒)</span></span><br><span class="line">                           wait();</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                        <span class="comment">//  watcher 的执行在另一个线程中，会唤醒等待锁的线程</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">catch</span> ( KeeperException.NoNodeException e ) </span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">   &#123;   </span><br><span class="line">        <span class="comment">// 处理线程中断  </span></span><br><span class="line">       ThreadUtils.checkInterrupted(e);</span><br><span class="line">       doDelete = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span></span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//被中断后，删除结点，释放锁（一点会删除成功，具体实现查询源代码）</span></span><br><span class="line">       <span class="keyword">if</span> ( doDelete )</span><br><span class="line">       &#123;</span><br><span class="line">           deleteOurPath(ourPath);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="InterProcessSemaphoreMutex"><a href="#InterProcessSemaphoreMutex" class="headerlink" title="InterProcessSemaphoreMutex"></a>InterProcessSemaphoreMutex</h3><p>该功能的锁是由：<code>InterProcessSemaphoreMutex</code>实现的，具体原理就不分析代码。</p>
<p>提一句：该锁的功能是通过：<code>InterProcessMutex</code>和<code>InterProcessSemaphoreV2</code>实现的。</p>
<p><code>InterProcessSemaphoreV2</code>：从名称上来说，该类是一个信号量，也就是说它可以提供N个可用的许可，可以用来管理同时访问共享资源的并发数。</p>
<blockquote>
<p>许可数量为:1的信号量可以当做锁来用。</p>
</blockquote>
<h3 id="InterProcessReadWriteLock"><a href="#InterProcessReadWriteLock" class="headerlink" title="InterProcessReadWriteLock"></a>InterProcessReadWriteLock</h3><p>读写锁和JDK提供的：<code>ReadWriteLock</code>功能是类似的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   String lockPath = <span class="string">"/config/lock/123"</span>;</span><br><span class="line">   InterProcessReadWriteLock readWriteLock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</span><br><span class="line"></span><br><span class="line">   InterProcessMutex readLock = readWriteLock.readLock();</span><br><span class="line">   InterProcessMutex writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点总结：</p>
<ol>
<li>可重入，读锁和写锁都是可重入的。</li>
<li>读锁非互斥，写锁是互斥的，只能有一个客户端获取</li>
<li>读写是互斥的</li>
<li>支持锁降级。支持写锁降级为读锁，读锁不能升级为写锁。</li>
</ol>
<h3 id="InterProcessMultiLock"><a href="#InterProcessMultiLock" class="headerlink" title="InterProcessMultiLock"></a>InterProcessMultiLock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(List&lt;InterProcessLock&gt; locks);</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(CuratorFramework client,</span><br><span class="line">                             List&lt;String&gt; paths);</span><br></pre></td></tr></table></figure>
<p><code>InterProcessMultiLock</code>维护一组锁。在获取锁时，只有获取所有的锁时才返回，释放时会释放所有的锁。</p>
<h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>在分布式系统中，Leader选举是一个非常基础和重要的能力。通过Zookeeper和Curator能非常容易的实现Leader选举。</p>
<p>Curator提供了两种机制来实现Leader选举：</p>
<h3 id="方法一：LeaderSelector"><a href="#方法一：LeaderSelector" class="headerlink" title="方法一：LeaderSelector"></a>方法一：LeaderSelector</h3><p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String leaderSelectionPath = <span class="string">"/config/vip/db/master"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeaderElection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">       threadPool.execute(<span class="keyword">new</span> Contender(buildLeaderSelectorListener()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 公平的选举（顺序性）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> LeaderSelectorListener listener;</span><br><span class="line"></span><br><span class="line">   Contender(LeaderSelectorListener listener) &#123;</span><br><span class="line">       <span class="keyword">this</span>.listener = listener;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       LeaderSelector selector = <span class="keyword">new</span> LeaderSelector(client, leaderSelectionPath, listener);</span><br><span class="line">       <span class="comment">// 自动加入Leader选举</span></span><br><span class="line">       selector.autoRequeue();</span><br><span class="line">       <span class="comment">//开始进行选举，不过该方法会立即返回。选举的结果是通过异步回调实现的</span></span><br><span class="line">       selector.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> LeaderSelectorListener <span class="title">buildLeaderSelectorListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LeaderSelectorListener listener = <span class="keyword">new</span> LeaderSelectorListenerAdapter() &#123;</span><br><span class="line">        <span class="comment">//该方法只有在该客户端被选为Leader才会被调用。</span></span><br><span class="line">        <span class="comment">//方法返回就表示客户端放弃Leader角色。</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="comment">// 模式业务操作</span></span><br><span class="line">            System.out.println(<span class="string">"Current Leader is : "</span> + Thread.currentThread().getName());</span><br><span class="line">           Thread.sleep(<span class="number">5000</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">return</span> listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二：LeaderLatch"><a href="#方法二：LeaderLatch" class="headerlink" title="方法二：LeaderLatch"></a>方法二：LeaderLatch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeaderRandomElection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">       LeaderLatch leaderLatch = <span class="keyword">new</span> LeaderLatch(client, leaderSelectionPath, String.valueOf(i));</span><br><span class="line">       threadPool.execute(<span class="keyword">new</span> RandomSelectLeader(leaderLatch));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">   threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomSelectLeader</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> LeaderLatch leaderLatch;</span><br><span class="line"></span><br><span class="line">   RandomSelectLeader(LeaderLatch leaderLatch) &#123;</span><br><span class="line">       <span class="keyword">this</span>.leaderLatch = leaderLatch;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//强烈建议添加Listener来监听链接变化，　处理Leader丢失问题</span></span><br><span class="line">           leaderLatch.addListener(<span class="keyword">new</span> LeaderLatchListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"I'am Selected to be a Leader"</span> + Thread.currentThread().getName());</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   System.out.println(<span class="string">"I'am Not Leader"</span> + Thread.currentThread().getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="comment">//调用该方法后才能开始参与选举（随机的）</span></span><br><span class="line">           leaderLatch.start();</span><br><span class="line">           <span class="comment">//死等，　直到被选为Leader</span></span><br><span class="line">           leaderLatch.await();</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">"Current Leader is : "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 退出选举，如果自己是Leader，则放弃Leader位置，其它的成员就可以再次选举</span></span><br><span class="line">               leaderLatch.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>推荐使用<code>LeaderSelector</code>来实现Leader选举，因为参加选举的结点代码编写简单，能自动完成丢失Leader角色后从新参加选举的功能，而且能灵活的控制释放Leader角色的时机。</p>
<h2 id="分布式栅栏"><a href="#分布式栅栏" class="headerlink" title="分布式栅栏"></a>分布式栅栏</h2><h3 id="DistributedBarrier"><a href="#DistributedBarrier" class="headerlink" title="DistributedBarrier"></a>DistributedBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistributedBarrier</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   String barrierPath = <span class="string">"/config/barriers"</span>;</span><br><span class="line">   DistributedBarrier barrier = <span class="keyword">new</span> DistributedBarrier(client, barrierPath);</span><br><span class="line"></span><br><span class="line">   ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">       executorService.execute(<span class="keyword">new</span> Worker(barrier));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//主线程设置结点，worker线程等待</span></span><br><span class="line">   barrier.setBarrier();</span><br><span class="line"></span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);</span><br><span class="line">   System.out.println(<span class="string">"ALL Done!"</span>);</span><br><span class="line"></span><br><span class="line">   barrier.removeBarrier();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> DistributedBarrier barrier;</span><br><span class="line"></span><br><span class="line">   Worker(DistributedBarrier barrier) &#123;</span><br><span class="line">       <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           barrier.waitOnBarrier();</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">" &gt;&gt;&gt;&gt; Finished"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DistributedDoubleBarrier"><a href="#DistributedDoubleBarrier" class="headerlink" title="DistributedDoubleBarrier"></a>DistributedDoubleBarrier</h3><p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。</p>
<p>构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String barrierPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> memberQty)</span></span></span><br><span class="line"><span class="function">Creates the barrier abstraction. memberQty is the number of members in the barrier. When <span class="title">enter</span><span class="params">()</span> is called, it blocks until</span></span><br><span class="line"><span class="function">all members have entered. When <span class="title">leave</span><span class="params">()</span> is called, it blocks until all members have left.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">barrierPath - path to use</span></span><br><span class="line"><span class="function">memberQty - the number of members in the barrier</span></span><br></pre></td></tr></table></figure>
<p><code>memberQty</code>是成员数量，当<code>enter</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter</code>。 当<code>leave</code>方法被调用时，它也阻塞调用线程， 直到所有的成员都调用了<code>leave</code>。</p>
<p><code>DistributedDoubleBarrier</code>会监控连接状态，当连接断掉时<code>enter</code>和<code>leave</code>方法会抛出异常。</p>
<p>下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistributedDoubleBarrier</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   String barrierPath = <span class="string">"/config/barriers"</span>;</span><br><span class="line"></span><br><span class="line">   ExecutorService executorService = Executors.newFixedThreadPool(QTY);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; i++) &#123;</span><br><span class="line">       <span class="keyword">final</span> DistributedDoubleBarrier barrier = <span class="keyword">new</span> DistributedDoubleBarrier(client, barrierPath, QTY);</span><br><span class="line">       executorService.execute(<span class="keyword">new</span> Worker(barrier));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">   System.out.println(<span class="string">"ALL Done!"</span>);</span><br><span class="line"></span><br><span class="line">   executorService.shutdown();</span><br><span class="line">   executorService.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   DistributedDoubleBarrier doubleBarrier;</span><br><span class="line"></span><br><span class="line">   Worker(DistributedDoubleBarrier doubleBarrier) &#123;</span><br><span class="line">       <span class="keyword">this</span>.doubleBarrier = doubleBarrier;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//等待所有客户端都到达</span></span><br><span class="line">           doubleBarrier.enter();</span><br><span class="line">           System.out.println(<span class="string">"I'am arrival"</span>);</span><br><span class="line">           System.out.println(Thread.currentThread().getName() + <span class="string">" &gt;&gt;&gt;&gt; Finished"</span>);</span><br><span class="line">           <span class="comment">//等待所有客户端都到达</span></span><br><span class="line">           doubleBarrier.leave();</span><br><span class="line">           System.out.println(<span class="string">"I'am leave"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分布式计数器"><a href="#分布式计数器" class="headerlink" title="分布式计数器"></a>分布式计数器</h2><h3 id="SharedCount"><a href="#SharedCount" class="headerlink" title="SharedCount"></a>SharedCount</h3><p><code>SharedCount</code> 管理一个共享的整型数字。所有监听该同一个Zookeeper Path的客户端都能获取到该整型数字的最新值。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedCountTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COUNTER_PATH = <span class="string">"/config/conunter/total"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSharedCount</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SharedCount sharedCount = <span class="keyword">new</span> SharedCount(client, COUNTER_PATH, <span class="number">0</span>);</span><br><span class="line">        sharedCount.start();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> SharedCount count = <span class="keyword">new</span> SharedCount(client, COUNTER_PATH, <span class="number">0</span>);</span><br><span class="line">            count.start();</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    count.addListener(<span class="keyword">new</span> SharedCountListener() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countHasChanged</span><span class="params">(SharedCountReader sharedCount, <span class="keyword">int</span> newCount)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"===="</span> + newCount);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">                            System.out.println(newState);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">        sharedCount.setCount(<span class="number">123</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">        sharedCount.setCount(<span class="number">456</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">20</span>);</span><br><span class="line">        sharedCount.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 如果连续两次调用<code>setCount</code>方法，在客户端只能观察到最后一次的结果。<code>trySetCount</code> 只有当该客户端的缓存的值和服务端保存的值一致才能设置成功，否则该客户端的值会自动更新（<code>trySetCount</code>返回false）。</p>
</blockquote>
<h3 id="DistributedAtomicLong"><a href="#DistributedAtomicLong" class="headerlink" title="DistributedAtomicLong"></a>DistributedAtomicLong</h3><p><code>DistributedAtomicLong</code> 是一个原子更新的计数器。它在更新值时，第一次尝试采用乐观锁机制，如果更新失败，则使用<code>InterProcessMutex</code>来实现更新。 不管采用哪种机制，它都会采用重试机制，直到更新成功。</p>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDistributedAtomicLong</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COUNTER_PATH = <span class="string">"/config/conunter/123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistributedAtomicLong</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryForever(<span class="number">10</span>);</span><br><span class="line">        DistributedAtomicLong atomicLong = <span class="keyword">new</span> DistributedAtomicLong(client, COUNTER_PATH, retryPolicy);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> RetryPolicy retryPolicyTmp = <span class="keyword">new</span> RetryForever(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">final</span> DistributedAtomicLong distCounter = <span class="keyword">new</span> DistributedAtomicLong(client, COUNTER_PATH, retryPolicyTmp);</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(distCounter);</span><br><span class="line"></span><br><span class="line">                    AtomicValue&lt;Long&gt; result = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        result = distCounter.increment();</span><br><span class="line">                        <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"===&gt; current value = "</span> + result.preValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After all current value is = "</span> + atomicLong.get().postValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在使用<code>DistributedAtomicLong</code>时，你必须首先检查<code>AtomicValue.succeeded()</code>的返回值。如果操作成功则该方法的返回<code>true</code>，否则返回<code>false</code>，表示原子更新失败。如果更新成功，则可以通过<code>preValue</code>和<code>postValue</code>获取更新前后的值。</p>
</blockquote>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="PathChildrenCache"><a href="#PathChildrenCache" class="headerlink" title="PathChildrenCache"></a>PathChildrenCache</h3><p><code>PathChildrenCache</code> 用来观察一个<code>ZNode</code>。无论该结点下新增子节点，删除子节点还是子节点更新，路径缓存都会更新它的状态来包含当前的结点集合（包括状态和数据）。</p>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathChildrenCacheTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PATH = <span class="string">"/config/cache"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPathChildrenCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PathChildrenCache pathChildrenCache = <span class="keyword">new</span> PathChildrenCache(client, CACHE_PATH, <span class="keyword">true</span>);</span><br><span class="line">        pathChildrenCache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        pathChildrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;ChildData&gt; childDataList = pathChildrenCache.getCurrentData();</span><br><span class="line">        <span class="keyword">for</span> (ChildData childData : childDataList) &#123;</span><br><span class="line">            System.out.println(childData);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathChildrenCache.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NodeCache"><a href="#NodeCache" class="headerlink" title="NodeCache"></a>NodeCache</h3><p><code>NodeCache</code>用来观察一个<code>ZNode</code>。当该结点的数据被更新，或被删除，<code>NodeCache</code>会同步到结点当前最新的数据，如果结点被删除，则<code>NodeCache</code>包含的数据为null。</p>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeCacheTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_NODE_PATH = <span class="string">"/config/cache/123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNodeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, CACHE_NODE_PATH);</span><br><span class="line">        nodeCache.start(<span class="keyword">true</span>);</span><br><span class="line">        nodeCache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(nodeCache.getCurrentData().getData()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line">        nodeCache.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeCache"><a href="#TreeCache" class="headerlink" title="TreeCache"></a>TreeCache</h3><p><code>TreeCache</code>是一个工具类，它试图将服务端某个<code>Path</code>下所有所有的结点数据缓存到本地。该类会监听指定的ZK路径，处理<code>update</code>,<code>create</code>,<code>delete</code>事件并拉取服务端的数据。你可以通过注册一个Listener来获取数据的变化通知。</p>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_PATH = <span class="string">"/config/cache"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TreeCache treeCache = <span class="keyword">new</span> TreeCache(client, CACHE_PATH);</span><br><span class="line">        treeCache.getListenable().addListener(<span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeCache.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, ChildData&gt; dataMap = treeCache.getCurrentChildren(CACHE_PATH);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, ChildData&gt; entry : dataMap.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">" =====》"</span> +  <span class="keyword">new</span> String(entry.getValue().getData()));</span><br><span class="line">        &#125;</span><br><span class="line">        treeCache.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Nodes"><a href="#Nodes" class="headerlink" title="Nodes"></a>Nodes</h2><h3 id="Persistent-Node"><a href="#Persistent-Node" class="headerlink" title="Persistent Node"></a>Persistent Node</h3><p>持久化结点是数据保存在Zookeeper服务端，并且在连接断开，session过期任然存在的结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentNodeTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NODE_PATH = <span class="string">"/persons/sky"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersistentNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PersistentNode persistentNode = <span class="keyword">new</span> PersistentNode(</span><br><span class="line">            client,</span><br><span class="line">            CreateMode.PERSISTENT,</span><br><span class="line">            <span class="keyword">true</span>,</span><br><span class="line">            NODE_PATH,</span><br><span class="line">            <span class="string">"123"</span>.getBytes()</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//必须先调用该方法(该方法会创建结点)</span></span><br><span class="line">        persistentNode.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(persistentNode.getActualPath());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(persistentNode.getData()));</span><br><span class="line">        <span class="comment">//会删除该结点</span></span><br><span class="line"><span class="comment">//        persistentNode.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Persistent-TTL-Node"><a href="#Persistent-TTL-Node" class="headerlink" title="Persistent TTL Node"></a>Persistent TTL Node</h3><p><code>`在你需要创建</code>TTL<code>节点，但不想通过定期设置数据手动保持它的活动状态时非常有用。</code>PersistentTtlNode<code>可以为你完成此操作。 此外，保持活动的方式不会在父节点上生成监视触发器。 它还提供了类似</code>PersistentNode`的保证，即使通过连接和会话中断，节点也会尝试保持在ZooKeeper中。</p>
<h3 id="Group-Member"><a href="#Group-Member" class="headerlink" title="Group Member"></a>Group Member</h3><h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>、、、、</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Apache &lt;a href=&quot;http://curator.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Curator&lt;/a&gt;是Netflix开源的操作Zookeeper的，功能非常强大的客户端。提供了很多非常好用的功能来帮助我们构建分布式应用。&lt;/p&gt;
&lt;h2 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h2&gt;&lt;p&gt;Curator 提供的分布式锁分为以下三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可重入公平锁 InterProcessMutex&lt;/li&gt;
&lt;li&gt;不可重入的非公平锁 InterProcessSemaphoreMutex&lt;/li&gt;
&lt;li&gt;可重入的读写锁 InterProcessReadWriteLock&lt;/li&gt;
&lt;li&gt;锁集合 InterProcessMultiLock&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="架构" scheme="https://leokongwq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="zookeeper" scheme="https://leokongwq.github.io/tags/zookeeper/"/>
    
      <category term="curator" scheme="https://leokongwq.github.io/tags/curator/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统一致性总结</title>
    <link href="https://leokongwq.github.io/2018/06/01/distributed-system-consitency.html"/>
    <id>https://leokongwq.github.io/2018/06/01/distributed-system-consitency.html</id>
    <published>2018-06-01T06:16:32.000Z</published>
    <updated>2018-06-01T06:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在学习过程中，阅读了好多关于分布式系统一致性的文章和资料，总是被分布式事务一致性和分布式数据一致性</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在学习过程中，阅读了好多关于分布式系统一致性的文章和资料，总是被分布式事务一致性和分布式数据一致性&lt;/p&gt;

    
    </summary>
    
      <category term="架构" scheme="https://leokongwq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>spring中RestTemplate简介</title>
    <link href="https://leokongwq.github.io/2018/05/30/spring-RestTemplate.html"/>
    <id>https://leokongwq.github.io/2018/05/30/spring-RestTemplate.html</id>
    <published>2018-05-30T08:44:51.000Z</published>
    <updated>2018-05-30T09:29:42.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RestTemplate-是什么？"><a href="#RestTemplate-是什么？" class="headerlink" title="RestTemplate 是什么？"></a>RestTemplate 是什么？</h3><p>RestTemplate是Spring提供的一个访问Http服务的客户端类，非常类似JdbcTemplate, JmsTemplate。它是线程安全的（一旦创建完成）。从名称上来看，该类更多是针对RESTFUL风格API设计的。当然如果你想通过它调用普通的Http接口也是可以的。</p>
<h3 id="RestTemplate-的方法"><a href="#RestTemplate-的方法" class="headerlink" title="RestTemplate 的方法"></a>RestTemplate 的方法</h3><p>RestTemplate提供的方法都是以Http协议中的6个动词开头的：</p>
<img src="/2018/05/30/spring-RestTemplate/spring-template.png">
<p>这些方法的名称清楚地表明它们调用的是哪个HTTP方法，而名称的第二部分表示返回的内容。 例如，<code>getForObject（）</code>将执行GET，将HTTP响应转换为你选择的对象类型，并返回该对象。<code>postForLocation</code>将执行POST，将给定对象转换为HTTP请求，并返回可以找到新创建对象的响应<code>HTTP Location</code>标头。 如你所见，这些方法试图强制执行REST最佳实践。</p>
<a id="more"></a>
<h3 id="URI-模板"><a href="#URI-模板" class="headerlink" title="URI 模板"></a>URI 模板</h3><p>这些方法中的每一个都将URI作为第一个参数。 该URI可以是URI模板，可以使用变量将模板扩展为正常的URI。 模板变量可以以两种形式传递：<code>作为String可变参数数组</code>，或作为<code>Map &lt;String，String&gt;</code>。 字符串可变数组按顺序展开复制给模板变量，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = restTemplate.getForObject(<span class="string">"http://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;"</span>, String.class, <span class="string">"42"</span>, <span class="string">"21"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码最终会请求：<a href="http://example.com/hotels/42/bookings/21" target="_blank" rel="noopener">http://example.com/hotels/42/bookings/21</a>。Map类型的模板数据，则会以模板变量的名称为key, 查询对应的值来做替换。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; vars = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">vars.put(<span class="string">"hotel"</span>, <span class="string">"42"</span>);</span><br><span class="line">vars.put(<span class="string">"booking"</span>, <span class="string">"21"</span>);</span><br><span class="line">String result = restTemplate.getForObject(<span class="string">"http://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;"</span>, String.class, vars);</span><br></pre></td></tr></table></figure>
<p>最终同样会发送请求：<a href="http://example.com/hotels/42/rooms/42" target="_blank" rel="noopener">http://example.com/hotels/42/rooms/42</a>。</p>
<h3 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h3><p>传递给方法<code>getForObject()</code>,<code>postForLocation()</code>,<code>put()</code>的数据对象，或是这些方法的返回数据对象都是通过<code>HttpMessageConverter</code>进行转换的。在发送请求时，将数据对象转为Http请求数据， 接收响应时，将Http响应数据转为对应的数据对象。具体参考下面的例子</p>
<h4 id="搜索图片"><a href="#搜索图片" class="headerlink" title="搜索图片"></a>搜索图片</h4><p>Flickr公开了各种API来操纵庞大的照片库。<code>flickr.photos.search</code>方法允许你通过使用<code>GET</code>方法请求地址：<a href="http://www.flickr.com/services/rest?method=flickr.photos.search&amp;api+key=xxx&amp;tags=penguins" target="_blank" rel="noopener">http://www.flickr.com/services/rest?method=flickr.photos.search&amp;api+key=xxx&amp;tags=penguins</a>来搜索照片，结果会以xml的形式展示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">photos</span> <span class="attr">page</span>=<span class="string">"2"</span> <span class="attr">pages</span>=<span class="string">"89"</span> <span class="attr">perpage</span>=<span class="string">"10"</span> <span class="attr">total</span>=<span class="string">"881"</span>&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">photo</span> <span class="attr">id</span>=<span class="string">"2636"</span> <span class="attr">owner</span>=<span class="string">"47058503995@N01"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">secret</span>=<span class="string">"a123456"</span> <span class="attr">server</span>=<span class="string">"2"</span> <span class="attr">title</span>=<span class="string">"test_04"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">ispublic</span>=<span class="string">"1"</span> <span class="attr">isfriend</span>=<span class="string">"0"</span> <span class="attr">isfamily</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">photo</span> <span class="attr">id</span>=<span class="string">"2635"</span> <span class="attr">owner</span>=<span class="string">"47058503995@N01"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">secret</span>=<span class="string">"b123456"</span> <span class="attr">server</span>=<span class="string">"2"</span> <span class="attr">title</span>=<span class="string">"test_03"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">ispublic</span>=<span class="string">"0"</span> <span class="attr">isfriend</span>=<span class="string">"1"</span> <span class="attr">isfamily</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">photo</span> <span class="attr">id</span>=<span class="string">"2633"</span> <span class="attr">owner</span>=<span class="string">"47058503995@N01"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">secret</span>=<span class="string">"c123456"</span> <span class="attr">server</span>=<span class="string">"2"</span> <span class="attr">title</span>=<span class="string">"test_01"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">ispublic</span>=<span class="string">"1"</span> <span class="attr">isfriend</span>=<span class="string">"0"</span> <span class="attr">isfamily</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">true<span class="tag">&lt;<span class="name">photo</span> <span class="attr">id</span>=<span class="string">"2610"</span> <span class="attr">owner</span>=<span class="string">"12037949754@N01"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">secret</span>=<span class="string">"d123456"</span> <span class="attr">server</span>=<span class="string">"2"</span> <span class="attr">title</span>=<span class="string">"00_tall"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">ispublic</span>=<span class="string">"1"</span> <span class="attr">isfriend</span>=<span class="string">"0"</span> <span class="attr">isfamily</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">photos</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String photoSearchUrl =</span><br><span class="line">   <span class="string">"http://www.flickr.com/services/rest?method=flickr.photos.search&amp;api+key=&#123;api-key&#125;&amp;tags=&#123;tag&#125;&amp;per_page=10"</span>;</span><br><span class="line">Source photos = restTemplate.getForObject(photoSearchUrl, Source.class, apiKey, searchTerm);</span><br></pre></td></tr></table></figure>
<h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><h4 id="getXXX"><a href="#getXXX" class="headerlink" title="getXXX"></a>getXXX</h4><p>GET请求的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... urlVariables) throws RestClientException </span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) throws RestClientException</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResponseEntity&lt;String&gt; responseEntity = restTemplate.getForEntity(<span class="string">"http://abc.com"</span>, String.class);</span><br><span class="line">    String body = responseEntity.getBody();</span><br><span class="line">    HttpStatus statusCode = responseEntity.getStatusCode();</span><br><span class="line">    <span class="keyword">int</span> statusCodeValue = responseEntity.getStatusCodeValue();</span><br><span class="line">    HttpHeaders headers = responseEntity.getHeaders();</span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="postXXX"><a href="#postXXX" class="headerlink" title="postXXX"></a>postXXX</h3><p>POST 请求的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">postForObject</span><span class="params">(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</span> <span class="keyword">throws</span> RestClientException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T <span class="title">postForObject</span><span class="params">(URI url, Object request, Class&lt;T&gt; responseType)</span> <span class="keyword">throws</span> RestClientException</span></span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.add(<span class="string">"X-Auth-Token"</span>, <span class="string">"e348bc22-5efa-4299-9142-529f07a18ac9"</span>);</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, String&gt; postParameters = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">postParameters.add(<span class="string">"owner"</span>, <span class="string">"11"</span>);</span><br><span class="line">postParameters.add(<span class="string">"subdomain"</span>, <span class="string">"aoa"</span>);</span><br><span class="line">postParameters.add(<span class="string">"comment"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; requestEntity  = <span class="keyword">new</span> HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(postParameters, headers);</span><br><span class="line"></span><br><span class="line">WebResult&lt;Person&gt; result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  result = restTemplate.postForObject(<span class="string">"请求地址"</span>,  requestEntity, WebResult.class);</span><br><span class="line">  logger.info(result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RestClientException e) &#123;</span><br><span class="line">  logger.info(<span class="string">"error"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RestTemplate配置"><a href="#RestTemplate配置" class="headerlink" title="RestTemplate配置"></a>RestTemplate配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123; RestOperations.class, RestTemplate.class &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">(ClientHttpRequestFactory factory)</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(factory);</span><br><span class="line"></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line">        Iterator&lt;HttpMessageConverter&lt;?&gt;&gt; iterator = messageConverters.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            HttpMessageConverter&lt;?&gt; converter = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (converter <span class="keyword">instanceof</span> StringHttpMessageConverter) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">        restTemplate.getMessageConverters().add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(&#123;ClientHttpRequestFactory.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">simpleClientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleClientHttpRequestFactory factory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">        factory.setReadTimeout(<span class="number">15000</span>);<span class="comment">// ms</span></span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://spring.io/blog/2009/03/27/rest-in-spring-3-resttemplate" target="_blank" rel="noopener">https://spring.io/blog/2009/03/27/rest-in-spring-3-resttemplate</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RestTemplate-是什么？&quot;&gt;&lt;a href=&quot;#RestTemplate-是什么？&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate 是什么？&quot;&gt;&lt;/a&gt;RestTemplate 是什么？&lt;/h3&gt;&lt;p&gt;RestTemplate是Spring提供的一个访问Http服务的客户端类，非常类似JdbcTemplate, JmsTemplate。它是线程安全的（一旦创建完成）。从名称上来看，该类更多是针对RESTFUL风格API设计的。当然如果你想通过它调用普通的Http接口也是可以的。&lt;/p&gt;
&lt;h3 id=&quot;RestTemplate-的方法&quot;&gt;&lt;a href=&quot;#RestTemplate-的方法&quot; class=&quot;headerlink&quot; title=&quot;RestTemplate 的方法&quot;&gt;&lt;/a&gt;RestTemplate 的方法&lt;/h3&gt;&lt;p&gt;RestTemplate提供的方法都是以Http协议中的6个动词开头的：&lt;/p&gt;
&lt;img src=&quot;/2018/05/30/spring-RestTemplate/spring-template.png&quot;&gt;
&lt;p&gt;这些方法的名称清楚地表明它们调用的是哪个HTTP方法，而名称的第二部分表示返回的内容。 例如，&lt;code&gt;getForObject（）&lt;/code&gt;将执行GET，将HTTP响应转换为你选择的对象类型，并返回该对象。&lt;code&gt;postForLocation&lt;/code&gt;将执行POST，将给定对象转换为HTTP请求，并返回可以找到新创建对象的响应&lt;code&gt;HTTP Location&lt;/code&gt;标头。 如你所见，这些方法试图强制执行REST最佳实践。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="https://leokongwq.github.io/categories/web/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
</feed>
