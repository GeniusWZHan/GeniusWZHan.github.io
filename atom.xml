<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戒修-沉迷技术的小沙弥</title>
  <subtitle>我喜欢GO</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leokongwq.github.io/"/>
  <updated>2019-12-13T16:20:17.183Z</updated>
  <id>https://leokongwq.github.io/</id>
  
  <author>
    <name>kongwenqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://leokongwq.github.io/2019/12/14/elastic-job-summary.html"/>
    <id>https://leokongwq.github.io/2019/12/14/elastic-job-summary.html</id>
    <published>2019-12-13T16:19:30.452Z</published>
    <updated>2019-12-13T16:20:17.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="elastic-job-是什么？"><a href="#elastic-job-是什么？" class="headerlink" title="elastic-job 是什么？"></a>elastic-job 是什么？</h2><p>还是看官方文档介绍：<a href="http://elasticjob.io/docs/elastic-job-lite/00-overview/" target="_blank" rel="noopener">http://elasticjob.io/docs/elastic-job-lite/00-overview/</a></p>
<h2 id="elastic-job-实现分析"><a href="#elastic-job-实现分析" class="headerlink" title="elastic-job 实现分析"></a>elastic-job 实现分析</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="http://elasticjob.io/docs/elastic-job-lite/img/architecture/elastic_job_lite.png" alt="Elastic-Job-Lite Architecture"></p>
<p>从上图可以看到 elastic-job 的实现主要依赖的外部组件是zookeeper。 用zookeeper来实现分布式任务的协调及相关任务信息的保存。具体任务的调度触发还是依赖core模块里面的Quartz API提供的能力。</p>
<a id="more"></a>
<h3 id="spring-集成分析"><a href="#spring-集成分析" class="headerlink" title="spring 集成分析"></a>spring 集成分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;reg:zookeeper id=<span class="string">"regCenter"</span></span><br><span class="line">                   server-lists=<span class="string">"$&#123;elastic.job.zk.host&#125;"</span></span><br><span class="line">                   namespace=<span class="string">"viptrade-job"</span></span><br><span class="line">                   base-sleep-time-milliseconds=<span class="string">"1000"</span></span><br><span class="line">                   max-sleep-time-milliseconds=<span class="string">"3000"</span></span><br><span class="line">                   max-retries=<span class="string">"3"</span></span><br><span class="line">                   session-timeout-milliseconds=<span class="string">"5000"</span></span><br><span class="line">                   connection-timeout-milliseconds=<span class="string">"3000"</span></span><br><span class="line">/&gt;</span><br><span class="line">&lt;job:simple id=<span class="string">"mySimpleElasticJob"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.leokongwq.elasticjob.elasticjobdemo.job.MySimpleElasticJob"</span> </span><br><span class="line">    registry-center-ref=<span class="string">"regCenter"</span></span><br><span class="line">    cron=<span class="string">"0/10 * * * * ?"</span></span><br><span class="line">    job-parameter=<span class="string">"name=sky;age=21"</span></span><br><span class="line">    sharding-total-count=<span class="string">"3"</span></span><br><span class="line">    sharding-item-parameters=<span class="string">"0=A,1=B,2=C"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>从上面的配置容易看出， elastic-job 是采用spring提供的命名空间扩展能力进行集成的。</p>
<p>具体是通过如下的配置和类实现：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http\://www.dangdang.com/schema/ddframe/reg/reg.xsd=META-INF/namespace/reg.xsd</span><br><span class="line">http\://www.dangdang.com/schema/ddframe/job/job.xsd=META-INF/namespace/job.xsd</span><br><span class="line"></span><br><span class="line">http\://www.dangdang.com/schema/ddframe/reg=io.elasticjob.lite.spring.reg.handler.RegNamespaceHandler</span><br><span class="line">http\://www.dangdang.com/schema/ddframe/job=io.elasticjob.lite.spring.job.handler.JobNamespaceHandler</span><br></pre></td></tr></table></figure>
<p><code>RegNamespaceHandler</code> 来负责解析 <code>reg</code>命名空间配置。<code>JobNamespaceHandler</code> 来解析<code>job</code>命名空间配置</p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>目前只支持基于zookeeper的注册中心，核心的类是<code>ZookeeperRegistryCenter</code>。</p>
<p>支持的核心配置如下：</p>
<ul>
<li>serverLists  zookeeper节点列表，逗号分隔</li>
<li>namespace 任务的命名空间， 同时也是Curator操作的命名空间，所有的操作都是相对于这个命名空间的。</li>
<li>baseSleepTimeMilliseconds maxSleepTimeMilliseconds maxRetries 这三个都是底层Curator的重试策略<code>ExponentialBackoffRetry</code>配置属性</li>
<li>sessionTimeoutMilliseconds zookeeper 回话超时时间</li>
<li>connectionTimeoutMilliseconds zookeeper 连接超时时间</li>
<li>digest zookeeper认证信息</li>
</ul>
<h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><p>不同的job定义是通过不同的Handler类处理的。</p>
<p>SimpleJobBeanDefinitionParser 处理 simple 命名空间的任务定义</p>
<p>DataflowJobBeanDefinitionParser 处理 dataflow命名空间的任务定义</p>
<p>ScriptJobBeanDefinitionParser 处理 script命名空间的任务定义</p>
<p>所有job 在spring容器中最终生成的 Bean 类型 都是 <code>SpringJobScheduler</code> 并通过<code>init</code>方法进行初始化。</p>
<h3 id="zookeeper-目录结构"><a href="#zookeeper-目录结构" class="headerlink" title="zookeeper 目录结构"></a>zookeeper 目录结构</h3><p>/jobname</p>
<p>/jobname/systemtime/current 保存当前时间</p>
<p>/jobname/config  job 配置信息</p>
<p>/jobname/guarantee/started/0  # 分布式环境下，任务同时开始</p>
<p>/jobname/guarantee/stoped/0  # 分布式环境下，任务同时结束</p>
<p>/jobname/servers/ip #曾经注册了可以执行job的机器. 数据节点的值为空字符串表示正常，disabled表示不可用</p>
<p>/jobname/instances/ip@-@pid #表示存活的实例，节点值为空字符串</p>
<p>/jobname/sharding/0/instance # 节点的值是instanceId eg. 10.3.9.7@-@4256</p>
<p>/jobname/sharding/0/running # 表示分片运行状态</p>
<p>/jobname/sharding/0/misfire # 表示任务被错过执行标志，第二次调度时，第一次的任务还没有执行完成。</p>
<p>/jobname/sharding/0/disabled # 表示分片被禁用</p>
<p>/jobname/sharding/0/failover # 表示执行分片failover， 节点的值是执行失败分片的实例id,即 instanceId</p>
<p>/jobname/learder/sharding/necessary # 表示Job是否需要分片， 分片完成后被删除</p>
<p>/jobname/learder/sharding/processing # 表示Job正在进行分片， 分片完成后被删除</p>
<p>/jobname/learder/election/latch # 表示进行选主的根节点</p>
<p>/jobname/learder/election/instance # 表示被选为master的实例，节点的值是master实例的instanceId</p>
<p>/jobname/learder/failover/items/0 # 表示需要failover的分片</p>
<h3 id="Quartz-如何调度任务？"><a href="#Quartz-如何调度任务？" class="headerlink" title="Quartz 如何调度任务？"></a>Quartz 如何调度任务？</h3><h4 id="QuartzSchedulerThread"><a href="#QuartzSchedulerThread" class="headerlink" title="QuartzSchedulerThread"></a>QuartzSchedulerThread</h4><figure class="highlight java"><figcaption><span>QuartzSchedulerThread</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JobRunShell shell = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">    shell.initialize(qs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">    qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (qsRsrcs.getThreadPool().runInThread(shell) == <span class="keyword">false</span>) &#123;</span><br><span class="line">    <span class="comment">// this case should never happen, as it is indicative of the</span></span><br><span class="line">    <span class="comment">// scheduler being shutdown or a bug in the thread pool or</span></span><br><span class="line">    <span class="comment">// a thread pool being used concurrently - which the docs</span></span><br><span class="line">    <span class="comment">// say not to do...</span></span><br><span class="line">    getLog().error(<span class="string">"ThreadPool.runInThread() return false!"</span>);</span><br><span class="line">    qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobFactory"><a href="#JobFactory" class="headerlink" title="JobFactory"></a>JobFactory</h4><p><code>JobFactory</code>负责Job的创建。 一般是通过<code>JobDetail</code>指的class属性，通过反射API进行创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobFactory</span> <span class="keyword">implements</span> <span class="title">JobFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(getClass());</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Logger <span class="title">getLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> log;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Job <span class="title">newJob</span><span class="params">(TriggerFiredBundle bundle, Scheduler Scheduler)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        JobDetail jobDetail = bundle.getJobDetail();</span><br><span class="line">        Class&lt;? extends Job&gt; jobClass = jobDetail.getJobClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(</span><br><span class="line">                    <span class="string">"Producing instance of Job '"</span> + jobDetail.getKey() + </span><br><span class="line">                    <span class="string">"', class="</span> + jobClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> jobClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Problem instantiating class '"</span></span><br><span class="line">                            + jobDetail.getJobClass().getName() + <span class="string">"'"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobRunShell"><a href="#JobRunShell" class="headerlink" title="JobRunShell"></a>JobRunShell</h4><p><code>JobRunShell</code>  提供Job执行环境，真正负责Job的执行。</p>
<figure class="highlight java"><figcaption><span>JobRunShell</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(QuartzScheduler sched)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.qs = sched;</span><br><span class="line"></span><br><span class="line">        Job job = <span class="keyword">null</span>;</span><br><span class="line">        JobDetail jobDetail = firedTriggerBundle.getJobDetail();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//负责Job的创建， 通过反射API创建</span></span><br><span class="line">            job = sched.getJobFactory().newJob(firedTriggerBundle, scheduler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">            sched.notifySchedulerListenersError(</span><br><span class="line">                    <span class="string">"An error occured instantiating job to be executed. job= '"</span></span><br><span class="line">                            + jobDetail.getKey() + <span class="string">"'"</span>, se);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ncdfe) &#123; <span class="comment">// such as NoClassDefFoundError</span></span><br><span class="line">            SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Problem instantiating class '"</span></span><br><span class="line">                            + jobDetail.getJobClass().getName() + <span class="string">"' - "</span>, ncdfe);</span><br><span class="line">            sched.notifySchedulerListenersError(</span><br><span class="line">                    <span class="string">"An error occured instantiating job to be executed. job= '"</span></span><br><span class="line">                            + jobDetail.getKey() + <span class="string">"'"</span>, se);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 创建Job执行上下文</span></span><br><span class="line">        <span class="keyword">this</span>.jec = <span class="keyword">new</span> JobExecutionContextImpl(scheduler, firedTriggerBundle, job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">trueqs.addInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OperableTrigger trigger = (OperableTrigger) jec.getTrigger();</span><br><span class="line">        JobDetail jobDetail = jec.getJobDetail();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">truetruetrue<span class="comment">// 删除一部分代码</span></span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> endTime = startTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// execute the job</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Calling execute on job "</span> + jobDetail.getKey());</span><br><span class="line">                <span class="comment">// job 开始执行</span></span><br><span class="line">                job.execute(jec);</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JobExecutionException jee) &#123;</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">                jobExEx = jee;</span><br><span class="line">                getLog().info(<span class="string">"Job "</span> + jobDetail.getKey() +</span><br><span class="line">                              <span class="string">" threw a JobExecutionException: "</span>, jobExEx);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">                getLog().error(<span class="string">"Job "</span> + jobDetail.getKey() +</span><br><span class="line">                               <span class="string">" threw an unhandled Exception: "</span>, e);</span><br><span class="line">                SchedulerException se = <span class="keyword">new</span> SchedulerException(</span><br><span class="line">                    <span class="string">"Job threw an unhandled exception."</span>, e);</span><br><span class="line">                qs.notifySchedulerListenersError(<span class="string">"Job ("</span></span><br><span class="line">                                                 + jec.getJobDetail().getKey()</span><br><span class="line">                                                 + <span class="string">" threw an exception."</span>, se);</span><br><span class="line">                jobExEx = <span class="keyword">new</span> JobExecutionException(se, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 删除部分代码</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        qs.removeInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LiteJob"><a href="#LiteJob" class="headerlink" title="LiteJob"></a>LiteJob</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lite调度作业.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangliang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LiteJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> ElasticJob elasticJob;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> JobFacade jobFacade;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LiteJob</code> 实现了Quartz 中表示任务的接口<code>Job</code> ， 通过<code>LiteJob</code>类，elastic-job实现了和Quartz的整合。</p>
<h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h4 id="JobInstance-amp-JobRegistry"><a href="#JobInstance-amp-JobRegistry" class="headerlink" title="JobInstance &amp; JobRegistry"></a>JobInstance &amp; JobRegistry</h4><p>JobRegistry 表示job注册中心，在Job创建时 以job的名称为key， JobInstance为Value保存到一个Map中。</p>
<p>JobInstance 本质上是一个字符串，来唯一标识一个Job</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler</span><br><span class="line">JobRegistry.getInstance().addJobInstance(liteJobConfig.getJobName(), <span class="keyword">new</span> JobInstance());</span><br><span class="line"></span><br><span class="line">JobRegistry</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, JobInstance&gt; jobInstanceMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加作业实例.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jobName 作业名称</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> jobInstance 作业实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJobInstance</span><span class="params">(<span class="keyword">final</span> String jobName, <span class="keyword">final</span> JobInstance jobInstance)</span> </span>&#123;</span><br><span class="line">    jobInstanceMap.put(jobName, jobInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GuaranteeService"><a href="#GuaranteeService" class="headerlink" title="GuaranteeService"></a>GuaranteeService</h4><p>保证分布式任务全部开始和结束状态的服务。</p>
<p>一个多片任务，通过该类实现所有分片同时开始，等待所有分片都完成。</p>
<h5 id="注册开始分片："><a href="#注册开始分片：" class="headerlink" title="注册开始分片："></a>注册开始分片：</h5><p>如果一个Job分为三片，那么就会在zookeeper上创建三个不同的<code>持久化</code>节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">job 开始</span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">1</span></span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">2</span></span><br><span class="line">/命名空间/job名称/guarantee/started/<span class="number">3</span></span><br><span class="line"></span><br><span class="line">job 结束</span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">1</span></span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">2</span></span><br><span class="line">/命名空间/job名称/guarantee/completed/<span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="LeaderService"><a href="#LeaderService" class="headerlink" title="LeaderService"></a>LeaderService</h4><p><code>LeaderService</code>是Job在zookeeper上主节点服务类，主要作用如下：</p>
<ol>
<li>Job主节点选举</li>
<li>判断当前节点是否是主节点</li>
<li>判断Job是否有主节点</li>
<li>删除主节点</li>
</ol>
<p>选举主节点底层是通过Curator提供的master选举功能。创建的节点路径是<code>Job名称/leader/election/latch/latch-*</code>  , * 表示1,2,3…(临时顺序节点)</p>
<p>并写入当前Job执行实例的<code>instanceId</code></p>
<p>说白了就是操作<code>jobName/leader</code>及其子节点的工具类</p>
<h4 id="ServerService"><a href="#ServerService" class="headerlink" title="ServerService"></a>ServerService</h4><p><code>ServerService</code>类用来操作<code>jobName/servers</code>及其子节点。主要功能如下：</p>
<ol>
<li>创建执行Job的服务节点<code>jobName</code>/servers/ip；如果该节点可用，则保存的数据为空字符串，不可用保存的数据为<code>DISABLED</code></li>
<li>判断是否还有可用的Job执行节点。其实就是判断<code>jobName</code>/servers/ip<code>节点存在并且保存的值是空字符串，并且节点</code>jobName/instances/ip`存在。</li>
</ol>
<h4 id="InstanceService"><a href="#InstanceService" class="headerlink" title="InstanceService"></a>InstanceService</h4><p><code>InstanceService</code>用来操作节点<code>jobName/instances</code>。主要功能如下：</p>
<ol>
<li>标识Job实例上线。其实就是创建一个节点<code>jobName/instances/instanceId</code></li>
<li>删除instance节点</li>
</ol>
<h4 id="ListenerManager"><a href="#ListenerManager" class="headerlink" title="ListenerManager"></a>ListenerManager</h4><p><code>ListenerManager</code>用来管理所有elastic-job的各种<code>Listener</code>或其他的<code>ListenerManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作业注册中心的监听器管理者.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhangliang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JobNodeStorage jobNodeStorage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElectionListenerManager electionListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShardingListenerManager shardingListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FailoverListenerManager failoverListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MonitorExecutionListenerManager monitorExecutionListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShutdownListenerManager shutdownListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TriggerListenerManager triggerListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RescheduleListenerManager rescheduleListenerManager;</span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 任务执行前或执行后的监听器， 在分布式环境下，确保只通知一次。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GuaranteeListenerManager guaranteeListenerManager;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RegistryCenterConnectionStateListener regCenterConnectionStateListener;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerManager</span><span class="params">(<span class="keyword">final</span> CoordinatorRegistryCenter regCenter, <span class="keyword">final</span> String jobName, <span class="keyword">final</span> List&lt;ElasticJobListener&gt; elasticJobListeners)</span> </span>&#123;</span><br><span class="line">        jobNodeStorage = <span class="keyword">new</span> JobNodeStorage(regCenter, jobName);</span><br><span class="line">        electionListenerManager = <span class="keyword">new</span> ElectionListenerManager(regCenter, jobName);</span><br><span class="line">        shardingListenerManager = <span class="keyword">new</span> ShardingListenerManager(regCenter, jobName);</span><br><span class="line">        failoverListenerManager = <span class="keyword">new</span> FailoverListenerManager(regCenter, jobName);</span><br><span class="line">        monitorExecutionListenerManager = <span class="keyword">new</span> MonitorExecutionListenerManager(regCenter, jobName);</span><br><span class="line">        shutdownListenerManager = <span class="keyword">new</span> ShutdownListenerManager(regCenter, jobName);</span><br><span class="line">        triggerListenerManager = <span class="keyword">new</span> TriggerListenerManager(regCenter, jobName);</span><br><span class="line">        rescheduleListenerManager = <span class="keyword">new</span> RescheduleListenerManager(regCenter, jobName);</span><br><span class="line">        guaranteeListenerManager = <span class="keyword">new</span> GuaranteeListenerManager(regCenter, jobName, elasticJobListeners);</span><br><span class="line">        regCenterConnectionStateListener = <span class="keyword">new</span> RegistryCenterConnectionStateListener(regCenter, jobName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启所有监听器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAllListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        electionListenerManager.start();</span><br><span class="line">        shardingListenerManager.start();</span><br><span class="line">        failoverListenerManager.start();</span><br><span class="line">        monitorExecutionListenerManager.start();</span><br><span class="line">        shutdownListenerManager.start();</span><br><span class="line">        triggerListenerManager.start();</span><br><span class="line">        rescheduleListenerManager.start();</span><br><span class="line">        guaranteeListenerManager.start();</span><br><span class="line">        jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShardingContext"><a href="#ShardingContext" class="headerlink" title="ShardingContext"></a>ShardingContext</h4><p>分片上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业名称.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业任务ID.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String taskId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分片总数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingTotalCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作业自定义参数.</span></span><br><span class="line"><span class="comment">     * 可以配置多个相同的作业, 但是用不同的参数作为不同的调度实例.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String jobParameter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配于本作业实例的分片项.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> shardingItem;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分配于本作业实例的分片参数.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String shardingParameter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JobExecutorFactory"><a href="#JobExecutorFactory" class="headerlink" title="JobExecutorFactory"></a>JobExecutorFactory</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 作业执行器工厂.</span><br><span class="line"> *</span><br><span class="line"> * @author zhangliang</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor(access = AccessLevel.PRIVATE)</span><br><span class="line">public final class JobExecutorFactory &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 获取作业执行器.</span><br><span class="line">     *</span><br><span class="line">     * @param elasticJob 分布式弹性作业</span><br><span class="line">     * @param jobFacade 作业内部服务门面服务</span><br><span class="line">     * @return 作业执行器</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public static AbstractElasticJobExecutor getJobExecutor(final ElasticJob elasticJob, final JobFacade jobFacade) &#123;</span><br><span class="line">        if (null == elasticJob) &#123;</span><br><span class="line">            return new ScriptJobExecutor(jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        if (elasticJob instanceof SimpleJob) &#123;</span><br><span class="line">            return new SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        if (elasticJob instanceof DataflowJob) &#123;</span><br><span class="line">            return new DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new JobConfigurationException(&quot;Cannot support job type &apos;%s&apos;&quot;, elasticJob.getClass().getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AbstractElasticJobExecutor"><a href="#AbstractElasticJobExecutor" class="headerlink" title="AbstractElasticJobExecutor"></a>AbstractElasticJobExecutor</h4><p><code>AbstractElasticJobExecutor</code>是Job执行的核心类。它有如下三个子类，分别对应不同种类的任务</p>
<ol>
<li>SimpleJobExecutor</li>
<li>DataflowJobExecutor</li>
<li>ScriptJobExecutor</li>
</ol>
<h3 id="作业初始化"><a href="#作业初始化" class="headerlink" title="作业初始化"></a>作业初始化</h3><p>所有配置的Job 最终都是生成一个调度对象<code>JobScheduler</code>进行任务的触发调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始化作业.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="comment">//更新配置信息</span></span><br><span class="line">    LiteJobConfiguration liteJobConfigFromRegCenter = schedulerFacade.updateJobConfiguration(liteJobConfig);</span><br><span class="line"><span class="comment">//设置Job当前的分片总数			JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());</span></span><br><span class="line">    <span class="comment">// 创建Job调度控制器</span></span><br><span class="line">trueJobScheduleController jobScheduleController = <span class="keyword">new</span> JobScheduleController(</span><br><span class="line">                createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</span><br><span class="line">true<span class="comment">//添加作业调度控制器</span></span><br><span class="line">    JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);</span><br><span class="line">true<span class="comment">//注册作业启动信息， 这个步骤非常重要</span></span><br><span class="line">    schedulerFacade.registerStartUpInfo(!liteJobConfigFromRegCenter.isDisabled());</span><br><span class="line"><span class="comment">// 调度Job		jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-冲突检查-amp-更新配置"><a href="#1-冲突检查-amp-更新配置" class="headerlink" title="1.冲突检查&amp;更新配置"></a>1.冲突检查&amp;更新配置</h4><p>每个Job的配置信息在 zookeeper上的节点路径是<code>/命名空间/job名称/config</code> 格式是一个json字符串。</p>
<p>如果配置信息里面保存的Job <code>class名称</code>和本地配置的<code>class</code>名称不同，此时elastic-job会提升冲突<code>JobConfigurationException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConflictJob</span><span class="params">(<span class="keyword">final</span> LiteJobConfiguration liteJobConfig)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//查询zookeeper上的配置信息</span></span><br><span class="line">    	Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (liteJobConfigFromZk.isPresent() &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JobConfigurationException(<span class="string">"Job conflict with register center. The job '%s' in register center's class is '%s', your job class is '%s'"</span>, </span><br><span class="line">                    liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Job配置的属性<code>overwrite=true</code>，则用本地的配置信息更新zookeeper上的配置信息。</p>
<h4 id="2-启动所有监听器"><a href="#2-启动所有监听器" class="headerlink" title="2. 启动所有监听器"></a>2. 启动所有监听器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开启所有监听器.</span><br><span class="line"> */</span><br><span class="line">public void startAllListeners() &#123;</span><br><span class="line">    electionListenerManager.start(); </span><br><span class="line">    shardingListenerManager.start(); </span><br><span class="line">    failoverListenerManager.start(); </span><br><span class="line">    monitorExecutionListenerManager.start(); // </span><br><span class="line">    shutdownListenerManager.start();</span><br><span class="line">    triggerListenerManager.start();</span><br><span class="line">    rescheduleListenerManager.start();</span><br><span class="line">    guaranteeListenerManager.start();</span><br><span class="line">    jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ElectionListener"><a href="#ElectionListener" class="headerlink" title="ElectionListener"></a>ElectionListener</h5><p>选主监听器，当master奔溃或上下线job服务器或服务器被禁用，进行选主</p>
<h5 id="ShardingListenerManager"><a href="#ShardingListenerManager" class="headerlink" title="ShardingListenerManager"></a>ShardingListenerManager</h5><p>job分片数调整，或job服务器上下线时触发分片调整（任务下次执行时，真正进行调整，listener只是设置需要调整分片标志）</p>
<p>当前的实现逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListenServersChangedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!JobRegistry.getInstance().isShutdown(jobName) &amp;&amp; (isInstanceChange(eventType, path) || isServerChange(path))) &#123;</span><br><span class="line">                shardingService.setReshardingFlag();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是`jobName/instances`开头的路径，并且不是数据更新事件，</span></span><br><span class="line">        <span class="comment">// 那么就必然是 NODE_ADD, 或 NODE_REMOVE 事件了</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isInstanceChange</span><span class="params">(<span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instanceNode.isInstancePath(path) &amp;&amp; Type.NODE_UPDATED != eventType;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isServerChange</span><span class="params">(<span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> serverNode.isServerPath(path);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FailoverListenerManager"><a href="#FailoverListenerManager" class="headerlink" title="FailoverListenerManager"></a>FailoverListenerManager</h5><ol>
<li><p>job执行中奔溃， 如果设置了Job的failover配置，那么进行Job的故障转移</p>
</li>
<li><p>如果将job的failover配置调整为false，那么删除job所有分片的failover节点。 <code>jobName/sharding/0/failover</code></p>
</li>
</ol>
<h5 id="MonitorExecutionListenerManager"><a href="#MonitorExecutionListenerManager" class="headerlink" title="MonitorExecutionListenerManager"></a>MonitorExecutionListenerManager</h5><ol>
<li>如果将job的配置项<code>monitorExecution</code>设置为false，那么删除Job所有分片的running节点。<code>jobName/sharding/0/running</code></li>
</ol>
<h5 id="ShutdownListenerManager"><a href="#ShutdownListenerManager" class="headerlink" title="ShutdownListenerManager"></a>ShutdownListenerManager</h5><ol>
<li>如果<code>jobName/sharding/0/instance</code> 节点被删除，那么该实例不再参与任务调度。</li>
<li>关闭Monitor Socket,  如果是master，则放弃master身份。关闭 job对应的Quartz调度器。</li>
<li>释放缓存</li>
<li>删除内存中的状态数据</li>
</ol>
<h5 id="TriggerListenerManager"><a href="#TriggerListenerManager" class="headerlink" title="TriggerListenerManager"></a>TriggerListenerManager</h5><ol>
<li>将<code>jobName/instances/instanceid</code> 节点的值设置为 <code>trigger</code>, 并且当前Job不处于运行中，则直接触发Job的执行。</li>
</ol>
<h5 id="RescheduleListenerManager"><a href="#RescheduleListenerManager" class="headerlink" title="RescheduleListenerManager"></a>RescheduleListenerManager</h5><ol>
<li>当修改任务的cron表达式时， 触发任务重新调度。 </li>
</ol>
<h5 id="GuaranteeListenerManager"><a href="#GuaranteeListenerManager" class="headerlink" title="GuaranteeListenerManager"></a>GuaranteeListenerManager</h5><ol>
<li>当节点<code>jobName/guarantee/started</code>节点被删除时，通知对应的Listener.</li>
<li>当节点<code>jobName/guarantee/completed</code>节点被删除时，通知对应的Listener.</li>
</ol>
<h5 id="RegistryCenterConnectionStateListener"><a href="#RegistryCenterConnectionStateListener" class="headerlink" title="RegistryCenterConnectionStateListener"></a>RegistryCenterConnectionStateListener</h5><p>zk连接状态监听器。</p>
<ol>
<li>当断开连接 或 连接出去挂起状态，暂时任务调度。<code>jobScheduleController.pauseJob();</code></li>
<li>连接重新建立时，上线<code>server</code>和<code>instance</code> , 清除分片的<code>running</code>状态。恢复job调度。</li>
</ol>
<h4 id="3-选取主节点"><a href="#3-选取主节点" class="headerlink" title="3.选取主节点"></a>3.选取主节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaderService.electLeader();</span><br><span class="line">/**</span><br><span class="line"> * 选举主节点.</span><br><span class="line"> */</span><br><span class="line">public void electLeader() &#123;</span><br><span class="line">    log.debug(&quot;Elect a new leader now.&quot;);</span><br><span class="line">    jobNodeStorage.executeInLeader(LeaderNode.LATCH, new 	LeaderElectionExecutionCallback());</span><br><span class="line">    log.debug(&quot;Leader election completed.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主节点选取成功后，获得master角色的实例，将它的实例id写入<code>jobName/leader/election/instance</code>节点</p>
<h4 id="4-上线服务器和实例"><a href="#4-上线服务器和实例" class="headerlink" title="4.上线服务器和实例"></a>4.上线服务器和实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serverService.persistOnline(enabled);</span><br><span class="line">instanceService.persistOnline();</span><br></pre></td></tr></table></figure>
<p><code>/jobName/servers/ip</code> 数据设置为空字符串</p>
<p><code>/jobName/instances/instanceid</code> 数据设置为空字符串</p>
<h4 id="5-设置需要分片信息"><a href="#5-设置需要分片信息" class="headerlink" title="5.设置需要分片信息"></a>5.设置需要分片信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shardingService.setReshardingFlag();</span><br></pre></td></tr></table></figure>
<p>设置需要分片标识<code>/jobName/leader/sharding/necessary</code> </p>
<h4 id="6-打开监控端口"><a href="#6-打开监控端口" class="headerlink" title="6.打开监控端口"></a>6.打开监控端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorService.listen();</span><br></pre></td></tr></table></figure>
<h4 id="7-启动分布式状态不一致修复服务"><a href="#7-启动分布式状态不一致修复服务" class="headerlink" title="7. 启动分布式状态不一致修复服务"></a>7. 启动分布式状态不一致修复服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!reconcileService.isRunning()) &#123;</span><br><span class="line">    reconcileService.startAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作业执行"><a href="#作业执行" class="headerlink" title="作业执行"></a>作业执行</h3><p>elastic-job 中作业的执行是通过不同的<code>JobExecutor</code>来实现的。核心逻辑都封装在父类<code>AbstractElasticJobExecutor</code>中。下面我们主要以<code>SimpleJobExecutor</code>来分析Job的执行流程。</p>
<h4 id="SimpleJobExecutor"><a href="#SimpleJobExecutor" class="headerlink" title="SimpleJobExecutor"></a>SimpleJobExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractElasticJobExecutor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleJob simpleJob;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleJobExecutor</span><span class="params">(<span class="keyword">final</span> SimpleJob simpleJob, <span class="keyword">final</span> JobFacade jobFacade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(jobFacade);</span><br><span class="line">        <span class="keyword">this</span>.simpleJob = simpleJob;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">final</span> ShardingContext shardingContext)</span> </span>&#123;</span><br><span class="line">        simpleJob.execute(shardingContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Job-执行入口-AbstractElasticJobExecutor"><a href="#Job-执行入口-AbstractElasticJobExecutor" class="headerlink" title="Job 执行入口 AbstractElasticJobExecutor"></a>Job 执行入口 AbstractElasticJobExecutor</h4><figure class="highlight java"><figcaption><span>AbstractElasticJobExecutor.execute</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 执行作业.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 检查执行环境，主要是检查时间误差是否在允许的时间范围内。</span></span><br><span class="line">        jobFacade.checkJobExecutionEnvironment();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> JobExecutionEnvironmentException cause) &#123;</span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造Job执行上下文对象，非常重要，后面专门分析</span></span><br><span class="line">    ShardingContexts shardingContexts = jobFacade.getShardingContexts();</span><br><span class="line">    <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</span><br><span class="line">        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(<span class="string">"Job '%s' execute begin."</span>, jobName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Job仍处于执行状态，则设置missfire标志</span></span><br><span class="line">    <span class="keyword">if</span> (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shardingContexts.isAllowSendJobEvent()) &#123;</span><br><span class="line">            jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</span><br><span class="line">                <span class="string">"Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed."</span>, jobName, </span><br><span class="line">                shardingContexts.getShardingItemParameters().keySet()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 ElasticJobListener </span></span><br><span class="line">        jobFacade.beforeJobExecuted(shardingContexts);</span><br><span class="line">        <span class="comment">//CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</span><br><span class="line">        <span class="comment">//CHECKSTYLE:ON</span></span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 job</span></span><br><span class="line">    execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</span><br><span class="line">    <span class="comment">// 如果开启了misfire功能，则再次Job</span></span><br><span class="line">    <span class="keyword">while</span> (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) &#123;</span><br><span class="line">        jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</span><br><span class="line">        execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有任务分片执行失败了，并且启用了failover功能，则重新执行失败了的分片</span></span><br><span class="line">    jobFacade.failoverIfNecessary();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通知 ElasticJobListener</span></span><br><span class="line">        jobFacade.afterJobExecuted(shardingContexts);</span><br><span class="line">        <span class="comment">//CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable cause) &#123;</span><br><span class="line">        <span class="comment">//CHECKSTYLE:ON</span></span><br><span class="line">        jobExceptionHandler.handleException(jobName, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LiteJobFacade-getShardingContexts"><a href="#LiteJobFacade-getShardingContexts" class="headerlink" title="LiteJobFacade.getShardingContexts"></a>LiteJobFacade.getShardingContexts</h4><p>获取Job执行的上下文信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ShardingContexts getShardingContexts() &#123;</span><br><span class="line">trueboolean isFailover = configService.load(true).isFailover();</span><br><span class="line">true//如果开始了failover功能</span><br><span class="line">    if (isFailover) &#123;</span><br><span class="line">    	// 获取分配到本机的failover分片</span><br><span class="line">        List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</span><br><span class="line">        log.debug(&quot;failover sharding items is &#123;&#125;&quot;, failoverShardingItems);</span><br><span class="line">        // 如果有分配给本实例执行的failover分片，则执行。</span><br><span class="line">        // 这里有个疑问， 本次任务调度，执行上次调度其他实例执行失败的分片， 那该实例本次调度</span><br><span class="line">        // 需要执行的任务还如何执行呢?</span><br><span class="line">        if (!failoverShardingItems.isEmpty()) &#123;</span><br><span class="line">            return executionContextService.getJobShardingContext(failoverShardingItems);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果需要，进行job分片处理</span><br><span class="line">    shardingService.shardingIfNecessary();</span><br><span class="line">    // 获取分配到本实例的分片，遍历job的所有分片，找出instance节点值和</span><br><span class="line">    // 当前job实例instanceId相同的分片</span><br><span class="line">    List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</span><br><span class="line">    // 如果开启了failover功能，去除failover分片</span><br><span class="line">    if (isFailover) &#123;</span><br><span class="line">        shardingItems.removeAll(failoverService.getLocalTakeOffItems());</span><br><span class="line">    &#125;</span><br><span class="line">    // 去除处于disabled状态的分片</span><br><span class="line">trueshardingItems.removeAll(executionService.getDisabledItems(shardingItems));</span><br><span class="line">true</span><br><span class="line">truereturn executionContextService.getJobShardingContext(shardingItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shardingService-shardingIfNecessary"><a href="#shardingService-shardingIfNecessary" class="headerlink" title="shardingService.shardingIfNecessary"></a>shardingService.shardingIfNecessary</h4><figure class="highlight java"><figcaption><span>shardingService.shardingIfNecessary()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果需要分片且当前节点为主节点, 则作业分片.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 如果当前无可用节点则不分片.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</span><br><span class="line">    <span class="comment">// 存在 jobName/leader/sharding/necessary 并且 有在线的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!isNeedSharding() || availableJobInstances.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断自己是否是主节点 或 等待选举完成后再次判断</span></span><br><span class="line">    <span class="comment">// 只有主节点才能进行分片</span></span><br><span class="line">    <span class="keyword">if</span> (!leaderService.isLeaderUntilBlock()) &#123;</span><br><span class="line">        <span class="comment">// 非主节点，则等待主节点完成分片操作</span></span><br><span class="line">        blockUntilShardingCompleted();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待正在执行的Job执行完成后，再执行分片调整。</span></span><br><span class="line">    waitingOtherJobCompleted();</span><br><span class="line">    LiteJobConfiguration liteJobConfig = configService.load(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">int</span> shardingTotalCount = liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount();</span><br><span class="line">    log.debug(<span class="string">"Job '&#123;&#125;' sharding begin."</span>, jobName);</span><br><span class="line">    jobNodeStorage.fillEphemeralJobNode(ShardingNode.PROCESSING, <span class="string">""</span>);</span><br><span class="line">    resetShardingInfo(shardingTotalCount);</span><br><span class="line">    JobShardingStrategy jobShardingStrategy = JobShardingStrategyFactory.getStrategy(liteJobConfig.getJobShardingStrategyClass());</span><br><span class="line">    jobNodeStorage.executeInTransaction(<span class="keyword">new</span> PersistShardingInfoTransactionExecutionCallback(jobShardingStrategy.sharding(availableJobInstances, jobName, shardingTotalCount)));</span><br><span class="line">    log.debug(<span class="string">"Job '&#123;&#125;' sharding complete."</span>, jobName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分片完成后的回调处理逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistShardingInfoTransactionExecutionCallback</span> <span class="keyword">implements</span> <span class="title">TransactionExecutionCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JobInstance, List&lt;Integer&gt;&gt; shardingResults;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> CuratorTransactionFinal curatorTransactionFinal)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;JobInstance, List&lt;Integer&gt;&gt; entry : shardingResults.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> shardingItem : entry.getValue()) &#123;</span><br><span class="line">                curatorTransactionFinal.create().forPath(jobNodePath.getFullPath(ShardingNode.getInstanceNode(shardingItem)), entry.getKey().getJobInstanceId().getBytes()).and();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 删除分片相关节点，Follower 节点不再等待，继续执行Job      curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.NECESSARY)).and();</span></span><br><span class="line">        curatorTransactionFinal.delete().forPath(jobNodePath.getFullPath(ShardingNode.PROCESSING)).and();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ExecutionContextService-getJobShardContext"><a href="#ExecutionContextService-getJobShardContext" class="headerlink" title="ExecutionContextService.getJobShardContext"></a>ExecutionContextService.getJobShardContext</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取当前作业服务器分片上下文.</span><br><span class="line"> * </span><br><span class="line"> * @param shardingItems 分片项, 有可能是只包含failover节点的分片项</span><br><span class="line"> * @return 分片上下文</span><br><span class="line"> */</span><br><span class="line">public ShardingContexts getJobShardingContext(final List&lt;Integer&gt; shardingItems) &#123;</span><br><span class="line">    LiteJobConfiguration liteJobConfig = configService.load(false);</span><br><span class="line">    // 去除还处于执行状态的分片</span><br><span class="line">    removeRunningIfMonitorExecution(liteJobConfig.isMonitorExecution(), shardingItems);</span><br><span class="line">    log.debug(&quot;After remove running sharding item, result is &#123;&#125;&quot;, shardingItems);</span><br><span class="line">    if (shardingItems.isEmpty()) &#123;</span><br><span class="line">        return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), </span><br><span class="line">                liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), Collections.&lt;Integer, String&gt;emptyMap());</span><br><span class="line">    &#125;</span><br><span class="line">    // 构造分片参数map， key是分片下标， values是分片参数</span><br><span class="line">    Map&lt;Integer, String&gt; shardingItemParameterMap = new ShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</span><br><span class="line">    </span><br><span class="line">    log.info(&quot;sharding Item parameters : &#123;&#125;&quot;, shardingItemParameterMap);</span><br><span class="line">    // 返回值</span><br><span class="line">    return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</span><br><span class="line">            liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), getAssignedShardingItemParameterMap(shardingItems, shardingItemParameterMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="failover实现逻辑"><a href="#failover实现逻辑" class="headerlink" title="failover实现逻辑"></a>failover实现逻辑</h3><p>failover指的是在Job执行中，突然宕机，elastic-job 将中断的Job重新调度到其他可用实例的过程。有一下几点需要注意：</p>
<ol>
<li>开启failover功能。</li>
<li>Job可以调度的实例大于1。</li>
<li>Job执行结果具有幂等性，否则对业务会有影响。</li>
</ol>
<h4 id="failover-监听"><a href="#failover-监听" class="headerlink" title="failover 监听"></a>failover 监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobCrashedJobListener</span> <span class="keyword">extends</span> <span class="title">AbstractJobListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 监听 jobName/instances/IP@-<span class="doctag">@PID</span> 节点的 remove事件，进行failover</span></span><br><span class="line"><span class="comment">         * note: 每个任务都会监听 job实例 crash 的事件, 如果job正在执行中，那么failover是正常的。</span></span><br><span class="line"><span class="comment">         * 但是有一种情况是: job已经执行完成了，此时重新调度执行就有问题了。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> path zk 事件发生的path</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> eventType &#123;<span class="doctag">@link</span> Type&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> data  zk 事件发生的path 节点的数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">(<span class="keyword">final</span> String path, <span class="keyword">final</span> Type eventType, <span class="keyword">final</span> String data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开启failover特性， 并且是 instance奔溃触发的zk事件</span></span><br><span class="line">        <span class="keyword">if</span> (isFailoverEnabled() &amp;&amp; Type.NODE_REMOVED == eventType &amp;&amp; instanceNode.isInstancePath(path)) &#123;</span><br><span class="line">            String jobInstanceId = path.substring(instanceNode.getInstanceFullPath().length() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (jobInstanceId.equals(JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId())) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"Job instance '&#123;&#125;' with path '&#123;&#125;' crashed! will trigger failover."</span>, jobInstanceId, path);</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; failoverItems = failoverService.getFailoverItems(jobInstanceId);</span><br><span class="line">            <span class="keyword">if</span> (!failoverItems.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> each : failoverItems) &#123;</span><br><span class="line">                    <span class="comment">// 创建节点 jobName/leader/failover/items/each </span></span><br><span class="line">                    failoverService.setCrashedFailoverFlag(each);</span><br><span class="line">                    <span class="comment">// 重新调度分片</span></span><br><span class="line">                    failoverService.failoverIfNecessary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取分配给该实例的Job分片信息, 设置failover相关节点，进行failover</span></span><br><span class="line">                <span class="comment">// 此处需要理解的是：</span></span><br><span class="line">                <span class="comment">// 1. 每个Job都有该监听器，每个Job会处理自己的failover逻辑</span></span><br><span class="line">                <span class="comment">// 2. 分片后的Job, 每个分片自己处理自己负责分片的failover逻辑</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> each : shardingService.getShardItemsForFailover(jobInstanceId)) &#123;</span><br><span class="line">                    failoverService.setCrashedFailoverFlag(each);</span><br><span class="line">                    failoverService.failoverIfNecessary();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShardingService获取需要重新调度的分片"><a href="#ShardingService获取需要重新调度的分片" class="headerlink" title="ShardingService获取需要重新调度的分片"></a>ShardingService获取需要重新调度的分片</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取作业运行实例的分片项集合.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jobInstanceId 作业运行实例主键</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 作业运行实例的分片项集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getShardingItems</span><span class="params">(<span class="keyword">final</span> String jobInstanceId)</span> </span>&#123;</span><br><span class="line">    JobInstance jobInstance = <span class="keyword">new</span> JobInstance(jobInstanceId);</span><br><span class="line">    <span class="comment">// 判断Job Crash 的实例ip 对应得服务器是否可用</span></span><br><span class="line">    <span class="comment">// 1. 该server是可用状态</span></span><br><span class="line">    <span class="comment">// 2. 该server还有在线的instance</span></span><br><span class="line">    <span class="keyword">if</span> (!serverService.isAvailableServer(jobInstance.getIp())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> shardingTotalCount = configService.load(<span class="keyword">true</span>).getTypeConfig().getCoreConfig().getShardingTotalCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shardingTotalCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobInstance.getJobInstanceId().equals(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) &#123;</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断作业服务器是否可用.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ip 作业服务器IP地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 作业服务器是否可用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isEnableServer(ip) &amp;&amp; hasOnlineInstances(ip);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断服务器是否启用.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ip 作业服务器IP地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务器是否启用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ServerStatus.DISABLED.name().equals(jobNodeStorage.getJobNodeData(serverNode.getServerNode(ip)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasOnlineInstances</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String each : jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (each.startsWith(ip)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实是有问题的，具体分析如下：</p>
<ol>
<li>突然挂掉的Job实例所在的服务器可能是没有Down机的，并且也不会被Disable。</li>
<li>在实践中中，一个server我们只会启动一个Job实例进程，如果该进程挂掉了，那么该Ip上就没有可用的调度实例了。</li>
<li>由1和2可以得出结论，getShardingItems 返回的结果集肯定是空，所有failover功能其实是失效的（除非一个服务器启动多个Job实例）。</li>
</ol>
<p>这个是在实践中得出的结论，并且<a href="https://github.com/elasticjob/elastic-job-lite/issues/669" target="_blank" rel="noopener">github上有多人反馈这个问题</a>，至今未修复。（好死不死，我就是在本机启动2个Job实例来测试failover功能的，没有问题啊）。只能自己fork了一个版本进行修复。</p>
<h4 id="FailoverServer-进行failover"><a href="#FailoverServer-进行failover" class="headerlink" title="FailoverServer 进行failover"></a>FailoverServer 进行failover</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果需要失效转移, 则执行作业失效转移.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failoverIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needFailover()) &#123;</span><br><span class="line">        jobNodeStorage.executeInLeader(FailoverNode.LATCH, <span class="keyword">new</span> FailoverLeaderExecutionCallback());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否需要进行failover</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 表示需要，false 表示不需要</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">needFailover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jobNodeStorage.isJobNodeExisted(FailoverNode.ITEMS_ROOT) &amp;&amp; !jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).isEmpty()</span><br><span class="line">        &amp;&amp; !JobRegistry.getInstance().isJobRunning(jobName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FailoverLeaderExecutionCallback</span> <span class="keyword">implements</span> <span class="title">LeaderExecutionCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (JobRegistry.getInstance().isShutdown(jobName) || !needFailover()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为什么是get(0)呢？ 原因在于每个分片都在不同的实例上面</span></span><br><span class="line">        <span class="comment">// 但是也有例外啊！ 分片数大于实例数也是可能的。 但是没有理由这么部署。</span></span><br><span class="line">        <span class="keyword">int</span> crashedItem = Integer.parseInt(jobNodeStorage.getJobNodeChildrenKeys(FailoverNode.ITEMS_ROOT).get(<span class="number">0</span>));</span><br><span class="line">        log.debug(<span class="string">"Failover job '&#123;&#125;' begin, crashed item '&#123;&#125;'"</span>, jobName, crashedItem);</span><br><span class="line">        jobNodeStorage.fillEphemeralJobNode(FailoverNode.getExecutionFailoverNode(crashedItem), JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</span><br><span class="line">        jobNodeStorage.removeJobNodeIfExisted(FailoverNode.getItemsNode(crashedItem));</span><br><span class="line">        <span class="comment">// TODO 不应使用triggerJob, 而是使用executor统一调度</span></span><br><span class="line">        JobScheduleController jobScheduleController = JobRegistry.getInstance().getJobScheduleController(jobName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jobScheduleController) &#123;</span><br><span class="line">            jobScheduleController.triggerJob();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="elastic-job-console"><a href="#elastic-job-console" class="headerlink" title="elastic-job-console"></a>elastic-job-console</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过Jetty实现的restful API。</p>
<h3 id="job状态"><a href="#job状态" class="headerlink" title="job状态"></a>job状态</h3><ul>
<li>crash ： 如果job没有可用的instance实例，则为此状态</li>
<li>disabled：如果job所有的server节点保存的值都是<code>disabled</code>，则为此状态</li>
<li>分片调整中：</li>
</ul>
<h3 id="server-操作"><a href="#server-操作" class="headerlink" title="server 操作"></a>server 操作</h3><h4 id="获取服务器总个数"><a href="#获取服务器总个数" class="headerlink" title="获取服务器总个数"></a>获取服务器总个数</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>/api/servers/count </p>
<h5 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>通过遍历每个Job节点下的<code>servers</code>子节点，获取所有的server ip ，进行计数。</p>
<h4 id="获取服务器简明信息"><a href="#获取服务器简明信息" class="headerlink" title="获取服务器简明信息"></a>获取服务器简明信息</h4><h5 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h5><p>/api/servers</p>
<h5 id="实现逻辑-1"><a href="#实现逻辑-1" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历根目录，获取去重后的server IP，统计每个server上注册的Job数量，统计每个Job的运行实例个数。</p>
<h4 id="失效server"><a href="#失效server" class="headerlink" title="失效server"></a>失效server</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>下线或禁用该服务器节点</p>
<h5 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/disable</p>
<h5 id="实现逻辑-2"><a href="#实现逻辑-2" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>jobName/servers/ip</code> 节点的数据设置为<code>disabled</code></p>
<h4 id="启用server"><a href="#启用server" class="headerlink" title="启用server"></a>启用server</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>上线线或启用该服务器节点</p>
<h5 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h5><p>DELETE /api/servers/10.110.114.42/disable</p>
<h5 id="实现逻辑-3"><a href="#实现逻辑-3" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，将<code>jobName/servers/ip</code> 节点的数据设置为空字符串。 </p>
<h4 id="终止server"><a href="#终止server" class="headerlink" title="终止server"></a>终止server</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-4"><a href="#API-4" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/shutdown</p>
<h5 id="实现逻辑-4"><a href="#实现逻辑-4" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，删除<code>jobName/instances/ip@-@pid</code> 节点。 </p>
<h4 id="清理server"><a href="#清理server" class="headerlink" title="清理server"></a>清理server</h4><h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-5"><a href="#API-5" class="headerlink" title="API"></a>API</h5><p>DELETE  /api/servers/10.110.114.42</p>
<h5 id="实现逻辑-5"><a href="#实现逻辑-5" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有job节点，删除<code>jobName/servers/ip</code> 节点。 </p>
<h4 id="获取该服务器下Job注册的简明详情"><a href="#获取该服务器下Job注册的简明详情" class="headerlink" title="获取该服务器下Job注册的简明详情"></a>获取该服务器下Job注册的简明详情</h4><h5 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h5><p>获取该服务器上注册的Job的简明信息</p>
<h5 id="API-6"><a href="#API-6" class="headerlink" title="API"></a>API</h5><p>/api/servers/10.110.114.42/jobs?order=asc&amp;offset=0&amp;limit=10&amp;_=1568597724872</p>
<h5 id="实现逻辑-6"><a href="#实现逻辑-6" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>通过遍历每个<code>job</code>节点下的<code>servers</code>子节点（<code>jobName/servers/ip</code>），判断servers子节点的ip是否和参数指定的ip相同，如果相同则命中，构造job的名称，状态(<code>jobName/servers/ip</code>节点数据，取值如果是非<code>disabled</code>则就是正常)，运行实例（<code>jobname/instances/ip@-@xxxxxx</code>）个数信息。</p>
<h4 id="禁用作业"><a href="#禁用作业" class="headerlink" title="禁用作业"></a>禁用作业</h4><h5 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h5><p>禁用作业</p>
<h5 id="API-7"><a href="#API-7" class="headerlink" title="API"></a>API</h5><p>POST /api/servers/10.110.114.42/jobs/{jobName}/disable</p>
<h5 id="实现逻辑-7"><a href="#实现逻辑-7" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>/jobName/servers</code>下指定IP的子节点（<code>jobName/servers/ip</code>）的数据设置为<code>disabled</code></p>
<h4 id="启用作业"><a href="#启用作业" class="headerlink" title="启用作业"></a>启用作业</h4><h5 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h5><p>启用作业</p>
<h5 id="API-8"><a href="#API-8" class="headerlink" title="API"></a>API</h5><p>DELETE /api/servers/10.110.114.42/jobs/{jobName}/disable</p>
<h5 id="实现逻辑-8"><a href="#实现逻辑-8" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>将<code>/jobName/servers</code>下指定IP的子节点（<code>jobName/servers/ip</code>）的数据设置为空字符串</p>
<h4 id="清理Job"><a href="#清理Job" class="headerlink" title="清理Job"></a>清理Job</h4><h5 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h5><p>下线该服务器节点，意味着所有在该Server节点执行的job实例都不会执行了。</p>
<h5 id="API-9"><a href="#API-9" class="headerlink" title="API"></a>API</h5><p>DELETE  /api/servers/10.110.114.42/jobs/{jobName}</p>
<h5 id="实现逻辑-9"><a href="#实现逻辑-9" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>删除<code>jobName/instances/ip@-@pid</code> 节点。 删除<code>jobName/servers/ip</code> 节点。</p>
<h3 id="Job操作"><a href="#Job操作" class="headerlink" title="Job操作"></a>Job操作</h3><h4 id="Job-数量"><a href="#Job-数量" class="headerlink" title="Job 数量"></a>Job 数量</h4><h5 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h5><p>获取Job的数量</p>
<h5 id="API-10"><a href="#API-10" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs/count</p>
<h5 id="实现逻辑-10"><a href="#实现逻辑-10" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有<code>namespace</code>下的jobName节点，累加。</p>
<h4 id="Job-简明信息列表"><a href="#Job-简明信息列表" class="headerlink" title="Job 简明信息列表"></a>Job 简明信息列表</h4><h5 id="作用-9"><a href="#作用-9" class="headerlink" title="作用"></a>作用</h5><p>获取Job简要列表信息</p>
<h5 id="API-11"><a href="#API-11" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs</p>
<h5 id="实现逻辑-11"><a href="#实现逻辑-11" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>遍历所有jobName节点，构造job简明信息。</p>
<p><code>jobName/config</code>节点的数据是json格式的Job配置信息。</p>
<h4 id="触发Job"><a href="#触发Job" class="headerlink" title="触发Job"></a>触发Job</h4><h5 id="作用-10"><a href="#作用-10" class="headerlink" title="作用"></a>作用</h5><p>触发作业立刻执行</p>
<h5 id="API-12"><a href="#API-12" class="headerlink" title="API"></a>API</h5><p>get /api/jobs/{jobName}/trigger</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>通过将节点<code>jobName/instances/</code>下的每个子节点<code>instanceId</code>的数据修改为<code>TRIGGER</code>来触发job的执行。 </p>
<p>因为执行job的机器会监听<code>jobName/instances/instanceId</code>节点的数据变化，然后通过quartz API来触发job的执行。前提是job当前没有执行。后续的版本可能改为堆积式执行。</p>
<h4 id="失效-生效"><a href="#失效-生效" class="headerlink" title="失效/生效"></a>失效/生效</h4><h5 id="作用-11"><a href="#作用-11" class="headerlink" title="作用"></a>作用</h5><p>禁用作业执行</p>
<h5 id="API-13"><a href="#API-13" class="headerlink" title="API"></a>API</h5><p>get /api/jobs/{jobName}/disable</p>
<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>通过将节点<code>jobName/servers/</code>下的每个子节点<code>ip</code>的数据修改为disabled来禁止Job的执行。原理是在Job执行时需要分片，分片时会判断分片所在Server 是不是可用状态（即，<code>jobName/servers/ip</code>）节点的值不是<code>disabled</code>。</p>
<p>我们在操作<code>servers/ip</code>节点或<code>intances/instanceId</code>节点时，监听器都会设置需要分片的标志，下次任务执行时，就会重新分片，即使原有的分片都OK。</p>
<p>禁用Job， 其实就是让Job没有可用的Server。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ShardingService</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shardingIfNecessary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; availableJobInstances = instanceService.getAvailableJobInstances();</span><br><span class="line">    <span class="keyword">if</span> (!isNeedSharding() || availableJobInstances.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略代码   </span></span><br><span class="line">&#125; </span><br><span class="line">InstanceService</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;JobInstance&gt; <span class="title">getAvailableJobInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;JobInstance&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String each : jobNodeStorage.getJobNodeChildrenKeys(InstanceNode.ROOT)) &#123;</span><br><span class="line">        JobInstance jobInstance = <span class="keyword">new</span> JobInstance(each);</span><br><span class="line">        <span class="keyword">if</span> (serverService.isEnableServer(jobInstance.getIp())) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> JobInstance(each));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerService</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnableServer</span><span class="params">(<span class="keyword">final</span> String ip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ServerStatus.DISABLED.name().equals(jobNodeStorage.getJobNodeData(serverNode.getServerNode(ip)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><h5 id="API-14"><a href="#API-14" class="headerlink" title="API"></a>API</h5><p>PUT /api/jobs/{jobName}/shutdown</p>
<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><p>删除<code>jobName/instances</code>节点下的所有子节点。</p>
<p>如果是从Server维度来操作的话，则只删除指定IP下的所有instance。<code>jobName/instances/instanceId</code> instanceId的ip是指定的IP。</p>
<p>监听器会处理instances节点变更时间，导致Job下次执行时重新分片，分片时因为没有可用的分片(jobName/instances 节点下面没有子节点)</p>
<p>终止Job，实质上就是让Job调度时没有可用的实例。</p>
<h4 id="PUT-修改job信息"><a href="#PUT-修改job信息" class="headerlink" title="PUT 修改job信息"></a>PUT 修改job信息</h4><h5 id="API-15"><a href="#API-15" class="headerlink" title="API"></a>API</h5><p>PUT /api/jobs/config</p>
<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><p>直接修改<code>jobName/config</code>节点的值</p>
<h4 id="获取Job分片信息"><a href="#获取Job分片信息" class="headerlink" title="获取Job分片信息"></a>获取Job分片信息</h4><h5 id="作用-12"><a href="#作用-12" class="headerlink" title="作用"></a>作用</h5><p>获取job的详细分片信息</p>
<h5 id="API-16"><a href="#API-16" class="headerlink" title="API"></a>API</h5><p>GET /api/jobs/{jobName}/sharding</p>
<h5 id="实现逻辑-12"><a href="#实现逻辑-12" class="headerlink" title="实现逻辑"></a>实现逻辑</h5><p>返回数据如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"item"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"serverIp"</span>: <span class="string">"10.110.27.147"</span>,</span><br><span class="line">        <span class="attr">"instanceId"</span>: <span class="string">"8535"</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="string">"SHARDING_FLAG"</span>,</span><br><span class="line">        <span class="attr">"failover"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>遍历<code>jobName/sharding</code>节点下的所有子节点(名称从0开始)，获取每个分片执行实例<code>jobName/sharding/0/instance</code>   的实例id,</p>
<p><code>jobName/sharding/0/disabled</code> 是否禁用，<code>jobName/sharding/0/running</code> 是否执行。</p>
<p>判断节点<code>jobName/instances/instanceId</code> 是否存，不存在表示分片error。</p>
<p>failover 值的判断逻辑为：判断节点<code>jobName/sharding/0/failover</code>是否存，存在表示可以failover。</p>
<p>status 值的判断逻辑为：如果<code>jobName/sharding/0/disabled</code>节点存在，则为<code>DISABLED</code>的。</p>
<p>如果<code>jobName/sharding/0/running</code>节点存在，则为<code>RUNNING</code>的。</p>
<p>如果<code>jobName/instances/instanceId</code> <code>节点不存在，则为</code>SHARDING_FLAG`的，表示需要分片。</p>
<p>其它情况表示待调度执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;elastic-job-是什么？&quot;&gt;&lt;a href=&quot;#elastic-job-是什么？&quot; class=&quot;headerlink&quot; title=&quot;elastic-job 是什么？&quot;&gt;&lt;/a&gt;elastic-job 是什么？&lt;/h2&gt;&lt;p&gt;还是看官方文档介绍：&lt;a href=&quot;http://elasticjob.io/docs/elastic-job-lite/00-overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://elasticjob.io/docs/elastic-job-lite/00-overview/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;elastic-job-实现分析&quot;&gt;&lt;a href=&quot;#elastic-job-实现分析&quot; class=&quot;headerlink&quot; title=&quot;elastic-job 实现分析&quot;&gt;&lt;/a&gt;elastic-job 实现分析&lt;/h2&gt;&lt;h3 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://elasticjob.io/docs/elastic-job-lite/img/architecture/elastic_job_lite.png&quot; alt=&quot;Elastic-Job-Lite Architecture&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看到 elastic-job 的实现主要依赖的外部组件是zookeeper。 用zookeeper来实现分布式任务的协调及相关任务信息的保存。具体任务的调度触发还是依赖core模块里面的Quartz API提供的能力。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leokongwq.github.io/2019/12/14/RockeqMQ-summary.html"/>
    <id>https://leokongwq.github.io/2019/12/14/RockeqMQ-summary.html</id>
    <published>2019-12-13T16:19:30.446Z</published>
    <updated>2019-12-13T16:20:24.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RocketMQ算是当前国内MQ领域内的明星产品。网上关于它文章非常的多。但是总觉得任何一项你想要在生产环境使用的技术，你必须亲自深入学习一遍才能更好的使用它，出了问题也好定位。在学习源码的过程中可能有许多意想不到的收获，也是提示技术能力的一种方式。</p>
<h3 id="RocketMQ-文件目录"><a href="#RocketMQ-文件目录" class="headerlink" title="RocketMQ 文件目录"></a>RocketMQ 文件目录</h3><p>RocketMQ 作为一个具有持久化功能的消息中间件，必然需要强大的存储功能。那么首先需要了解的就是它的存储架构。</p>
<p>RocketMQ 存储目录结构</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── abort</span><br><span class="line">├── checkpoint</span><br><span class="line">├── commitlog</span><br><span class="line">│   ├── <span class="number">00000000000000000000</span></span><br><span class="line">│   └── <span class="number">00000000001073741824</span></span><br><span class="line">├── config</span><br><span class="line">│   ├── consumerFilter.json</span><br><span class="line">│   ├── consumerFilter.json.bak</span><br><span class="line">│   ├── consumerOffset.json</span><br><span class="line">│   ├── consumerOffset.json.bak</span><br><span class="line">│   ├── delayOffset.json</span><br><span class="line">│   ├── delayOffset.json.bak</span><br><span class="line">│   ├── subscriptionGroup.json</span><br><span class="line">│   ├── topics.json</span><br><span class="line">│   └── topics.json.bak</span><br><span class="line">├── consumequeue</span><br><span class="line">│   ├── rmq-test-topic</span><br><span class="line">│   │   ├── <span class="number">0</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">1</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">2</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">3</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">4</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">5</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   ├── <span class="number">6</span></span><br><span class="line">│   │   │   └── <span class="number">00000000000000000000</span></span><br><span class="line">│   │   └── <span class="number">7</span></span><br><span class="line">│   │       └── <span class="number">00000000000000000000</span></span><br><span class="line">│   └── SCHEDULE_TOPIC_XXXX</span><br><span class="line">│       └── <span class="number">2</span></span><br><span class="line">│           └── <span class="number">00000000000000000000</span></span><br><span class="line">├── index</span><br><span class="line">│   └── <span class="number">20191014212222129</span></span><br><span class="line">└── lock</span><br></pre></td></tr></table></figure>
<p> RocketMQ 整体存储结构<img src="https://upload-images.jianshu.io/upload_images/4325076-6021ce04990eef9e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1146/format/webp" alt="img"> </p>
<p>上图是测试环境搭建的一个单机集群（只有一个NameServer和Broker）的目录结构。</p>
<h3 id="commitlog"><a href="#commitlog" class="headerlink" title="commitlog"></a>commitlog</h3><p>commitlog 文件夹下面的每个文件大小默认 1G，内容是每条消息的完整内容。</p>
<blockquote>
<p> 需要注意的是：不可能所有的消息加起来恰好等于1G, 所以文件的尾部可能会有填充。</p>
</blockquote>
<h3 id="consumequeue"><a href="#consumequeue" class="headerlink" title="consumequeue"></a>consumequeue</h3><p>consumequeue 文件夹下面是每个Topic的消费队列数据。</p>
<p>每个消费队列文件中保存的待消费的消息：结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset:length:taghash</span><br></pre></td></tr></table></figure>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>config 目录保存的是一些配置信息</p>
<h4 id="consumerFilter-json"><a href="#consumerFilter-json" class="headerlink" title="consumerFilter.json"></a>consumerFilter.json</h4><p>该文件保存的是每个Topic中消息的过滤逻辑。</p>
<h4 id="consumerOffset-json"><a href="#consumerOffset-json" class="headerlink" title="consumerOffset.json"></a>consumerOffset.json</h4><p>该文件保存每个consumer group 的消费进度</p>
<h4 id="delayOffset-json"><a href="#delayOffset-json" class="headerlink" title="delayOffset.json"></a>delayOffset.json</h4><p>该文件保存构建延迟消息的进度</p>
<h4 id="subscriptionGroup-json"><a href="#subscriptionGroup-json" class="headerlink" title="subscriptionGroup.json"></a>subscriptionGroup.json</h4><p>该文件保存consumerGroup和Topic的订阅关系</p>
<h4 id="topics-json"><a href="#topics-json" class="headerlink" title="topics.json"></a>topics.json</h4><p>该文件保存Topic信息</p>
<h4 id="abort文件"><a href="#abort文件" class="headerlink" title="abort文件"></a>abort文件</h4><p>abort 文件是在<code>DefaultMessageStore</code>启动时创建在，在正常关机的情况下会删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTempFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String fileName = StorePathConfigHelper.getAbortFile(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir());</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    MappedFile.ensureDirOK(file.getParent());</span><br><span class="line">    <span class="keyword">boolean</span> result = file.createNewFile();</span><br><span class="line">    log.info(fileName + (result ? <span class="string">" create OK"</span> : <span class="string">" already exists"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="checkpoint-文件"><a href="#checkpoint-文件" class="headerlink" title="checkpoint 文件"></a>checkpoint 文件</h4><p>文件内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StoreCheckpoint</span><span class="params">(<span class="keyword">final</span> String scpPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(scpPath);</span><br><span class="line">    MappedFile.ensureDirOK(file.getParent());</span><br><span class="line">    <span class="keyword">boolean</span> fileExists = file.exists();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.randomAccessFile = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">    <span class="keyword">this</span>.fileChannel = <span class="keyword">this</span>.randomAccessFile.getChannel();</span><br><span class="line">    <span class="keyword">this</span>.mappedByteBuffer = fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, MappedFile.OS_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileExists) &#123;</span><br><span class="line">        log.info(<span class="string">"store checkpoint file exists, "</span> + scpPath);</span><br><span class="line">        <span class="keyword">this</span>.physicMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.logicsMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">this</span>.indexMsgTimestamp = <span class="keyword">this</span>.mappedByteBuffer.getLong(<span class="number">16</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"store checkpoint file not exists, "</span> + scpPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MappedFile-amp-MappedFileQueue-amp-AllocateMappedFileService"><a href="#MappedFile-amp-MappedFileQueue-amp-AllocateMappedFileService" class="headerlink" title="MappedFile &amp; MappedFileQueue &amp; AllocateMappedFileService"></a>MappedFile &amp; MappedFileQueue &amp; AllocateMappedFileService</h3><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><p>MappedFile ：顾名思义就是一个内存映射文件。内存映射文件写入时，首先写入<code>OS Page Cache</code>中，OS会定期刷新文件内容到磁盘上。也可以通过如下的方法强制写入磁盘：</p>
<ol>
<li>FileChannel.force</li>
<li>MappedByteBuffer.force</li>
</ol>
<p>MappedFile 是最底层，真正用来保存消息的，主要的保存消息方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(msg, cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessages</span><span class="params">(<span class="keyword">final</span> MessageExtBatch messageExtBatch, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> appendMessagesInner(messageExtBatch, cb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Broker 写入消息时调用的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line">true<span class="comment">// 当前写入MappedFile文件的位置</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">// writeBuffer 本身也是一个DirectBuffer, 默认大小1G 和 MappedFile大小相同</span></span><br><span class="line">        <span class="comment">// 每次slice 都会得到position == 0, limit 和 capacity 等于1G 的影子ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        <span class="comment">// 通过设置position， 使得上面获取的影子ByteBuffer写入时不会覆盖原有数据</span></span><br><span class="line">        <span class="comment">// 只能从底层真实的ByteBuffer的position处开始写数据</span></span><br><span class="line">        <span class="comment">// 因为 writeBuffer 和 mappedByteBuffer 的position一直保持不变</span></span><br><span class="line">        <span class="comment">// 所以设置position的方法不会抛出异常</span></span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">"MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;"</span>, currentPos, <span class="keyword">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((currentPos + data.length) &lt;= <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.position(currentPos);</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.write(ByteBuffer.wrap(data));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when append message to mappedFile."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(data.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAbleToFlush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//上次刷盘的位置</span></span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.flushedPosition.get();</span><br><span class="line">    <span class="comment">// 当前的写入位置</span></span><br><span class="line">    <span class="keyword">int</span> write = getReadPosition();</span><br><span class="line">true<span class="comment">//如果文件写满了，那么需要刷盘</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">//计算是否满足最少刷盘页数的的要求</span></span><br><span class="line">    <span class="keyword">if</span> (flushLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不可以用(write - flush) / OS_PAGE_SIZE 吗？</span></span><br><span class="line">        <span class="comment">// OS_PAGE_SIZE 写死为 4k, 如果启用大页， 吞吐量不是更高吗？</span></span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 只要上次刷盘后有新的数据写入，就可以刷盘</span></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The current flushed position</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToFlush(flushLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = getReadPosition();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//We only append data to fileChannel or mappedByteBuffer, never both.</span></span><br><span class="line">                <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> || <span class="keyword">this</span>.fileChannel.position() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.fileChannel.force(<span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"Error occurred when force data to disk."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(value);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in flush, hold failed, flush offset = "</span> + <span class="keyword">this</span>.flushedPosition.get());</span><br><span class="line">            <span class="comment">// 如果 使用了writeBuffer, getReadPosition返回的是当前写入的position</span></span><br><span class="line">            <span class="comment">// 写入的position 是大于等于 刷盘的位置的，没有刷盘就更新flushedPosition合适吗？</span></span><br><span class="line">            <span class="keyword">this</span>.flushedPosition.set(getReadPosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getFlushedPosition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAbleToCommit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flush = <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">    <span class="keyword">int</span> write = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isFull()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitLeastPages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= commitLeastPages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> write &gt; flush;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> commitLeastPages)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// writeBuffer 为 NULL 表示消息是直接写入MappedByteBuffer的</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hold()) &#123;</span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="keyword">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"in commit, hold failed, commit offset = "</span> + <span class="keyword">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All dirty data has been committed to FileChannel.</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.transientStorePool != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.fileSize == <span class="keyword">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="keyword">this</span>.writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MappedFileQueue"><a href="#MappedFileQueue" class="headerlink" title="MappedFileQueue"></a>MappedFileQueue</h4><p>MappedFileQueue  就是由多个<code>MappedFile</code>组成的一个队列。由它来管理多个分配的内存映射文件。多个文件组成一个逻辑上的单一文件，供上层的业务使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有分配的MappedFile</span></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MappedFile&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存刷盘位置, 该字段的值是在Broker启动时，恢复状态时计算出来的。</span></span><br><span class="line">    <span class="comment">// 正常情况下，是CommmitLog在磁盘上最后一个MappedFile中最后一个正常消息的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flushedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 写入到PageCache的位置， 在Broker启动时，值和flushedWhere计算逻辑一致。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> committedWhere = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行刷盘操作，由刷盘后台线程调用</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flush</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> flushLeastPages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">this</span>.findMappedFileByOffset(<span class="keyword">this</span>.flushedWhere, <span class="keyword">this</span>.flushedWhere == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> tmpTimeStamp = mappedFile.getStoreTimestamp();</span><br><span class="line">            <span class="comment">// 最底层的刷盘操作，返回MappedFile中已经落盘的数据量</span></span><br><span class="line">            <span class="keyword">int</span> offset = mappedFile.flush(flushLeastPages);</span><br><span class="line">            <span class="comment">// 计算并更新下次刷盘的位置</span></span><br><span class="line">            <span class="keyword">long</span> where = mappedFile.getFileFromOffset() + offset;</span><br><span class="line">            result = where == <span class="keyword">this</span>.flushedWhere;</span><br><span class="line">            <span class="keyword">this</span>.flushedWhere = where;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == flushLeastPages) &#123;</span><br><span class="line">                <span class="keyword">this</span>.storeTimestamp = tmpTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AllocateMappedFileService"><a href="#AllocateMappedFileService" class="headerlink" title="AllocateMappedFileService"></a>AllocateMappedFileService</h4><p>MappedFile 的创建有2种方式：</p>
<ol>
<li>通过MappedFile的构造方法进行创建。</li>
<li>通过AllocateMappedFileService进行异步创建。(内部有一个创建的<code>MappedFile</code>的请求队列，由独立的线程进行<code>MappedFile</code>创建)</li>
</ol>
<p><code>MappedFileQueue</code> 在进行消息保存，需要创建新的<code>MappedFile</code>时，内部是通过 <code>DefaultMessageStore</code>创建时创建的<code>AllocateMappedFileService</code>进行<code>MappedFile</code>创建的。</p>
<p>AllocateMappedFileService 会使用<code>MappedFile</code>如下的构造方法进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MappedFile</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize, transientStorePool);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">final</span> TransientStorePool transientStorePool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    init(fileName, fileSize);</span><br><span class="line">    <span class="comment">// 消息会先写入ByteBuffer中，然后再写入FileChannel</span></span><br><span class="line">    <span class="comment">// writeBuffer 大小默认是1G, 和 MappedFile的文件大小相同</span></span><br><span class="line">    <span class="keyword">this</span>.writeBuffer = transientStorePool.borrowBuffer();</span><br><span class="line">    <span class="keyword">this</span>.transientStorePool = transientStorePool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefaultMessageStore-启动流程"><a href="#DefaultMessageStore-启动流程" class="headerlink" title="DefaultMessageStore 启动流程"></a>DefaultMessageStore 启动流程</h3><h4 id="DefaultMessageStore-初始化"><a href="#DefaultMessageStore-初始化" class="headerlink" title="DefaultMessageStore 初始化"></a>DefaultMessageStore 初始化</h4><p>初始化过程最重要的是加载消息文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否上次是否是正常退出。 正常退出是没有abort文件的</span></span><br><span class="line">        <span class="keyword">boolean</span> lastExitOK = !<span class="keyword">this</span>.isTempFileExist();</span><br><span class="line">        log.info(<span class="string">"last shutdown &#123;&#125;"</span>, lastExitOK ? <span class="string">"normally"</span> : <span class="string">"abnormally"</span>);</span><br><span class="line">true    <span class="comment">// 先加载延迟消息		</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">            result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load Commit Log</span></span><br><span class="line">        <span class="comment">// 加载 Commit Log 文件，其实是通过 MappedFileQueue加载每一个MappedFile</span></span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load Consume Queue</span></span><br><span class="line">        <span class="comment">// 实现机制和 Commit Log 一样</span></span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="comment">// 初始化checkpoint</span></span><br><span class="line">            <span class="keyword">this</span>.storeCheckpoint =</span><br><span class="line">                <span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">truetruetrue<span class="comment">// 加载索引文件</span></span><br><span class="line">            <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">truetruetrue<span class="comment">// 进行状态恢复， 底层还是通过</span></span><br><span class="line">            <span class="keyword">this</span>.recover(lastExitOK);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"load over, and the max phy offset = &#123;&#125;"</span>, <span class="keyword">this</span>.getMaxPhyOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"load exception"</span>, e);</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.allocateMappedFileService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> lastExitOK)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 恢复消费队列状态</span></span><br><span class="line">    <span class="keyword">this</span>.recoverConsumeQueue();</span><br><span class="line">true<span class="comment">// 恢复Commit Log 状态</span></span><br><span class="line">    <span class="keyword">if</span> (lastExitOK) &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverNormally();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLog.recoverAbnormally();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.recoverTopicQueueTable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DefaultMessageStore-启动"><a href="#DefaultMessageStore-启动" class="headerlink" title="DefaultMessageStore 启动"></a>DefaultMessageStore 启动</h4><h3 id="CommitLog-启动流程"><a href="#CommitLog-启动流程" class="headerlink" title="CommitLog 启动流程"></a>CommitLog 启动流程</h3><h4 id="CommitLog-加载"><a href="#CommitLog-加载" class="headerlink" title="CommitLog 加载"></a>CommitLog 加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.mappedFileQueue.load();</span><br><span class="line">    log.info(<span class="string">"load commit log "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Failed"</span>));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载的过程就是对构成的Commit Log的所有磁盘文件，创建对应的MappedFile，并通过MappedFileQueue进行组织的过程。再次过程，申请了虚拟内存空间，但是并没有读取磁盘文件。</p>
<h4 id="CommitLog-启动"><a href="#CommitLog-启动" class="headerlink" title="CommitLog 启动"></a>CommitLog 启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动消息 刷盘后台服务线程</span></span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService.start();</span><br><span class="line">true<span class="comment">// 如果启用了异步刷盘，则启动 消息commit后台服务线程</span></span><br><span class="line">    <span class="keyword">if</span> (defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.commitLogService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CommitLog-恢复"><a href="#CommitLog-恢复" class="headerlink" title="CommitLog  恢复"></a>CommitLog  恢复</h4><p>恢复分为正常恢复和异常恢复</p>
<h5 id="正常恢复"><a href="#正常恢复" class="headerlink" title="正常恢复"></a>正常恢复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否校验数据完成性，这个会导致启动变慢</span></span><br><span class="line">    <span class="keyword">boolean</span> checkCRCOnRecover = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isCheckCRCOnRecover();</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从最后三个文件进行恢复</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">truetrue</span><br><span class="line">        MappedFile mappedFile = mappedFiles.get(index);</span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="comment">//本文件的起始偏移量，也就是文件名称</span></span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="comment">// 从0开始校验消息文件</span></span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">            <span class="comment">// Normal data</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Come the end of the file, switch to the next file Since the</span></span><br><span class="line">            <span class="comment">// return 0 representatives met last hole,</span></span><br><span class="line">            <span class="comment">// this can not be included in truncate offset</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dispatchRequest.isSuccess() &amp;&amp; size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 所有文件都验证完成</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123;</span><br><span class="line">                    <span class="comment">// Current branch can not happen</span></span><br><span class="line">                    log.info(<span class="string">"recover last 3 physics file over, last mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 切换下一个文件进行校验</span></span><br><span class="line">                    mappedFile = mappedFiles.get(index);</span><br><span class="line">                    byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                    processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                    mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                    log.info(<span class="string">"recover next physics file, "</span> + mappedFile.getFileName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intermediate file read error</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// processOffset 就是有效消息的位置</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="comment">// 丢弃broken的消息</span></span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="异常恢复"><a href="#异常恢复" class="headerlink" title="异常恢复"></a>异常恢复</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverAbnormally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// recover by the minimum time stamp</span></span><br><span class="line">    <span class="keyword">boolean</span> checkCRCOnRecover = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isCheckCRCOnRecover();</span><br><span class="line">    <span class="keyword">final</span> List&lt;MappedFile&gt; mappedFiles = <span class="keyword">this</span>.mappedFileQueue.getMappedFiles();</span><br><span class="line">    <span class="keyword">if</span> (!mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第一个开始恢复， 在load的时候，按文件名称排序的</span></span><br><span class="line">        <span class="keyword">int</span> index = mappedFiles.size() - <span class="number">1</span>;</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            mappedFile = mappedFiles.get(index);</span><br><span class="line">            <span class="comment">//查找第一个需要需要恢复的文件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isMappedFileMatchedRecover(mappedFile)) &#123;</span><br><span class="line">                log.info(<span class="string">"recover from this mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 没有满足恢复查找条件的问题件，那么从第一个文件开始恢复</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            mappedFile = mappedFiles.get(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">        <span class="keyword">long</span> processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">        <span class="keyword">long</span> mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            DispatchRequest dispatchRequest = <span class="keyword">this</span>.checkMessageAndReturnSize(byteBuffer, checkCRCOnRecover);</span><br><span class="line">            <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Normal data</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mappedFileOffset += size;</span><br><span class="line">truetruetruetrue<span class="comment">// 是否允许重复消息</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">                    <span class="comment">// getCommitLogOffset 返回的是 消息在Commit Log中的偏移量</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.getCommitLogOffset() &lt; <span class="keyword">this</span>.defaultMessageStore.getConfirmOffset()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.defaultMessageStore.doDispatch(dispatchRequest);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 构建索引 和 消费队列</span></span><br><span class="line">                    <span class="keyword">this</span>.defaultMessageStore.doDispatch(dispatchRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Intermediate file read error</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == -<span class="number">1</span>) &#123;</span><br><span class="line">                log.info(<span class="string">"recover physics file end, "</span> + mappedFile.getFileName());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Come the end of the file, switch to the next file</span></span><br><span class="line">            <span class="comment">// Since the return 0 representatives met last hole, this can</span></span><br><span class="line">            <span class="comment">// not be included in truncate offset</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  <span class="comment">// 文件末尾</span></span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">if</span> (index &gt;= mappedFiles.size()) &#123; <span class="comment">// 最后一个文件</span></span><br><span class="line">                    <span class="comment">// The current branch under normal circumstances should</span></span><br><span class="line">                    <span class="comment">// not happen</span></span><br><span class="line">                    log.info(<span class="string">"recover physics file over, last mapped file "</span> + mappedFile.getFileName());</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 切换下一个文件进行恢复</span></span><br><span class="line">                    mappedFile = mappedFiles.get(index);</span><br><span class="line">                    byteBuffer = mappedFile.sliceByteBuffer();</span><br><span class="line">                    processOffset = mappedFile.getFileFromOffset();</span><br><span class="line">                    mappedFileOffset = <span class="number">0</span>;</span><br><span class="line">                    log.info(<span class="string">"recover next physics file, "</span> + mappedFile.getFileName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 设置初始状态</span></span><br><span class="line">        processOffset += mappedFileOffset;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(processOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.truncateDirtyFiles(processOffset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clear ConsumeQueue redundant data</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(processOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Commitlog case files are deleted</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setFlushedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappedFileQueue.setCommittedWhere(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.destroyLogics();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Broker消息保存流程"><a href="#Broker消息保存流程" class="headerlink" title="Broker消息保存流程"></a>Broker消息保存流程</h3><h4 id="1-Rpc请求处理"><a href="#1-Rpc请求处理" class="headerlink" title="1. Rpc请求处理"></a>1. Rpc请求处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RemotingCommand</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            processMessageReceived(ctx, msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessageReceived</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand cmd = msg;</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_COMMAND:</span><br><span class="line">                processRequestCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RESPONSE_COMMAND:</span><br><span class="line">                processResponseCommand(ctx, cmd);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process incoming request command issued by remote peer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx channel handler context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cmd request command.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequestCommand</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, <span class="keyword">final</span> RemotingCommand cmd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同任务的请求是由不同的线程池和Processor进行处理的</span></span><br><span class="line">    <span class="comment">// 这样可以实现请求隔离，防止意外请求导致整个服务不可用</span></span><br><span class="line">    <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; matched = <span class="keyword">this</span>.processorTable.get(cmd.getCode());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Pair&lt;NettyRequestProcessor, ExecutorService&gt; pair = <span class="keyword">null</span> == matched ? <span class="keyword">this</span>.defaultRequestProcessor : matched;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> opaque = cmd.getOpaque();</span><br><span class="line">true</span><br><span class="line">    <span class="keyword">if</span> (pair != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">// 构造异步请求任务，准备投递到对于的线程池中    </span></span><br><span class="line">        Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行钩子程序</span></span><br><span class="line">                    RPCHook rpcHook = NettyRemotingAbstract.<span class="keyword">this</span>.getRPCHook();</span><br><span class="line">                    <span class="keyword">if</span> (rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line"> rpcHook.doBeforeRequest(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd);</span><br><span class="line">                    &#125;</span><br><span class="line">truetruetruetruetrue<span class="comment">// 真正进行请求的处理， SendMessageProcessor</span></span><br><span class="line">                    <span class="keyword">final</span> RemotingCommand response = pair.getObject1().processRequest(ctx, cmd);</span><br><span class="line">                    <span class="keyword">if</span> (rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 执行钩子程序    rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(ctx.channel()), cmd, response);</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            response.setOpaque(opaque);</span><br><span class="line">                            response.markResponseType();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ctx.writeAndFlush(response);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                log.error(<span class="string">"process request over, but response failed"</span>, e);</span><br><span class="line">                                log.error(cmd.toString());</span><br><span class="line">                                log.error(response.toString());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"process request exception"</span>, e);</span><br><span class="line">                    log.error(cmd.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_ERROR,</span><br><span class="line">                                                                                               RemotingHelper.exceptionSimpleDesc(e));</span><br><span class="line">                        response.setOpaque(opaque);</span><br><span class="line">                        ctx.writeAndFlush(response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 请求处理线程池拒绝服务，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (pair.getObject1().rejectRequest()) &#123;</span><br><span class="line">            <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,</span><br><span class="line">                                                                                   <span class="string">"[REJECTREQUEST]system busy, start flow control for a while"</span>);</span><br><span class="line">            response.setOpaque(opaque);</span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//投递到线程池进行处理</span></span><br><span class="line">            <span class="keyword">final</span> RequestTask requestTask = <span class="keyword">new</span> RequestTask(run, ctx.channel(), cmd);</span><br><span class="line">            pair.getObject2().submit(requestTask);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.currentTimeMillis() % <span class="number">10000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                log.warn(RemotingHelper.parseChannelRemoteAddr(ctx.channel())</span><br><span class="line">                         + <span class="string">", too many requests and system thread pool busy, RejectedExecutionException "</span></span><br><span class="line">                         + pair.getObject2().toString()</span><br><span class="line">                         + <span class="string">" request code: "</span> + cmd.getCode());</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 返回系统繁忙，客户端可以重试</span></span><br><span class="line">            <span class="keyword">if</span> (!cmd.isOnewayRPC()) &#123;</span><br><span class="line">                <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RemotingSysResponseCode.SYSTEM_BUSY,</span><br><span class="line">                                                                                       <span class="string">"[OVERLOAD]system busy, start flow control for a while"</span>);</span><br><span class="line">                response.setOpaque(opaque);</span><br><span class="line">                ctx.writeAndFlush(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不支持的请求CODE</span></span><br><span class="line">        String error = <span class="string">" request type "</span> + cmd.getCode() + <span class="string">" not supported"</span>;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response =</span><br><span class="line">            RemotingCommand.createResponseCommand(RemotingSysResponseCode.REQUEST_CODE_NOT_SUPPORTED, error);</span><br><span class="line">        response.setOpaque(opaque);</span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">        log.error(RemotingHelper.parseChannelRemoteAddr(ctx.channel()) + error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-消息处理器SendMessageProcessor"><a href="#2-消息处理器SendMessageProcessor" class="headerlink" title="2. 消息处理器SendMessageProcessor"></a>2. 消息处理器SendMessageProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="comment">// 处理消费者ack</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="comment">// 执行钩子程序</span></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            String topic = requestHeader.getTopic();</span><br><span class="line">            <span class="keyword">this</span>.checkTopicAuthority(ctx, topic);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">truetruetrue<span class="comment">// 执行钩子程序</span></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(SendMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_MSG_REGION, <span class="keyword">this</span>.brokerController.getBrokerConfig().getRegionId());</span><br><span class="line">    response.addExtField(MessageConst.PROPERTY_TRACE_SWITCH, String.valueOf(<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceOn()));</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"receive SendMessage request command, &#123;&#125;"</span>, request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Broker还没有开始服务</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTimestamp = <span class="keyword">this</span>.brokerController.getBrokerConfig().getStartAcceptSendRequestTimeStamp();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStore().now() &lt; startTimestamp) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(String.format(<span class="string">"broker unable to service, until %s"</span>, UtilAll.timeMillisToHumanString2(startTimestamp)));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.setCode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">super</span>.msgCheck(ctx, requestHeader, response);</span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] body = request.getBody();</span><br><span class="line">true<span class="comment">// 获取 队列id，判断是否是发送到指定的队列</span></span><br><span class="line">    <span class="keyword">int</span> queueIdInt = requestHeader.getQueueId();</span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">// 随机选择一个队列进行写入</span></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % topicConfig.getWriteQueueNums();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">    msgInner.setQueueId(queueIdInt);</span><br><span class="line">    <span class="comment">// 处理重试消息</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="comment">// 事务消息处理</span></span><br><span class="line">    <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">        transHalfMsg = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// schedule message don't support transaction message now</span></span><br><span class="line">        <span class="keyword">int</span> delayInSeconds = msgInner.getDelayTimeInSeconds();</span><br><span class="line">        <span class="keyword">int</span> delayLevel = msgInner.getDelayTimeLevel();</span><br><span class="line">        <span class="keyword">if</span> (delayInSeconds != <span class="number">0</span> &amp;&amp; delayLevel != <span class="number">0</span>) &#123;</span><br><span class="line">            response.setCode(ResponseCode.MESSAGE_ILLEGAL);</span><br><span class="line">            response.setRemark(<span class="string">"delayInSeconds and delayTimeLevel should not be specified at the same time."</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延迟消息处理</span></span><br><span class="line">        <span class="keyword">if</span> (delayInSeconds != <span class="number">0</span>) &#123;</span><br><span class="line">            putMessageResult = <span class="keyword">this</span>.brokerController.getScheduledMessageStore().putMessage(msgInner);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 普通消息处理</span></span><br><span class="line">            putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sendMessageContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendMessageContext.buildTrackMsgType(transHalfMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="普通消息保存"><a href="#普通消息保存" class="headerlink" title="普通消息保存"></a>普通消息保存</h4><p>普通消息保存是由 <code>DefaultMessageStore.putMessage</code>来实现消息具体的保存逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.shutdown) &#123;</span><br><span class="line">        log.warn(<span class="string">"message store has shutdown, so putMessage is forbidden"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.SERVICE_NOT_AVAILABLE, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，获取锁后，消息写入MappedFile的时间超过1s，表示OS Page Cache 忙</span></span><br><span class="line">    <span class="comment">// 此处应该是异步刷盘，同步刷盘超时概率变大</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isOSPageCacheBusy()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    <span class="comment">// CommitLog 真正写入消息</span></span><br><span class="line">    PutMessageResult result = <span class="keyword">this</span>.commitLog.putMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">if</span> (eclipseTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"putMessage not in lock eclipse time(ms)=&#123;&#125;, bodyLength=&#123;&#125;"</span>, eclipseTime, msg.getBody().length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监控消息写入性能 和 失败率</span></span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setPutMessageEntireTimeMax(eclipseTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CommitLog写入消息"><a href="#CommitLog写入消息" class="headerlink" title="CommitLog写入消息"></a>CommitLog写入消息</h4><p><code>CommitLog</code>表示RocketMQ Broker上保存的所有消息。 消息分布在多个<code>MappedFile</code>文件中，所有的<code>MappedFile</code>组成一个<code>MappedFileQueue</code>。</p>
<h5 id="MappedFile-1"><a href="#MappedFile-1" class="headerlink" title="MappedFile"></a>MappedFile</h5><p>顾名思义<code>MappedFile</code>表示一个内存映射文件，通过下面的代码创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line"><span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br></pre></td></tr></table></figure>
<p>为什么用内存映射文件呢？</p>
<p>答案是：效率。消息写入直接写入内存页，由OS负责刷新内存中的内容到磁盘 或 通过API <code>MappedByteBuffer.force</code> 和 <code>FileChannel.force</code>方法来手动刷盘。</p>
<h5 id="putMessage"><a href="#putMessage" class="headerlink" title="putMessage"></a>putMessage</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    String topic = msg.getTopic();</span><br><span class="line">    <span class="keyword">int</span> queueId = msg.getQueueId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="comment">// commit 消息 或 非事务消息</span></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">        || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入到固定的Topic SCHEDULE_TOPIC_XXXX</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            <span class="comment">// 根据延迟时间登记，选择一个队列</span></span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取最后一个使用的MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="keyword">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">        <span class="comment">// 创建第一个文件 或 创建下一个使用的文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">            log.error(<span class="string">"create mapped file1 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 写入共享内存</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                <span class="comment">// 文件满了，创建新文件来保存消息</span></span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statistics</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line">true<span class="comment">// 通知刷盘线程进行刷盘操作</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    <span class="comment">// 主从复制处理</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MappedFileQueue-getLastMappedFile"><a href="#MappedFileQueue-getLastMappedFile" class="headerlink" title="MappedFileQueue.getLastMappedFile()"></a>MappedFileQueue.getLastMappedFile()</h5><p><code>MappedFileQueue</code>是由多个<code>MappedFile</code>组成。 获取最近一次使用的<code>MappedFile</code>时，存在2种情况。</p>
<ol>
<li>队列为空，创建第一个MappedFile</li>
<li>不为空，返回最近一次使用的MappedFile</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MappedFile mappedFileLast = <span class="keyword">null</span>;</span><br><span class="line">true</span><br><span class="line">    <span class="comment">//有并发问题，此处简化处理了</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mappedFileLast = <span class="keyword">this</span>.mappedFiles.get(<span class="keyword">this</span>.mappedFiles.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            <span class="comment">//continue;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"getLastMappedFile has exception."</span>, e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列为空，直接返回null, 下面的方法会创建一个新的MappedFile </span></span><br><span class="line">    <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="MappedFileQueue-getLastMappedFile-final-long-startOffset-boolean-needCreate"><a href="#MappedFileQueue-getLastMappedFile-final-long-startOffset-boolean-needCreate" class="headerlink" title="MappedFileQueue.getLastMappedFile(final long startOffset, boolean needCreate)"></a>MappedFileQueue.getLastMappedFile(final long startOffset, boolean needCreate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getLastMappedFile(startOffset, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset, <span class="keyword">boolean</span> needCreate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> createOffset = -<span class="number">1</span>;</span><br><span class="line">    MappedFile mappedFileLast = getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFileLast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        createOffset = startOffset - (startOffset % <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 满了， 创建一个新文件，新文件的名称 = createOffset</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFileLast != <span class="keyword">null</span> &amp;&amp; mappedFileLast.isFull()) &#123;</span><br><span class="line">        createOffset = mappedFileLast.getFileFromOffset() + <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">    &#125;</span><br><span class="line">true<span class="comment">// 新创建的文件,名称必须是20个0， 或者 mappedFileSize的整数倍(格式化后为20位)</span></span><br><span class="line">    <span class="keyword">if</span> (createOffset != -<span class="number">1</span> &amp;&amp; needCreate) &#123;</span><br><span class="line">        String nextFilePath = <span class="keyword">this</span>.storePath + File.separator + UtilAll.offset2FileName(createOffset);</span><br><span class="line">        String nextNextFilePath = <span class="keyword">this</span>.storePath + File.separator</span><br><span class="line">            + UtilAll.offset2FileName(createOffset + <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">        MappedFile mappedFile = <span class="keyword">null</span>;</span><br><span class="line">truetrue<span class="comment">// 交给 MappedFile 分配服务，异步创建。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.allocateMappedFileService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.allocateMappedFileService.putRequestAndReturnMappedFile(nextFilePath,</span><br><span class="line">                                                                                      nextNextFilePath, <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//直接创建MappedFile</span></span><br><span class="line">                mappedFile = <span class="keyword">new</span> MappedFile(nextFilePath, <span class="keyword">this</span>.mappedFileSize);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(<span class="string">"create mappedFile exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">                mappedFile.setFirstCreateInQueue(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.mappedFiles.add(mappedFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CommitLog-Flush-流程"><a href="#CommitLog-Flush-流程" class="headerlink" title="CommitLog Flush 流程"></a>CommitLog Flush 流程</h3><p>消息刷盘的过程是由 <code>FlushCommitLogService</code>的3GroupCommitService个子类完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> GroupCommitService();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.flushCommitLogService = <span class="keyword">new</span> FlushRealTimeService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.commitLogService = <span class="keyword">new</span> CommitRealTimeService();</span><br></pre></td></tr></table></figure>
<h4 id="CommitRealTimeService"><a href="#CommitRealTimeService" class="headerlink" title="CommitRealTimeService"></a>CommitRealTimeService</h4><p>CommitRealTimeService 该后台服务线程起作用的前提是<code>MappedFile</code>写入数据时使用了<code>WriteBuffer</code>，</p>
<p>也就是配置项<code>transientStorePoolEnable</code> 的值为true，并且刷盘模式是<code>ASYNC_FLUSH</code>， 而且是Master。</p>
<p>作用是：消息先写入DirectByteBuffer中，然后通过该后台服务线程写入到FileChannel （）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastCommitTimestamp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommitRealTimeService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">// 默认值200ms, 只有在启用了 TransientStorePool 的时候使用</span></span><br><span class="line">            <span class="comment">// 刷新数据到FileChannel</span></span><br><span class="line">            <span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line">truetruetrue<span class="comment">// 默认的页数 4页</span></span><br><span class="line">            <span class="keyword">int</span> commitDataLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line">truetruetrue<span class="comment">// 默认值 200ms</span></span><br><span class="line">            <span class="keyword">int</span> commitDataThoroughInterval =</span><br><span class="line">                CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (begin &gt;= (<span class="keyword">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">                commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">                    <span class="comment">//now wake up flush thread.</span></span><br><span class="line">                    flushCommitLogService.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"Commit data to file costs &#123;&#125; ms"</span>, end - begin);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                CommitLog.log.error(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">            result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.commit(<span class="number">0</span>);</span><br><span class="line">            CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service shutdown, retry "</span> + (i + <span class="number">1</span>) + <span class="string">" times "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Not OK"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GroupCommitService"><a href="#GroupCommitService" class="headerlink" title="GroupCommitService"></a>GroupCommitService</h4><p>如果配置了同步刷盘模式，则使用<code>GroupCommitService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupCommitService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;GroupCommitRequest&gt; requestsWrite = <span class="keyword">new</span> ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;GroupCommitRequest&gt; requestsRead = <span class="keyword">new</span> ArrayList&lt;GroupCommitRequest&gt;();</span><br><span class="line">true</span><br><span class="line">    <span class="comment">// 提交同步刷盘请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(<span class="keyword">final</span> GroupCommitRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsWrite) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestsWrite.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasNotified.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            waitPoint.countDown(); <span class="comment">// notify</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swapRequests</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;GroupCommitRequest&gt; tmp = <span class="keyword">this</span>.requestsWrite;</span><br><span class="line">        <span class="keyword">this</span>.requestsWrite = <span class="keyword">this</span>.requestsRead;</span><br><span class="line">        <span class="keyword">this</span>.requestsRead = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                    <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                    <span class="comment">// two times the flush</span></span><br><span class="line">                    <span class="keyword">boolean</span> flushOK = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                        <span class="comment">// 判断是否已经刷盘了</span></span><br><span class="line">                        flushOK = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                        <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">                            <span class="comment">// 刷盘页数为0表示直接调用force方法</span></span><br><span class="line">                            <span class="comment">// 不再判断commited 和 write直接的差值</span></span><br><span class="line">                            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">truetruetruetruetrue<span class="comment">// 唤醒等待的消息写入线程</span></span><br><span class="line">                    req.wakeupCustomer(flushOK);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">                <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">                <span class="comment">// will come to this process</span></span><br><span class="line">                CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 没有被通知刷盘，则等待10ms</span></span><br><span class="line">                <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">// 执行刷盘操作</span></span><br><span class="line">                <span class="keyword">this</span>.doCommit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">truetrue<span class="comment">// 优雅停机时，执行下面的操作</span></span><br><span class="line">        <span class="comment">// Under normal circumstances shutdown, wait for the arrival of the</span></span><br><span class="line">        <span class="comment">// request, and then flush</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="string">"GroupCommitService Exception, "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.swapRequests();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.doCommit();</span><br><span class="line"></span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.swapRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GroupCommitService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getJointime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FlushRealTimeService"><a href="#FlushRealTimeService" class="headerlink" title="FlushRealTimeService"></a>FlushRealTimeService</h4><p>如果配置了异步刷盘模式，则使用<code>FlushRealTimeService</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlushRealTimeService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastFlushTimestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> printTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">            <span class="comment">//是否定时进行CommitLog的刷盘操作, 默认是False (也就是说默认同步刷盘)</span></span><br><span class="line">            <span class="keyword">boolean</span> flushCommitLogTimed = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line">truetruetrue<span class="comment">// 刷盘的时间间隔， 默认是 500 毫秒</span></span><br><span class="line">            <span class="keyword">int</span> interval = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line">            <span class="comment">// 每次刷盘至少需要刷盘的页数，默认是4</span></span><br><span class="line">            <span class="keyword">int</span> flushPhysicQueueLeastPages = CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line">truetruetrue<span class="comment">// 默认是 10 * 1000</span></span><br><span class="line">            <span class="keyword">int</span> flushPhysicQueueThoroughInterval =</span><br><span class="line"> CommitLog.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> printFlushProgress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Print flush progress</span></span><br><span class="line">            <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="keyword">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">                flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">                printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是异步刷盘，则休眠 500 毫秒后进行刷盘操作</span></span><br><span class="line">                <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                    Thread.sleep(interval);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 同步刷盘，则等待通知</span></span><br><span class="line">                    <span class="comment">// CommitLog 完成消息写入后，通过方法handleDiskFlush来唤醒刷盘线程</span></span><br><span class="line">                    <span class="keyword">this</span>.waitForRunning(interval);</span><br><span class="line">                &#125;</span><br><span class="line">truetruetruetrue<span class="comment">// 输出刷盘信息， 源码输出日志被注释</span></span><br><span class="line">                <span class="keyword">if</span> (printFlushProgress) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">// 真正执行刷盘</span></span><br><span class="line">                CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line">                <span class="keyword">long</span> storeTimestamp = CommitLog.<span class="keyword">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">                <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    CommitLog.<span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> past = System.currentTimeMillis() - begin;</span><br><span class="line">                <span class="keyword">if</span> (past &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"Flush data to disk costs &#123;&#125; ms"</span>, past);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                CommitLog.log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">                <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Normal shutdown, to ensure that all the flush before exit</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">            result = CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">            CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service shutdown, retry "</span> + (i + <span class="number">1</span>) + <span class="string">" times "</span> + (result ? <span class="string">"OK"</span> : <span class="string">"Not OK"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.printFlushProgress();</span><br><span class="line"></span><br><span class="line">        CommitLog.log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FlushRealTimeService.class.getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printFlushProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CommitLog.log.info("how much disk fall behind memory, "</span></span><br><span class="line">        <span class="comment">// + CommitLog.this.mappedFileQueue.howMuchFallBehind());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getJointime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列索引构建流程"><a href="#队列索引构建流程" class="headerlink" title="队列索引构建流程"></a>队列索引构建流程</h3><p>所有消息都是先写入CommitLog文件中(不同的Topic消息也是在一个文件中)，然后异步构建消息队列 和 消息索引。</p>
<h4 id="ReputMessageService"><a href="#ReputMessageService" class="headerlink" title="ReputMessageService"></a>ReputMessageService</h4><p>该类是一个后台服务线程。它在Broker启动时，从CommitLog文件指定的offset处开始读取消息，然后通过<code>CommitLogDispatcher</code>进行消息分发。</p>
<blockquote>
<p>注意：Broker启动时应该从哪个位置读取消息进行分发是非常重要的。通常有2个选择：</p>
<ol>
<li>从CommitLog文件最大的可读数据点开始分发（可以是最后写入消息的位置 或 已经commit的消息位置）。</li>
<li>从CommitLog确认点开放分发。（如果开启了 duplicationEnable = true 配置项）</li>
</ol>
</blockquote>
<p>DefaultMessageStore 在启动时的代码，计算reput的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()) &#123;</span><br><span class="line">    <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getConfirmOffset());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.reputMessageService.setReputFromOffset(<span class="keyword">this</span>.commitLog.getMaxOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要reput的位置后有新写入的消息，则可以构建消费队里和消息索引</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitLogAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">true<span class="keyword">return</span> <span class="keyword">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">truetrue<span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="keyword">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                    DispatchRequest dispatchRequest =</span><br><span class="line">                        DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                                                                          dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                                                                          dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                                                                          dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                            readSize += size;</span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).incrementAndGet();</span><br><span class="line">                                DefaultMessageStore.<span class="keyword">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                    .addAndGet(dispatchRequest.getMsgSize());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                            readSize = result.getSize();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">"[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;"</span>, reputFromOffset);</span><br><span class="line">                            <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            doNext = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                                log.error(<span class="string">"[BUG]the master dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;"</span>,</span><br><span class="line">                                          <span class="keyword">this</span>.reputFromOffset);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                result.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doNext = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLogDispatcherBuildConsumeQueue 此类用来构建队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                <span class="comment">// 从方法名称能看出，是保存消息位置信息</span></span><br><span class="line">                <span class="comment">// 队列中保存的是消息的offset，size, tag</span></span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLogDispatcherBuildIndex 此类用来构建消息索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">             DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延迟消息实现"><a href="#延迟消息实现" class="headerlink" title="延迟消息实现"></a>延迟消息实现</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>RocketMQ延迟消息的实现，是通过将延迟消息根据延迟的时间长度不同，写入到不同时间粒度的Block中。</p>
<p>满足即将要发送（可能是一个小时内要发送的消息）的延迟消息会加载到内存中，通过TimeWheel来发送到目标Topicz中。通过后台线程不断查询满足条件的消息，及时加载到TimeWheel中。</p>
<h3 id="RocketMQ-目录和文件"><a href="#RocketMQ-目录和文件" class="headerlink" title="RocketMQ 目录和文件"></a>RocketMQ 目录和文件</h3><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>数据存储根目录：user.home /store </p>
<p>commit log 存储目录：user.home /store/commitlog</p>
<p>延迟消息存储目录：user.home /store/scheduledtempdata</p>
<h4 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h4><p>消费者队列文件每个文件大小 30w * 20 byte</p>
<p>user.home / store / abort.scheduled  文件存在表示上次是正常关机，否则是异常关机（延迟消息恢复时使用）。</p>
<h3 id="ScheduledMessageStore"><a href="#ScheduledMessageStore" class="headerlink" title="ScheduledMessageStore"></a>ScheduledMessageStore</h3><p>ScheduledMessageStore 提供访问延迟消息的API。</p>
<ol>
<li>load</li>
<li>start</li>
</ol>
<h3 id="Block-介绍"><a href="#Block-介绍" class="headerlink" title="Block 介绍"></a>Block 介绍</h3><p>Block是一个逻辑概念，底层是由多个大小相同的log文件组成。时间粒度一般为一个小时。</p>
<p>Block文件目录结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user.home/store/scheduledtempdata/<span class="number">20190910</span></span><br><span class="line">    /log/<span class="number">000000</span>xxxxxx <span class="comment">// log目录下每个文件大小相同都是128M, 顺序写</span></span><br><span class="line">    /queue/<span class="number">000000</span>xxxxx <span class="comment">// 每个文件大小为 30w * 24 字节</span></span><br><span class="line">    /checkpoint</span><br></pre></td></tr></table></figure>
<h3 id="ScheduledTempBlock"><a href="#ScheduledTempBlock" class="headerlink" title="ScheduledTempBlock"></a>ScheduledTempBlock</h3><p>保存特定时间范围内的延迟消息，提供对于的操作API。</p>
<h3 id="延迟消息加载逻辑"><a href="#延迟消息加载逻辑" class="headerlink" title="延迟消息加载逻辑"></a>延迟消息加载逻辑</h3><p>RocketMQ启动时，需要恢复延迟消息到上次关机是的状态。</p>
<ol>
<li>检查是否正常关机并打印日志。是否正常关机通过文件:<code>user.home / store / abort.scheduled</code>是否存在来判断。</li>
<li>加载Block。遍历保存延迟消息的Block目录，通过每个<code>ScheduledTempBlock.load</code>方法来load各个Block。</li>
<li>每个Block是由大小相同的文件组成，这些文件组成<code>MappedFileQueue</code>，每个Block load时，底层其实是通过<code>MappedFileQueue</code>来恢复，<code>MappedFileQueue.load</code>时，会把该Block对应的所有文件进行<code>mmap</code>，并恢复<code>MappedFile</code>的状态。</li>
<li>恢复Block。遍历保存延迟消息的Block目录，通过每个<code>ScheduledTempBlock.revover</code>方法进行状态恢复。底层实现是通过<code>ScheduledTempQueue.recover</code>和<code>ScheduledTempLog.recoverNormally</code>来实现恢复。如果Queue 文件个数小于等于3,则从第一个Queue文件恢复，否则从倒数第三个开始恢复。</li>
<li>TimeWheelService 加载延迟消息。</li>
</ol>
<h3 id="Consumer-Queue-文件结构"><a href="#Consumer-Queue-文件结构" class="headerlink" title="Consumer Queue 文件结构"></a>Consumer Queue 文件结构</h3><p>ConsumeQueue中每个消息时20Byte长。结构为</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5149787-be103f4e0b434fe5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h2 id="相关知识总结"><a href="#相关知识总结" class="headerlink" title="相关知识总结"></a>相关知识总结</h2><h3 id="JVM-shutdownhook"><a href="#JVM-shutdownhook" class="headerlink" title="JVM shutdownhook"></a>JVM shutdownhook</h3><p>JVM 在在shutdown时， 会响应如下两种事件：</p>
<ol>
<li>进程正常退出（最后一个非Daemon线程退出） 或 通过<code>System.exit(int status)</code>方法 或 这等价方法退出。</li>
<li>用户中断进程(例如：Ctrl + C)， 或OS系统事件(用户退出， 系统关机)</li>
</ol>
<p>shutdownhook 本质上是一个已经初始化，但是未启动的线程。</p>
<p>JVM 在进入shutdown 流程后，多个shutdownhook会并发执行。所有的shutdownhook执行完成后，如果开启了<code>finalization-on-exit</code>时，JVM 还会执行所有未被调用的<code>finalizers</code>。 </p>
<blockquote>
<p>注意：如果是通过<code>System.exit</code>触发的shutdown流程，则在shutdown流程中，Daemon 和 非Daemon线程还在继续执行。</p>
<p>shutdown流程一旦开启，则是不可逆的，除非通过调用<code>Runtime.halt</code>方法，该方法会强制关闭JVM。</p>
<p>shutdown流程执行中，不能再添加或删除shutdownhook，否则会抛出IllegalStateException异常。</p>
<p>shutdownhook 代码需要精心编写：例如是线程安全，不会导致死锁，不会有异常等。</p>
<p>JVM 不能响应 kill -9 （SIGKILL）信号</p>
</blockquote>
<p> <a href="https://www.jianshu.com/p/3cb9aacc26a2" target="_blank" rel="noopener">JVM对于signal的处理及案例分析</a> </p>
<h3 id="JNA"><a href="#JNA" class="headerlink" title="JNA"></a>JNA</h3><p>在RocketMQ实现中，为了实现高性能，避免进程内存页被swap，它通过调用本地C库API来锁定内存页。这里面就涉及到了Java如何调用本地库的实现。在<a href="https://github.com/java-native-access/jna" target="_blank" rel="noopener">JNA</a>之前，我们只能通过<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html" target="_blank" rel="noopener">JNI</a>进行跨语言的相互调用，非常的繁琐。幸亏有了JNA，使我们得以非常快捷的实现跨语言调用。</p>
<p>RocketMQ中的实现。</p>
<h4 id="定义本地调用接口"><a href="#定义本地调用接口" class="headerlink" title="定义本地调用接口"></a>定义本地调用接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LibC</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">    LibC INSTANCE = (LibC) Native.loadLibrary(Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>, LibC.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MADV_WILLNEED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> MADV_DONTNEED = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MCL_CURRENT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> MCL_FUTURE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> MCL_ONFAULT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sync memory asynchronously */</span></span><br><span class="line">    <span class="keyword">int</span> MS_ASYNC = <span class="number">0x0001</span>;</span><br><span class="line">    <span class="comment">/* invalidate mappings &amp; caches */</span></span><br><span class="line">    <span class="keyword">int</span> MS_INVALIDATE = <span class="number">0x0002</span>;</span><br><span class="line">    <span class="comment">/* synchronous memory sync */</span></span><br><span class="line">    <span class="keyword">int</span> MS_SYNC = <span class="number">0x0004</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">madvise</span><span class="params">(Pointer var1, NativeLong var2, <span class="keyword">int</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Pointer <span class="title">memset</span><span class="params">(Pointer p, <span class="keyword">int</span> v, <span class="keyword">long</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlockall</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(Pointer p, NativeLong length, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本地库接口一般继承<code>Library</code> ，在接口中定义你需要调用的本地API对应的Java方法。这里需要非常注意Jav、a中的数据类型和本地接口的数据类型匹配问题。此外还需要注意一定订单一个<code>public static</code>的变量</p>
<p>该变量就是你调用本地API的入口对象。</p>
</blockquote>
<h4 id="内存锁定"><a href="#内存锁定" class="headerlink" title="内存锁定"></a>内存锁定</h4><p>有了和本地API进行交互的能力后，就可以方便的利用Java SDK中不具备，只能通过本地接口提供的功能了。</p>
<h5 id="mlock"><a href="#mlock" class="headerlink" title="mlock"></a>mlock</h5><p>mlock 方法接受2个参数，一个是要锁定内存的起始地址，一个是锁定的大小。但是需要注意的是你锁定的页面当前页可能并不在物理内存中，因此你需要对要锁定的内存区域写入数据。RocketMQ就是在创建MappedFile并warm的时候写入0进行内存完全占用的。</p>
<p>内存锁定是危险操作，需要具有ROOT权限。</p>
<h5 id="munlock"><a href="#munlock" class="headerlink" title="munlock"></a>munlock</h5><p>作用同mlock相反，用来取消内存锁定。</p>
<h2 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h2><ol>
<li><p>OS_PAGE_SIZE 在刷盘时，是按照页大小4K进行的，如果操作系统(应用进程)启用了大页，是不是可以通过大页作为单位呢？</p>
</li>
<li><p>刷盘时，最少页数的计算 ((write / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE)) &gt;= flushLeastPages; 是不是可以通过 (write - flush) / OS_PAGE_SIZE &gt;= flushLeastPages 呢？</p>
</li>
<li><p>同步刷盘需要处理一个刷盘请求队列，队列里面有多个请求，当刷盘请求较密集时(还有线程切换原因)，可能导致多次调用force方法，但是每次刷盘的数据其实不会很多。现有的逻辑是每次等待10ms来达到类似MySQL redo log组提交的效果，其实 10ms 这个值可以通过 磁盘的IOPS 和 配置参数进行调节，这样刷盘效果可能更好。</p>
</li>
<li><p>感觉消息持久化逻辑和InnoDB的redo log 刷盘逻辑很类型。</p>
</li>
<li><p>NUMA 架构下的优化</p>
</li>
<li><p>MappedFile wrotePosition, commitedPosition, flushedPosition。 </p>
<ol>
<li>wrotePosition 是写入到MappedByteBuffer的位置</li>
<li>commitedPosition 是启用了TransientStorePool后，写入到DirectByteBuffer的位置。</li>
<li>flushedPosition 是最后刷盘的位置</li>
<li>wrotePosition  &gt;= commitedPosition &gt;= flushedPosition</li>
</ol>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></p>
<p> <a href="https://www.jianshu.com/p/ccdf6fc710b0" target="_blank" rel="noopener">https://www.jianshu.com/p/ccdf6fc710b0</a> </p>
<p> <a href="https://www.jianshu.com/p/6d0c118c17de" target="_blank" rel="noopener">https://www.jianshu.com/p/6d0c118c17de</a> </p>
<p> <a href="http://jm.taobao.org/2017/03/23/20170323/" target="_blank" rel="noopener">http://jm.taobao.org/2017/03/23/20170323/</a> </p>
<p> <a href="https://www.cnblogs.com/lanxuezaipiao/p/3635556.html" target="_blank" rel="noopener">https://www.cnblogs.com/lanxuezaipiao/p/3635556.html</a> </p>
<p> <a href="https://github.com/OpenHFT/Java-Thread-Affinity" target="_blank" rel="noopener">https://github.com/OpenHFT/Java-Thread-Affinity</a> </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RocketMQ算是当前国内MQ领域内的明星产品。网上关于它文章非常的多。但是总觉得任何一项你想要在生产环境使用的技术，你必须亲自深入学习一遍才能更好的使用它，出了问题也好定位。在学习源码的过程中可能有许多意想不到的收获，也是提示技术能力的一种方式。&lt;/p&gt;
&lt;h3 id=&quot;RocketMQ-文件目录&quot;&gt;&lt;a href=&quot;#RocketMQ-文件目录&quot; class=&quot;headerlink&quot; title=&quot;RocketMQ 文件目录&quot;&gt;&lt;/a&gt;RocketMQ 文件目录&lt;/h3&gt;&lt;p&gt;RocketMQ 作为一个具有持久化功能的消息中间件，必然需要强大的存储功能。那么首先需要了解的就是它的存储架构。&lt;/p&gt;
&lt;p&gt;RocketMQ 存储目录结构&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leokongwq.github.io/2019/12/14/JDBC-timeout-analyze.html"/>
    <id>https://leokongwq.github.io/2019/12/14/JDBC-timeout-analyze.html</id>
    <published>2019-12-13T16:19:30.446Z</published>
    <updated>2019-12-13T16:21:57.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-TCP连接超时"><a href="#Linux-TCP连接超时" class="headerlink" title="Linux TCP连接超时"></a>Linux TCP连接超时</h2><p>建立TCP连接时，需要三次握手。</p>
<figure class="highlight plain"><figcaption><span>-&gt; server  发送 sync 分节</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次：client -&gt; server  发送 sync 分节</span><br></pre></td></tr></table></figure>
<p>如果 client 迟迟不能收到 server返回的ack就会重试。默认重试6次。每次重试的时间间隔都是2的幂次方。</p>
<p>具体是：</p>
<ol>
<li>第 1 次发送 SYN 报文后等待 1s（2 的 0 次幂），如果超时，则重试</li>
<li>第 2 次发送后等待 2s（2 的 1 次幂），如果超时，则重试</li>
<li>第 3 次发送后等待 4s（2 的 2 次幂），如果超时，则重试</li>
<li>第 4 次发送后等待 8s（2 的 3 次幂），如果超时，则重试</li>
<li>第 5 次发送后等待 16s（2 的 4 次幂），如果超时，则重试</li>
<li>第 6 次发送后等待 32s（2 的 5 次幂），如果超时，则重试</li>
<li>第 7 次发送后等待 64s（2 的 6 次幂），如果超时，则超时失败</li>
</ol>
<p>总计127秒。也就是说连接超时的默认时间是127秒。</p>
<a id="more"></a>
<p>我们的应用通常需要的是快速失败策略，显然这个超时时间太长了。可以通过减少重试的次数来缩短超时时间。</p>
<p>具体如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改/etc/sysctl.conf文件添加如下配置：</span><br><span class="line">tcp_syn_retries = 1 //超时时间为3s</span><br><span class="line">或 直接通过命令：sysctl net.ipv4.tcp_syn_retries=1</span><br></pre></td></tr></table></figure>
<p>顺便提一下：<code>net.ipv4.tcp_synack_retries</code>这个参数</p>
<p>这个参数用来控制 server 端发生第二次握手分节的重试次数。</p>
<h2 id="Socket-连接超时"><a href="#Socket-连接超时" class="headerlink" title="Socket 连接超时"></a>Socket 连接超时</h2><p>Java 中的Socket API 可以指定连接超时时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* timeout  the timeout value to be used in milliseconds.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SocketAddress endpoint, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核在放弃建立连接前会重试指定的次数（可以计算出最大时间），Socket API也可以指定超时时间，这2个超时时间是有关联的。</p>
<ol>
<li>如果内核还在重试，但是API指定的超时时间已经到了，那么应用也会收到超时异常。</li>
<li>如果内核不再重试，API还在等待建立连接，那么在指定的超时时间后收到超时。</li>
</ol>
<h3 id="Socket-读取超时"><a href="#Socket-读取超时" class="headerlink" title="Socket 读取超时"></a>Socket 读取超时</h3><p>读超时可以通过下面的API进行设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Enable/disable &#123;<span class="doctag">@link</span> SocketOptions#SO_TIMEOUT SO_TIMEOUT&#125;</span></span><br><span class="line"><span class="comment">* with the specified timeout, in milliseconds. With this option set</span></span><br><span class="line"><span class="comment">* to a non-zero timeout, a read() call on the InputStream associated with</span></span><br><span class="line"><span class="comment">* this Socket will block for only this amount of time. </span></span><br><span class="line"><span class="comment">* timeout the specified timeout, in milliseconds</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSoTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SocketException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的知识，我们可以知道， 虽然可能读取超时了，但是正常的数据还是能被内核接收到。 在下次读取的时候依然可以读取。</p>
<h3 id="MySQL连接超时和读取超时"><a href="#MySQL连接超时和读取超时" class="headerlink" title="MySQL连接超时和读取超时"></a>MySQL连接超时和读取超时</h3><p>我们现在使用MySQL驱动都是type4型驱动，通过TCP和MySQL Server进行通信。既然是基于TCP，那么一定会受到TCP超时设置的影响。 </p>
<p>在建立MySQL连接时，可以通过在连接串添加超时参数来控制连接超时时间。</p>
<p>例如：jdbc:mysql://127.0.0.1:3306/test?connectTimeout=2000&amp;socketTime=2000</p>
<h2 id="JDBC-Statement超时时间"><a href="#JDBC-Statement超时时间" class="headerlink" title="JDBC Statement超时时间"></a>JDBC Statement超时时间</h2><p>Statement执行的超时时间可以通过下面的API进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets the number of seconds the driver will wait for a</span></span><br><span class="line"><span class="comment">* &lt;code&gt;Statement&lt;/code&gt; object to execute to the given number of seconds.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setQueryTimeout</span><span class="params">(<span class="keyword">int</span> seconds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>注意：JDBC 底层TCP的读取超时时间 必须大于 Statement的超时时间，否则Statement的超时设置没有任何意义，包括上面的事务超时设置。</p>
<h3 id="MySQL如何处理Statement超时"><a href="#MySQL如何处理Statement超时" class="headerlink" title="MySQL如何处理Statement超时"></a>MySQL如何处理Statement超时</h3><ol>
<li><p>调用 Connection 的 createStatement() 方法创建一个 Statement 对象</p>
</li>
<li><p>调用 Statement 的 executeQuery() 方法</p>
</li>
<li><p>如果启用了查询超时功能(通过连接串参数enableQueryTimeouts指定，默认为true)，并且设置了Statement 的超时时间，Statement 创建一个新的延时任务提交到所属Connection的Timer中</p>
</li>
<li>Timer到期后会创建一个线程，然后创建一个和当前连接配置相同的新连接，用新连接向MySQL发送一条取消查询的命令：<code>KILL QUERY connectionId</code></li>
<li><p>通过内部的 Connection 将查询命令传输到  MySQL数据库</p>
</li>
<li><p>获取sql执行的返回结果，判断取消查询的任务是否已经执行</p>
</li>
<li><p>如果已经执行，则抛出超时异常。</p>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/5015984-f32a72cdff5de604.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614/format/webp" alt="img"></p>
<h3 id="连接池获取连接超时"><a href="#连接池获取连接超时" class="headerlink" title="连接池获取连接超时"></a>连接池获取连接超时</h3><p>不同的连接池配置属性不同，这点就不展开了。</p>
<p>DruidDataSource通过下面的属性进行配置。默认值为：0，表示不进行超时限制。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queryTimeout"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="网络相关知识"><a href="#网络相关知识" class="headerlink" title="网络相关知识"></a>网络相关知识</h2><h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><p>定义：RTT(Round-Trip Time) 往返时延 </p>
<p>计算公式：RTT=2*Tp+Tb; Tp为传播时延；Tb为确认信号时间。</p>
<h3 id="RTO"><a href="#RTO" class="headerlink" title="RTO"></a>RTO</h3><p>RTO = Retransmission TimeOut 指连接的超时重传时间，根据RTT不断的进行调整，防止重传时间太短导致发出太多包，防止重传时间太长使得应用层反应缓慢。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://weakyon.com/2015/07/30/the-impact-fo-rto-to-tcp-timeout.html" target="_blank" rel="noopener">http://weakyon.com/2015/07/30/the-impact-fo-rto-to-tcp-timeout.html</a></p>
<p><a href="http://xiaorui.cc/2016/06/05/理解linux网络的tcp超时和重传/" target="_blank" rel="noopener">http://xiaorui.cc/2016/06/05/%E7%90%86%E8%A7%A3linux%E7%BD%91%E7%BB%9C%E7%9A%84tcp%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E4%BC%A0/</a></p>
<p><a href="http://www.chengweiyang.cn/2017/02/18/linux-connect-timeout/" target="_blank" rel="noopener">http://www.chengweiyang.cn/2017/02/18/linux-connect-timeout/</a></p>
<p><a href="https://xwl-note.readthedocs.io/en/latest/linux/tuning.html" target="_blank" rel="noopener">https://xwl-note.readthedocs.io/en/latest/linux/tuning.html</a></p>
<p><a href="http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/" target="_blank" rel="noopener">http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/</a></p>
<p><a href="https://www.jianshu.com/p/2deaf51bf715" target="_blank" rel="noopener">https://www.jianshu.com/p/2deaf51bf715</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-TCP连接超时&quot;&gt;&lt;a href=&quot;#Linux-TCP连接超时&quot; class=&quot;headerlink&quot; title=&quot;Linux TCP连接超时&quot;&gt;&lt;/a&gt;Linux TCP连接超时&lt;/h2&gt;&lt;p&gt;建立TCP连接时，需要三次握手。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;-&amp;gt; server  发送 sync 分节&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第一次：client -&amp;gt; server  发送 sync 分节&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果 client 迟迟不能收到 server返回的ack就会重试。默认重试6次。每次重试的时间间隔都是2的幂次方。&lt;/p&gt;
&lt;p&gt;具体是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第 1 次发送 SYN 报文后等待 1s（2 的 0 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 2 次发送后等待 2s（2 的 1 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 3 次发送后等待 4s（2 的 2 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 4 次发送后等待 8s（2 的 3 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 5 次发送后等待 16s（2 的 4 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 6 次发送后等待 32s（2 的 5 次幂），如果超时，则重试&lt;/li&gt;
&lt;li&gt;第 7 次发送后等待 64s（2 的 6 次幂），如果超时，则超时失败&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总计127秒。也就是说连接超时的默认时间是127秒。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://leokongwq.github.io/2019/12/14/HttpMessageConverter%E6%80%BB%E7%BB%93.html"/>
    <id>https://leokongwq.github.io/2019/12/14/HttpMessageConverter总结.html</id>
    <published>2019-12-13T16:19:30.445Z</published>
    <updated>2019-12-13T16:22:32.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HttpMessageConverter-是什么？"><a href="#HttpMessageConverter-是什么？" class="headerlink" title="HttpMessageConverter 是什么？"></a>HttpMessageConverter 是什么？</h3><p>简单来说<code>HttpMessageConverter</code>是spring-web提供的一个接口，用来将HTTP请求转为应用使用的数据，或将HTTP接口的返回数据转为客户端需要的数据。</p>
<p>接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据参数判断该Converter是否能对请求进行转换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 根据参数判断是否可以转换，生成指定的HTTP响应</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the list of &#123;<span class="doctag">@link</span> MediaType&#125; objects supported by this converter.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the list of supported media types</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 从 inputMessage 读取数据，转为class指定的对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将参数t指定的数据，转换为 contentType 指定的媒体类型，写入到HTTP响应。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="FastJsonHttpMessageConverter"><a href="#FastJsonHttpMessageConverter" class="headerlink" title="FastJsonHttpMessageConverter"></a>FastJsonHttpMessageConverter</h3><p><code>FastJsonHttpMessageConverter</code> 是fastjson提供的一个 <code>HttpMessageConverter</code>实现，</p>
<p>在实践中，用来将HTTP请求(请求体是json格式)， 或将响应对象转为 json响应(application/json)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractHttpMessageConverter</span>&lt;<span class="title">Object</span>&gt;//</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">GenericHttpMessageConverter</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * with fastJson config</span></span><br><span class="line"><span class="comment">     * 可以通过 FastJsonConfig 设置 json 序列化的配置， 例如：日期格式，编码等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Can serialize/deserialize all types.</span></span><br><span class="line"><span class="comment">     * MediaType.ALL 表示可以转换所有的媒体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastJsonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(MediaType.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fastJsonConfig the fastJsonConfig to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.2.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFastJsonConfig</span><span class="params">(FastJsonConfig fastJsonConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastJsonConfig = fastJsonConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">    FastJsonHttpMessageConverter jsonHttpMessageConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line">    FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">    fastJsonConfig.setCharset(Charsets.UTF_8);</span><br><span class="line">    fastJsonConfig.setDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    jsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">    <span class="keyword">super</span>.extendMessageConverters(converters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-如何获取支持的媒体类型-MediaType"><a href="#spring-mvc-如何获取支持的媒体类型-MediaType" class="headerlink" title="spring-mvc 如何获取支持的媒体类型 (MediaType) ?"></a>spring-mvc 如何获取支持的媒体类型 (MediaType) ?</h3><p>答：通过获取所有<code>HttpMessageConverter</code>支持的媒体类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AbstractMessageConverterMethodArgumentResolver 类：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;MediaType&gt; <span class="title">getAllSupportedMediaTypes</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</span><br><span class="line">truetrueSet&lt;MediaType&gt; allSupportedMediaTypes = <span class="keyword">new</span> LinkedHashSet&lt;MediaType&gt;();</span><br><span class="line">truetrue<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; messageConverter : messageConverters) &#123;</span><br><span class="line">truetruetrueallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrueList&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(allSupportedMediaTypes);</span><br><span class="line">truetrueMediaType.sortBySpecificity(result);</span><br><span class="line">truetrue<span class="keyword">return</span> Collections.unmodifiableList(result);</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-针对Response对象如何获取可以生成的媒体类-MediaType"><a href="#spring-mvc-针对Response对象如何获取可以生成的媒体类-MediaType" class="headerlink" title="spring-mvc 针对Response对象如何获取可以生成的媒体类(MediaType) ?"></a>spring-mvc 针对Response对象如何获取可以生成的媒体类(MediaType) ?</h3><p>答：通过判断所有<code>HttpMessageConverter</code>是否可以转换(<code>canWrite</code>)Response对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AbstractMessageConverterMethodProcessor 类：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;MediaType&gt; <span class="title">getProducibleMediaTypes</span><span class="params">(HttpServletRequest request, Class&lt;?&gt; valueClass, Type declaredType)</span> </span>&#123;</span><br><span class="line">truetrueSet&lt;MediaType&gt; mediaTypes = (Set&lt;MediaType&gt;) request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">truetrue<span class="keyword">if</span> (!CollectionUtils.isEmpty(mediaTypes)) &#123;</span><br><span class="line">truetruetrue<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(mediaTypes);</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allSupportedMediaTypes.isEmpty()) &#123;</span><br><span class="line">truetruetrueList&lt;MediaType&gt; result = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;();</span><br><span class="line">truetruetrue<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">truetruetruetrue<span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter &amp;&amp; declaredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">truetruetruetruetrue<span class="keyword">if</span> (((GenericHttpMessageConverter&lt;?&gt;) converter).canWrite(declaredType, valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">truetruetruetruetruetrueresult.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">truetruetruetruetrue&#125;</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetruetrue<span class="keyword">else</span> <span class="keyword">if</span> (converter.canWrite(valueClass, <span class="keyword">null</span>)) &#123;</span><br><span class="line">truetruetruetruetrueresult.addAll(converter.getSupportedMediaTypes());</span><br><span class="line">truetruetruetrue&#125;</span><br><span class="line">truetruetrue&#125;</span><br><span class="line">truetruetrue<span class="keyword">return</span> result;</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">else</span> &#123;</span><br><span class="line">truetruetrue<span class="keyword">return</span> Collections.singletonList(MediaType.ALL);</span><br><span class="line">truetrue&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-如何判断客户端请求的媒体类-MediaType"><a href="#spring-mvc-如何判断客户端请求的媒体类-MediaType" class="headerlink" title="spring-mvc 如何判断客户端请求的媒体类(MediaType) ?"></a>spring-mvc 如何判断客户端请求的媒体类(MediaType) ?</h3><p>答：通过<code>ContentNegotiationStrategy</code> 策略接口的实现类来判断。</p>
<ul>
<li>HeaderContentNegotiationStrategy 通过请求头<code>Accept</code></li>
<li>FixedContentNegotiationStrategy  固定类型</li>
<li>PathExtensionContentNegotiationStrategy  通过扩</li>
<li>ServletPathExtensionContentNegotiationStrategy 通过请求路径扩展名称 eg. user.json / user.xml</li>
<li>ParameterContentNegotiationStrategy 通过请求参数。user?format<strong>=</strong>json</li>
<li>OptionalPathExtensionContentNegotiationStrategy</li>
</ul>
<h3 id="spring-mvc-如何进行请求和响应内容的匹配和选择呢？"><a href="#spring-mvc-如何进行请求和响应内容的匹配和选择呢？" class="headerlink" title="spring-mvc 如何进行请求和响应内容的匹配和选择呢？"></a>spring-mvc 如何进行请求和响应内容的匹配和选择呢？</h3><p>答：根据请求的媒体类型和框架组件能生成的媒体类型进行匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">writeWithMessageConverters</span><span class="params">(T value, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, </span></span><br><span class="line"><span class="function">HttpMessageNotWritableException </span>&#123;</span><br><span class="line">true<span class="comment">//省略</span></span><br><span class="line">    Set&lt;MediaType&gt; compatibleMediaTypes = <span class="keyword">new</span> LinkedHashSet&lt;MediaType&gt;();</span><br><span class="line">    <span class="keyword">for</span> (MediaType requestedType : requestedMediaTypes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MediaType producibleType : producibleMediaTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestedType.isCompatibleWith(producibleType)) &#123;</span><br><span class="line">                compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    </span><br><span class="line">    List&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;(compatibleMediaTypes);</span><br><span class="line">true<span class="comment">//排序， 越是具体的媒体类型越靠前</span></span><br><span class="line">    MediaType.sortBySpecificityAndQuality(mediaTypes);</span><br><span class="line">    MediaType selectedMediaType = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (MediaType mediaType : mediaTypes) &#123;</span><br><span class="line">        <span class="comment">// 选择第一个具体的媒体类型</span></span><br><span class="line">        <span class="keyword">if</span> (mediaType.isConcrete()) &#123;</span><br><span class="line">            selectedMediaType = mediaType;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) &#123;</span><br><span class="line">            selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-HttpMessageConverter-写入Response"><a href="#spring-mvc-HttpMessageConverter-写入Response" class="headerlink" title="spring-mvc HttpMessageConverter 写入Response"></a>spring-mvc HttpMessageConverter 写入Response</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedMediaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    selectedMediaType = selectedMediaType.removeQualityValue();</span><br><span class="line">    <span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; messageConverter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">        <span class="comment">//泛型实现</span></span><br><span class="line">        <span class="keyword">if</span> (messageConverter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((GenericHttpMessageConverter) messageConverter).canWrite(</span><br><span class="line">                declaredType, valueType, selectedMediaType)) &#123;</span><br><span class="line">                <span class="comment">// 可以对outputValue进行进一步处理，例如jsonp接口</span></span><br><span class="line">                outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,</span><br><span class="line">                                                              (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(),</span><br><span class="line">                                                              inputMessage, outputMessage);</span><br><span class="line">                <span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">                    ((GenericHttpMessageConverter) messageConverter).write(</span><br><span class="line">                        outputValue, declaredType, selectedMediaType, outputMessage);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Written ["</span> + outputValue + <span class="string">"] as \""</span> + selectedMediaType +</span><br><span class="line">                                     <span class="string">"\" using ["</span> + messageConverter + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (messageConverter.canWrite(valueType, selectedMediaType)) &#123;</span><br><span class="line">            outputValue = (T) getAdvice().beforeBodyWrite(outputValue, returnType, selectedMediaType,</span><br><span class="line">                                                          (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) messageConverter.getClass(),</span><br><span class="line">                                                          inputMessage, outputMessage);</span><br><span class="line">            <span class="keyword">if</span> (outputValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                addContentDispositionHeader(inputMessage, outputMessage);</span><br><span class="line">                ((HttpMessageConverter) messageConverter).write(outputValue, selectedMediaType, outputMessage);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Written ["</span> + outputValue + <span class="string">"] as \""</span> + selectedMediaType +</span><br><span class="line">                                 <span class="string">"\" using ["</span> + messageConverter + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-返回jsonp"><a href="#spring-mvc-返回jsonp" class="headerlink" title="spring-mvc 返回jsonp"></a>spring-mvc 返回jsonp</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FastJsonpResponseBodyAdvice <span class="title">fastJsonpResponseBodyAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当请求参数有 callback 或 jsonp时，次Advice生效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastJsonpResponseBodyAdvice(<span class="string">"callback"</span>, <span class="string">"jsonp"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MediaType <span class="title">getContentType</span><span class="params">(MediaType contentType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"javascript"</span>, Charsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 需要注意的是，如果是jsonp响应， <code>FastJsonHttpMessageConverter</code>会重新设置<code>Content-Type</code>响应头， 并且不带<code>charset</code>属性。1.2.28 没有问题。 为了修复安全漏洞，1.2.58有问题了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isJsonp = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不知道为什么会有这行代码， 但是为了保持和原来的行为一致，还是保留下来</span></span><br><span class="line">Object value = strangeCodeForJackson(object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> FastJsonContainer) &#123;</span><br><span class="line">    FastJsonContainer fastJsonContainer = (FastJsonContainer) value;</span><br><span class="line">    PropertyPreFilters filters = fastJsonContainer.getFilters();</span><br><span class="line">    allFilters.addAll(filters.getFilters());</span><br><span class="line">    value = fastJsonContainer.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//revise 2017-10-23 ,</span></span><br><span class="line"><span class="comment">// 保持原有的MappingFastJsonValue对象的contentType不做修改 保持旧版兼容。</span></span><br><span class="line"><span class="comment">// 但是新的JSONPObject将返回标准的contentType：application/javascript ，不对是否有function进行判断</span></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> MappingFastJsonValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(((MappingFastJsonValue) value).getJsonpFunction())) &#123;</span><br><span class="line">        isJsonp = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> JSONPObject) &#123;</span><br><span class="line">    isJsonp = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isJsonp) &#123;</span><br><span class="line">     <span class="comment">// 重新设置了Content-Type的值</span></span><br><span class="line">     headers.setContentType(APPLICATION_JAVASCRIPT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-mvc-内容协商"><a href="#spring-mvc-内容协商" class="headerlink" title="spring-mvc 内容协商"></a>spring-mvc 内容协商</h3><p>参考：<a href="https://junq.io/spring-mvc实现http内容协商-content-negotiation.html" target="_blank" rel="noopener">https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HttpMessageConverter-是什么？&quot;&gt;&lt;a href=&quot;#HttpMessageConverter-是什么？&quot; class=&quot;headerlink&quot; title=&quot;HttpMessageConverter 是什么？&quot;&gt;&lt;/a&gt;HttpMessageConverter 是什么？&lt;/h3&gt;&lt;p&gt;简单来说&lt;code&gt;HttpMessageConverter&lt;/code&gt;是spring-web提供的一个接口，用来将HTTP请求转为应用使用的数据，或将HTTP接口的返回数据转为客户端需要的数据。&lt;/p&gt;
&lt;p&gt;接口定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HttpMessageConverter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 根据参数判断该Converter是否能对请求进行转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 根据参数判断是否可以转换，生成指定的HTTP响应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canWrite&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;?&amp;gt; clazz, MediaType mediaType)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * Return the list of &amp;#123;&lt;span class=&quot;doctag&quot;&gt;@link&lt;/span&gt; MediaType&amp;#125; objects supported by this converter.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the list of supported media types&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;List&amp;lt;MediaType&amp;gt; &lt;span class=&quot;title&quot;&gt;getSupportedMediaTypes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 从 inputMessage 读取数据，转为class指定的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;? extends T&amp;gt; clazz, HttpInputMessage inputMessage)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotReadableException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 将参数t指定的数据，转换为 contentType 指定的媒体类型，写入到HTTP响应。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;true&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t, MediaType contentType, HttpOutputMessage outputMessage)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, HttpMessageNotWritableException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL中join操作总结</title>
    <link href="https://leokongwq.github.io/2019/12/13/mysql-join-summary.html"/>
    <id>https://leokongwq.github.io/2019/12/13/mysql-join-summary.html</id>
    <published>2019-12-13T15:17:50.000Z</published>
    <updated>2019-12-13T16:42:10.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在数据库中Join操作被称为连接。目的是从多个表中获取数据作为结果集返回给客户端。join 操作分为如下几种：</p>
<p>外连接：<code>left join</code>，<code>right join</code><br>内连接：<code>inner join</code><br>全连接：<code>full join</code><br>笛卡尔积： <code>cross join</code> </p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>新建2个表t1, t2，结构相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h3><p><code>left join</code> 只需要记住左表的数据全部保留，右表满足连接条件的记录展示，不满足的条件的记录全是null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT  JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">| id | a    | b    | id   | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |    1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |    2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 | NULL | NULL | NULL |</span><br><span class="line">+<span class="comment">----+------+------+------+------+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h3><p><code>right join</code> 只需要记住右表的数据全部保留，左表满足连接条件的记录展示，不满足的条件的记录全是null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 right JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">| id   | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">|    1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|    2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">| NULL | NULL | NULL |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">------+------+------+----+------+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p><code>inner join</code> 只保留左右两个表中满足连接条件的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="full-join"><a href="#full-join" class="headerlink" title="full join"></a>full join</h3><p>mysql 不支持<code>full join</code>，不过可以通过<code>union</code>来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 LEFT  JOIN t2 ON t1.id = t2.id union SELECT * FROM t1 right JOIN t2 ON t1.id = t2.id;</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">| id   | a    | b    | id   | a    | b    |</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">|    1 |    1 |    1 |    1 |    1 |    1 |</span><br><span class="line">|    2 |    2 |    2 |    2 |    2 |    2 |</span><br><span class="line">|    3 |    3 |    3 | NULL | NULL | NULL |</span><br><span class="line">| NULL | NULL | NULL |    4 |    4 |    4 |</span><br><span class="line">+<span class="comment">------+------+------+------+------+------+</span></span><br><span class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>从结果可以看出来，左右表不满足连接条件的记录也保留了下来。</p>
<h3 id="cross-join"><a href="#cross-join" class="headerlink" title="cross join"></a>cross join</h3><blockquote>
<p>笛卡尔乘积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × &gt; Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。</p>
</blockquote>
<p><code>cross join</code> 结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 CROSS JOIN t2;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  1 |    1 |    1 |</span><br><span class="line">|  3 |    3 |    3 |  1 |    1 |    1 |</span><br><span class="line">|  1 |    1 |    1 |  2 |    2 |    2 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 |  2 |    2 |    2 |</span><br><span class="line">|  1 |    1 |    1 |  4 |    4 |    4 |</span><br><span class="line">|  2 |    2 |    2 |  4 |    4 |    4 |</span><br><span class="line">|  3 |    3 |    3 |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>那我们再看一下不加连接条件的<code>inner join</code>的执行结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t1 INNER JOIN t2;</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">| id | a    | b    | id | a    | b    |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">|  1 |    1 |    1 |  1 |    1 |    1 |</span><br><span class="line">|  2 |    2 |    2 |  1 |    1 |    1 |</span><br><span class="line">|  3 |    3 |    3 |  1 |    1 |    1 |</span><br><span class="line">|  1 |    1 |    1 |  2 |    2 |    2 |</span><br><span class="line">|  2 |    2 |    2 |  2 |    2 |    2 |</span><br><span class="line">|  3 |    3 |    3 |  2 |    2 |    2 |</span><br><span class="line">|  1 |    1 |    1 |  4 |    4 |    4 |</span><br><span class="line">|  2 |    2 |    2 |  4 |    4 |    4 |</span><br><span class="line">|  3 |    3 |    3 |  4 |    4 |    4 |</span><br><span class="line">+<span class="comment">----+------+------+----+------+------+</span></span><br><span class="line">9 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>可以看出不加连接条件的<code>inner join</code> 和 <code>cross join</code> 的结果相同。</p>
<p>在MySQL中 <code>join</code>，<code>cross join</code>, <code>inner join</code></p>
<h3 id="Join语句是怎么执行的？"><a href="#Join语句是怎么执行的？" class="headerlink" title="Join语句是怎么执行的？"></a>Join语句是怎么执行的？</h3><p>MySQL中join语句的执行有3中方式，分别如下所示：</p>
<h4 id="Index-Nested-Loop-Join"><a href="#Index-Nested-Loop-Join" class="headerlink" title="Index Nested-Loop Join"></a>Index Nested-Loop Join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a = t2.a)</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ol>
<li>从表 t1 中读入一行数据R；</li>
<li>从数据行 R 中，取出 a 字段到表 t2 里去查找；</li>
<li>取出表 t2 中满足条件的行，和 R 组成一行，作为结果集的一部分；</li>
<li>重复执行步骤 1 和 3 ，知道 t1 的末尾循环结束。</li>
</ol>
<p>在形式上，这个过程就跟我们写成程序时的嵌套查询类似，并且<strong>可以用上被驱动表的索引</strong>，所以我们成为<code>Index Nested-Loop Join</code>，简称<code>NLJ</code>。</p>
<p>如果不使用join:</p>
<ol>
<li>执行select * from t1，查出t1的所有数据，100行</li>
<li>循环遍历这100行：<ul>
<li>从每一行R取出字段a的值$R.a;</li>
<li>执行select * from t2 where a=$R.a;</li>
<li>把返回结果和R构成结果集的一行。</li>
</ul>
</li>
</ol>
<p>可以看到，在这个查询过程，也是扫描了200行，但是总共执行了101条语句，比直接join多了100次交互。除此之外，客户端还要自己拼接SQL语句。</p>
<p>显然，这么做还不如直接join好。</p>
<p>假设被驱动表的行数是M。每次查找被驱动表中一行数据时，要先搜索索引a，再搜索主键索引树。每次搜索一棵树近似复杂度是以 2 为底的M的对数，记为log2M，所以再被驱动表上查一行的时间复杂度是 2*log2M。</p>
<p>结论：</p>
<ol>
<li>使用join语句，性能比强行拆成多个单表执行sql语句的性能要好。</li>
<li>如果使用join语句的话，需要让小表做驱动表</li>
</ol>
<p>但是，需要注意，这个结论的前提是<strong>可以使用被驱动表的索引</strong></p>
<h4 id="Simple-Nested-loop-join"><a href="#Simple-Nested-loop-join" class="headerlink" title="Simple Nested-loop join"></a>Simple Nested-loop join</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a = t2.b)</span><br></pre></td></tr></table></figure>
<p>t1是驱动表，t2是被驱动表。</p>
<p>由于表t2的字段b上没有索引，因此再用上面提到的执行流程时，每次到t2去匹配的时候，就要做一次<strong>全表扫描</strong></p>
<p>这时，每次t2去匹配的时候，就要做一次全表扫描。这个sql请求就要扫描表t2多达100次，总共扫描100*1000=10万行。</p>
<p>当然MYSQL没有使用这个方法，而是下面的 <strong>Block Nested-Loop Join</strong></p>
<h4 id="Block-Nested-Loop-Join"><a href="#Block-Nested-Loop-Join" class="headerlink" title="Block Nested-Loop Join"></a>Block Nested-Loop Join</h4><p>这时候，被驱动表上没有可用的索引，算法的流程是这样的：</p>
<ol>
<li>把表t1的数据读入线程内存<code>join_buffer</code>中，由于我们这个语句中写的是<code>select *</code>，因此是把整个t1放入了内存；</li>
<li>扫描表t2，把表t2的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足join条件的(也就是on指定的条件)，作为结果集的一部分返回。</li>
</ol>
<p>可以看到，在这个过程中，对表t1和t2都做了一次全表扫描，因此总的扫描行数是1100.由于join_buffer是以无序数组的方式组织的，因此对表t2中的每一行，都要做100次判断，总共需要在内存中做的判断次数是：100*1000=10万行。</p>
<p>前面我们说过，如果使用<code>Simple Nested-Loop Join</code>算法进行查询，扫描行数也是10万行。因此，从时间复杂度上来说，这两个算法是一样的。但是Block Nested-Loop Join算法的这10万次判断是内存操作，速度上会快很多，性能也更好</p>
<p>接下来，我们来看一下，在这种情况下，应该选择哪个表做驱动表。</p>
<p>假设小表的行数据是N，大表的行数是M，那么在这个算法里：</p>
<p>两个表都做一次全表扫描，所以总的扫描行数是M+N；<br>内存中的判断次数是M*N<br>可以看到，调换这两个算式中的M和N没有区别，因此这时候选择大表还是小表做驱动表，执行耗时是一样的。</p>
<p>然后，你可能马上就会问了，这个例子里t1才100行，要是表t1是一个大表，<code>join_buffer</code>放不下怎么办呢？</p>
<p><code>join_buffer</code> 的大小是由<code>join_buffer_size</code>设定的，默认值是256k。如果放不下t1的所有数据的话，策略很简单，就是分段放。把<code>join_buffer_size</code>改成1200，再执行：</p>
<p><strong>过程就变成了：</strong></p>
<ol>
<li>扫描表t1，顺序读取数据行放入<code>join_buffer</code>中，放完第88行join_buffer满了，继续第二步</li>
<li>扫描表t2，把t2中的每一行取出来，跟<code>join_buffer</code>中的数据做对比，满足join条件的，作为结果集的一部分返回；<br>清空<code>join_buffer</code><br>继续扫描表t1，顺序读取最后的12行数据放入<code>join_buffer</code>中，继续执行第2步<br>这个流程才体现出了这个算法名字中<code>Block</code>的由来，表示<code>分块去join</code></li>
</ol>
<p>可以看到，这时候由于表t1被分成两次放入join_buffer中，导致表t2会被扫描两次，但是判断等值条件的次数还是不变的，（88+12）*1000=10万次。</p>
<p>假设，驱动表的数据行数是N，需要分K段才能完成算法流程，被驱动表的数据行数是M。</p>
<p>注意，这里的 K 不是常数，N 越大 K 就会越大，因此把 K 表示为λ*N，显然λ的取值范围是 (0,1)。</p>
<p>所以，在这个算法的执行过程中：</p>
<ol>
<li>扫描行数是 N+λ<em>N</em>M；</li>
<li>内存判断 N*M 次。</li>
</ol>
<p>显然，内存判断次数是不受选择哪个表作为驱动表影响的。而考虑到扫描行数，在 M 和 N 大小确定的情况下，N 小一些，整个算式的结果会更小。</p>
<p>当然，你会发现，在 N+λ<em>N</em>M 这个式子里，λ才是影响扫描行数的关键因素，这个值越小越好。</p>
<p>刚刚我们说了 N 越大，分段数 K 越大。那么，N 固定的时候，什么参数会影响 K 的大小呢？（也就是λ的大小）答案是 join_buffer_size。join_buffer_size越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。</p>
<p>这就是为什么，你可能会看到一些建议告诉你，如果你的 join 语句很慢，就把 join_buffer_size 改大。</p>
<h3 id="on-字句和-where-的顺序问题"><a href="#on-字句和-where-的顺序问题" class="headerlink" title="on 字句和 where 的顺序问题"></a>on 字句和 where 的顺序问题</h3><p>直接说结论：从上面的分析可以知道，on字句的条件用来过滤被驱动表中的数据。where字句指定的条件用来过滤最终join的结果集。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://dev.mysql.com/worklog/task/?id=1604" target="_blank" rel="noopener">https://dev.mysql.com/worklog/task/?id=1604</a></p>
<p><a href="https://time.geekbang.org/column/article/83183" target="_blank" rel="noopener">MySQL45讲 - 我订阅的课程</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/join.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在数据库中Join操作被称为连接。目的是从多个表中获取数据作为结果集返回给客户端。join 操作分为如下几种：&lt;/p&gt;
&lt;p&gt;外连接：&lt;code&gt;left join&lt;/code&gt;，&lt;code&gt;right join&lt;/code&gt;&lt;br&gt;内连接：&lt;code&gt;inner join&lt;/code&gt;&lt;br&gt;全连接：&lt;code&gt;full join&lt;/code&gt;&lt;br&gt;笛卡尔积： &lt;code&gt;cross join&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;p&gt;新建2个表t1, t2，结构相同。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`t1`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`t2`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`b`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`a`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; t1 &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; t2 &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://leokongwq.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://leokongwq.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关于timeout你必须了解</title>
    <link href="https://leokongwq.github.io/2019/11/30/all-timeout-summary.html"/>
    <id>https://leokongwq.github.io/2019/11/30/all-timeout-summary.html</id>
    <published>2019-11-30T05:14:37.000Z</published>
    <updated>2019-12-01T15:25:47.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有经验的开发同学都知道访问依赖的服务服务时需要设置超时时间。这些外部服务可能是一个http接口，RPC接口，获取分布式锁等等。没有合理的超时时间设置，你的系统可能出现雪崩。但是在工作中发现大部分同学，包括我自己在内对如何合理的设置timeout没有形成一个完整的知识链条，这就会导致你可能设置了timeout，但系统并不会像你想象中的正常工作。</p>
<p>下面以一个简单的访问数据库的HTTP请求来串起整个理论。可能理解或实践有误，还请发现的同学留言斧正。</p>
<blockquote>
<p>注意：所有代码例子都是在Linux 3.10.0 测试上通过，使用Java语言编写的。</p>
</blockquote>
<h3 id="connect-timeout"><a href="#connect-timeout" class="headerlink" title="connect timeout"></a>connect timeout</h3><p>我们使用最为广泛的数据库驱动底层是通过TCP来完成Client和Server通信的，在通信前必须建立网络连接。</p>
<img src="/2019/11/30/all-timeout-summary/tcp-connect.jpg">
<p>如图所示，Client 发送的syn包如果在一定的时间内没有收到Server的响应，那么Client就会报<code>ConnectException</code></p>
<h4 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h4><p>为了模拟syn丢包，我们通过在Server上添加如下的防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -I INPUT -s 10.110.82.169 -j DROP</span><br></pre></td></tr></table></figure>
<p>客户端IP : 10.110.82.169 进来的包都会被DROP</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>Server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/11/30 - 13:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket socketServer = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"10.13.40.95"</span>, <span class="number">3333</span>);</span><br><span class="line">        socketServer.bind(socketAddress, <span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Server started."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client 代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> * created 2019/11/30 - 13:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket client = <span class="keyword">new</span> Socket();</span><br><span class="line">        InetSocketAddress socketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"10.13.40.95"</span>, <span class="number">3333</span>);</span><br><span class="line">        client.connect(socketAddress);</span><br><span class="line">        System.out.println(<span class="string">"Client connect Server success."</span>);</span><br><span class="line">        client.setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">        OutputStream outputStream = client.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>执行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sat Nov <span class="number">30</span> <span class="number">15</span>:<span class="number">39</span>:<span class="number">49</span> CST <span class="number">2019</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.net.ConnectException: <span class="function">Connection timed <span class="title">out</span> <span class="params">(Connection timed out)</span></span></span><br><span class="line"><span class="function">        at java.net.PlainSocketImpl.<span class="title">socketConnect</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">doConnect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connectToAddress</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.SocksSocketImpl.<span class="title">connect</span><span class="params">(SocksSocketImpl.java:<span class="number">392</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">589</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">538</span>)</span></span></span><br><span class="line"><span class="function">        at Client.<span class="title">main</span><span class="params">(Client.java:<span class="number">15</span>)</span></span></span><br><span class="line"><span class="function">Sat Nov 30 15:39:52 CST 2019</span></span><br></pre></td></tr></table></figure>
<p>可以看到超时时间大概是：<code>3s</code></p>
<p>那为什么是3s呢？这是因为Linux内核关于TCP协议栈的配置。</p>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep retries</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.dccp.default.request_retries = 6</span><br><span class="line">net.dccp.default.retries1 = 3</span><br><span class="line">net.dccp.default.retries2 = 15</span><br><span class="line">net.ipv4.tcp_orphan_retries = 0</span><br><span class="line">net.ipv4.tcp_retries1 = 3</span><br><span class="line">net.ipv4.tcp_retries2 = 15</span><br><span class="line"># 下面2个配置很重要</span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br></pre></td></tr></table></figure>
<p>可以看到机器配置的<code>net.ipv4.tcp_syn_retries</code>和<code>net.ipv4.tcp_synack_retries</code>都是1。</p>
<p>注意: 1表示的是重试的次数，每次重试的间隔都是2的N次幂。例如：1, 2, 4, 8, 16, 32, 64。</p>
<p>将重试次数设置为7</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 7 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure>
<p>重新测试，结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date</span><br><span class="line">Sat Nov <span class="number">30</span> <span class="number">16</span>:<span class="number">16</span>:<span class="number">27</span> CST <span class="number">2019</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.net.ConnectException: <span class="function">Connection timed <span class="title">out</span> <span class="params">(Connection timed out)</span></span></span><br><span class="line"><span class="function">        at java.net.PlainSocketImpl.<span class="title">socketConnect</span><span class="params">(Native Method)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">doConnect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">350</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connectToAddress</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">206</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.AbstractPlainSocketImpl.<span class="title">connect</span><span class="params">(AbstractPlainSocketImpl.java:<span class="number">188</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.SocksSocketImpl.<span class="title">connect</span><span class="params">(SocksSocketImpl.java:<span class="number">392</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">589</span>)</span></span></span><br><span class="line"><span class="function">        at java.net.Socket.<span class="title">connect</span><span class="params">(Socket.java:<span class="number">538</span>)</span></span></span><br><span class="line"><span class="function">        at Client.<span class="title">main</span><span class="params">(Client.java:<span class="number">15</span>)</span></span></span><br><span class="line"><span class="function">Sat Nov 30 16:20:34 CST 2019</span></span><br></pre></td></tr></table></figure>
<p>耗时大概是：4分7秒 = 247 &lt; 1+2+4+8+16+32+64+128 = 255 (结果表明这个时间有误差) </p>
<p>将重试次数设置为8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 8 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure>
<p>重新测试，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">date ; java Client; date                    </span><br><span class="line">Sat Nov 30 16:26:14 CST 2019</span><br><span class="line">Exception in thread &quot;main&quot; java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">        at Client.main(Client.java:15)</span><br><span class="line">Sat Nov 30 16:32:22 CST 2019</span><br></pre></td></tr></table></figure>
<p>耗时是 6分8秒 = 368 约等于 1+2+4+8+16+32+64+128 + 128 = 383</p>
<p>man page 解释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcp_syn_retries (integer; default: 5; since Linux 2.2)</span><br><span class="line">      The maximum number of times initial SYNs for an active TCP</span><br><span class="line">      connection attempt will be retransmitted.  This value should</span><br><span class="line">      not be higher than 255.  The default value is 5, which</span><br><span class="line">      corresponds to approximately 180 seconds.</span><br></pre></td></tr></table></figure>
<p>默认重试5次，最大值不应该大于255。 在默认情况下大概是180秒左右超时。</p>
<p>再次设置为5，测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> java Client; date                    </span><br><span class="line">Sat Nov 30 16:47:14 CST 2019</span><br><span class="line">Exception in thread &quot;main&quot; java.net.ConnectException: Connection timed out (Connection timed out)</span><br><span class="line">        at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">        at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">        at Client.main(Client.java:15)</span><br><span class="line">Sat Nov 30 16:48:18 CST 2019</span><br></pre></td></tr></table></figure>
<p>超时时间是：63秒。 这个值和文档的值有出入，可能是原因是新的内核版本对这部分逻辑进行了修改。</p>
<blockquote>
<p>注意：不同的OS内核实现机制是不同的，例如基于BSD包括Mac OS X 在内，最大的等待时间是75秒。</p>
</blockquote>
<h3 id="read-timeout"><a href="#read-timeout" class="headerlink" title="read timeout"></a>read timeout</h3><p>连接建立了，那么就要相互交换数据了。举个例子：你发出了一个请求，通过读取对端的响应数据来判断对端是否正确处理了请求，如果不设置读取超时时间，那么就只能死等，非阻塞读还好，如果是阻塞模式，那么就导致线程占用，整个机器的线程资源会很快耗尽，不能服务。</p>
<p>这里需要注意的是：写操作是写入socket写缓冲区就返回了(TCP会进行重试)，作为客户端你是不知道你的请求对端究竟有没有收到。只能通过对端对请求的响应来判断。</p>
<h3 id="数据库应该开发中超时设置"><a href="#数据库应该开发中超时设置" class="headerlink" title="数据库应该开发中超时设置"></a>数据库应该开发中超时设置</h3><p>目前开发的大多数应用都是基于数据库，数据库作为稀缺资源一定要谨慎使用。</p>
<p>举个例子：如果没有设置java.sql.Statement执行sql的超时时间，哪个不小心上线了一个慢查询SQL，很容导致数据库连接池打满，整个服务不可用。</p>
<h4 id="MySQL-连接超时和读取超时"><a href="#MySQL-连接超时和读取超时" class="headerlink" title="MySQL 连接超时和读取超时"></a>MySQL 连接超时和读取超时</h4><p>MySQL的超时时间可以通过连接MySQL的url参数来指定，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:<span class="comment">//127.0.0.1:3306/test?connectTimeout=10000&amp;socketTimeout=3000</span></span><br></pre></td></tr></table></figure>
<p>connectTimeout 连接超时时间，单位为毫秒，默认值为0，依赖OS设置。</p>
<p>socketTimeout 读写超时时间，单位为毫秒，默认值为0。</p>
<h4 id="java-jdbc-Statement-超时时间"><a href="#java-jdbc-Statement-超时时间" class="headerlink" title="java.jdbc.Statement 超时时间"></a>java.jdbc.Statement 超时时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setQueryTimeout</span><span class="params">(<span class="keyword">int</span> seconds)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>
<p>设置数据库驱动等待Statement执行的超时时间，默认是0，表示永不超时。如果超时会抛出<code>SQLTimeoutException</code>异常。</p>
<p>在MySQL的驱动实现中，通过一个定时器来检查SQL执行超时，如果超时则通过一个新的连接给MySQL发送<code>kill query</code>命令，并抛出一个异常告诉客户端SQL执行超时。</p>
<h4 id="事务超时时间"><a href="#事务超时时间" class="headerlink" title="事务超时时间"></a>事务超时时间</h4><p>事务超时通常是基于我们使用的事物框架来设置的。我们通常使用的是Spring提供的事物管理器。</p>
<p>AbstractPlatformTransactionManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Specify the default timeout that this transaction manager should apply</span></span><br><span class="line"><span class="comment">	 * if there is no timeout specified at the transaction level, in seconds.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Default is the underlying transaction infrastructure's default timeout,</span></span><br><span class="line"><span class="comment">	 * e.g. typically 30 seconds in case of a JTA provider, indicated by the</span></span><br><span class="line"><span class="comment">	 * &lt;code&gt;TransactionDefinition.TIMEOUT_DEFAULT&lt;/code&gt; value.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.transaction.TransactionDefinition#TIMEOUT_DEFAULT</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDefaultTimeout</span><span class="params">(<span class="keyword">int</span> defaultTimeout)</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">if</span> (defaultTimeout &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">truetruetrue<span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid default timeout"</span>, defaultTimeout);</span><br><span class="line">truetrue&#125;</span><br><span class="line">truetrue<span class="keyword">this</span>.defaultTimeout = defaultTimeout;</span><br><span class="line">true&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，没有设置事务超时时间。 </p>
<h5 id="spring实现超时"><a href="#spring实现超时" class="headerlink" title="spring实现超时"></a>spring实现超时</h5><ol>
<li>根据timeout+当前时间点 赋值给一个deadLine。</li>
<li>每一次执行sql，就会获取到一个statement时，计算liveTime =（deadline- 当前时间），分如下两种情况处理：<ol>
<li>如果liveTime&gt;0，此时就执行stam</li>
<li>如果liveTime &lt; 0,此时就抛出异常</li>
</ol>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/eefe3877650f" target="_blank" rel="noopener">mac下的iptables—pfctl</a><br><a href="https://blog.scottlowe.org/2013/05/15/using-pf-on-os-x-mountain-lion/" target="_blank" rel="noopener">Using pf on OS X Mountain Lion</a><br><a href="https://krypted.com/mac-security/a-cheat-sheet-for-using-pf-in-os-x-lion-and-up/" target="_blank" rel="noopener">A Cheat Sheet For Using pf in OS X Lion and Up</a><br><a href="http://willbryant.net/overriding_the_default_linux_kernel_20_second_tcp_socket_connect_timeout" target="_blank" rel="noopener">Overriding the default Linux kernel 20-second TCP socket connect timeout</a><br><a href="http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/" target="_blank" rel="noopener">聊一聊重传次数</a><br><a href="https://www.cnblogs.com/lshs/p/6038527.html" target="_blank" rel="noopener">TCP系列12—重传—2、Linux超时重传引入示例</a><br><a href="https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-configuration-properties.html" target="_blank" rel="noopener">Configuration Properties for Connector/J</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;有经验的开发同学都知道访问依赖的服务服务时需要设置超时时间。这些外部服务可能是一个http接口，RPC接口，获取分布式锁等等。没有合理的超时
    
    </summary>
    
    
      <category term="网络" scheme="https://leokongwq.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>java 总的内存映射</title>
    <link href="https://leokongwq.github.io/2019/09/12/java-mmap.html"/>
    <id>https://leokongwq.github.io/2019/09/12/java-mmap.html</id>
    <published>2019-09-12T14:57:50.000Z</published>
    <updated>2019-09-14T03:56:56.705Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在阅读公司内部扩展的RocketMQ中延迟消息的实现代码，其中使用到了一个组件<code>MappedFile</code>。<code>MappedFile</code>就代表了一个mmap的文件。其实在很早前就了解到RMQ实现用使用了mmap技术，但是一直没有深入了解，借此机会就将Java中mmap的内容进行一次总结。</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p> <code>mmap</code>是一个系统调用。它的作用是将一个文件或者其它对象的一部分内容映射到进程的地址空间。这样进程就可以直接读写这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间。通过<code>mmap</code>也可以实现不同进程间的共享内存。</p>
 <a id="more"></a>
<h3 id="Java中如何使用mmap"><a href="#Java中如何使用mmap" class="headerlink" title="Java中如何使用mmap"></a>Java中如何使用mmap</h3><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEN_MB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    RandomAccessFile  raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/Users/jiexiu/a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    MappedByteBuffer mappedByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, TEN_MB);</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FileChannel-map方法详解"><a href="#FileChannel-map方法详解" class="headerlink" title="FileChannel.map方法详解"></a><code>FileChannel.map</code>方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>将FileChannle对于的文件的一部分直接映射到内存。（这里的内存是堆外内存）</li>
<li>映射模式可以是<code>MapMode.READ_ONLY</code>(只读)，<code>MapMode.READ_WRITE</code>(读写)，<code>MapMode.PRIVATE</code>（私有，写时复制）</li>
<li>如果是只读模式映射，那么文件通道必须是以只读模式打开。</li>
<li>方法返回的<code>MappedByteBuffer</code>的<code>position</code>是0，<code>limit</code> 和 <code>capacity</code>的值是参数<code>size</code>的值。</li>
<li>一旦映射完成，那么该<code>MappedByteBuffer</code>就和创建它的<code>FileChannel</code>无关。关闭<code>FileChannel</code>不会影响该<code>MappedByteBuffer</code>。</li>
<li>该方法的底层实现依赖于具体操作系统中mmap系统调用的实现逻辑。不同的操作系统可能表现不同。例如：程序修改了<code>MappedByteBuffer</code>的内容，操作系统何时将变更写入到磁盘，这个是不确定的。</li>
<li>对大多数操作系统来说该方法都是一个昂贵的操作，如果仅仅是映射很小范围，那么不建议使用。针对大文件推荐使用该操作。</li>
</ol>
<h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p><code>MappedByteBuffer</code>本质上是一块对外内存，也就是<code>DirectByteBuffer</code>。通过<code>FileChannel.map</code>来创建，直到被GC才结束它的生命。</p>
<p>它有两个非常重要的方法，分别是<code>load</code>和<code>force</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载该缓存的内容到物理内存中。这是因为mapp完成后，OS并没有直接读取文件的内容，当真正要访问的时候，通过缺页异常来进行读磁盘操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>force 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 强制将修改后的的内容写入到存储设备上。</span></span><br><span class="line"><span class="comment"> * 需要注意的是：如果是本地设备，那么该方法返回时，确保自从该缓存区创建后或该方法最后一次调用后，变更的内容一定写入了设备，如果是网络文件则没有该保证。</span></span><br><span class="line"><span class="comment"> * 如果不是通过`MapMode.READ_WRITE`模式映射的，调用该方法没有任何影响。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> MappedByteBuffer <span class="title">force</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于force方法多说一点：即使我们不手动调动该方法写缓存区的更改写入底层设备，操作系统底层也会定时将变更的脏页刷到设备上，不过时间不确定。</p>
<p>MappedByteBuffer 在我们关闭FileChannel和文件后如果还没有被GC，那么对于的文件也是无法删除的，因为底层的文件句柄还没有释放。在RocketMQ中有专门针对该问题编写的代码。具体如下：</p>
<figure class="highlight java"><figcaption><span>MappedFile.clean</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(<span class="keyword">final</span> ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="keyword">null</span> || !buffer.isDirect() || buffer.capacity() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    invoke(invoke(viewed(buffer), <span class="string">"cleaner"</span>), <span class="string">"clean"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用是获取<code>DirectByteBuffer</code>中的<code>Cleaner</code>，然后调用它的<code>clean</code>方法来回收该<code>DirectByteBuffer</code>，也就是<code>MappedByteBuffer</code>。</p>
<p><code>Cleaner</code>底层是通过<code>unsafe.freeMemory(address);</code>来释放内存的。</p>
<h3 id="题外话-如何创建指定大小的文件"><a href="#题外话-如何创建指定大小的文件" class="headerlink" title="题外话 - 如何创建指定大小的文件"></a>题外话 - 如何创建指定大小的文件</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile  raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/Users/jiexiu/a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">raf.setLength(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>); <span class="comment">// 10M</span></span><br><span class="line">raf.close()</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    fos.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=hello.txt bs=100M count=1</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnkirito.moe/file-io-best-practise/" target="_blank" rel="noopener">文件IO操作的一些最佳实践</a><br><a href="https://how2playlife.com/2018/05/27/Javanet8/" target="_blank" rel="noopener">Java网络编程与NIO详解8：浅析mmap和Direct Buffer</a><br><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析mmap：是什么 为什么 怎么用</a><br><a href="https://blog.csdn.net/aitangyong/article/details/39455229" target="_blank" rel="noopener">使用sun.misc.Cleaner或者PhantomReference实现堆外内存的自动释放</a><br><a href="https://how2playlife.com/2018/05/27/Javanet8/" target="_blank" rel="noopener">Java网络编程与NIO详解8：浅析mmap和Direct Buffer</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近在阅读公司内部扩展的RocketMQ中延迟消息的实现代码，其中使用到了一个组件&lt;code&gt;MappedFile&lt;/code&gt;。&lt;code&gt;MappedFile&lt;/code&gt;就代表了一个mmap的文件。其实在很早前就了解到RMQ实现用使用了mmap技术，但是一直没有深入了解，借此机会就将Java中mmap的内容进行一次总结。&lt;/p&gt;
&lt;h3 id=&quot;mmap&quot;&gt;&lt;a href=&quot;#mmap&quot; class=&quot;headerlink&quot; title=&quot;mmap&quot;&gt;&lt;/a&gt;mmap&lt;/h3&gt;&lt;p&gt; &lt;code&gt;mmap&lt;/code&gt;是一个系统调用。它的作用是将一个文件或者其它对象的一部分内容映射到进程的地址空间。这样进程就可以直接读写这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间。通过&lt;code&gt;mmap&lt;/code&gt;也可以实现不同进程间的共享内存。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mmap" scheme="https://leokongwq.github.io/tags/mmap/"/>
    
      <category term="RMQ" scheme="https://leokongwq.github.io/tags/RMQ/"/>
    
  </entry>
  
  <entry>
    <title>springboot配置activemq</title>
    <link href="https://leokongwq.github.io/2019/08/28/springboot-jms.html"/>
    <id>https://leokongwq.github.io/2019/08/28/springboot-jms.html</id>
    <published>2019-08-28T12:09:19.000Z</published>
    <updated>2019-08-28T13:54:24.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>网上有好多介绍springboot集成activemq的文章，看了一些文章感觉比较零散，还是抽时间自己详细总结一个如何使用，需要注意哪些点。尤其是关于连接池的配置，需要重点关注，否则在消息量大的情况下会把服务器搞挂。</p>
<h3 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h3><p>如果你只是连接一个activemq集群或节点，那么配置非常简单(这也是springboot便捷的原因)。</p>
<p>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp:<span class="comment">//127.0.0.1:61616?connectionTimeout=3000&amp;soTimeout=500&amp;tcpNoDelay=true&amp;jms.redeliveryPolicy.maximumRedeliveries=1&amp;jms.redeliveryPolicy.initialRedeliveryDelay=10</span></span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br></pre></td></tr></table></figure>
<p>就这么简单！有了上面的配置你就可以发送消息了(通过JmsTemplate)。这背后的原理是通过springboot提供的<code>ActiveMQAutoConfiguration</code>来实现的。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(JmsAutoConfiguration.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; JndiConnectionFactoryAutoConfiguration.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; ConnectionFactory.class, ActiveMQConnectionFactory.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(ConnectionFactory.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ActiveMQProperties.class)</span><br><span class="line"><span class="meta">@Import</span>(&#123; ActiveMQXAConnectionFactoryConfiguration.class,</span><br><span class="line">truetrueActiveMQConnectionFactoryConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>ActiveMQAutoConfiguration</code>的代码能得知，只要你的classpath里面存在<code>ConnectionFactory.class和ActiveMQConnectionFactory.class</code> 并且容器里面没有类型为<code>ConnectionFactory.class</code>的Bean，那么该自动配置组件就会生效。</p>
<p>通过<code>ActiveMQAutoConfiguration</code>，我们在spring容器中就能自动获取一个类型为<code>ConnectionFactory.class</code>的Bean 和 <code>JmsTemplate.class</code>的Bean。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@ActiveProfiles</span>(profiles = &#123;<span class="string">"dev"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSendAmqMsg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMsgDefault</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        jmsTemplate.convertAndSend(<span class="string">"java"</span>);</span><br><span class="line">        <span class="comment">//等待消费，因为是自发自消费</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码其实是不能正常工作的。原因是<code>jmsTemplate.convertAndSend</code>没有指定<code>Destination</code>。</p>
<p><code>Destination</code>的指定有两种方式，一种是通过方法参数指定。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmsTemplate.convertAndSend(<span class="string">"hello-jms-queue"</span>, <span class="string">"java"</span>);</span><br></pre></td></tr></table></figure>
<p>一种是通过在application.properties文件中指定一个默认值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.template.<span class="keyword">default</span>-destination=hello-jms-<span class="keyword">default</span></span><br></pre></td></tr></table></figure>
<p>还有一点需要注意的是<code>Destination</code>类型，是Topic还是Queue。默认是Queue。<code>Destination</code>类型也可以通过两种方式设置。</p>
<p>一种是通过在application.properties文件中指定一个默认值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># false 表示是Queue</span><br><span class="line">spring.jms.pub-sub-domain=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>一种是通过API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmsTemplate.setPubSubDomain(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：上面的例子虽然能实现消息的发送和接收，但是非常有局限性。一个ActiveMQ上既有Topic也有Queue，我们通过<code>JmsTemplate</code>发送和消费消息时，最好是通过参数<code>Destination</code>来指定目的地，热不是一个字符串(不知道是具体是什么类型，只能通过全局配置)。</p>
</blockquote>
<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><p>有了上面的配置，我们可以有两种消费消息的方式。</p>
<ol>
<li>通过<code>JmsTemplate</code>的API来主动消费。这个就不详细讲了。</li>
<li>通过<code>@JmsListener</code>来被动消费</li>
</ol>
<p>通过<code>@JmsListener</code>来实现消息消费，配置如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener</span>(containerFactory = <span class="string">"jmsListenerContainerFactory"</span>, destination = <span class="string">"hello-jms"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"############# Received message is : ["</span> + msg + <span class="string">"]*************"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableJms</code>的作用是启用spring的Jms的注解驱动能力。注册了<code>JmsListenerAnnotationBeanPostProcessor</code>Bean。原理如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(JmsBootstrapConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableJms &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsBootstrapConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = JmsListenerConfigUtils.JMS_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JmsListenerAnnotationBeanPostProcessor <span class="title">jmsListenerAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">new</span> JmsListenerAnnotationBeanPostProcessor();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span>(name = JmsListenerConfigUtils.JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> JmsListenerEndpointRegistry <span class="title">defaultJmsListenerEndpointRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrue<span class="keyword">return</span> <span class="keyword">new</span> JmsListenerEndpointRegistry();</span><br><span class="line">true&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JmsAnnotationDrivenConfiguration</code>该配置类非常关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EnableJms.class)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JmsAnnotationDrivenConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactoryConfigurer <span class="title">jmsListenerContainerFactoryConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	DefaultJmsListenerContainerFactoryConfigurer configurer = <span class="keyword">new</span> DefaultJmsListenerContainerFactoryConfigurer();</span><br><span class="line">        	configurer.setDestinationResolver(<span class="keyword">this</span>.destinationResolver.getIfUnique());</span><br><span class="line">        	configurer.setTransactionManager(<span class="keyword">this</span>.transactionManager.getIfUnique());</span><br><span class="line">        	configurer.setMessageConverter(<span class="keyword">this</span>.messageConverter.getIfUnique());</span><br><span class="line">        	configurer.setJmsProperties(<span class="keyword">this</span>.properties);</span><br><span class="line">        	<span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span></span><br><span class="line">true<span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"jmsListenerContainerFactory"</span>)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">jmsListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			DefaultJmsListenerContainerFactoryConfigurer configurer,</span></span></span><br><span class="line"><span class="function"><span class="params">			ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">truetrueDefaultJmsListenerContainerFactory factory = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">truetrueconfigurer.configure(factory, connectionFactory);</span><br><span class="line">truetrue<span class="keyword">return</span> factory;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置JmsTemplate属性"><a href="#配置JmsTemplate属性" class="headerlink" title="配置JmsTemplate属性"></a>配置JmsTemplate属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.jms.template.<span class="keyword">default</span>-destination=hello-jms-<span class="keyword">default</span></span><br><span class="line">spring.jms.template.delivery-mode=non_persistent</span><br><span class="line">spring.jms.template.priority=<span class="number">100</span></span><br><span class="line">spring.jms.template.qos-enabled=<span class="keyword">true</span></span><br><span class="line">spring.jms.template.time-to-live=<span class="number">50</span></span><br><span class="line"># 设置消息延迟投递时间 需要jms 2.0 支持</span><br><span class="line">#spring.jms.template.delivery-delay=1</span><br><span class="line">spring.jms.template.receive-timeout=<span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="配置消费属性"><a href="#配置消费属性" class="headerlink" title="配置消费属性"></a>配置消费属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 消息消费</span><br><span class="line">spring.jms.listener.acknowledge-mode=client</span><br><span class="line">spring.jms.listener.auto-startup=<span class="keyword">true</span></span><br><span class="line">spring.jms.listener.concurrency=<span class="number">10</span></span><br><span class="line">spring.jms.listener.max-concurrency=<span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h3><p>通过上面的学习，我们已经能实现消息的发送和消费了。但是有一个问题就是，我们会和ActiveMQ Broker建立大量的短连接。在高并发下肯定是不可以的。通过在<code>application.properties</code>中简单配置，我们就能获得连接池能力。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-pool<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.14.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 只有配置了该选项，才会启用activemq连接池功能，参见：ActiveMQConnectionFactoryConfiguration</span><br><span class="line">spring.activemq.pool.enabled=<span class="keyword">true</span></span><br><span class="line"># 配置连接池参数</span><br><span class="line">spring.activemq.pool.configuration.max-connections=<span class="number">10</span></span><br><span class="line">spring.activemq.pool.configuration.idle-timeout=<span class="number">30000</span></span><br><span class="line">spring.activemq.pool.configuration.expiry-timeout=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">spring.activemq.pool.configuration.create-connection-on-startup=<span class="keyword">false</span></span><br><span class="line">spring.activemq.pool.configuration.time-between-expiration-check-millis=<span class="number">60000</span></span><br><span class="line">spring.activemq.pool.configuration.maximum-active-session-per-connection=<span class="number">100</span></span><br><span class="line">spring.activemq.pool.configuration.reconnect-on-exception=<span class="keyword">true</span></span><br><span class="line">spring.activemq.pool.configuration.block-<span class="keyword">if</span>-session-pool-is-full=<span class="keyword">true</span></span><br><span class="line">spring.activemq.pool.configuration.block-<span class="keyword">if</span>-session-pool-is-full-timeout=<span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h4 id="连接池自动配置实现原理"><a href="#连接池自动配置实现原理" class="headerlink" title="连接池自动配置实现原理"></a>连接池自动配置实现原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(PooledConnectionFactory.class)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledConnectionFactoryConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="meta">@Bean</span>(destroyMethod = <span class="string">"stop"</span>)</span><br><span class="line">true<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.activemq.pool"</span>, name = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">true<span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.activemq.pool.configuration"</span>)</span><br><span class="line">true<span class="function"><span class="keyword">public</span> PooledConnectionFactory <span class="title">pooledJmsConnectionFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ActiveMQProperties properties)</span> </span>&#123;</span><br><span class="line">truetruePooledConnectionFactory pooledConnectionFactory = <span class="keyword">new</span> PooledConnectionFactory(</span><br><span class="line">truetruetruetrue<span class="keyword">new</span> ActiveMQConnectionFactoryFactory(properties)</span><br><span class="line">truetruetruetruetruetrue.createConnectionFactory(ActiveMQConnectionFactory.class));</span><br><span class="line"></span><br><span class="line">truetrueActiveMQProperties.Pool pool = properties.getPool();</span><br><span class="line">truetruepooledConnectionFactory.setMaxConnections(pool.getMaxConnections());</span><br><span class="line">truetruepooledConnectionFactory.setIdleTimeout(pool.getIdleTimeout());</span><br><span class="line">truetruepooledConnectionFactory.setExpiryTimeout(pool.getExpiryTimeout());</span><br><span class="line">truetrue<span class="keyword">return</span> pooledConnectionFactory;</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个实现作为参考，如果我们不想使用springboot提供的<code>ActiveMQ</code>自动配置功能，我们自己写代码配置，也能实现连接池的功能，无非就是普通的<code>ActiveMQConnectionFactoryFactory</code>进行包装而已。</p>
<p>有一个细节需要注意：前置为<code>spring.activemq.pool.configuration</code>的配置属性是如何设置到<code>PooledConnectionFactory</code>的呢？但是是通过<code>ConfigurationPropertiesBindingPostProcessor</code> 该类会处理注解<code>ConfigurationProperties</code> 指定的属性，通过反射设置到生成的Bean中（在Bean初始化前）。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相关代码地址:<a href="https://github.com/leokongwq/springboot-learn" target="_blank" rel="noopener">springboot-learn</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;网上有好多介绍springboot集成activemq的文章，看了一些文章感觉比较零散，还是抽时间自己详细总结一个如何使用，需要注意哪些点。尤其是关于连接池的配置，需要重点关注，否则在消息量大的情况下会把服务器搞挂。&lt;/p&gt;
&lt;h3 id=&quot;快速配置&quot;&gt;&lt;a href=&quot;#快速配置&quot; class=&quot;headerlink&quot; title=&quot;快速配置&quot;&gt;&lt;/a&gt;快速配置&lt;/h3&gt;&lt;p&gt;如果你只是连接一个activemq集群或节点，那么配置非常简单(这也是springboot便捷的原因)。&lt;/p&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.broker-url=tcp:&lt;span class=&quot;comment&quot;&gt;//127.0.0.1:61616?connectionTimeout=3000&amp;amp;soTimeout=500&amp;amp;tcpNoDelay=true&amp;amp;jms.redeliveryPolicy.maximumRedeliveries=1&amp;amp;jms.redeliveryPolicy.initialRedeliveryDelay=10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.user=admin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;spring.activemq.password=admin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就这么简单！有了上面的配置你就可以发送消息了(通过JmsTemplate)。这背后的原理是通过springboot提供的&lt;code&gt;ActiveMQAutoConfiguration&lt;/code&gt;来实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="activemq" scheme="https://leokongwq.github.io/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>java agent技术学习总结</title>
    <link href="https://leokongwq.github.io/2019/08/25/java-agent-summary.html"/>
    <id>https://leokongwq.github.io/2019/08/25/java-agent-summary.html</id>
    <published>2019-08-25T13:18:49.000Z</published>
    <updated>2019-08-25T14:17:43.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>JVMDI：jvm debug interface jvm 调试接口。<br>JVMPI：jvm profile interface jvm 性能分析接口。<br>JVMTI：jvm tool interface jvm 工具接口，jdk1.5引入，用来替换JVMDI和JVMPI。</p>
<h3 id="JPDA"><a href="#JPDA" class="headerlink" title="JPDA"></a>JPDA</h3><p>JPDA： <a href="http://java.sun.com/products/jpda/" target="_blank" rel="noopener">Java Platform Debugger Architecture</a> SUN 公司提供的让你在各种场景加调试运行中的Java程序的技术。</p>
<h4 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h4><ol>
<li>JPDA 是一组帮助调试Java程序的API集合。</li>
<li>JPDA 不是一个应用程序或调试工具。</li>
<li>JPDA 是一组精心设计和实现的接口和协议。</li>
<li>debugger 调试程序</li>
<li>debuggee 被调试程序</li>
</ol>
<h3 id="JPDA-构成"><a href="#JPDA-构成" class="headerlink" title="JPDA 构成"></a>JPDA 构成</h3><p>JPDA 由三大部分组成：</p>
<ol>
<li>JVMTI（Java Virtual Machine Tools Interface） JVMTI 定义了一个VM必须提供的调试服务。</li>
<li>JDWP（The Java Debug Wire Protocol）JDWP 定义了调试程序和被调试程序间的交互协议。 </li>
<li>JDI (Java Debug Interface) JDI在用户代码级别定义调试信息和调试请求。</li>
</ol>
<p>JPAD 架构</p>
<img src="/2019/08/25/java-agent-summary/jpda.gif">
<p>debugger 和 debuggee 之间的通讯通道由两部分组成：</p>
<ol>
<li>连接器 connector。 一个 connector 是一个 JDI 对象，表示debugger 和 debuggee之间建立的连接。JPDA 定义了debugger 和 debuggee 之间有三种连接方式：<ul>
<li>listening: debugger 监听由debuggee发送的连接请求。</li>
<li>attaching: debugger 连接到运行中debuggee上，然后进行调试数据的传输。这是使用最多的方式。</li>
<li>launching: The front-end actually launches the Java process that will run the debuggee code and the back-end.</li>
</ul>
</li>
<li>传输通道 transport。 一个 transport 定义了debugger和debuggee底层之间交换数据的方式。<br>该数据传输机制规范没有规定，可选的机制有:socket, 串口，共享内存或其他方式。 但是传输的数据格式是由JDWP规定好的。</li>
</ol>
<h3 id="JPDA-使用"><a href="#JPDA-使用" class="headerlink" title="JPDA 使用"></a>JPDA 使用</h3><p>使用JPDA，需要在JVM命令行添加如下格式的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=&lt;name1&gt;[=&lt;value1&gt;],&lt;name2&gt;[=&lt;value2&gt;]</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">-Xrunjdwp:&lt;name1&gt;[=&lt;value1&gt;],&lt;name2&gt;[=&lt;value2&gt;]</span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentlib:jdwp=transport=dt_socket,server=y,address=<span class="number">8000</span></span><br></pre></td></tr></table></figure>
<h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><ul>
<li>help: 输出详细的使用信息</li>
<li>transport: 一般都是用 dt_socket。</li>
<li>server: 参数值是<code>y</code>或<code>n</code>。如果设置为<code>y</code>，则等待debugger程序来连接。否则，连接到特定地址的debugger程序。</li>
<li>address: 连接的传输地址。如果<code>server</code>参数设置为<code>n</code>，则该地址为debugger的地址。如果<code>server</code>参数设置为<code>y</code>，则在改地址等待dubugger连接。</li>
<li>timeout: 连接超时的时间，单位为毫秒。</li>
<li>suspend: 如何设置为<code>y</code>，则JVM挂起执行流程，知道dubugger连接到该debuggee JVM。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.techrepublic.com/article/debug-your-java-code-with-ease-using-jpda/" target="_blank" rel="noopener">debug-your-java-code-with-ease-using-jpda</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/" target="_blank" rel="noopener">jpda</a><br><a href="http://www.fanyilun.me/2017/07/18/%E8%B0%88%E8%B0%88Java%20Intrumentation%E5%92%8C%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">谈谈Java Intrumentation和相关应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h3&gt;&lt;p&gt;JVMDI：jvm debug interface jvm 调试接口。&lt;br&gt;JVMPI：jvm profile inter
    
    </summary>
    
      <category term="java" scheme="https://leokongwq.github.io/categories/java/"/>
    
    
      <category term="java agent" scheme="https://leokongwq.github.io/tags/java-agent/"/>
    
  </entry>
  
  <entry>
    <title>hystrix学习总结</title>
    <link href="https://leokongwq.github.io/2019/08/10/hystrix-summary.html"/>
    <id>https://leokongwq.github.io/2019/08/10/hystrix-summary.html</id>
    <published>2019-08-10T11:36:33.000Z</published>
    <updated>2019-08-25T13:10:50.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hystrix是什么？"><a href="#hystrix是什么？" class="headerlink" title="hystrix是什么？"></a>hystrix是什么？</h3><p>官网对hystrix的定义如下：</p>
<blockquote>
<p>Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.</p>
</blockquote>
<p>个人理解如下：</p>
<ol>
<li>首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。</li>
<li>Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。</li>
</ol>
<a id="more"></a>
<h3 id="hystrix基本用法"><a href="#hystrix基本用法" class="headerlink" title="hystrix基本用法"></a>hystrix基本用法</h3><h4 id="HystrixCommand"><a href="#HystrixCommand" class="headerlink" title="HystrixCommand"></a>HystrixCommand</h4><p>使用Hystrix最简单直接的方式就是继承<code>HystrixCommand</code>对象并复写<code>run</code>方法。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂方法HystrixCommandGroupKey.Factory.asKey</span></span><br><span class="line">        <span class="comment">// 指定CommandGroup的名称</span></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">"!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意只有非 HystrixBadRequestException 才会触发fallback    </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fallback: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).execute();</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; result = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从名字也能看出来，需要在返回值上注册一个观察者来获取结果</span></span><br><span class="line">Observable&lt;String&gt; observable = <span class="keyword">new</span> HelloWorldCommand(<span class="string">"jiexiu"</span>).observe();</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">Observable&lt;String&gt; stringObservable1 = helloWorldCommand.toObservable();</span><br><span class="line"><span class="comment">// 注册观察者 获取结果</span></span><br><span class="line"><span class="comment">// 先执行onNext再执行onCompleted</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"onNext: "</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">truetrue</span><br><span class="line"><span class="comment">// 只有成功才会被回调</span></span><br><span class="line">observable.subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">true<span class="comment">// 相当于上面的onNext()</span></span><br><span class="line">true<span class="comment">// @Override</span></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String v)</span> </span>&#123;</span><br><span class="line">truetrueSystem.out.println(<span class="string">"call: "</span> + v);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>execute</code>方法用来同步获取执行结果（内部还是通过线程池异步执行）内部逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue().get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exceptions.sneakyThrow(decomposeException(e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>queue</code> 通过返回一个<code>Future</code>来异步获取结果。</p>
<p><code>observe和toObservable</code> 通过返回一个<code>Observable</code>, 需要用户注册一个回调来接收调用结果。</p>
<p><code>observe</code> 和 <code>toObservable</code>的区别是：observe 在注册回调前就已经执行服务调用，toObservable是在注册回调后才开始执行。</p>
<h4 id="HystrixObservableCommand"><a href="#HystrixObservableCommand" class="headerlink" title="HystrixObservableCommand"></a>HystrixObservableCommand</h4><p>HystrixObservableCommand 和 HystrixCommand 功能是相同的。不过HystrixObservableCommand的定位是用在全异步的环境下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloHystrixObservableCommand</span> <span class="keyword">extends</span> <span class="title">HystrixObservableCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloHystrixObservableCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"HelloHystrixObservableCommand"</span>));</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Observable&lt;String&gt; <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return Observable.just("1", "2", "3");</span></span><br><span class="line"><span class="comment">//        return Observable.just("Hello " + name);</span></span><br><span class="line"><span class="comment">//        return Observable.from(new String[]&#123;"1", "2"&#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// OnSubscribe 是一个Callback， 当 Observable被注册的时候会被执行</span></span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//remote http call</span></span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 写业务逻辑，注意try-catch</span></span><br><span class="line">                    <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">                        String result = restTemplate.getForObject(<span class="string">"http://www.jiexiu.com"</span>, String.class);</span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        subscriber.onNext(result);</span><br><span class="line">                        subscriber.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    subscriber.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * fallback </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">resumeWithFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; observer)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!observer.isUnsubscribed()) &#123;</span><br><span class="line">                        observer.onNext(<span class="string">"fallback-jiexiu"</span>);</span><br><span class="line">                        observer.onCompleted();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    observer.onError(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        HelloHystrixObservableCommand observableCommand =</span><br><span class="line">                <span class="keyword">new</span> HelloHystrixObservableCommand(<span class="string">"jiexiu"</span>);</span><br><span class="line">        Observable&lt;String&gt; observable = observableCommand.construct();</span><br><span class="line">        observable.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h3><p>Hystrix中实现优雅降级有2中方式：</p>
<ol>
<li>通过在HystrixCommand中添加<code>getFallback</code>方法</li>
<li>通过在HystrixObservableCommand中添加<code>resumeWithFallback</code>方法</li>
</ol>
<h4 id="fallback-触发时机"><a href="#fallback-触发时机" class="headerlink" title="fallback 触发时机"></a>fallback 触发时机</h4><ol>
<li>run方法或construct方法执行异常（非HystrixBadRequestException异常）。</li>
<li>run方法或construct方法超时</li>
<li>线程池满了或信号量为空</li>
<li>断路器处于打开状态</li>
</ol>
<p>注意: run方法抛出的所有异常中除了<code>HystrixBadRequestException</code>异常外都会被记录为失败，触发fallback，更新断路器统计信息。</p>
<h3 id="Hystrix-隔离机制"><a href="#Hystrix-隔离机制" class="headerlink" title="Hystrix 隔离机制"></a>Hystrix 隔离机制</h3><p>Hystrix有2中实现请求故障隔离的机制。一种是利用线程池，一种是使用信号量，默认是使用线程池。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super(HystrixCommandGroupKey.Factory.asKey("ExampleGroup"));</span></span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">            .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">            .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-ThreadPool"</span>))</span><br><span class="line">            .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()</span><br><span class="line">                    .withCoreSize(<span class="number">5</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withMaximumSize(<span class="number">10</span>) <span class="comment">//默认是10</span></span><br><span class="line">                    .withKeepAliveTimeMinutes(<span class="number">5</span>) <span class="comment">//默认是1，单位为分钟</span></span><br><span class="line">                    .withMaxQueueSize(<span class="number">100</span>) <span class="comment">// 默认是-1, 意味着底层使用 SynchronousQueue, 该属性不能动态修改</span></span><br><span class="line">                    .withQueueSizeRejectionThreshold(<span class="number">80</span>)</span><br><span class="line">            )</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                    .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line"></span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程池机制很容易理解，不同的HystrixCommandGroup底层使用不同的线程池，彼此不干扰。<br>可以通过<code>andThreadPoolKey</code>配置了线程池的名称。如果没有通过<code>andThreadPoolKey</code>来设置线程池的名称，默认使用<code>withGroupKey</code>设置的名称。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloWorldCommand</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">                .andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"helloWorld"</span>))</span><br><span class="line">                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ExampleGroup-Semaphore-ThreadPool"</span>))</span><br><span class="line">                .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                        .withExecutionTimeoutInMilliseconds(<span class="number">3000</span>) <span class="comment">//默认是1s</span></span><br><span class="line">                        .withCircuitBreakerEnabled(<span class="keyword">true</span>) <span class="comment">//默认是true</span></span><br><span class="line">                        .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE)</span><br><span class="line">                        .withExecutionIsolationSemaphoreMaxConcurrentRequests(<span class="number">3</span>) </span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                        .withFallbackIsolationSemaphoreMaxConcurrentRequests(<span class="number">1</span>)</span><br><span class="line">                        <span class="comment">//默认值10</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="熔断器-CircuitBreaker"><a href="#熔断器-CircuitBreaker" class="headerlink" title="熔断器 CircuitBreaker"></a>熔断器 CircuitBreaker</h3><p>通常有2</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>HystrixCommandGroupKey 需要指定，用来将不同的HystrixCommand组织起来</p>
<p>HystrixCommandKey 的默认值是 Command的类名称(不带包名)，也可以单独指定。</p>
<p>HystrixThreadPoolKey 的默认值是 HystrixCommandGroupKey。但是建议手动指定HystrixCommand执行的<code>HystrixThreadPool</code>的名称。因为同属一个Group下的Command可能需要在不同的<code>HystrixThreadPool</code>中隔离执行。</p>
<p>在fallback的处理中，如果需要调用一个远程服务获取值(e.g. 查询缓存) 那么最好使用单独的线程池来执行，否则可能由于主Command的执行线程池已经满了导致fallback不能正常工作。</p>
<img src="/2019/08/10/hystrix-summary/fallback-via-command-640.png">
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hystrix是什么？&quot;&gt;&lt;a href=&quot;#hystrix是什么？&quot; class=&quot;headerlink&quot; title=&quot;hystrix是什么？&quot;&gt;&lt;/a&gt;hystrix是什么？&lt;/h3&gt;&lt;p&gt;官网对hystrix的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hystrix is a latency and fault tolerance library designed to isolate points of access to remote systems, services and 3rd party libraries, stop cascading failure and enable resilience in complex distributed systems where failure is inevitable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人理解如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先 Hystrix 只是一个库，意味着非常容易使用，通过maven或gradle引入即可。&lt;/li&gt;
&lt;li&gt;Hystrix 的目的是在访问远程系统，服务或使用第三方库的时候由于网络故障，延迟或其他错误可能导致的系统级联故障的点进行隔离。从而使得整个分布式系统具有弹性和容错能力。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hystrix" scheme="https://leokongwq.github.io/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>spring SpEL表达式</title>
    <link href="https://leokongwq.github.io/2019/04/17/spring-spel.html"/>
    <id>https://leokongwq.github.io/2019/04/17/spring-spel.html</id>
    <published>2019-04-17T02:25:27.000Z</published>
    <updated>2019-08-02T14:46:15.687Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自：<a href="https://blog.csdn.net/zhoudaxia/article/details/38174169" target="_blank" rel="noopener">https://blog.csdn.net/zhoudaxia/article/details/38174169</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1  概述"></a>1  概述</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1  概述"></a>1.1  概述</h3><p>　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p>
<p>　　表达式语言给静态Java语言增加了动态功能。</p>
<p>　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p>
<h3 id="1-2-能干什么"><a href="#1-2-能干什么" class="headerlink" title="1.2  能干什么"></a>1.2  能干什么</h3><p>　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p>
<p>　　SpEL支持如下表达式：</p>
<p>　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；</p>
<p>　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；</p>
<p>　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；</p>
<p>　　四、其他表达式：模板表达式。</p>
<p>　　注：SpEL表达式中的关键字是不区分大小写的。</p>
<a id="more"></a>
<h2 id="2-SpEL基础"><a href="#2-SpEL基础" class="headerlink" title="2. SpEL基础"></a>2. SpEL基础</h2><h3 id="2-1-HelloWorld"><a href="#2-1-HelloWorld" class="headerlink" title="2.1  HelloWorld"></a>2.1  HelloWorld</h3><p>首先准备支持SpEL的Jar包：“org.springframework.expression-3.0.5.RELEASE.jar”将其添加到类路径中。</p>
<p>SpEL在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。</p>
<p>让我们看下代码片段吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> junit.framework.Assert;  </span><br><span class="line"><span class="keyword">import</span> org.junit.Test;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELTest</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">        Expression expression =  </span><br><span class="line">            parser.parseExpression(<span class="string">"('Hello' + ' World').concat(#end)"</span>);  </span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">        context.setVariable(<span class="string">"end"</span>, <span class="string">"!"</span>);  </span><br><span class="line">        Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue(context));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来让我们分析下代码：</p>
<ol>
<li>创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</li>
<li>解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据。</li>
<li>求值：通过Expression接口的getValue方法根据上下文获得表达式值。</li>
</ol>
<p>　　是不是很简单，接下来让我们看下其具体实现及原理吧。</p>
<h3 id="2-3-SpEL原理及接口"><a href="#2-3-SpEL原理及接口" class="headerlink" title="2.3  SpEL原理及接口"></a>2.3  SpEL原理及接口</h3><p>SpEL提供简单的接口从而简化用户使用，在介绍原理前让我们学习下几个概念：</p>
<p>一、表达式：表达式是表达式语言的核心，所以表达式语言都是围绕表达式进行的，从我们角度来看是“干什么”；</p>
<p>二、解析器：用于将字符串表达式解析为表达式对象，从我们角度来看是“谁来干”；</p>
<p>三、上下文：表达式对象执行的环境，该环境可能定义变量、定义自定义函数、提供类型转换等等，从我们角度看是“在哪干”；</p>
<p>四、根对象及活动上下文对象：根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象，从我们角度看是“对谁干”。</p>
<p>理解了这些概念后，让我们看下SpEL如何工作的呢，如图5-1所示</p>
<img src="/2019/04/17/spring-spel/20140727174757196.jpg">
<p>1）首先定义表达式：“1+2”；</p>
<p>2）定义解析器ExpressionParser实现，SpEL提供默认实现SpelExpressionParser；</p>
<p>　　2.1）SpelExpressionParser解析器内部使用Tokenizer类进行词法分析，即把字符串流分析为记号流，记号在SpEL使用Token类来表示；</p>
<p>　　2.2）有了记号流后，解析器便可根据记号流生成内部抽象语法树；在SpEL中语法树节点由SpelNode接口实现代表：如OpPlus表示加操作节点、IntLiteral表示int型字面量节点；使用SpelNodel实现组成了抽象语法树；</p>
<p>　　2.3）对外提供Expression接口来简化表示抽象语法树，从而隐藏内部实现细节，并提供getValue简单方法用于获取表达式值；SpEL提供默认实现为SpelExpression；</p>
<p>3）定义表达式上下文对象（可选），SpEL使用EvaluationContext接口表示上下文对象，用于设置根对象、自定义变量、自定义函数、类型转换器等，SpEL提供默认实现StandardEvaluationContext；</p>
<p>4）使用表达式对象根据上下文对象（可选）求值（调用表达式对象的getValue方法）获得结果。</p>
<p>接下来让我们看下SpEL的主要接口吧：</p>
<h4 id="ExpressionParser"><a href="#ExpressionParser" class="headerlink" title="ExpressionParser"></a>ExpressionParser</h4><p>ExpressionParser接口：表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpressionParser</span> </span>&#123;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString)</span></span>;  </span><br><span class="line">    <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParserContext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    ParserContext parserContext = <span class="keyword">new</span> ParserContext() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTemplate</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionPrefix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#&#123;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getExpressionSuffix</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&#125;"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;  </span><br><span class="line">    String template = <span class="string">"#&#123;'Hello '&#125;#&#123;'World!'&#125;"</span>;  </span><br><span class="line">    Expression expression = parser.parseExpression(template, parserContext);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, expression.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此我们演示的是使用ParserContext的情况，此处定义了ParserContext实现：定义表达式是模块，表达式前缀为<code>#{”，后缀为“}</code>；使用parseExpression解析时传入的模板必须以<code>#{”开头，以“}</code>结尾，如<code>#{&#39;Hello &#39;}#{&#39;World!&#39;}</code>。</p>
<p>默认传入的字符串表达式不是模板形式，如之前演示的Hello World。</p>
<h4 id="EvaluationContext"><a href="#EvaluationContext" class="headerlink" title="EvaluationContext"></a>EvaluationContext</h4><p>EvaluationContext接口：表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。</p>
<h4 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h4><p>Expression接口：表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。</p>
<p>了解了SpEL原理及接口，接下来的事情就是SpEL语法了。</p>
<h2 id="SpEL-语法"><a href="#SpEL-语法" class="headerlink" title="SpEL 语法"></a>SpEL 语法</h2><h3 id="字面量表达式："><a href="#字面量表达式：" class="headerlink" title="字面量表达式："></a>字面量表达式：</h3><p>SpEL支持的字面量包括：字符串、数字类型（int、long、float、double）、布尔类型、null类型。</p>
<p>字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = parser.parseExpression(<span class="string">"'Hello World!'"</span>).getValue(String.class);</span><br><span class="line">String str2 = parser.parseExpression(<span class="string">"\"Hello World!\""</span>).getValue(String.class);</span><br></pre></td></tr></table></figure>
<p>数字类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> int1 = parser.parseExpression(<span class="string">"1"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> long1 = parser.parseExpression(<span class="string">"-1L"</span>).getValue(<span class="keyword">long</span>.class);</span><br><span class="line"><span class="keyword">float</span> float1 = parser.parseExpression(<span class="string">"1.1"</span>).getValue(Float.class);</span><br><span class="line"><span class="keyword">double</span> double1 = parser.parseExpression(<span class="string">"1.1E+2"</span>).getValue(<span class="keyword">double</span>.class);</span><br><span class="line"><span class="keyword">int</span> hex1 = parser.parseExpression(<span class="string">"0xa"</span>).getValue(Integer.class);</span><br><span class="line"><span class="keyword">long</span> hex2 = parser.parseExpression(<span class="string">"0xaL"</span>).getValue(<span class="keyword">long</span>.class);</span><br></pre></td></tr></table></figure>
<p>boolean类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> true1 = parser.parseExpression(<span class="string">"true"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="keyword">boolean</span> false1 = parser.parseExpression(<span class="string">"false"</span>).getValue(<span class="keyword">boolean</span>.class);</span><br></pre></td></tr></table></figure>
<p>null 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object null1 = parser.parseExpression(<span class="string">"null"</span>).getValue(Object.class);</span><br></pre></td></tr></table></figure>
<h3 id="算数运算表达式"><a href="#算数运算表达式" class="headerlink" title="算数运算表达式"></a>算数运算表达式</h3><p>算数运算表达式： SpEL支持加(+)、减(-)、乘(*)、除(/)、求余（%）、幂（^）运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"1+2-3*4/2"</span>).getValue(Integer.class);<span class="comment">//-3</span></span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"4%3"</span>).getValue(Integer.class);<span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"2^3"</span>).getValue(Integer.class);<span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>　SpEL还提供求余（MOD）和除（DIV）而外两个运算符，与“%”和“/”等价，不区分大小写。</p>
</blockquote>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>关系表达式：等于（==）、不等于(!=)、大于(&gt;)、大于等于(&gt;=)、小于(&lt;)、小于等于(&lt;=)，区间（between）运算，如<code>parser.parseExpression(&quot;1&gt;2&quot;).getValue(boolean.class);</code>将返回false；而<code>parser.parseExpression(&quot;1 between {1, 2}&quot;).getValue(boolean.class);</code>将返回true。</p>
<p>between运算符右边操作数必须是列表类型，且只能包含2个元素。第一个元素为开始，第二个元素为结束，区间运算是包含边界值的，即 xxx&gt;=list.get(0) &amp;&amp; xxx&lt;=list.get(1)。</p>
<p>SpEL同样提供了等价的“EQ” 、“NE”、 “GT”、“GE”、 “LT” 、“LE”来表示等于、不等于、大于、大于等于、小于、小于等于，不区分大小写。</p>
<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>逻辑表达式：且（and）、或(or)、非(!或NOT)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String expression1 = <span class="string">"2&gt;1 and (!true or !false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result1);  </span><br><span class="line">   </span><br><span class="line">String expression2 = <span class="string">"2&gt;1 and (NOT true or NOT false)"</span>;  </span><br><span class="line"><span class="keyword">boolean</span> result2 = parser.parseExpression(expression2).getValue(<span class="keyword">boolean</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑运算符不支持 Java中的 &amp;&amp; 和 || 。</p>
</blockquote>
<h3 id="字符串连接及截取表达式"><a href="#字符串连接及截取表达式" class="headerlink" title="字符串连接及截取表达式"></a>字符串连接及截取表达式</h3><p>字符串连接及截取表达式：使用“+”进行字符串连接，使用“’String’[0] [index]”来截取一个字符，目前只支持截取一个，如“’Hello ‘ + ‘World!’”得到“Hello World!”；而“’Hello World!’[0]”将返回“H”。</p>
<h3 id="三目运算及Elivis运算表达式："><a href="#三目运算及Elivis运算表达式：" class="headerlink" title="三目运算及Elivis运算表达式："></a>三目运算及Elivis运算表达式：</h3><p>三目运算符 “表达式1?表达式2:表达式3”用于构造三目运算表达式，如“2&gt;1?true:false”将返回true；</p>
<p>Elivis运算符“表达式1?:表达式2”从Groovy语言引入用于简化三目运算符的，当表达式1为非null时则返回表达式1，当表达式1为null时则返回表达式2，简化了三目运算符方式“表达式1? 表达式1:表达式2”，如“null?:false”将返回false，而“true?:false”将返回true；</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>使用“str matches regex，如“’123’ matches ‘\d{3}’”将返回true；</p>
<h3 id="括号优先级表达式"><a href="#括号优先级表达式" class="headerlink" title="括号优先级表达式"></a>括号优先级表达式</h3><p>括号优先级表达式：使用“(表达式)”构造，括号里的具有高优先级。</p>
<h3 id="类相关表达式"><a href="#类相关表达式" class="headerlink" title="类相关表达式"></a>类相关表达式</h3><p>一、类类型表达式：使用“T(Type)”来表示java.lang.Class实例，“Type”必须是类全限定名，“java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>
<p>具体使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClassTypeExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    <span class="comment">//java.lang包类访问  </span></span><br><span class="line">    Class&lt;String&gt; result1 = parser.parseExpression(<span class="string">"T(String)"</span>).getValue(Class.class);  </span><br><span class="line">    Assert.assertEquals(String.class, result1);  </span><br><span class="line">    <span class="comment">//其他包类访问  </span></span><br><span class="line">    String expression2 = <span class="string">"T(cn.javass.spring.chapter5.SpELTest)"</span>;  </span><br><span class="line">    Class&lt;String&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);</span><br><span class="line">    Assert.assertEquals(SpELTest.class, result2);  </span><br><span class="line">    <span class="comment">//类静态字段访问  </span></span><br><span class="line">    <span class="keyword">int</span> result3=parser.parseExpression(<span class="string">"T(Integer).MAX_VALUE"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(Integer.MAX_VALUE, result3);  </span><br><span class="line">    <span class="comment">//类静态方法调用  </span></span><br><span class="line">    <span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"T(Integer).parseInt('1')"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, result4);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于java.lang包里的可以直接使用“T(String)”访问；其他包必须是类全限定名；可以进行静态字段访问如“T(Integer).MAX_VALUE”；也可以进行静态方法访问如“T(Integer).parseInt(‘1’)”。<br>　<br>二、类实例化：类实例化同样使用java关键字“new”，类名必须是全限定名，但java.lang包内的类型除外，如String、Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructorExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"new String('haha')"</span>).getValue(String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">    Date result2 = parser.parseExpression(<span class="string">"new java.util.Date()"</span>).getValue(Date.class);  </span><br><span class="line">    Assert.assertNotNull(result2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化完全跟Java内方式一样。</p>
<p>三，instanceof表达式：SpEL支持instanceof运算符，跟Java内使用同义；如“’haha’ instanceof T(String)”将返回true。</p>
<p>四， 变量定义及引用：变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用“#variableName”引用；除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用“#root”引用根对象，使用“#this”引用当前上下文对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    context.setVariable(<span class="string">"variable"</span>, <span class="string">"haha"</span>);  </span><br><span class="line">    String result1 = parser.parseExpression(<span class="string">"#variable"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result1);  </span><br><span class="line">   </span><br><span class="line">    context = <span class="keyword">new</span> StandardEvaluationContext(<span class="string">"haha"</span>);  </span><br><span class="line">    String result2 = parser.parseExpression(<span class="string">"#root"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result2);  </span><br><span class="line">    String result3 = parser.parseExpression(<span class="string">"#this"</span>).getValue(context, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, result3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>#variable</code>来引用在<code>EvaluationContext</code>定义的变量；除了可以引用自定义变量，还可以使用<code>#root</code>引用根对象，<code>#this</code>引用当前上下文对象，此处<code>#this</code>即根对象。</p>
<p>五、自定义函数：目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionExpression</span><span class="params">()</span> <span class="keyword">throws</span> SecurityException, NoSuchMethodException </span>&#123;  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    Method parseInt = Integer.class.getDeclaredMethod(<span class="string">"parseInt"</span>, String.class);  </span><br><span class="line">    context.registerFunction(<span class="string">"parseInt"</span>, parseInt);  </span><br><span class="line">    context.setVariable(<span class="string">"parseInt2"</span>, parseInt);  </span><br><span class="line">    String expression1 = <span class="string">"#parseInt('3') == #parseInt2('3')"</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> result1 = parser.parseExpression(expression1).getValue(context, <span class="keyword">boolean</span>.class);  </span><br><span class="line">    Assert.assertEquals(<span class="keyword">true</span>, result1);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处可以看出<code>registerFunction</code>和<code>setVariable</code>都可以注册自定义函数，但是两个方法的含义不一样，推荐使用<code>registerFunction</code>方法注册自定义函数。</p>
<p>六、赋值表达式：SpEL即允许给自定义变量赋值，也允许给根对象赋值，直接使用<code>#variableName=value</code>即可赋值：</p>
<p>使用<code>#root=&#39;aaaaa&#39;</code>给根对象赋值，使用“”#this=’aaaa’”给当前上下文对象赋值，使用<code>#variable=#root</code>给自定义变量赋值，很简单。</p>
<p>七、对象属性存取及安全导航表达式：对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的；SpEL还引入了Groovy语言中的安全导航运算符“(对象|属性)?.属性”，用来避免“?.”前边的表达式为null时抛出空指针异常，而是返回null；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line"><span class="comment">//1.访问root对象属性  </span></span><br><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result1);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于当前上下文对象属性及方法访问，可以直接使用属性或方法名访问，比如此处根对象date属性<code>year</code>，注意此处属性名首字母不区分大小写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.安全访问  </span></span><br><span class="line">context.setRootObject(<span class="keyword">null</span>);  </span><br><span class="line">Object result3 = parser.parseExpression(<span class="string">"#root?.year"</span>).getValue(context, Object.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">null</span>, result3);</span><br></pre></td></tr></table></figure>
<p>SpEL引入了Groovy的安全导航运算符，比如此处根对象为null，所以如果访问其属性时肯定抛出空指针异常，而采用“?.”安全访问导航运算符将不抛空指针异常，而是简单的返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.给root对象属性赋值  </span></span><br><span class="line">context.setRootObject(date);  </span><br><span class="line"><span class="keyword">int</span> result4 = parser.parseExpression(<span class="string">"Year = 4"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result4);  </span><br><span class="line">parser.parseExpression(<span class="string">"Year"</span>).setValue(context, <span class="number">5</span>);  </span><br><span class="line"><span class="keyword">int</span> result5 = parser.parseExpression(<span class="string">"Year"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">5</span>, result5);</span><br></pre></td></tr></table></figure>
<p>给对象属性赋值可以采用赋值表达式或Expression接口的setValue方法赋值，而且也可以采用点缀方式赋值。</p>
<p>八、对象方法调用：对象方法调用更简单，跟Java语法一样；如“’haha’.substring(2,4)”将返回“ha”；而对于根对象可以直接调用方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();  </span><br><span class="line">StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(date);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"getYear()"</span>).getValue(context, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(date.getYear(), result2);</span><br></pre></td></tr></table></figure>
<p>比如根对象date方法“getYear”可以直接调用。</p>
<p>九、Bean引用：SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeanExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext();  </span><br><span class="line">    ctx.refresh();  </span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();  </span><br><span class="line">    StandardEvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">    context.setBeanResolver(<span class="keyword">new</span> BeanFactoryResolver(ctx));  </span><br><span class="line">    Properties result1 = parser.parseExpression(<span class="string">"@systemProperties"</span>).getValue(context, Properties.class);  </span><br><span class="line">    Assert.assertEquals(System.getProperties(), result1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在示例中我们首先初始化了一个IoC容器，ClassPathXmlApplicationContext 实现默认会把“System.getProperties()”注册为“systemProperties”Bean，因此我们使用 “@systemProperties”来引用该Bean。</p>
<h3 id="集合相关表达式"><a href="#集合相关表达式" class="headerlink" title="集合相关表达式"></a>集合相关表达式</h3><p>内联List</p>
<p>从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List，如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将返回不可修改的空List  </span></span><br><span class="line">List&lt;Integer&gt; result2 = parser.parseExpression(<span class="string">"&#123;&#125;"</span>).getValue(List.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于字面量列表也将返回不可修改的List  </span></span><br><span class="line">List&lt;Integer&gt; result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;"</span>).getValue(List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">1</span>), result1.get(<span class="number">0</span>));  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    result1.set(<span class="number">0</span>, <span class="number">2</span>);  </span><br><span class="line">    <span class="comment">//不可能执行到这，对于字面量列表不可修改  </span></span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于列表中只要有一个不是字面量表达式，将只返回原始List，  </span></span><br><span class="line"><span class="comment">//不会进行不可修改处理  </span></span><br><span class="line">String expression3 = <span class="string">"&#123;&#123;1+2,2+4&#125;,&#123;3,4+4&#125;&#125;"</span>;  </span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; result3 = parser.parseExpression(expression3).getValue(List.class);  </span><br><span class="line">result3.get(<span class="number">0</span>).set(<span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3.size());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/声明二维数组并初始化  </span><br><span class="line"><span class="keyword">int</span>[] result2 = parser.parseExpression(<span class="string">"new int[2]&#123;1,2&#125;"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一维数组并初始化  </span></span><br><span class="line"><span class="keyword">int</span>[] result1 = parser.parseExpression(<span class="string">"new int[1]"</span>).getValue(<span class="keyword">int</span>[].class);</span><br></pre></td></tr></table></figure>
<p>内联数组</p>
<p>和Java 数组定义类似，只是在定义时进行多维数组初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义多维数组但不初始化  </span></span><br><span class="line"><span class="keyword">int</span>[][][] result3 = parser.parseExpression(expression3).getValue(<span class="keyword">int</span>[][][].class);</span><br></pre></td></tr></table></figure>
<p>错误的定义多维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的定义多维数组，多维数组不能初始化  </span></span><br><span class="line">String expression4 = <span class="string">"new int[1][2][3]&#123;&#123;1&#125;&#123;2&#125;&#123;3&#125;&#125;"</span>;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">int</span>[][][] result4 = parser.parseExpression(expression4).getValue(<span class="keyword">int</span>[][][].class);  </span><br><span class="line">    Assert.fail();  </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br></pre></td></tr></table></figure>
<p>集合，字典元素访问</p>
<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL内联List访问  </span></span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"&#123;1,2,3&#125;[0]"</span>).getValue(<span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//即list.get(0)  </span></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL目前支持所有集合类型的访问  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> HashSet&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line"><span class="comment">//对于任何集合类型通过Iterator来定位元素  </span></span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SpEL对Map字典元素访问的支持  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a']"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result3);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：集合元素访问是通过Iterator遍历来定位元素位置的。</p>
</blockquote>
<p>四、列表，字典，数组元素修改：</p>
<p>可以使用赋值表达式或Expression接口的setValue方法修改；<br>　　<br>修改数组元素值<br>　　<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.修改数组元素值  </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  </span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"array"</span>, array);  </span><br><span class="line"><span class="keyword">int</span> result1 = parser.parseExpression(<span class="string">"#array[1] = 3"</span>).getValue(context1, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result1);</span><br></pre></td></tr></table></figure></p>
<p>修改集合值  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.修改集合值  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">1</span>);  </span><br><span class="line">collection.add(<span class="number">2</span>);  </span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line"><span class="keyword">int</span> result2 = parser.parseExpression(<span class="string">"#collection[1] = 3"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">3</span>, result2);  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection[1]"</span>).setValue(context2, <span class="number">4</span>);  </span><br><span class="line">result2 = parser.parseExpression(<span class="string">"#collection[1]"</span>).getValue(context2, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">4</span>, result2);</span><br></pre></td></tr></table></figure>
<p>修改map元素值 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.修改map元素值  </span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);  </span><br><span class="line">EvaluationContext context3 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context3.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line"><span class="keyword">int</span> result3 = parser.parseExpression(<span class="string">"#map['a'] = 2"</span>).getValue(context3, <span class="keyword">int</span>.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3);</span><br></pre></td></tr></table></figure>
<p>对数组修改直接对“#array[index]”赋值即可修改元素值，同理适用于集合和字典类型。</p>
<p>五、集合投影：</p>
<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.测试集合或数组  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.![#this+1]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“#this”代表每个集合或数组元素，可以使用比如“#this.property”来获取集合元素的属性，其中“#this”可以省略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.测试字典  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">List&lt;Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.![ value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result2.size());</span><br></pre></td></tr></table></figure>
<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。</p>
<p>六、集合选择：</p>
<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.首先准备测试数据  </span></span><br><span class="line">Collection&lt;Integer&gt; collection = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">collection.add(<span class="number">4</span>);   collection.add(<span class="number">5</span>);  </span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();  </span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="number">1</span>);    map.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//2.集合或数组测试  </span></span><br><span class="line">EvaluationContext context1 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);  </span><br><span class="line">Collection&lt;Integer&gt; result1 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#collection.?[#this&gt;4]"</span>).getValue(context1, Collection.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result1.size());  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">5</span>), result1.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于集合或数组选择，如“#collection.?[#this&gt;4]”将选择出集合元素值大于4的所有元素。选择表达式必须返回布尔类型，使用“#this”表示当前元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.字典测试  </span></span><br><span class="line">EvaluationContext context2 = <span class="keyword">new</span> StandardEvaluationContext();  </span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, map);  </span><br><span class="line">Map&lt;String, Integer&gt; result2 =  </span><br><span class="line">parser.parseExpression(<span class="string">"#map.?[#this.key != 'a']"</span>).getValue(context2, Map.class);  </span><br><span class="line">Assert.assertEquals(<span class="number">1</span>, result2.size());  </span><br><span class="line">   </span><br><span class="line">List&lt;Integer&gt; result3 =  </span><br><span class="line">    parser.parseExpression(<span class="string">"#map.?[key != 'a'].![value+1]"</span>).getValue(context2, List.class);  </span><br><span class="line">Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">3</span>), result3.iterator().next());</span><br></pre></td></tr></table></figure>
<p>对于字典选择，如“#map.?[#this.key != ‘a’]”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != ‘a’].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。</p>
<h2 id="表达式模板"><a href="#表达式模板" class="headerlink" title="表达式模板"></a>表达式模板</h2><p>模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由<code>前缀+表达式+后缀</code>形式组成，如<code>${1+2}</code>即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了。</p>
<h3 id="在Bean定义中使用EL"><a href="#在Bean定义中使用EL" class="headerlink" title="在Bean定义中使用EL"></a>在Bean定义中使用EL</h3><p>xml风格的配置</p>
<p>SpEL支持在Bean定义时注入，默认使用<code>#{SpEL表达式}</code>表示，其中“#root”根对象默认可以认为是ApplicationContext，只有ApplicationContext实现默认支持SpEL，获取根对象属性其实是获取容器中的Bean。</p>
<p>首先看下配置方式吧：<br>　　<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello'&#125;#&#123;world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;    </span><br><span class="line">&lt;bean id=<span class="string">"hello2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">    &lt;!-- 不支持嵌套的 --&gt;  </span><br><span class="line">    &lt;!--&lt;constructor-arg value=<span class="string">"#&#123;'Hello'#&#123;world&#125;&#125;"</span>/&gt;--&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"hello3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"#&#123;'Hello' + @world&#125;"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>模板默认以前缀<code>#{”开头，以后缀“}</code>结尾，且不允许嵌套，如<code>#{&#39;Hello&#39;#{world}}</code>错误，如<code>#{&#39;Hello&#39; + world}</code>中“world”默认解析为Bean。当然可以使用“@bean”引用了。<br>接下来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testXmlExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el1.xml"</span>);  </span><br><span class="line">    String hello1 = ctx.getBean(<span class="string">"hello1"</span>, String.class);  </span><br><span class="line">    String hello2 = ctx.getBean(<span class="string">"hello2"</span>, String.class);  </span><br><span class="line">    String hello3 = ctx.getBean(<span class="string">"hello3"</span>, String.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello1);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello2);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, hello3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很简单，除了XML配置方式，Spring还提供一种注解方式@Value，接着往下看吧。</p>
<h3 id="注解风格的配置"><a href="#注解风格的配置" class="headerlink" title="注解风格的配置"></a>注解风格的配置</h3><p>基于注解风格的SpEL配置也非常简单，使用@Value注解来指定SpEL表达式，该注解可以放到字段、方法及方法参数上。</p>
<p>测试Bean类如下，使用@Value来指定SpEL表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBean</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'Hello' + world&#125;"</span>)  </span><br><span class="line">    <span class="keyword">private</span> String value;  </span><br><span class="line">    <span class="comment">//setter和getter由于篇幅省略，自己写上  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看下配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </span><br><span class="line">&lt;beans  xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  </span><br><span class="line">        xsi:schemaLocation=&quot;  </span><br><span class="line">          http://www.springframework.org/schema/beans  </span><br><span class="line">          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span><br><span class="line">          http://www.springframework.org/schema/context  </span><br><span class="line">http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean id=&quot;world&quot; class=&quot;java.lang.String&quot;&gt;  </span><br><span class="line">       &lt;constructor-arg value=&quot;#&#123;&apos; World!&apos;&#125;&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean1&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;/&gt;  </span><br><span class="line">   &lt;bean id=&quot;helloBean2&quot; class=&quot;cn.javass.spring.chapter5.SpELBean&quot;&gt;  </span><br><span class="line">       &lt;property name=&quot;value&quot; value=&quot;haha&quot;/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置时必须使用“<context:annotation-config>”来开启对注解的支持。<br>有了配置文件那开始测试吧：</context:annotation-config></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el2.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"haha"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中“helloBean1 ”值是SpEL表达式的值，而“helloBean2”是通过setter注入的值，这说明setter注入将覆盖@Value的值。</p>
<h3 id="在Bean定义中SpEL的问题"><a href="#在Bean定义中SpEL的问题" class="headerlink" title="在Bean定义中SpEL的问题"></a>在Bean定义中SpEL的问题</h3><p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有同学问<code>#{我不是SpEL表达式}</code>不是SpEL表达式，而是公司内部的模板，想换个前缀和后缀该如何实现呢？</p>
<p>那我们来看下Spring如何在IoC容器内使用BeanExpressionResolver接口实现来求值SpEL表达式，那如果我们通过某种方式获取该接口实现，然后把前缀后缀修改了不就可以了。</p>
<p>此处我们使用BeanFactoryPostProcessor接口提供postProcessBeanFactory回调方法，它是在IoC容器创建好但还未进行任何Bean初始化时被ApplicationContext实现调用，因此在这个阶段把SpEL前缀及后缀修改掉是安全的，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javass.spring.chapter5;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.expression.StandardBeanExpressionResolver;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        StandardBeanExpressionResolver resolver = (StandardBeanExpressionResolver) beanFactory.getBeanExpressionResolver();  </span><br><span class="line">        resolver.setExpressionPrefix(<span class="string">"%&#123;"</span>);  </span><br><span class="line">        resolver.setExpressionSuffix(<span class="string">"&#125;"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过 ConfigurableListableBeanFactory的getBeanExpressionResolver方法获取BeanExpressionResolver实现，其次强制类型转换为StandardBeanExpressionResolver，其为Spring默认实现，然后改掉前缀及后缀。</p>
<p>开始测试吧，首先准备配置文件(chapter5/el3.xml)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;  </span><br><span class="line">&lt;beans  xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        xsi:schemaLocation=<span class="string">"  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context  </span></span><br><span class="line"><span class="string">           http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;  </span><br><span class="line">   &lt;context:annotation-config/&gt;  </span><br><span class="line">   &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"world"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"java.lang.String"</span>&gt;  </span><br><span class="line">       &lt;constructor-arg value=<span class="string">"%&#123;' World!'&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>/&gt;  </span><br><span class="line">   &lt;bean id=<span class="string">"helloBean2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.javass.spring.chapter5.SpELBean"</span>&gt;  </span><br><span class="line">       &lt;property name=<span class="string">"value"</span> value=<span class="string">"%&#123;'Hello' + world&#125;"</span>/&gt;  </span><br><span class="line">   &lt;/bean&gt;  </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件和注解风格的几乎一样，只有SpEL表达式前缀变为<code>%{</code>了，并且注册了“cn.javass.spring.chapter5.SpELBeanFactoryPostProcessor” Bean，用于修改前缀和后缀的。</p>
<p>写测试代码测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPrefixExpression</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"chapter5/el3.xml"</span>);  </span><br><span class="line">    SpELBean helloBean1 = ctx.getBean(<span class="string">"helloBean1"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"#&#123;'Hello' + world&#125;"</span>, helloBean1.getValue());  </span><br><span class="line">    SpELBean helloBean2 = ctx.getBean(<span class="string">"helloBean2"</span>, SpELBean.class);  </span><br><span class="line">    Assert.assertEquals(<span class="string">"Hello World!"</span>, helloBean2.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处helloBean1中通过@Value注入的<code>#{&#39;Hello&#39; + world}</code>结果还是<code>#{&#39;Hello&#39; + world}</code>说明不对其进行SpEL表达式求值了，而helloBean2使用<code>%{&#39;Hello&#39; + world}</code>注入，得到正确的“”Hello World!”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章转载自：&lt;a href=&quot;https://blog.csdn.net/zhoudaxia/article/details/38174169&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/zhoudaxia/article/details/38174169&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1  概述&quot;&gt;&lt;/a&gt;1  概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-概述&quot;&gt;&lt;a href=&quot;#1-1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.1  概述&quot;&gt;&lt;/a&gt;1.1  概述&lt;/h3&gt;&lt;p&gt;　　Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。&lt;/p&gt;
&lt;p&gt;　　表达式语言给静态Java语言增加了动态功能。&lt;/p&gt;
&lt;p&gt;　　SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。&lt;/p&gt;
&lt;h3 id=&quot;1-2-能干什么&quot;&gt;&lt;a href=&quot;#1-2-能干什么&quot; class=&quot;headerlink&quot; title=&quot;1.2  能干什么&quot;&gt;&lt;/a&gt;1.2  能干什么&lt;/h3&gt;&lt;p&gt;　　表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。&lt;/p&gt;
&lt;p&gt;　　SpEL支持如下表达式：&lt;/p&gt;
&lt;p&gt;　　一、基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式；&lt;/p&gt;
&lt;p&gt;　　二、类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；&lt;/p&gt;
&lt;p&gt;　　三、集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；&lt;/p&gt;
&lt;p&gt;　　四、其他表达式：模板表达式。&lt;/p&gt;
&lt;p&gt;　　注：SpEL表达式中的关键字是不区分大小写的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>mysql中字段究竟该不该为null</title>
    <link href="https://leokongwq.github.io/2019/01/05/mysql-null-column.html"/>
    <id>https://leokongwq.github.io/2019/01/05/mysql-null-column.html</id>
    <published>2019-01-05T01:54:48.000Z</published>
    <updated>2019-02-15T06:44:31.215Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么会有许多表的字段设置为null？"><a href="#为什么会有许多表的字段设置为null？" class="headerlink" title="为什么会有许多表的字段设置为null？"></a>为什么会有许多表的字段设置为null？</h3><ol>
<li>开发中常用的建表工具创建表时字段默认可以为null。</li>
<li>开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。</li>
<li>默认为null，在插入数据时可以少很多判断</li>
</ol>
<p>针对这些问题，下面就彻底搞清楚字段该不该为null。    </p>
<h3 id="null-字段可以节省空间吗？"><a href="#null-字段可以节省空间吗？" class="headerlink" title="null 字段可以节省空间吗？"></a>null 字段可以节省空间吗？</h3><h4 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h4><p>MySQL官方文档有如下的描述：</p>
<blockquote>
<p>For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
<p>从上面的描述中可以知道，在MyISAM中<code>NULL</code>字段并不能完全的节省空间。</p>
<a id="more"></a>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB 表的行格式</p>
<img src="/2019/01/05/mysql-null-column/mysql_innodb_row_format.png">
<p>平时使用COMPACT格式的行较多，正对该格式，文档有如下的说明。</p>
<blockquote>
<p>The variable-length part of the record header contains a bit vector for indicating NULL columns. If the number of columns in the index that can be NULL is N, the bit vector occupies CEILING(N/8) bytes. (For example, if there are anywhere from 9 to 16 columns that can be NULL, the bit vector uses two bytes.) Columns that are NULL do not occupy space other than the bit in this vector. The variable-length part of the header also contains the lengths of variable-length columns. Each length takes one or two bytes, depending on the maximum length of the column. If all columns in the index are NOT NULL and have a fixed length, the record header has no variable-length part.</p>
</blockquote>
<p>从上面的内容可以知道，NULL列除不能节省空间，反而会增加空间。</p>
<p>MySQL考虑的是越小的行大小，在固定大小的内存中就可以更多的缓存行数据，提升性能。如果字段有值就存，没值就不存，默认值也不是保存行数据里面的。</p>
<h3 id="null-字段带来的问题"><a href="#null-字段带来的问题" class="headerlink" title="null 字段带来的问题"></a>null 字段带来的问题</h3><ol>
<li>NULL值到非NULL的更新无法做到原地更新，更容易发生页分裂，从而影响性能。</li>
<li>NULL值在<code>timestamp</code>类型下容易出问题，特别是没有启用参数<code>explicit_defaults_for_timestamp=true</code>具体见文章最后的：参考资料</li>
<li><code>NOT IN</code>、<code>!=</code> 等负向条件查询在有<code>NULL</code>值的情况下返回永远为空结果，查询容易出错</li>
</ol>
<p>1，NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</p>
<figure class="highlight sql"><figcaption><span>NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_2 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_3 (</span><br><span class="line">true <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">true user_name <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_2 <span class="keyword">values</span> (<span class="number">4</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_1"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_1"</span>),(<span class="number">1</span>,<span class="string">"zhangsan_2"</span>),(<span class="number">2</span>,<span class="string">"lisi_2_2"</span>),(<span class="number">4</span>,<span class="string">"zhaoliu_2_2"</span>),(<span class="number">3</span>,<span class="string">"wangmazi_2_2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_3 <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">"zhaoliu_2_1"</span>),(<span class="number">2</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> table_2 <span class="keyword">where</span> user_name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_name <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">id</span>!=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>2，单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集如果name允许为null，索引不存储null值，结果集中不会包含这些记录。所以，请使用not null约束以及默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_3 <span class="keyword">where</span> <span class="keyword">name</span> != <span class="string">'zhaoliu_2_1'</span></span><br></pre></td></tr></table></figure>
<p>3，如果在两个字段进行拼接：比如题号+分数，首先要各字段进行非null判断，否则只要任意一个字段为空都会造成拼接的结果为null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="string">"1"</span>, <span class="literal">null</span>) <span class="keyword">from</span> dual; <span class="comment">-- 执行结果为null。</span></span><br></pre></td></tr></table></figure>
<p>4，如果有 Null column 存在的情况下，count(Null column)需要格外注意，null 值不会参与统计。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 下面的语句返回 2， 但是数据库里面有4条记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(user_name) <span class="keyword">from</span> table_3;</span><br></pre></td></tr></table></figure>
<p>5， null 字段的判断 需要使用 <code>is null</code> 或 <code>is not null</code></p>
<h3 id="NULL字段和索引"><a href="#NULL字段和索引" class="headerlink" title="NULL字段和索引"></a>NULL字段和索引</h3><h4 id="索引长度-key-len"><a href="#索引长度-key-len" class="headerlink" title="索引长度 key_len"></a>索引长度 key_len</h4><p>key_len 的计算规则和三个因素有关：数据类型、字符编码、是否为 NULL </p>
<p>key_len 62 == 20*3（utf8 3字节） + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<p>key_len 83 == 20*4（utf8mb4 4字节） +  1 (是否为 Null 的标识) + 2 （存储 varchar 变长字符长度 2字节，定长字段无需额外的字节）</p>
<h3 id="null字段唯一索引"><a href="#null字段唯一索引" class="headerlink" title="null字段唯一索引"></a>null字段唯一索引</h3><p>在可以为NULL的字段上也是可以建立唯一索引的，但需要注意的是：唯一索引想要防止重复记录的功能就失效了。官方文档描述如下：</p>
<blockquote>
<p>A UNIQUE index creates a constraint such that all values in the index must be distinct. An error occurs if you try to add a new row with a key value that matches an existing row. For all engines, a UNIQUE index permits multiple NULL values for columns that can contain NULL.</p>
</blockquote>
<h3 id="null字段普通索引"><a href="#null字段普通索引" class="headerlink" title="null字段普通索引"></a>null字段普通索引</h3><p>在可以为null的字段上建立普通索引，则所有索引字段为null的索引记录都是排列在一起的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://my.oschina.net/leejun2005/blog/1342985" target="_blank" rel="noopener">https://my.oschina.net/leejun2005/blog/1342985</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/column-count-limit.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-row-format.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/is-null-optimization.html</a><br><a href="https://www.jianshu.com/p/d7d364745173" target="_blank" rel="noopener">https://www.jianshu.com/p/d7d364745173</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/problems-with-null.html</a><br><a href="http://mysql.taobao.org/monthly/2018/01/04/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/01/04/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;a href=&quot;#为什么会有许多表的字段设置为null？&quot; class=&quot;headerlink&quot; title=&quot;为什么会有许多表的字段设置为null？&quot;&gt;&lt;/a&gt;为什么会有许多表的字段设置为null？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发中常用的建表工具创建表时字段默认可以为null。&lt;/li&gt;
&lt;li&gt;开发人员不能正确区分null和not null的区别，以为默认null可以节省空间。&lt;/li&gt;
&lt;li&gt;默认为null，在插入数据时可以少很多判断&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这些问题，下面就彻底搞清楚字段该不该为null。    &lt;/p&gt;
&lt;h3 id=&quot;null-字段可以节省空间吗？&quot;&gt;&lt;a href=&quot;#null-字段可以节省空间吗？&quot; class=&quot;headerlink&quot; title=&quot;null 字段可以节省空间吗？&quot;&gt;&lt;/a&gt;null 字段可以节省空间吗？&lt;/h3&gt;&lt;h4 id=&quot;NULL&quot;&gt;&lt;a href=&quot;#NULL&quot; class=&quot;headerlink&quot; title=&quot;NULL&quot;&gt;&lt;/a&gt;NULL&lt;/h4&gt;&lt;p&gt;MySQL官方文档有如下的描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For NULL tables, NULL columns require additional space in the row to record whether their values are NULL. Each NULL column takes one bit extra, rounded up to the nearest byte.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的描述中可以知道，在MyISAM中&lt;code&gt;NULL&lt;/code&gt;字段并不能完全的节省空间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>极客时间mysql学习笔记</title>
    <link href="https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html"/>
    <id>https://leokongwq.github.io/2018/12/21/geektime-mysql-learn.html</id>
    <published>2018-12-21T05:48:17.000Z</published>
    <updated>2019-03-12T12:02:32.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是对极客时间专栏<a href="https://time.geekbang.org/column/139" target="_blank" rel="noopener">MySQL实战45讲</a> 文章内容和讨论区内容的总结。</p>
<h2 id="第一讲-基础架构：一条SQL查询语句是如何执行的？"><a href="#第一讲-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="第一讲 基础架构：一条SQL查询语句是如何执行的？"></a>第一讲 基础架构：一条SQL查询语句是如何执行的？</h2><h3 id="mysql-架构"><a href="#mysql-架构" class="headerlink" title="mysql 架构"></a>mysql 架构</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_arch.png">
<ol>
<li>MySQL 可以分为 Server 层和存储引擎层两部</li>
<li>Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。</li>
<li>存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。</li>
</ol>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><ol>
<li>负责为何和客户端的TCP连接， 权限获取，验证。</li>
<li>连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。</li>
<li>通过<code>show processlits</code>查看当前所有的连接。<img src="/2018/12/21/geektime-mysql-learn/show_processlist.png"></li>
<li>如果连接在<code>wait_timeout</code>指定的时间内没有任何操作，则会被关闭。默认是8小时。</li>
<li>长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。<ul>
<li>定时关闭连接 或 执行了大的查询语句后断开连接</li>
<li>MySQL5.7以后的版本可以通过<code>mysql_reset_connection</code>重新初始化连接（不会重新验证权限）。</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><ol>
<li>查询缓存可以是一个简单的KV缓存，sql语句为key，缓存的内容为值</li>
<li>只要查询语句中的表执行了更新，该表相关的所有查询缓存都会失效。</li>
<li>对于频繁更新的表，不建议开启查询缓存。</li>
<li>基础配置表建议使用查询缓存。</li>
<li>将参数<code>query_cache_type</code>的值设置为<code>demand</code>，默认不启用查询缓存，除非显示指定：<code>select SQL_CACHE * from T where...</code></li>
</ol>
<h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>词法分析：识别出SQL中每个单词的含义，例如： <code>表名</code>,<code>字段名称</code>,<code>数据库名称</code>,<code>关键字</code>等。<br>语法分析：分析SQL语句的含义，是否满足SQL语法。</p>
<h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>对SQL语句进行改写优化。 </p>
<ul>
<li>索引选择</li>
<li>关联查询表的选择</li>
<li>优化器可能<code>选错索引</code>。</li>
</ul>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><ol>
<li>执行器执行SQL前会检查对应的权限。</li>
<li>执行器调用引擎接口获取数据（取下一行，索引：取满足条件的下一行），并计数。该计数可能引擎真实扫描的数据行数不一致。</li>
</ol>
<h2 id="第二讲-日志系统：一条SQL更新语句是如何执行的？"><a href="#第二讲-日志系统：一条SQL更新语句是如何执行的？" class="headerlink" title="第二讲 日志系统：一条SQL更新语句是如何执行的？"></a>第二讲 日志系统：一条SQL更新语句是如何执行的？</h2><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p><code>redo log</code> 是提高MySQL写入性能的一种机制。否则每次更新都需要写磁盘，频繁写磁盘性能很差。<code>redo log</code> 减少磁盘写入次数，将单次写入转为批量顺序写入，提高性能。</p>
<p><code>redo log</code> 可以配置个数和大小，并且是循环写入的。</p>
<img src="/2018/12/21/geektime-mysql-learn/msyql_redolog.jpg">
<p><code>redo log</code>保证MySQL的<code>Crash-Safe</code>能力。</p>
<p>InnoDB 必须配置至少一组 redo log。 每组下面至少两个文件， 每个文件大小一致。默认只有一组 redo log， 共2个文件，分别是： ib_logfile0, iblogfile1。</p>
<p>innodb_log_file_size : 指定每个文件的大小<br>innodb_log_files_in_group : 每组下面文件的个数<br>innodb_mirrored_log_groups : 指定日志镜像文件组的数量，默认是1. 如果磁盘做了高可用，可以保持不变。<br>innodb_log_group_home_dir : 指定日志文件所在路径。默认值<code>./</code></p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p><code>binlog</code> 是MySQL Server层的日志，也称为归档日志。</p>
<p><code>binlog</code> 有三种格式：statement, row, mix</p>
<p>通过<code>set sql_log_bin=0</code>来关闭binlog。</p>
<h3 id="redo-log-vs-binlog"><a href="#redo-log-vs-binlog" class="headerlink" title="redo log vs binlog"></a>redo log vs binlog</h3><ol>
<li>redo log 是InnoDB引擎特有的日志。binlog是MySQL Server层的日志，所有引擎共享。</li>
<li>redo log 是大小固定，循环写入的，会写满，binlog是追加写入的。</li>
<li>redo log 是物理日志，记录了<code>哪个数据页,做了哪些修改</code>；binlog是逻辑日志，记录了语句的原始逻辑。</li>
</ol>
<h3 id="update语句执行流程"><a href="#update语句执行流程" class="headerlink" title="update语句执行流程"></a>update语句执行流程</h3>
<p>redo log 和 binlog使用了两阶段提交，以此来保证两个日志的逻辑一致。否则会导致数据不一致。</p>
<ol>
<li>先写redo log 后（crash）写 binlog， 通过binlog恢复数据，数据丢失更新。</li>
<li>先写binlog 后写 redo log, 数据库扩容，通过binlog追主库的数据时，多了一次更新。</li>
<li>prepare 阶段，redo log 已经写入磁盘，只是状态是<code>prepare</code>。</li>
<li>commit 阶段，引擎会将redo log的状态改为<code>commit</code>。</li>
</ol>
<h3 id="innodb-flush-log-at-trx-commit-amp-sync-binlog"><a href="#innodb-flush-log-at-trx-commit-amp-sync-binlog" class="headerlink" title="innodb_flush_log_at_trx_commit &amp; sync_binlog"></a>innodb_flush_log_at_trx_commit &amp; sync_binlog</h3><p><code>innodb_flush_log_at_trx_commit</code>有三个取值：</p>
<ul>
<li>0: 表示事务提交时并不将redo log 写入文件， 等待redo log刷新线程写入文件或其它触发条件。 不能保证是事务的持久性。</li>
<li>1: 该参数设置为1，表示每次事务提交，都将redo log写入磁盘（fsync调用）。</li>
<li>2: 异步写redo log， 写入操作系统page cache， 不能保证是事务的持久性。</li>
</ul>
<p><code>sync_binlog</code> 设置为 1 表示每次事务的binlog都写入磁盘。</p>
<h3 id="优质问题："><a href="#优质问题：" class="headerlink" title="优质问题："></a>优质问题：</h3><ol>
<li>当redo log写满后，新来的事务会导致MySQL将已经更新但是未提交事务修改的内存页(脏页)写入到磁盘中。但因为这些数据其他事务不能读到，或者读到也会放弃。</li>
</ol>
<h2 id="第三讲-事务隔离：为什么你改了我还看不见？"><a href="#第三讲-事务隔离：为什么你改了我还看不见？" class="headerlink" title="第三讲 事务隔离：为什么你改了我还看不见？"></a>第三讲 事务隔离：为什么你改了我还看不见？</h2><p>多个事务并发执行时，可能出现<code>脏读</code>，<code>不可重复读</code>，<code>幻读</code>的现象，为了解决这些问题，出现两个隔离级别的概念，不同的隔离级别，解决不同的问题。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li>读未提交 ： 事务的修改还没有提及，其他事务能看到修改的结果</li>
<li>读提交：一个事务的变更只有提交后才能被其他事务看见。</li>
<li>可重复读： 一个事务执行过程中看到的数据，总是和事务启动时看到的数据一致。</li>
<li>串性化：所有事务串行执行。</li>
</ul>
<h3 id="事务视图"><a href="#事务视图" class="headerlink" title="事务视图"></a>事务视图</h3><p>事务执行时会创建一个视图，数据访问时以该视图的逻辑结果为准。</p>
<ul>
<li>读提交 ：这个视图是在每个SQL语句执行前创建的</li>
<li>可重复读 ：视图在事务开始时创建</li>
</ul>
<h3 id="事务隔离实现"><a href="#事务隔离实现" class="headerlink" title="事务隔离实现"></a>事务隔离实现</h3><p>MySQL中每个记录的更新都有会记录对应的回滚操作。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_undo.png">
<ul>
<li>不同时刻启动的事务拥有不同的视图。</li>
<li>MySQL中一条记录会存在多个不同的版本，这个就是数据库的多版本并发控制MVCC。</li>
<li>事务要获取自己视图的数据值，只需要将当前值依次应用回滚日志。</li>
<li>当前系统中没有比回滚日志更早的view时，回滚日志会被删除。</li>
<li>尽量不要使用长事务，会导致回滚日志占用大量内存；mysql5.5和之前的版本中，回滚日志和数据字典一起存放在ibdata文件中，即使事务提交，回滚日志被清理，但是文件不会缩小。极端情况下需要重建库。</li>
</ul>
<h3 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h3><ol>
<li>通过 <code>begin</code> 或 <code>start transaction</code> 启动事务。</li>
<li>通过<code>set autocommit = 1</code>启用自动提交，这样每个语句执行后，MySQL自动追加一个<code>commit</code></li>
<li><code>set autocommit = 0</code> 关闭自动提交功能。这样连接始终处于一个事务中，直到显式<code>commit</code>, <code>rollback</code>，或者断开连接事务才结束。但是显示提交事务后，MySQL有马上开启了一个事务。</li>
<li>可以通过<code>infomation_schema</code>库中的<code>innodb_trx</code>表查询正在执行的事务。</li>
</ol>
<h2 id="第四五讲-深入浅出索引"><a href="#第四五讲-深入浅出索引" class="headerlink" title="第四五讲 深入浅出索引"></a>第四五讲 深入浅出索引</h2><p>所有索引的目的都是为了加速数据的查询。</p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul>
<li>哈希索引 ， 适用与等值查询，不适用区间查询，查询最大值，最小值等</li>
<li>有序数组索引， 适用于等值查询，范围查询。因为是数组，插入，更新效率低，所以适用静态数据索引。</li>
<li>二叉搜素树索引，平衡二叉查找树查询时间复杂度：log(N)，适用于内存索引，不适合磁盘索引，因为会导致随机访问问题，并且随着数量的增大，树的高度很高，查询效率降低的很快。</li>
<li>N叉搜素树索引, B树，B+树。适配磁盘访问模式，树的高度更低，查询一个数据需要更少的磁盘访问次数。</li>
</ul>
<h3 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h3><p>InnoDB中，表数据是按照<code>主键</code>顺序以索引的形式存放，这种方式称为<code>索引组织表</code>。InnoDB使用了B+树作为索引，也就是说数据是存放在B+树种的。</p>
<p>InnoDB中，每个索引都是一个B+树。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_tree.png">
<p>上图：左边是主键索引，右边是非主键索引。</p>
<p>主键索引的叶子节点保存了<code>整行</code>数据, 主键索引也称为<code>聚簇索引</code>，非主键索引的叶子节点的内容保存了主键ID。非主键索引也称为二级索引。</p>
<h4 id="主键索引和非主键索引的查询区别？"><a href="#主键索引和非主键索引的查询区别？" class="headerlink" title="主键索引和非主键索引的查询区别？"></a>主键索引和非主键索引的查询区别？</h4><ul>
<li>主键索引查询，只需要查询主键索引树。</li>
<li>非主键查询，需要先访问二级索引，获取主键索引的值，再访问主键索引树获取数据（这里不考虑覆盖索引）。</li>
</ul>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>插入，删除数据时，InnoDB需要维护主键索引非主键索引。</p>
<ol>
<li>插入数据时，如果叶子节点所在的页已经满了的话，需要开辟新的<code>页</code>，移动部分数据到新的<code>页</code>，该操作称为页分裂，会降低页的空间利用率。</li>
<li>删除数据时，如果相邻的2个<code>页</code>里面数据很少，达到某个阈值，那么就会进行页合并，提高空间利用率。</li>
</ol>
<h3 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h3><ol>
<li>尽量使用主键索引，因为少了一个查询索引树的操作，速度更快。</li>
<li>建表时，尽量定义自增主键。这样插入数据时，是顺序写入。空间利用率和写入效率都很高。如果是业务主键，那么写入就是随机的，不能利用磁盘的特性（SSD 随机写入要好很多）。</li>
<li>主键索引尽可能的小，这样普通二级索引的叶子节点也较小，整个二级索引树也很小。内存中也可以更多的缓存索引数据。</li>
<li>在表只有一个索引，该索引必须是唯一索引的情况下，可以使用业务字段作为主键索引。</li>
</ol>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>覆盖索引其实是索引的一种特殊类型，指的是：查询返回的字段值全部在<code>二级索引</code>上都能满足，不需要再搜素主键索引树的一种情况。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树索引支持按索引的最左前缀来定位记录。</p>
<p>下图： (name, age)是联合索引</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_left_prefix.jpg">
<p>索引项是按照索引定义中字段出现的顺序进行排序的。</p>
<ol>
<li>不只是索引定义的全部字段，只要满足最左前缀（联合索引的左前n个字段，N个字符）都可以加速查询。有了<code>(a,b)</code>就可以不定义索引:<code>a</code>， 但是如果有字段<code>b</code>的查询,可能需要单独建立字段<code>b</code>上的索引。</li>
<li>联合索引，优先考虑索引的复用率，可通过调整字段的顺序来减少需要创建索引个个数。</li>
<li>联合索引需要考虑空间。</li>
</ol>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是mysql5.6新增的一个功能。指的是使用联合索引查询时，在满足最左前缀的条件下，查询语句同时使用了联合索引的其他字段作为条件时，首先使用索引中包含的字段进行条件过滤，减少通过主键ID进行回表查询的次数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like '张 %' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>该查询可以使用(name, age)这个联合索引，在判断<code>age=10</code>这个条件时，可以使用联合索引中age字段的值进行条件过滤。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k)) <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>如果要要重建索引<code>k</code>,SQL应该怎么写？</p>
<p>答案：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br></pre></td></tr></table></figure>
<p>删除主键索引和创建主键索引都会导致表的重建。 如果要重建主键索引可以通过下面的语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">engine</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>下面的索引是否有问题？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>答案：（a, b）, (c) 索引都没有问题，能满足通过字段<code>a</code>,<code>a</code>和<code>b</code>，字段<code>c</code>的查询逻辑。</p>
<p>索引(c, a) 不需要（where c=x order by a），因为数据本身就是按照主键索引(a, b)排序的。</p>
<p>索引(c, b) 满足<code>where c=x order by b</code>的场景。</p>
<h2 id="第六讲全局锁和表锁"><a href="#第六讲全局锁和表锁" class="headerlink" title="第六讲全局锁和表锁"></a>第六讲全局锁和表锁</h2><p>数据库锁是用来协调数据库并发请求的。 根据锁范围分为：全局锁，表锁，行锁.</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>可以使用<code>flush tables with read lock;</code>给整个数据库添加读锁。此后：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结果），更新类事务的提交语句都会被阻塞。</p>
<p>全局锁的典型使用场景是：做整个数据库的逻辑备份。确保备份的数据满足一致性要求。</p>
<p>mysqldump 工具在备份数据库时，启动一个事务<code>添加参数：--single transaction</code>，确保拿到一致性视图，然后开启备份。但前提是存储引擎必须支持事务。</p>
<p><code>set global readonly=true;</code> 也可以让整个数据库进入只读状态，但是有如下的问题，不建议使用。</p>
<ol>
<li>使用该命令，影响面积太大。一些系统根据该变量的值来判断数据库时主库还是从库。</li>
<li><code>flush tables with read lock;</code>命令执行后，如果客户端断开连接，那么锁会被MySQL自动释放，然而<code>set global readonly=true;</code>不会自动释放锁，这样会导致业务不可用的时间变长。</li>
<li>从库上，如果用户有SUPER权限，则read only是无效的。</li>
</ol>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL有2中表级锁，一个是表锁，一个是元数据锁MDL。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁的语法是<code>lock tables a, b... read/write;</code> 通过 <code>unlock tables</code>释放锁，客户端断开连接也会释放锁。注意：<code>lock tables</code> 会同时限制本线程和其他线程的后续操作。</p>
<h3 id="MDL锁"><a href="#MDL锁" class="headerlink" title="MDL锁"></a>MDL锁</h3><p>MySQL5.5 引入。MDL表锁不需要显式加锁，它会在访问表时自动添加和释放。</p>
<ul>
<li>当执行<code>CRUD</code>操作时，加MDL读锁。 </li>
<li>当修改表结构时，加MDL写锁。</li>
<li>读锁直接不互斥，读写，写写直接互斥。</li>
<li>事务提交MDL锁才会释放。</li>
<li>获取MDL写锁时，添加超时控制。MariaDB和AliSQL支持该功能。</li>
</ul>
<h3 id="课后题"><a href="#课后题" class="headerlink" title="课后题"></a>课后题</h3><p>当备库用<code>–single-transaction</code> 做逻辑备份的时候，如果从主库的binlog传来一个DDL语句，从库会怎么样？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:<span class="keyword">SET</span> <span class="keyword">SESSION</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line">Q2:<span class="keyword">START</span> <span class="keyword">TRANSACTION</span>  <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span>；</span><br><span class="line"><span class="comment">/* other tables */</span></span><br><span class="line">Q3:<span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 1 */</span></span><br><span class="line">Q4:<span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 2 */</span></span><br><span class="line">Q5:<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/* 时刻 3 */</span></span><br><span class="line">Q6:<span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> sp;</span><br><span class="line"><span class="comment">/* 时刻 4 */</span></span><br><span class="line"><span class="comment">/* other tables */</span></span><br></pre></td></tr></table></figure>
<ol>
<li>为了确保RR隔离级别，再次设置了隔离级别。</li>
<li>开启事务，获取一致性视图。</li>
<li>设置保存点sp</li>
<li>获取表结构</li>
<li>获取数据</li>
<li>回滚到保存点sp,释放MDL读锁</li>
</ol>
<ul>
<li>如果binlog在Q4语句执行前到达，则没有影响，后续获取的是最新的表结构</li>
<li>如果在时刻2前到达，则表结构被修改了。后续流程不会执行。mysqldump退出。</li>
<li>如果在时刻2和3之间到达，mysqldump占用了MDL锁，binlog被阻塞，现象就是主从延迟。直到Q6完成后才能恢复。</li>
<li>从时刻4开始，MDL锁已经释放。现象是没有影响，不过备份拿到的是DDL前的表结构。</li>
</ul>
<h2 id="第七讲-行锁功过：怎么减少行锁对性能的影响"><a href="#第七讲-行锁功过：怎么减少行锁对性能的影响" class="headerlink" title="第七讲 行锁功过：怎么减少行锁对性能的影响"></a>第七讲 行锁功过：怎么减少行锁对性能的影响</h2><p>MySQL的行锁是在引擎层实现的。不是所有的引擎都支持行锁，MyISAM就不支持。</p>
<p>InnoDB支持行锁。行锁是在需要时获取，事务提交时释放。这也就是是MySQL的：两阶段锁协议。加锁阶段和释放锁阶段，缩放锁阶段不会再获取锁。</p>
<p>在事务中，把最容易造成锁冲突，最可能影响并发度的操作尽可能放到事务靠后的位置。</p>
<h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_deadlock.jpg">
<p>高并发系统中，MySQL出现死锁几乎是不可避免的。幸运的是MySQL有死锁检测机制。</p>
<p>解决死锁有两种机制：</p>
<ul>
<li>超时等待。innodb_lock_wait_timeout 参考来控制超时时间(默认50s)。</li>
<li>死锁检测。检测到发送死锁时，MySQL回滚权值较低的事务。<code>innodb_deadlock_detect</code>设置为 <code>on</code>表示开启死锁检测（默认是开启的）。</li>
</ul>
<p>超时等待太长，业务不可接受。太短可能将简单的锁等待当做死锁处理。所以建议使用死锁检测机制。</p>
<p>死锁检测时，由于每个新来的请求不能获取锁时，都会检测是否因为自己的加入导致了锁等待。当并发量很大时，非常消耗CPU，结果却发现没有死锁。</p>
<p>有两种方法来解决该问题：</p>
<ol>
<li>如果你确认业务不会发生死锁，则可以临时关闭死锁检测。</li>
<li>控制并发度。在MySQL服务端，针对相同行的更新，进行请求排队。</li>
<li>业务优化，将热点数据行拆分为多行，减少并发度。</li>
</ol>
<h3 id="课后题-1"><a href="#课后题-1" class="headerlink" title="课后题"></a>课后题</h3><p>如果要删除一个数据表中的前10000行数据，有如下三种方式。哪种方式更合适。</p>
<ol>
<li><code>delete from t limit 10000;</code></li>
<li>一个连接中循环20次<code>delete from t limit 500</code>;</li>
<li>20个连接同时执行<code>delete from t limit 500</code>;</li>
</ol>
<p>答案是：方法二。 方法一：会导致获取多个行锁，事务提交时才释放锁，影响并发度。方法三：人为的增加并发度，因为死锁检测逻辑，导致更多的冲突。</p>
<h2 id="第8讲：事务到底是隔离的还是不隔离的？"><a href="#第8讲：事务到底是隔离的还是不隔离的？" class="headerlink" title="第8讲：事务到底是隔离的还是不隔离的？"></a>第8讲：事务到底是隔离的还是不隔离的？</h2><p>通常事务的起点并不是<code>begin/start transaction</code>, 而是在该语句后面执行第一个操作InnoDB表的语句是开始事务。如果想要立刻开始事务，可以通过<code>start transaction with consistent snapshot;</code>.</p>
<p>MySQL中有两个视图view概念：</p>
<ol>
<li>通过查询语句创建的虚拟表</li>
<li>InnoDB实现MVCC时定义的一致性读视图 consistent read view，用于支持实现RC, RR事务隔离级别。</li>
<li>一致性读视图没有物理结构，它是用来定义事务执行期间每个事务能看到的数据规则。</li>
</ol>
<h3 id="快照在MVCC里如何工作"><a href="#快照在MVCC里如何工作" class="headerlink" title="快照在MVCC里如何工作"></a>快照在MVCC里如何工作</h3><ul>
<li>在可重复读隔离级别下，事务在启动的时候生产一个快照，并且是整个数据库的快照。</li>
<li>InnoDB里，每个事务都有一个事务ID，事务ID是系统严格按照递增顺序生成的。</li>
<li>每行数据都有多个版本，每次数据更新时，都会生成新的数据版本，并把操作更新的事务id赋值给新版本数据的事务ID，通过新版本可以找到数据的旧版本。<img src="/2018/12/21/geektime-mysql-learn/mysql_row_trx_id.png"></li>
<li>数据的其他版本可用通过每个事务的当前版本通过应用undo log来获取。</li>
<li>可重复读隔离级别下，一个事务启动时，获取了一个新的事务ID，它只认可在它之前生成的数据版本和它本身生成的数据版本。其它事务的更新生成的数据版本对它都是不可见的。</li>
<li>实现上InnoDB，在每个事务启动时，创建了一个数组，用来保存当前<code>活跃</code>的事务ID，这里活跃指的是已经启动，但是还未提交。</li>
<li>数组里面，事务ID的最小值记为<code>低水位</code>，当前系统已经创建过的事务ID的<code>最大值+1</code>记为<code>高水位</code>。这个视图数组和<code>高水位</code>共同构成事务的一致性视图。</li>
<li>数据版本的可见性规则，就是基于这个数据的row trx_id和该一致性视图的对比结果得到。</li>
</ul>
<h3 id="数据版本可见性规则"><a href="#数据版本可见性规则" class="headerlink" title="数据版本可见性规则"></a>数据版本可见性规则</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_array.png">
<p>如上图：事务启动瞬间，一个数据版本的row trx_id可能的取值有一下几种：</p>
<ol>
<li>位于绿色区间，表示这个版本是已经提交的，或者当前事务自己生成的，对当前事务可见。</li>
<li>位于红色区间，表示这个版本是未来的事务生成的，肯定不可见，这个容易理解。</li>
<li>位于黄色区间，有2中情况，<br> a. 如果row trx_id在数组中，表示该版本是未提交事务生成的。不可见。<br> b. row trx_id 不在数组中，表示这个版本是已经提交了的事务生成。可见。（当前活跃事务的ID数组是有序的，但每个元素之间的步长不是1， 中间有漏洞，漏洞里面的事务就是已经提交了的事务）</li>
</ol>
<p>一个事务视图中，除了自己的更新可见外，有其他三种情况：</p>
<ol>
<li>版本未提交，不可见。</li>
<li>版本已提交，但是在事务视图创建后提交的，不可见。</li>
<li>版本已提交，在事务视图创建前提交的，可见。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_trx_analyze.png">
<p>如上图所示，事务A最终读取到的K值是1， 事务B最终读取到的K值是3。（autocommit=1, 隔离级别是可重复读）</p>
<p>这里需要注意的是事务B。 因为事务B的update语句是<code>当前读</code>(所有的更新都是先读后写，update会加锁)，所以会读取到事务C已经提交后的结果，事务B是在C=2的基础上进行更新，否则就丢失了事务C的更新。</p>
<p>除了update语句，加锁的select与也是当前读。</p>
<p><code>select ... for update</code> 或 <code>select .... lock in share mode</code>。</p>
<h3 id="课后题-2"><a href="#课后题-2" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(<span class="keyword">id</span>, c) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_trx_update_problem.png">
<p>如果复现上图的问题，原因是什么？</p>
<p>答案：如何复现：其它事务在本事务执行更新语句前修改<code>c</code>的值并提交，因为隔离级别是RR, 那么本事务中进行select，结果还是更新前的值。但是update语句是当前读，读取的结果是其它事务更新后的值，已经不满足更新条件了，更新的结果就是上图所示的结果。如果在当前事务的update语句后面执行当前读(<code>for update</code>，<code>lock in share mode</code>)就能看到最新的值。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_can_not_update.png">
<h2 id="第9讲：普通索引和唯一索引怎么选？"><a href="#第9讲：普通索引和唯一索引怎么选？" class="headerlink" title="第9讲：普通索引和唯一索引怎么选？"></a>第9讲：普通索引和唯一索引怎么选？</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>在查询中，普通索引和唯一索引的性能消耗可以忽略不计。原因在于MySQL还按页读取和写入数据的（默认的页大小是16KB），在一个数据页中查找到满足条件的记录后，如果是唯一索引，则停止搜索；如果是普通索引，则继续搜索，因为此时数据页已经在内存中，再加上OS的磁盘预读机制，大概率剩下的满足条件的数据页在内存中，查找内存的效率是很高的。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h4><p>MySQL更新数据时，如果记录所在的数据页在内存中，则直接更新。否则，在不影响数据一致性的前提下，InnoDB会将更新操作缓存在<code>change buffer</code>中，并不会立即读取磁盘上数据页然后进行更新。<code>change buffer</code>会同时保持在磁盘和内存中。后续查询需要访问这个数据页时，才会从磁盘读取数据页，然后使用<code>change buffer</code>里面的数据更新数据页的内容。将<code>change buffer</code>中的更新操作应用到原始数据页上的操作称为<code>merge</code>。</p>
<p><code>change buffer</code> 减少了磁盘访问次数，间接减少了内存占用。</p>
<p><code>change buffer</code> 使用的是<code>buffer pool</code>里面的内存。可以通过参数<code>innodb_change_buffer_max_size</code>来动态调整。</p>
<h4 id="merge的触发时机"><a href="#merge的触发时机" class="headerlink" title="merge的触发时机"></a>merge的触发时机</h4><ol>
<li>访问数据页</li>
<li>数据库正常停机</li>
<li>后台线程周期性merge</li>
</ol>
<h4 id="change-buffer-使用条件"><a href="#change-buffer-使用条件" class="headerlink" title="change buffer 使用条件"></a>change buffer 使用条件</h4><p>普通索引才能使用<code>change buffer</code>。原因在于针对唯一索引，当数据页不在内存是，更新操作（insert, update）需要读取数据页才能进行唯一性判断。普通索引直接将更新操作添加到<code>change buffer</code>即可。针对普通索引，<code>change buffer</code>减少了磁盘的随机访问，唯一索引容易引起磁盘的随机访问，造成性能下降。</p>
<p><code>change buffer</code>的作用是尽量缓存更新操作直到进行merge操作前。如果数据更新后，马上被读取，那么缓存效果会大打折扣。也就是说：<code>change buffer</code>对<code>写多读少</code>的应用更合适。相反，更新后马上读取，就会触发merge操作，随机I/O并没有减少，反而要维护<code>change buffer</code>，代价更高。</p>
<p>insert的时候，写主键是肯定不能用<code>change buffer</code>了，但是同时也会要写其它索引，而其它索引中的<code>非唯一索引</code>是可以用的这个机制的；</p>
<p><code>change buffer</code>的前身是<code>insert buffer</code>,只能对insert 操作优化；后来升级了，增加了<code>update/delete</code>的支持，名字也改叫<code>change buffer</code>。</p>
<p>一个数据行的多次更新，会在change buffer中存在多个记录。</p>
<h3 id="索引选择和实践"><a href="#索引选择和实践" class="headerlink" title="索引选择和实践"></a>索引选择和实践</h3><p>普通索引和唯一索引在查询能力上差别微乎其微，主要区别在于更新操作，所以建议使用普通索引。</p>
<p>如果更新后马上进行读取，则考虑关闭<code>change buffer</code>。</p>
<p>实践：在线库可以使用唯一索引满足业务需求，历史备份表可以将唯一索引改为普通索引，配合较大的<code>change buffer</code>设置，可以提高备份库的写入速度。</p>
<h3 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h3><h4 id="带-change-buffer-写入"><a href="#带-change-buffer-写入" class="headerlink" title="带 change buffer 写入"></a>带 change buffer 写入</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_redolog_change_buffer.png"> 
<p>上面的sql做了如下操作：</p>
<ol>
<li>Page 1 在内存中，直接更新内存； </li>
<li>Page 2 没在内存中，记录insert操作到<code>change buffer</code>中。</li>
<li>将上面2个操作记录到redo log。</li>
</ol>
<h4 id="带-change-buffer-读取"><a href="#带-change-buffer-读取" class="headerlink" title="带 change buffer 读取"></a>带 change buffer 读取</h4><img src="/2018/12/21/geektime-mysql-learn/mysql_read_with_change_buffer.png"> 
<p>读取时，如果数据页在内存中，直接返回。只有数据页不在内存中，才需要读取磁盘上的数据，然后应用<code>change buffer</code>里面的操作。</p>
<p><code>redo log</code>节省的是随机写的性能消耗（转为顺序写），<code>change buffer</code>主要节省的是随机读的性能消耗。</p>
<h3 id="课后题-3"><a href="#课后题-3" class="headerlink" title="课后题"></a>课后题</h3><p><code>change buffer</code>的更新没有应用到磁盘数据页，掉电后，会不会导致<code>change buffer</code>丢失，也就是会不会导致丢失更新呢？</p>
<p>答案：不会。</p>
<p>1.<code>change buffer</code>有一部分在内存有一部分在<code>ibdata</code>.<br>做<code>purge</code>操作,应该就会把<code>change buffer</code>里相应的数据持久化到<code>ibdata</code><br>2.<code>redo log</code>里记录了数据页的修改以及<code>change buffer</code>新写入的信息<br>如果掉电,持久化的<code>change buffer</code>数据已经<code>purge</code>,不用恢复。主要分析没有持久化的数据<br>情况又分为以下几种:<br>(1)<code>change buffer</code>写入,<code>redo log</code>虽然做了<code>fsync</code>但未<code>commit</code>,<code>binlog</code>未<code>fsync</code>到磁盘,这部分数据丢失<br>(2)<code>change buffer</code>写入,<code>redo log</code>写入但没有<code>commit</code>,<code>binlog</code>已经<code>fsync</code>到磁盘,先从<code>binlog</code>恢复<code>redo log</code>,再从<code>redo log</code>恢复<code>change buffer</code>。不会丢失<br>(3)<code>change buffer</code>写入,<code>redo log</code>和<code>binlog</code>都已经<code>fsync</code>, 那么直接从<code>redo log</code>里恢复。不会丢失。</p>
<h2 id="第10讲-MySQL为什么有时候会选错索引？"><a href="#第10讲-MySQL为什么有时候会选错索引？" class="headerlink" title="第10讲 MySQL为什么有时候会选错索引？"></a>第10讲 MySQL为什么有时候会选错索引？</h2><p>通常查询语句使用哪个索引是由MySQL来决定的(优化器)。但我们也可以在SQL语句强制mysql使用指定的索引。</p>
<h3 id="force-index"><a href="#force-index" class="headerlink" title="force index"></a>force index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">FORCE</span> <span class="keyword">INDEX</span> (FIELD1) …</span><br></pre></td></tr></table></figure>
<h3 id="ignore-index"><a href="#ignore-index" class="headerlink" title="ignore index"></a>ignore index</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1 <span class="keyword">IGNORE</span> <span class="keyword">INDEX</span> (FIELD1, FIELD2) …</span><br></pre></td></tr></table></figure>
<h3 id="SQL-NO-CACHE"><a href="#SQL-NO-CACHE" class="headerlink" title="SQL_NO_CACHE"></a>SQL_NO_CACHE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE field1, field2 <span class="keyword">FROM</span> TABLE1;</span><br></pre></td></tr></table></figure>
<h3 id="选错索引例子"><a href="#选错索引例子" class="headerlink" title="选错索引例子"></a>选错索引例子</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>；</span><br><span class="line"><span class="comment"># 插入数据的存储过程</span></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>分析索引使用情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where a between 10000 and 20000;</span><br></pre></td></tr></table></figure>
<p>因为<code>a</code>字段上有索引，结果是使用索引。</p>
<p>如下操作显示MySQL选择的错误的索引：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_select_error_index.png">
<p>通过SQL进行验证：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure>
<h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>优化器根据查询的扫描行数，是否使用临时表，是否排序等因素来综合判断，生成执行计划。</p>
<p>MySQL在执行语句前会根据统计信息来估算可能的扫描行数，这个统计信息就是索引的区分度。</p>
<p>一个索引上不同值得个数称为基数。可以通过语句<code>show index from table;</code>来查看。</p>
<p>优化器同时会考虑使用普通索引时，查询回表的代价。</p>
<h4 id="采样统计"><a href="#采样统计" class="headerlink" title="采样统计"></a>采样统计</h4><p>MySQL默认选择N个数据页，统计N个页面上的不同值，得到一个平均值。平均值 * 索引的页面数 得到这个索引的基数。数据表一直更新，当变更的行数超过<code>1/M</code>时会触发一次新的索引统计计算。</p>
<p><code>innodb_stats_persistent = on</code> 表示MySQL的统计信息会持久化保存（这时N=20,M=10），<code>off</code>表示仅保存在内存中(这时N=8,M=16)。</p>
<h3 id="选错索引处理办法"><a href="#选错索引处理办法" class="headerlink" title="选错索引处理办法"></a>选错索引处理办法</h3><ol>
<li>由于统计信息不及时和不准确，可以通过<code>analyze table table_name</code>来重新统计索引信息。</li>
<li>通过<code>force index</code>语句来强制使用指定索引。</li>
<li>修改SQL语句，引导MySQL使用正确索引（前提是不改变SQL语句的业务逻辑）。</li>
<li>新增更合适的索引，或删除误用的索引。</li>
</ol>
<h3 id="课后题-4"><a href="#课后题-4" class="headerlink" title="课后题"></a>课后题</h3><p>如果没有<code>session A</code>的配合，只有<code>session B</code> 则会看到扫描行数还是<code>10000</code>左右，原因是什么?</p>
<p>答案：因为事务隔离级别是RR, 存在Session A的情况下，事务没有提交，原来插入的数据不能被删除。之前的每行数据有2个版本，旧版本是delete前的数据，新版本是标记为<code>deleted</code>的数据。session B又插入了10w上记录，这样索引a上就有2份数据。</p>
<p>主键索引扫描行数的估计值是通过<code>show table status like &#39;table_name&#39;</code> 来获取的。</p>
<h2 id="11讲-怎么给字符串字段加索引？"><a href="#11讲-怎么给字符串字段加索引？" class="headerlink" title="11讲 - 怎么给字符串字段加索引？"></a>11讲 - 怎么给字符串字段加索引？</h2><p>字符串字段添加索引有2中方式：</p>
<ol>
<li>整个字段的值都作为索引值。</li>
<li>字符串的前N个字符作为索引值。</li>
</ol>
<p>这两种做法各有利弊。整个字段作为索引，可以减少扫描行数，但是索引较大。<br>前缀索引索引占用空间小，但是扫描行数较多。所以在实践中，可以通过调节N的值，来平衡索引的大小和扫描的行数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br><span class="line"><span class="comment"># 取不同的N值，计算前缀索引的区分度。</span></span><br><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<p>使用前缀索引不能利用覆盖索引可以避免回表的优化机制，必须回表查询。</p>
<p>如果遇到前缀索引前N位区分度很小的情况下，有如下两种优化办法：</p>
<ol>
<li>倒序存储（例如身份证号，同一个地区，前6位都是相同的）。</li>
<li>对字段值进行hash,保存hash后的值，建立索引。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>倒序存储和hash，都不能进行范围查询。hash只能进行等值查询</li>
<li>倒叙存储和hash存储，插入数据和查询数据，都需要进行额外的计算（reverse , crc）。</li>
<li>和倒叙存储比较起来，hash存储方式查询效率更好。</li>
</ol>
<h2 id="12讲-为什么我的MySQL会“抖”一下？"><a href="#12讲-为什么我的MySQL会“抖”一下？" class="headerlink" title="12讲 - 为什么我的MySQL会“抖”一下？"></a>12讲 - 为什么我的MySQL会“抖”一下？</h2><p>通常的更新操作，只是更新内存数据页，写redo log，不会有大量的磁盘写入操作。这就导致磁盘数据页和内存数据页的数据不一致，这样的数据页称为<code>脏页</code>，MySQL会定时或被动触发将脏页刷新到磁盘中操作。</p>
<h3 id="刷脏页的触发时机"><a href="#刷脏页的触发时机" class="headerlink" title="刷脏页的触发时机"></a>刷脏页的触发时机</h3><p>场景一：当redo log写满了，也就是write pos 追上check point时, 如下图：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_flush_dirty_page.jpg">
<p>当check point 往前推进时，需要把推进区间内对应的脏页都写入磁盘。</p>
<p>场景二：当某个查询需要大量内存，但是内存空闲的干净页不足，此时需要把脏页写入磁盘来增加干净页。</p>
<p>场景三：系统空闲时，后台线程执行刷脏页操作。</p>
<p>场景四：MySQL停机。</p>
<p>我们在实践中需要尽量避免场景一的出现，因为此时MySQL不再执行任何更新操作。如果脏页积累的太多，会导致一次需要刷大量的脏页到磁盘，也是需要尽力避免。</p>
<h3 id="InnoDB刷脏页控制策略"><a href="#InnoDB刷脏页控制策略" class="headerlink" title="InnoDB刷脏页控制策略"></a>InnoDB刷脏页控制策略</h3><p>获取磁盘的IOPS</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure>
<p>告诉InnoDB磁盘的IOPS值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_io_capacity=IOPS</span><br></pre></td></tr></table></figure>
<p>参数<code>innodb_max_dirty_pages_pct</code>控制脏页比例的上限。</p>
<p>InnoDB根据当前的脏页比例M计算出一个[0 - 100]间的数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> M&gt;=innodb_max_dirty_pages_pct then</span><br><span class="line">      <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>*M/innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InnoDB每次写入的redo log都有一个序号(LSN)，当前写入日志的序号和check point直接的差值记为<code>N</code>，InnoDB会根据<code>N</code>算出一个0-100间的数字，这公式记为F2(N)，算法比较复杂，<code>N</code>越大，则结果越大。</p>
<p>InnoDB根据<code>F1(M)</code>和<code>F2(N)</code>二者结果的 <code>最大值</code> * <code>innodb_io_capacity</code>的结果控制刷脏页的速度。</p>
<p>可以通过如下语句计算脏页比例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty';</span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> global_status <span class="keyword">where</span> VARIABLE_NAME = <span class="string">'Innodb_buffer_pool_pages_total'</span>;</span><br><span class="line"><span class="keyword">select</span> @a/@b;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：InnoDB刷脏页的过程中，如果相邻页也是脏页，那么相邻页也会被刷到磁盘上，如果相邻页的相邻页也是脏页，也会被刷。也就是说这个过程是级联的。这会导致雪上加霜的效果。<code>innodb_flush_neighbors</code>参数就是控制这个机制的。设置为<code>0</code>表示只刷自己，为<code>1</code>。MySQL8.0默认值为<code>0</code>;</p>
</blockquote>
<h3 id="课后题-amp-讨论"><a href="#课后题-amp-讨论" class="headerlink" title="课后题&amp;讨论"></a>课后题&amp;讨论</h3><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>因内存不足导致刷脏页时，不会刷redo文件的。redo log 在重放时，如果一个数据页已经刷过的话，会被识别出来，并跳过。</p>
<h4 id="课后题-5"><a href="#课后题-5" class="headerlink" title="课后题"></a>课后题</h4><p>一个内存配置为 128GB、innodb_io_capacity=20000的高配实例，redo log设置为一个100MB的文件，会发生什么情况，原因是什么？</p>
<p>答案：因为redo log文件设置的比较小，那么redo log文件就容易写满，导致频繁刷脏页，由于磁盘的IOPS很大，监控上开起来磁盘压力不大，但是性能间歇性的不好，但是也不会降低很大，因为每次刷脏页的速度还是很快的。</p>
<h2 id="13讲-为什么表数据删掉一半，表文件大小不变？"><a href="#13讲-为什么表数据删掉一半，表文件大小不变？" class="headerlink" title="13讲 - 为什么表数据删掉一半，表文件大小不变？"></a>13讲 - 为什么表数据删掉一半，表文件大小不变？</h2><p>InnoDB 8.0以前，表结构保存在<code>.frm</code>文件中，从8.0开始运行把表结构保存到系统数据表中。因为表结构文件非常小心。</p>
<h3 id="innodb-file-per-table"><a href="#innodb-file-per-table" class="headerlink" title="innodb_file_per_table"></a>innodb_file_per_table</h3><p><code>innodb_file_per_table</code>参考用来控制表数据是放到共享表空间还是独立的文件。</p>
<ul>
<li>on: 表示每个数据表独立保存一个后缀为<code>.ibd</code>的文件中。</li>
<li>off: 表示数据放到系统共享表空间中，也就是和数据字典放在一起。</li>
</ul>
<p>从MySQL5.6.6开始，默认值就是<code>on</code>。建议一直将该参数设置为<code>on</code>，除了好管理外，<code>drop table</code> 后MySQL会直接删除该文件，否则保存在共享表空间，表删除了，但是空间不会自动释放。</p>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_delete.png">
<p>innodb删除数据是<code>标记删除</code>。标记删除的记录占用的空间可以被复用，单记录空间的复用只限于特定范围。</p>
<p>如果一个数据页的所有数据都被标记为删除，则整个数据页都可以被复用，并可以复用到任何位置。</p>
<p>如果相邻的两个页的空间利用率都比较小，innodb会将相邻的页合并为一个页，另一个页标记为可复用。</p>
<p>由于是标记删除，所以占用的磁盘空间并不会自动释放，导致的结果就是文件很大，记录数很少，把这些可以复用而没有使用的空间称为<code>空洞</code>。</p>
<p>删除，插入记录（页分裂，分配了一个新的页，导致2个页的空间利用率很低), 更新索引上的值，都会导致空洞的产生。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_page_split.png">
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>当你想要收缩表空间时，可以新建一个结构相同的表，将老表的数据导入新表，然后重命名，并删除旧表。</p>
<p>因为新表是按照索引递增的顺序插入数据记录，数据页的空间利用率很高，磁盘占用很少。</p>
<p>可以通过<code>alter table A engine=InnoDB</code>来实现这个操作。但是需要注意的是在MySQL5.5版本前，这个操作执行过程中，老的表不能有数据更新（不能进行DML操作），否则会导致丢失更新。也就是说这个操作不是Online的。而在MySQL5.6版本引入了Online DDL，优化了该流程（原理是：导数据的过程中记录老表的变更操作到文件中，数据导完后，再应用期间的变更），可以在放心使用。</p>
<p>注意：针对较大的表，导数据过程中需要大量的CPU和I/O资源，可以选择在业务低峰期进行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># inplace 方式（server 层视角）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br><span class="line"><span class="comment"># copy 拷贝方式（MySQL老版本实现方式）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure>
<h3 id="online-vs-inplace"><a href="#online-vs-inplace" class="headerlink" title="online vs inplace"></a>online vs inplace</h3><ol>
<li>DDL的过程是online的，那一定就是inplace的。</li>
<li>反过来未必，也就是说inplace的DDL不一定是online的。截止到MySQL8.0，添加全文索引和空间索引就是这种情况。</li>
</ol>
<h3 id="optimize-table-vs-analyze-table-vs-alter-table-engine-innodb"><a href="#optimize-table-vs-analyze-table-vs-alter-table-engine-innodb" class="headerlink" title="optimize table vs analyze table vs alter table engine=innodb"></a>optimize table vs analyze table vs alter table engine=innodb</h3><p><code>optimize table</code> = recreate + analyze</p>
<p><code>analyze table</code> 没有重建表，只是更新索引统计信息。</p>
<p><code>alter table engine=innodb</code> 就是重建表recreate。</p>
<p><code>truncate table</code> = drop + create</p>
<h3 id="课后题-6"><a href="#课后题-6" class="headerlink" title="课后题"></a>课后题</h3><p>有没有可能执行完<code>alter table engine=innodb</code>后数据文件反而变大的情况？ 原因可能是什么？</p>
<p>答案：有的。</p>
<ol>
<li>刚进行完表的重建后再次进行重建，期间有DML操作，这些新的操作导致有空洞的产生。</li>
<li>表的重建，每个数据页不是完全满的，InnoDB会预留一部分空间。但是在数据页的合并过程中每个数据页可能是完全满的。</li>
<li>重建表后，插入一些数据占用预留空间，再次重建表，导致新增预留空间，数据文件会变大。</li>
</ol>
<h2 id="14讲-count-这么慢，我该怎么办？"><a href="#14讲-count-这么慢，我该怎么办？" class="headerlink" title="14讲 - count(*)这么慢，我该怎么办？"></a>14讲 - count(*)这么慢，我该怎么办？</h2><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*) 的实现方式"></a>count(*) 的实现方式</h3><p>不同的存储引擎实现方式不同。下文讨论的都是不加<code>where</code>条件的。</p>
<ul>
<li>MyISAM 会把表的总数保存到磁盘上，执行count(*)时直接返回</li>
<li>InnoDB 执行count(*)时，需要把数据从引擎中一行行读出来进行累加，速度较慢。</li>
</ul>
<p>InnoDB由于MVCC的原因，每个事务查询时，返回的总数都不是确定的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_innodb_count.png">
<p>InnoDB在执行<code>count(*)</code>时，也会做一点优化。主键索引树的叶子节点是数据，普通索引的叶子节点是主键值。索引普通索引比主键索引小很多。因此MySQL优化器会选择最小的索引树进行遍历获取<code>count(*)</code>的值。</p>
<p><code>show table status</code> 显示的记录数是估值，官方文档说误差在40%到50%，因此也不准确。</p>
<h3 id="如何快速计算表的记录总数"><a href="#如何快速计算表的记录总数" class="headerlink" title="如何快速计算表的记录总数"></a>如何快速计算表的记录总数</h3><ul>
<li>如果不需要完全准确的值，可以缓存表的记录数，动态更新 并 定时全表扫描更新缓存中的值。</li>
<li>通过数据库<code>独立计数表</code>进行统计，通过事务保证计数值和表记录总数的一致性。</li>
</ul>
<h3 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h3><p>count是一个聚合函数（server层实现的，这个很重要），只要参数判断不为NULL，计数值就+1</p>
<p>count(*)， count(主键)， count(1)都表示满足条件的记录总数。</p>
<p>count(字段) 表示满足条件并且该字段不为null的记录总数。</p>
<p>性能差别：</p>
<ol>
<li>server层要什么字段，引擎层就给什么字段</li>
<li>InnoDB只给必要的值</li>
<li>现在的优化器只优化了<code>count(*)</code>的语义为<code>取行数</code>，其他<code>显而易见</code>的优化并没有做。</li>
</ol>
<h4 id="count-主键"><a href="#count-主键" class="headerlink" title="count(主键)"></a>count(主键)</h4><p>InnoDB遍历表，把每一行的主键取出来返回给Server层。</p>
<h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>InnoDB遍历表，但是不取值，server层对返回的每一行，放入。<br>一个数字<code>1</code>进行判断，判断是不肯能为空的，按行累加。</p>
<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><code>count(*)</code> 并不会把全部字段取出来，而是专门做了优化，不取值。<code>count(*)</code>肯定不为NULL，按行累加。</p>
<h4 id="count-字段"><a href="#count-字段" class="headerlink" title="count(字段)"></a>count(字段)</h4><ol>
<li>如果字段定义为Not null， 从每一行中读取该字段，判断不能为null，按行累加。</li>
<li>如果字段定义为可以为NULL，那么还是需要从行中读取该字段，并判断是否为NULL，不是NULL才进行累加。</li>
</ol>
<p>综上，按照效率来说，count(字段) &lt; count(主键) &lt; count(1) ≈ count(*)</p>
<p>所以建议使用<code>count(*)</code></p>
<h2 id="15讲-日志和索引相关问题"><a href="#15讲-日志和索引相关问题" class="headerlink" title="15讲 - 日志和索引相关问题"></a>15讲 - 日志和索引相关问题</h2><p>MySQL在崩溃恢复时，是通过binlog和redo log共同判断事务应该提交还是回滚：</p>
<ol>
<li>如果redo log里面的事务是完整的，并且有commit标志，那么直接提交事务。</li>
<li>redo log里面的事务有完整的prepare，如果binlog完整，则提交事务，否则回滚事务。</li>
</ol>
<h3 id="MySQL如何知道binlog的完整性？"><a href="#MySQL如何知道binlog的完整性？" class="headerlink" title="MySQL如何知道binlog的完整性？"></a>MySQL如何知道binlog的完整性？</h3><p>一个事务的binlog是有完整格式的</p>
<ul>
<li>statement格式的binlog，最后会有<code>COMMMIT</code>.</li>
<li>row格式的binlog，最后会有一个XID event.</li>
<li>5.6.2版本后，添加了binlog-checksum参数，用来验证binlog的完整性。</li>
</ul>
<h3 id="redo-log-如何和-binlog进行关联"><a href="#redo-log-如何和-binlog进行关联" class="headerlink" title="redo log 如何和 binlog进行关联"></a>redo log 如何和 binlog进行关联</h3><p>redo log 和 binlog 有一个共同的数据字段<code>XID</code>。</p>
<h3 id="处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计"><a href="#处于-prepare-阶段的-redo-log-加上完整-binlog，重启就能恢复，MySQL-为什么要这么设计" class="headerlink" title="处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?"></a>处于 prepare 阶段的 redo log 加上完整 binlog，重启就能恢复，MySQL 为什么要这么设计?</h3><p>binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</p>
<h3 id="如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"><a href="#如果这样的话，为什么还要两阶段提交呢？干脆先-redo-log-写完，再写-binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？" class="headerlink" title="如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？"></a>如果这样的话，为什么还要两阶段提交呢？干脆先 redo log 写完，再写 binlog。崩溃恢复的时候，必须得两个日志都完整才可以。是不是一样的逻辑？</h3><p>对于 InnoDB 引擎来说，如果 redo log 提交完成了，事务就不能回滚（如果这还允许回滚，就可能覆盖掉别的事务的更新）。而如果 redo log 直接提交，然后 binlog 写入的时候失败，InnoDB 又回滚不了，数据和 binlog 日志又不一致了。</p>
<h3 id="不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？"><a href="#不引入两个日志，也就没有两阶段提交的必要了。只用-binlog-来支持崩溃恢复，又能支持归档，不就可以了？" class="headerlink" title="不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？"></a>不引入两个日志，也就没有两阶段提交的必要了。只用 binlog 来支持崩溃恢复，又能支持归档，不就可以了？</h3><p>答案是不可以。binlog 没有能力恢复“数据页”。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_binlog_crash_safe.jpg">
<h3 id="那能不能反过来，只用-redo-log，不要-binlog？"><a href="#那能不能反过来，只用-redo-log，不要-binlog？" class="headerlink" title="那能不能反过来，只用 redo log，不要 binlog？"></a>那能不能反过来，只用 redo log，不要 binlog？</h3><p>回答：如果只从崩溃恢复的角度来讲是可以的。你可以把 binlog 关掉，这样就没有两阶段提交了，但系统依然是 crash-safe 的。</p>
<p>但是，如果你了解一下业界各个公司的使用场景的话，就会发现在正式的生产库上，binlog 都是开着的。因为 binlog 有着 redo log 无法替代的功能。</p>
<p>一个是归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</p>
<p>一个就是 MySQL 系统依赖于 binlog。binlog 作为 MySQL 一开始就有的功能，被用在了很多地方。其中，MySQL 系统高可用的基础，就是 binlog 复制。</p>
<p>还有很多公司有异构系统（比如一些数据分析系统），这些系统就靠消费 MySQL 的 binlog 来更新自己的数据。关掉 binlog 的话，这些下游系统就没法输入了。</p>
<p>总之，由于现在包括 MySQL 高可用在内的很多系统机制都依赖于 binlog，所以“鸠占鹊巢”redo log 还做不到。你看，发展生态是多么重要。</p>
<h3 id="追问-7：redo-log-一般设置多大？"><a href="#追问-7：redo-log-一般设置多大？" class="headerlink" title="追问 7：redo log 一般设置多大？"></a>追问 7：redo log 一般设置多大？</h3><p>回答：redo log 太小的话，会导致很快就被写满，然后不得不强行刷 redo log，这样 WAL 机制的能力就发挥不出来了。</p>
<p>所以，如果是现在常见的几个 TB 的磁盘的话，就不要太小气了，直接将 redo log 设置为 4 个文件、每个文件 1GB 吧。</p>
<h3 id="追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？"><a href="#追问-8：正常运行中的实例，数据写入后的最终落盘，是从-redo-log-更新过来的还是从-buffer-pool-更新过来的呢？" class="headerlink" title="追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？"></a>追问 8：正常运行中的实例，数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</h3><p>回答：这个问题其实问得非常好。这里涉及到了，“redo log 里面到底是什么”的问题。</p>
<p>实际上，redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页，也就不存在“数据最终落盘，是由 redo log 更新过去”的情况。</p>
<p>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。这个过程，甚至与 redo log 毫无关系。</p>
<p>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它读到内存，然后让 redo log 更新内存内容。更新完成后，内存页变成脏页，就回到了第一种情况的状态。</p>
<h3 id="追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？"><a href="#追问-9：redo-log-buffer-是什么？是先修改内存，还是先写-redo-log-文件？" class="headerlink" title="追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？"></a>追问 9：redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</h3><p>在一个事务的更新过程中，日志是要写多次的。比如下面这个事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 ...</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个事务要往两个表中插入记录，插入数据的过程中，生成的日志都得先保存起来，但又不能在还没 commit 的时候就直接写到 redo log 文件里。</p>
<p>所以，redo log buffer 就是一块内存，用来先存 redo 日志的。也就是说，在执行第一个 insert 的时候，数据的内存被修改了，redo log buffer 也写入了日志。</p>
<p>但是，真正把日志写到 redo log 文件（文件名是 ib_logfile+ 数字），是在执行 commit 语句的时候做的。（这里说的是事务执行过程中不会“主动去刷盘”，以减少不必要的 IO 消耗。但是可能会出现“被动写入磁盘”，比如内存不够、其他事务提交等情况。这个问题我们会在后面第 22 篇文章《MySQL 有哪些“饮鸩止渴”的提高性能的方法？》中再详细展开）。</p>
<p>单独执行一个更新语句的时候，InnoDB 会自己启动一个事务，在语句执行完成的时候提交。过程跟上面是一样的，只不过是“压缩”到了一个语句里面完成。</p>
<h3 id="课后题-7"><a href="#课后题-7" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">`id` int(11) NOT NULL primary key auto_increment,</span><br><span class="line">`a` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>执行如下的语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t set a=2 where id=1;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br><img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value.png"></p>
<p>仅从现象上看，MySQL 内部在处理这个命令的时候，可以有以下三种选择：</p>
<ol>
<li>更新都是先读后写的，MySQL 读出数据，发现 a 的值本来就是 2，不更新，直接返回，执行结束；</li>
<li>MySQL 调用了 InnoDB 引擎提供的“修改为 (1,2)”这个接口，但是引擎发现值与原来相同，不更新，直接返回；</li>
<li>InnoDB 认真执行了“把这个值修改成 (1,2)”这个操作，该加锁的加锁，该更新的更新。</li>
</ol>
<p>答案：第三种。分析如下：</p>
<p>针对第一种假设：如果不更新，直接返回。那么就不会加行锁。因此可以通过如下步骤验证</p>
<ol>
<li>SessionA 开启一个事务执行update语句，不提交事务。</li>
<li>SessionB 执行同样的更新语句，如果出现Block现象，那么说明SessionA对数据加了行锁，也就是说Server层调用了InnoDB的更新接口。(<code>行锁是在InnoDB中实现的</code>)</li>
</ol>
<p>针对第二种假设：如果InnoDB没有进行数据更新，那么在RR事务隔离级别下，A和B两个事务执行同样的更新语句，B事务的更新对A事务不可见，在A事务中，更新语句前后执行查询语句，如果2次的查询结果都是2，说明InnoDB确实没有执行更新操作。如果第二次查询可以看到更新后的值，说明InnoDB执行了更新。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_1.png">
<p>如果InnoDB能肯定更新前后的值相同，它确实不会再执行更新的。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_update_same_value_2.png">
<p>where 语句有<code>k=3</code>这个条件，更新后还是3，InnoDB确实就不进行更新了。</p>
<p>注意：虽然InnoDB执行了更新，但是对MySQL Server层来说，前后的数据并没有变，row 格式下也不会产生binlog。</p>
<h2 id="第16讲-“order-by”是怎么工作的？"><a href="#第16讲-“order-by”是怎么工作的？" class="headerlink" title="第16讲 -  “order by”是怎么工作的？"></a>第16讲 -  “order by”是怎么工作的？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>查询排序语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by.png">
<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>MySQL给每个线程分配一个排序缓存(sort buffer)，针对上面的查询排序语句，MySQL从<code>city</code>索引树上查询满足条件的记录主键，回表查询<code>city,name,age</code>自动的值放入sort buffer。 最后对sort buffer中的记录按name字段进行快速排序，将排序结果的前1000条数据返回。</p>
<p><code>sort buffer</code>有大小，如果满足条件的记录在<code>sort buffer</code>把放不下，则需要使用文件排序（归并排序）。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_diagram.jpg">
<p>参数：<code>sort_buffer_size</code> 可以控制 排序缓存的大小，增大该参数的值，可以加速排序。</p>
<p>通过下面的语句来验证查询是否使用了临时文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>如果查询的结果需要返回记录的大部分字段或者或者所有字段，此时会占用大量内存，很容易导致采用文件排序，效率是低下的。MySQL针对这种情况进行了优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>这个参数是专门控制参与内存排序的数据行大小的，如果参与排序的数据行大小大于该值，那么MySQL将采用另一种排序算法：</p>
<ol>
<li>将满足条件的记录中需要参与排序的字段和主键放入sort buffer。</li>
<li>对sort buffer中的记录按name进行排序。</li>
<li>取出排序结果的前1000行，根据ID，查询主键索引树，获取要返回的字段值。</li>
</ol>

<h3 id="全字段排序-vs-rowid排序"><a href="#全字段排序-vs-rowid排序" class="headerlink" title="全字段排序 vs rowid排序"></a>全字段排序 vs rowid排序</h3><ol>
<li>MySQL倾向于使用内存排序，所以尽量使用大内存机器，避免文件排序和rowid排序(需要回表，查询慢)</li>
<li>查询语句尽量只返回需要的字段，不要<code>select *</code></li>
<li>适当调高<code>max_length_for_sort_data</code>的值。</li>
</ol>
<h3 id="避免排序"><a href="#避免排序" class="headerlink" title="避免排序"></a>避免排序</h3><p>并不是所有的order by都会排序。如果从索引树上获取的结果集本身就是有序的就可以避免排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>
<p>有了这个索引，city相同，name本身就是有序的，就避免了排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_not_need_sort.jpg">
<p>explain:</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_using_index.png">
<h4 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure>
<p>有了覆盖索引的优化，避免了回表，性能进一步提高。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index.jpg">
<p>explain结果：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_order_by_cover_index_explain.png">
<h3 id="explain-type"><a href="#explain-type" class="headerlink" title="explain type"></a>explain type</h3><p>all : 全表扫描</p>
<p>index: 使用索引，如果是覆盖索引，可以不用回表，如果没有where条件，会扫描整个索引树。</p>
<p>range: 以范围的形式扫描索引树。 </p>
<p>ref: 非唯一索引引用</p>
<p>eq_ref: 等值引用。 使用有唯一性索引查找（主键或唯一性索引）</p>
<p>const：（常量连接）被称为<code>常量</code>，这个词不好理解，不过出现 const 的话就表示发生下面两种情况：</p>
<ol>
<li>在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id=1 就肯定只有一行，只需读取一次表数据便能取得所需的结果，且表数据在分解执行计划时读取。返回值直接放在 select 语句中，类似 select 1 AS f 。可以通过 extended 选择查看内部过程：</li>
</ol>
<h3 id="explain-extra"><a href="#explain-extra" class="headerlink" title="explain extra"></a>explain extra</h3><ul>
<li><code>Using filesort</code> : 通常在使用到排序语句ORDER BY的时候，会出现该信息，表示一种排序算法，可能使用文件排序。</li>
<li><code>Using index</code> : 表示只使用了索引，不用回表，使用了覆盖索引。如果同时出现<code>Using where</code>，表示需要回表。</li>
<li><code>Using where</code>：表示条件查询，如果不读取表的所有数据，或不是仅仅通过索引就可以获取所有需要的数据，则会出现<code>Using where</code>。如果type列是<code>ALL</code>或<code>index</code>，而没有出现该信息，则有可能在执行错误的查询：返回所有数据。  </li>
<li><code>Using temporary</code>：表示为了得到结果，使用了临时表，这通常是出现在多表联合查询，结果排序的场合。</li>
</ul>
<h2 id="课后题-8"><a href="#课后题-8" class="headerlink" title="课后题"></a>课后题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> city <span class="keyword">in</span> （<span class="string">'杭州'</span>,<span class="string">'苏州'</span>）<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>答案：拆为2次查询，应用内归并排序，取前100行。</p>
<p>如果是<code>limit 10000, 100</code>的话，解决思路也是类似的。但缺点是应用需要保存大量的数据，如果offset太大的话，客户端内存排序就不可行了（内存溢出）。</p>
<p>为了减少内存占用，可以只返回<code>id,name</code>字段数据，排序后，用ID再查询数据库获取数据。</p>
<h2 id="第17讲-如何正确地显示随机消息？"><a href="#第17讲-如何正确地显示随机消息？" class="headerlink" title="第17讲 - 如何正确地显示随机消息？"></a>第17讲 - 如何正确地显示随机消息？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure>
<p>随机排序，取前3个。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_mem_temp.png">
<p>上图表示使用了<code>内存临时表</code>，并且进行了排序。</p>
<p>由于内存临时表的回表速度非常快，MySQL此时优先选择排序是排序行越少越好，就是rowid排序。</p>
<p>上述语句的执行流程：</p>
<ol>
<li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li>
<li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li>
<li>现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。</li>
<li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li>
<li>从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li>
<li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li>
<li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li>
</ol>
<p>慢查询日志分析：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Query_time: 0.900376  Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span></span><br><span class="line"><span class="keyword">SET</span> <span class="built_in">timestamp</span>=<span class="number">1541402277</span>;</span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_random_sort_diag.png">
<h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>不是所有的临时表都是内存临时表（memory引擎）。</p>
<p>参数<code>tmp_table_size</code>限制内存临时表的大小，默认是16MB。大于该值就转为磁盘临时表（默认是InnoDB引擎，可以通过<code>internal_tmp_disk_storage_engine</code>来控制， 该临时表没有显示索引）。</p>
<p>MySQL5.6引入了一个新的排序算法，优先级队列排序，其实就是堆排序。用来处理TOP(n)的情况，可以避免对整个数据进行排序。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_sort_heap.png">
<p>但是使用优先级队列排序的前提是：待排序的数据集不能超过<code>sort_buffer_size</code></p>
<h3 id="随机排序方法"><a href="#随机排序方法" class="headerlink" title="随机排序方法"></a>随机排序方法</h3><p>随机算法一：</p>
<p>生成一个ID最小值和最大值之间的随机数，取大于整个值的第一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select max(id),min(id) into @M,@N from t ;</span><br><span class="line"><span class="keyword">set</span> @X= <span class="keyword">floor</span>((@M-@N+<span class="number">1</span>)*<span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法效率很高，因为取 max(id) 和 min(id) 都是不需要扫描索引的，而第三步的 select 也可以用索引快速定位，可以认为就只扫描了 3 行。但实际上，这个算法本身并不严格满足题目的随机要求，因为 ID 中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。</p>
<p>随机算法二：</p>
<p>生成一个小于数据总行数C的随机数Y，<code>limit Y , 1</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sql</span> = <span class="keyword">concat</span>(<span class="string">"select * from t limit "</span>, @Y, <span class="string">",1"</span>);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure>
<p>MySQL 处理 limit Y,1 的做法就是按顺序一个一个地读出来，丢掉前 Y 个，然后把下一个记录作为返回结果，因此这一步需要扫描 Y+1 行。再加上，第一步扫描的 C 行，总共需要扫描 C+Y+1 行，执行代价比随机算法 1 的代价要高。</p>
<p>随机算法三：</p>
<p>要获取N个随机数，只需要执行N次获取随机数第Y行的操作，再获取每次的行即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) into @C from t;</span><br><span class="line"><span class="keyword">set</span> @Y1 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y2 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y3 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y1，<span class="number">1</span>； // 在应用代码里面取 Y1、Y2、Y3 值，拼出 <span class="keyword">SQL</span> 后执行</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y2，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y3，<span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p>注意：需要注意去重问题。</p>
<h3 id="课后题-9"><a href="#课后题-9" class="headerlink" title="课后题"></a>课后题</h3><p>上面的随机算法 3 的总扫描行数是 C+(Y1+1)+(Y2+1)+(Y3+1)，实际上它还是可以继续优化，来进一步减少扫描行数的。</p>
<p>我的答案：</p>
<p>C的扫描过程可以通过单独的计数来避免，如何计数可以参考前面<code>count(*)</code>的内容。</p>
<p>Y1,Y2,Y3的扫描优化: 对Y1, Y2, Y3进行排序，假设排序后 Y1 &lt; Y2 &lt; Y3。 Y1的扫描不可避免，获取Y1+1的行ID记为min_id， 然后<code>where id &gt; min_id_1 limit (Y2 - Y1), 1</code>;</p>
<p>其他答案：</p>
<ol>
<li>对有空洞的表进行整理，消除空洞后，利用算法一。</li>
<li>老师的方法：取 Y1、Y2 和 Y3 里面最大的一个数，记为 M，最小的一个数记为 N，然后执行下面这条 SQL 语句：<code>mysql&gt; select * from t limit N, M-N+1;</code></li>
</ol>
<h2 id="18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？"><a href="#18讲-为什么这些SQL语句逻辑相同，性能却差异巨大？" class="headerlink" title="18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？"></a>18讲 - 为什么这些SQL语句逻辑相同，性能却差异巨大？</h2><p>在 MySQL 中，有很多看上去逻辑相同，但性能却差异巨大的 SQL 语句。对这些语句使用不当的话，就会不经意间导致整个数据库的压力变大。</p>
<h3 id="案例一：条件字段函数操作"><a href="#案例一：条件字段函数操作" class="headerlink" title="案例一：条件字段函数操作"></a>案例一：条件字段函数操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `tradelog` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `operator` int(11) DEFAULT NULL,</span><br><span class="line">  `t_modified` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`),</span><br><span class="line">  KEY `t_modified` (`t_modified`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>查询交易记录日志表，每年7月份的总数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where month(t_modified)=7;</span><br></pre></td></tr></table></figure>
<p>这条语句会执行全表扫描或索引扫描。原因如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_index_func.png">
<p>month函数计算后导致无法使用索引。</p>
<p>推而广之：针对索引自动进行函数操作，结果可能破坏索引的有序性，导致不能使用索引。</p>
<p>针对该问题，下面的SQL可以解决。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tradelog where</span><br><span class="line">    -&gt; (t_modified &gt;= '2016-7-1' and t_modified&lt;'2016-8-1') or</span><br><span class="line">    -&gt; (t_modified &gt;= '2017-7-1' and t_modified&lt;'2017-8-1') or </span><br><span class="line">    -&gt; (t_modified &gt;= '2018-7-1' and t_modified&lt;'2018-8-1');</span><br></pre></td></tr></table></figure>
<p>优化器也有<code>偷懒</code>的行为, 即使是对于不改变有序性的函数，也不会考虑使用索引。比如，对于 <code>select * from tradelog where id + 1 = 10000</code> 这个 SQL 语句，这个加 1 操作并不会改变有序性，但是 MySQL 优化器还是不能用 id 索引快速定位到 9999 这一行。所以，需要你在写 SQL 语句的时候，手动改写成 <code>where id = 10000 - 1</code> 才可以(这也说明，优化器会先计算<code>10000 - 1</code>表达式，通结果作为条件)。</p>
<h3 id="案例二：隐式类型转换"><a href="#案例二：隐式类型转换" class="headerlink" title="案例二：隐式类型转换"></a>案例二：隐式类型转换</h3><p>数字字符串和数字进行比较时，会先转为数字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">"10"</span> &gt; <span class="number">9</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment"># 结果是：1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where tradeid=110717;</span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tradelog where  CAST(tradid AS signed int) = 110717;</span><br></pre></td></tr></table></figure>
<p>对索引字段执行了cast函数，优化器判断不能使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">id</span>=<span class="string">"83126"</span>;</span><br></pre></td></tr></table></figure>
<p>上面的SQL可以使用索引，原因是优化器可以先将”83126”转为数字83126，然后进行查询，此时可以利用索引。</p>
<h3 id="案例三：隐式字符编码转换"><a href="#案例三：隐式字符编码转换" class="headerlink" title="案例三：隐式字符编码转换"></a>案例三：隐式字符编码转换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `trade_detail` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `tradeid` varchar(32) DEFAULT NULL,</span><br><span class="line">  `trade_step` int(11) DEFAULT NULL, <span class="comment">/* 操作步骤 */</span></span><br><span class="line">  `step_info` varchar(32) DEFAULT NULL, <span class="comment">/* 步骤信息 */</span></span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `tradeid` (`tradeid`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tradelog <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1000</span>, <span class="keyword">now</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'aaaaaaaa'</span>, <span class="number">3</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">4</span>, <span class="string">'aaaaaaab'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'aaaaaaab'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">6</span>, <span class="string">'aaaaaaab'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">7</span>, <span class="string">'aaaaaaab'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">8</span>, <span class="string">'aaaaaaac'</span>, <span class="number">1</span>, <span class="string">'add'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">9</span>, <span class="string">'aaaaaaac'</span>, <span class="number">2</span>, <span class="string">'update'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">'aaaaaaac'</span>, <span class="number">3</span>, <span class="string">'update again'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> trade_detail <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'aaaaaaac'</span>, <span class="number">4</span>, <span class="string">'commit'</span>);</span><br></pre></td></tr></table></figure>
<p>关联查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l, trade_detail d where d.tradeid=l.tradeid and l.id=2; /* 语句 Q1*/</span><br></pre></td></tr></table></figure>
<p>查询trade_detail时不能使用tradeid索引的原因是2个表的字符集不同。</p>
<p>tradelog表的字符集是utf8mb4, trade_detail表是utf8。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> trade_detail  <span class="keyword">where</span> <span class="keyword">CONVERT</span>(traideid <span class="keyword">USING</span> utf8mb4)=$L2.tradeid.value;</span><br></pre></td></tr></table></figure>
<p>有了前面的分析，我们提前将查询条件进行手动转换，这样就可以利用索引了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select d.* from tradelog l , trade_detail d where d.tradeid=CONVERT(l.tradeid USING utf8) and l.id=2;</span><br></pre></td></tr></table></figure>
<h2 id="19讲-为什么我只查一行的语句，也执行这么慢？"><a href="#19讲-为什么我只查一行的语句，也执行这么慢？" class="headerlink" title="19讲 - 为什么我只查一行的语句，也执行这么慢？"></a>19讲 - 为什么我只查一行的语句，也执行这么慢？</h2><h3 id="等待MDL锁"><a href="#等待MDL锁" class="headerlink" title="等待MDL锁"></a>等待MDL锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i)</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>查询语句：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1;</span><br></pre></td></tr></table></figure>
<p>这个查询为啥慢呢？ 如果还记得MDL元数据锁的话，你就理解了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">processlist</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl.png">
<p>如何复现(5.7)：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_wait_mdl_case.png">
<p>SessionA 持有表的MDL写锁， SessionB要获取MDL读锁，只能等待。</p>
<p>解决版本是kill掉持有MDL写锁的线程。</p>
<p>但是，由于在 show processlist 的结果里面，session A 的 Command 列是“Sleep”，导致查找起来很不方便。不过有了 <code>performance_schema</code> 和 <code>sys</code> 系统库以后，就方便多了。（MySQL 启动时需要设置 performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失)</p>
<p>通过查询 <code>sys.schema_table_lock_waits</code> 这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
<h3 id="等待flush"><a href="#等待flush" class="headerlink" title="等待flush"></a>等待flush</h3><p>flush 表时，查询语句需要等待flush执行完才能继续执行。</p>
<p>MySQL 里面对表做 flush 操作的用法，一般有以下两个</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> t <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;</span><br></pre></td></tr></table></figure>
<p>通常这2个语句都执行的很快，除非被其他语句阻塞。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_flush_table.png">
<p>flush被一个查询语句阻塞，进而导致我们的查询阻塞。</p>
<h3 id="等行锁"><a href="#等行锁" class="headerlink" title="等行锁"></a>等行锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1 lock in share mode;</span><br></pre></td></tr></table></figure>
<p>这个语句要获取一个读锁，如果这一行正在被更新，也就是说被加了写锁，那么该语句只能等待。</p>
<p>读写互斥，2个写操作也是互斥的。</p>
<p>在MySQL5.7版本，可以通过下面的语句查询锁的持有情况：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table=`'test'.'t'`\G</span><br></pre></td></tr></table></figure>
<h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>在没有索引的字段执行查询，在数据量比较大时，查询就很慢。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where c=50000 limit 1;</span><br></pre></td></tr></table></figure>
<p>字段c长没有建索引。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=1；</span><br></pre></td></tr></table></figure>
<p>id字段有索引，而且是快照读，按理说应该很快。但有时候可能执行的非常慢。</p>
<p>原因在于：在一个事务中，这个查询语句2次执行期间，如果该行数据被频繁更新，这样就导致unlog非常大，<br>因为是快照读，所以第二次查询需要：<code>根据当前值逐一应用undo log，直到查询到自己事务开始的版本</code>。</p>
<p>这种情况下，加锁读反而很快。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog.png">
<p>应用undo log。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_slow_query_undolog_1.png">
<h3 id="课后题-10"><a href="#课后题-10" class="headerlink" title="课后题"></a>课后题</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>这个语句序列是怎么加锁的呢？加的锁又是什么时候释放呢？</p>
<p>答案：</p>
<p>RC隔离级别：</p>
<p>所有扫描到的行都需要加锁，在返回到Server层后，会<code>提前释放</code>不满足条件的行锁。<br>原因是不需要解决幻读问题。</p>
<p>RR隔离解绑：</p>
<p>所有扫描到的行都需要加锁，行之间会添加间隙锁(gap锁)</p>
<h2 id="20讲-幻读是什么，幻读有什么问题？"><a href="#20讲-幻读是什么，幻读有什么问题？" class="headerlink" title="20讲 - 幻读是什么，幻读有什么问题？"></a>20讲 - 幻读是什么，幻读有什么问题？</h2><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/PhantomRead.png">
<h3 id="幻读定义"><a href="#幻读定义" class="headerlink" title="幻读定义"></a>幻读定义</h3><p>幻读指的是在一个事务中，前后2次查询同一个范围内的数据，第二次查询返回第一次查询没有看到的行的现象。</p>
<ol>
<li>在RR隔离级别下，普通的读是快照读，是不会看到别的事务插入的数据的。只有<code>当前读</code>才会出现幻读现象。</li>
<li>幻读仅专指<code>新插入的行</code>。</li>
</ol>
<h3 id="幻读的问题"><a href="#幻读的问题" class="headerlink" title="幻读的问题"></a>幻读的问题</h3><h3 id="语义的问题"><a href="#语义的问题" class="headerlink" title="语义的问题"></a>语义的问题</h3><p>破坏了sql语句的语义。</p>
<h4 id="数据一致性的问题"><a href="#数据一致性的问题" class="headerlink" title="数据一致性的问题"></a>数据一致性的问题</h4><img src="/2018/12/21/geektime-mysql-learn/PhantomReadConsitentProblem.png">
<p>binlog总SQL语句时序如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session B</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"><span class="comment">-- session C</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"><span class="comment">-- session A</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/* 所有 d=5 的行，d 改成 100*/</span></span><br></pre></td></tr></table></figure>
<p><em>注意</em>:事务提交时写入binlog。session A最后提交，所以最后写入binlog。</p>
<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>为了解决幻读问题，MySQL引入了间隙锁(Gap Lock)， 间隙锁锁的是2个值之间的空隙。</p>
<blockquote>
<p>跟间隙锁存在冲突关系的，是<code>往这个间隙中插入一个记录</code>这个操，两个间隙锁不冲突。<br>间隙锁和行锁合称:<code>next-key lock</code>, 每个 <code>next-key lock</code> 都是前开后闭区间<br>间隙锁的引入，导致锁定的范围更大，更容易引起死锁问题，同时影响并发度。<br>间隙锁只有在RR隔离级别下才生效，在生产环境中可以通过<code>RC</code>隔离级别 + <code>binlog format = row</code>的配置来解决数据不一致的问题。</p>
</blockquote>
<h3 id="课后题-11"><a href="#课后题-11" class="headerlink" title="课后题"></a>课后题</h3>
<p>session B 和 session C 都会阻塞，原因如下：</p>
<p>session A加的锁如下：</p>
<ol>
<li>由于是 order by c desc，第一个要定位的是索引 c 上“最右边的”c=20 的行，所以会加上间隙锁 (20,25) 和 next-key lock (15,20]。</li>
<li>在索引 c 上向左遍历，要扫描到 c=10 才停下来，所以 next-key lock 会加到 (5,10]，这正是阻塞 session B 的 insert 语句的原因。</li>
<li>在扫描过程中，c=20、c=15、c=10 这三行都存在值，由于是 <code>select *</code>，所以会在主键 id 上加三个行锁。</li>
</ol>
<p>因此，session A 的 select 语句锁的范围就是：</p>
<ol>
<li>索引 c 上 (5, 25)；</li>
<li>主键索引上 id=10、15、20 三个行锁。</li>
</ol>
<h2 id="21-讲-为什么我只改一行的语句，锁这么多？"><a href="#21-讲-为什么我只改一行的语句，锁这么多？" class="headerlink" title="21 讲 为什么我只改一行的语句，锁这么多？"></a>21 讲 为什么我只改一行的语句，锁这么多？</h2><h3 id="加锁规则总结"><a href="#加锁规则总结" class="headerlink" title="加锁规则总结"></a>加锁规则总结</h3><h4 id="版本条件"><a href="#版本条件" class="headerlink" title="版本条件"></a>版本条件</h4><p>5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8….</p>
<h4 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h4><p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
<p>原则 2：查找过程中访问到的对象才会加锁。</p>
<p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
<p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
<p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo1.png">
<p>由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：</p>
<p>根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；</p>
<p>同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。</p>
<p>所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。</p>
<h4 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h4><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo2.png">
<p>根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。</p>
<p>要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。</p>
<p>但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。</p>
<p>根据原则 2 ，<code>只有访问到的对象才会加锁</code>，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。</p>
<p>但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。</p>
<blockquote>
<p>需要注意，在这个例子中，<code>lock in share mode</code> 只锁覆盖索引，但是如果是 <code>for update</code> 就不一样了。 执行 <code>for update</code> 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。</p>
</blockquote>
<p>这个例子说明，<code>锁是加在索引上的</code>；同时，它给我们的指导是，如果你要用 <code>lock in share mode</code> 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 <code>select d from t where c=5 lock in share mode</code>。你可以自己验证一下效果。</p>
<h3 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t where id=10 for update;</span><br><span class="line">mysql&gt; select * from t where id&gt;=10 and id&lt;11 for update;</span><br></pre></td></tr></table></figure>
<p>在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo3.png">
<p>开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。</p>
<p>范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo4.png">
<p>这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。</p>
<p>所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。</p>
<p>这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。</p>
<h3 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo5.png">
<p>session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。</p>
<p>但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。</p>
<h3 id="案例六：非唯一索引上存在”等值”的例子"><a href="#案例六：非唯一索引上存在”等值”的例子" class="headerlink" title="案例六：非唯一索引上存在”等值”的例子"></a>案例六：非唯一索引上存在”等值”的例子</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6.png">
<p>可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。</p>
<p>这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select … for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。</p>
<img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo6_1.png">
<p>这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。</p>

<h3 id="案例七：limit-语句加锁"><a href="#案例七：limit-语句加锁" class="headerlink" title="案例七：limit 语句加锁"></a>案例七：limit 语句加锁</h3><img src="/2018/12/21/geektime-mysql-learn/gap_lock_demo7.png">
<p>这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。</p>
<p>这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。</p>
<p>因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/bb0ad92483d71f0dcaeeef278f89cb24.png">
<p>这个例子对我们实践的指导意义就是，<code>在删除数据的时候尽量加 limit</code> 。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。</p>
<h3 id="案例八：一个死锁的例子"><a href="#案例八：一个死锁的例子" class="headerlink" title="案例八：一个死锁的例子"></a>案例八：一个死锁的例子</h3><p>前面的例子中，我们在分析的时候，是按照 next-key lock 的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。</p>

<p>session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；</p>
<p>session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；</p>
<p>然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。</p>
<p>原因：session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。</p>
<p>也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。</p>
</blockquote>
<h2 id="22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？"><a href="#22讲-MySQL有哪些“饮鸩止渴”提高性能的方法？" class="headerlink" title="22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？"></a>22讲 - MySQL有哪些“饮鸩止渴”提高性能的方法？</h2><p>这些方案都是<code>剑走偏锋</code>的优化，或问题解决方案，紧急情况下可以使用。</p>
<h3 id="短连接风暴"><a href="#短连接风暴" class="headerlink" title="短连接风暴"></a>短连接风暴</h3><p>大量的执行很少逻辑就断开的连接。导致短时间内连接数暴涨。</p>
<p><code>max_connections</code>控制总的连接数。MySQL负载很高时，再建立新的连接会加重负载，此时可以考虑下面的方法释放空闲的连接：</p>
<ol>
<li>通过<code>show processlist</code> + <code>infomation_schema.inno_trx</code>表查询空闲的连接，通过<code>kill connnection</code>关闭空闲连接。需要注意到是服务断开连接后，客户端不能马上感知，直到客户端执行下一个sql，客户端如果不进行重连就会导致问题。极端情况下可以kill掉处于事务中的空闲连接。</li>
<li>减少连接建立过程中的消耗。跳过权限验证，重启数据库，添加参数<code>–skip-grant-tables</code></li>
</ol>
<h3 id="慢查询性能问题"><a href="#慢查询性能问题" class="headerlink" title="慢查询性能问题"></a>慢查询性能问题</h3><h3 id="索引没有设计好"><a href="#索引没有设计好" class="headerlink" title="索引没有设计好"></a>索引没有设计好</h3><ol>
<li>关闭从库的binlog功能</li>
<li>从库执行alter table, 添加索引，主从切换</li>
<li>原来的主库变为从库，进行同样的操作。</li>
</ol>
<p>平时的运维，应该优先使用<code>gh-ost</code>这个样的工具，紧急处理可以考虑上面的方案。</p>
<h3 id="SQL语句写的不好"><a href="#SQL语句写的不好" class="headerlink" title="SQL语句写的不好"></a>SQL语句写的不好</h3><p>mysql5.7提供了<code>query_rewrite</code>功能</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能使用索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values ("select * from t where id + 1 = ?", "select * from t where id = ? - 1", "db1");</span><br><span class="line"><span class="comment">-- 使新插入的规则生效</span></span><br><span class="line"><span class="keyword">call</span> query_rewrite.flush_rewrite_rules();</span><br></pre></td></tr></table></figure>
<h3 id="优化器选错索引"><a href="#优化器选错索引" class="headerlink" title="优化器选错索引"></a>优化器选错索引</h3><ol>
<li>通过上面提到的<code>query_rewrite</code>功能</li>
<li>修改SQL语句, <code>force index</code>强制使用指定的索引。</li>
</ol>
<h3 id="QPS-突增"><a href="#QPS-突增" class="headerlink" title="QPS 突增"></a>QPS 突增</h3><ol>
<li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li>
<li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li>
<li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成”select 1”返回。</li>
</ol>
<h2 id="23讲-MySQL是怎么保证数据不丢的？"><a href="#23讲-MySQL是怎么保证数据不丢的？" class="headerlink" title="23讲 - MySQL是怎么保证数据不丢的？"></a>23讲 - MySQL是怎么保证数据不丢的？</h2><h3 id="binlog写入机制"><a href="#binlog写入机制" class="headerlink" title="binlog写入机制"></a>binlog写入机制</h3><p>事务执行过程中，binlog先写入binlog cache, 事务提交时，写入binlog 文件。</p>
<p>一个事务的binlog不能被拆分写入，必须一次性写入。</p>
<p><code>binlog_cache_size</code>设置每个线程占用的binlog缓存大小。</p>
<h3 id="sync-binlog"><a href="#sync-binlog" class="headerlink" title="sync_binlog"></a>sync_binlog</h3><ol>
<li>sync_binlog = 0 只写入文件page cache</li>
<li>sync_binlog = 1 每次事务提交都进行fsync操作</li>
<li>sync_binlog &gt; 1(N) 每次事务提交都写文件，但是N次以后进行一次fsync</li>
</ol>
<h3 id="redo-log-写入机制"><a href="#redo-log-写入机制" class="headerlink" title="redo log 写入机制"></a>redo log 写入机制</h3><p>事务执行过程中，会不断的将redo log写入redo log cache中。</p>
<p>innodb的后台线程会每秒（<code>write + fsync</code>）或每10秒（<code>write + fsync</code>），或者当redo log cache的剩余空间小于50%时，将缓存中的日志写入文件（<code>write</code>）, 或者其他事务提交时，将未提交事务的redo log写入文件。</p>
<p>所以没有提交事务的redo log也会被写入文件, 由此可知：innodb在大事务下，提交也是非常快的。</p>
<p><code>innodb_flush_log_at_trx_commit</code>参考控制事务提交时，redo log以哪种机制写入日志文件。</p>
<ol>
<li><code>innodb_flush_log_at_trx_commit=0</code> 事务提交时，redo log保存在缓存中。</li>
<li><code>innodb_flush_log_at_trx_commit=1</code> 事务提交时，redo log写入刷新到文件。</li>
<li><code>innodb_flush_log_at_trx_commit=2</code> 事务提交时，写入page cache。</li>
</ol>
<p>redo log 和 binlog的文件写入操作遵循两阶段提交机制：当<code>innodb_flush_log_at_trx_commit=1</code><br>时，redo log 的prepare阶段就会磁盘，当binglog写入后，提交事务时，innodb不会进行fsync。</p>
<h3 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h3><h4 id="LSN"><a href="#LSN" class="headerlink" title="LSN"></a>LSN</h4><p>LSN 是 log sequence number的缩写。它是单调递增的，用来表示redo log的一个个写入点，每次写入长度为length的redo log， LSN的值就会增加length。</p>
<p>组提交机制：三个事务都写完redo log处于prepare状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit.png">
<ol>
<li>trx 1 第一个到达，被选为leader</li>
<li>trx 1 开始写磁盘是，组内已经有3个事务了，此时LSN=160</li>
<li>trx 1 写磁盘时，保存的LSN就是160, 所有小于160的LSN都被持久到磁盘了。</li>
<li>trx2, trx3提交时，就不用再写磁盘了，直接返回。</li>
</ol>
<p>结论：</p>
<ol>
<li>一次组提交，组内成员越多，就能更好的节约磁盘IOPS。</li>
<li>并发场景下，第一个事务（Leader）执行fsync越晚，组员就越多，节约的磁盘IOPS就越多。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/innodb_group_commit_optimize.png">
<p><code>binlog_group_commit_sync_delay</code> 参数表示延迟多少微妙后才调用fsync。</p>
<p><code>binlog_group_commit_sync_no_dely</code> 参数表示累积多少次后才调用fsync。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>如果线上MySQL有I/O瓶颈，可以暂时修改这些参数，提高性能。但需要注意丢失数据的风险。</p>
<h3 id="课后题-哪些场景可以将MySQL设置为非双1模式"><a href="#课后题-哪些场景可以将MySQL设置为非双1模式" class="headerlink" title="课后题 - 哪些场景可以将MySQL设置为非双1模式"></a>课后题 - 哪些场景可以将MySQL设置为非双1模式</h3><ol>
<li>可知的业务高峰期。</li>
<li>备库延迟</li>
<li>用备份恢复主库的副本，应用binlog的过程。</li>
<li>批量数据导入。</li>
</ol>
<h2 id="24讲-MySQL是怎么保证主备一致的？"><a href="#24讲-MySQL是怎么保证主备一致的？" class="headerlink" title="24讲 - MySQL是怎么保证主备一致的？"></a>24讲 - MySQL是怎么保证主备一致的？</h2><h3 id="MySQL主备基本原理"><a href="#MySQL主备基本原理" class="headerlink" title="MySQL主备基本原理"></a>MySQL主备基本原理</h3><p>MySQL主备切换流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave.png">
<h4 id="备库设置为readonly建议"><a href="#备库设置为readonly建议" class="headerlink" title="备库设置为readonly建议"></a>备库设置为readonly建议</h4><ol>
<li>运营的统计查询需要一半在备库执行，设置为readonly可以防止误操作。</li>
<li>防止主从切换逻辑bug,导致双master。</li>
<li>用readonly判断主从角色。</li>
</ol>
<p>从库虽然是readonly，但是由于同步更新线程拥有super权限，所以readonly的设置对同步更新是无效的。</p>
<p>MySQL主备执行流程</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_master_slave_diagram.png">
<ol>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<blockquote>
<p>最新的版本：sql_thread 演化成为了多个线程。</p>
</blockquote>
<h3 id="binlog三种格式"><a href="#binlog三种格式" class="headerlink" title="binlog三种格式"></a>binlog三种格式</h3><h4 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h4><p>记录的是原始的SQL语句。格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<p>statement 有可能导致主从数据不一致。原因在于，同样的语句，在主从库上执行时，会因为索引选择不同，导致最终的执行结果不同。</p>
<h4 id="row"><a href="#row" class="headerlink" title="row"></a>row</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="keyword">database</span>;</span><br><span class="line">sql 语句;</span><br><span class="line"><span class="keyword">commit</span> <span class="comment">/* xid = 123 */</span>;</span><br></pre></td></tr></table></figure>
<h4 id="mix-statement-row"><a href="#mix-statement-row" class="headerlink" title="mix = statement + row"></a>mix = statement + row</h4><p>statement 格式的binlog会导致主从数据不一致，优点是：占用空间小。row格式不会导致主从不一致，但是占用空间大。所有就有了mix这种格式。MySQL会自动判断SQL语句，不影响主从一致的SQL使用statement,其他的使用row格式。</p>
<h3 id="binlog-格式最佳实践"><a href="#binlog-格式最佳实践" class="headerlink" title="binlog 格式最佳实践"></a>binlog 格式最佳实践</h3><p>推荐使用<code>row</code>格式。</p>
<ol>
<li>数据恢复，binlog里面包含了所有的信息，可以恢复误操作影响的数据。</li>
<li>基于binlog进行业务消息处理。</li>
</ol>
<h3 id="查看binlog"><a href="#查看binlog" class="headerlink" title="查看binlog"></a>查看binlog</h3><p>确定正在写入的binlog文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的binlog文件</span></span><br><span class="line"><span class="keyword">show</span> <span class="built_in">binary</span> <span class="keyword">logs</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000607</span><br><span class="line">         Position: 226668235</span><br><span class="line">     Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line">Executed_Gtid_Set:</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看指定binlog文件的内容语法：</p>
<blockquote>
<p>SHOW BINLOG EVENTS [IN ‘log_name’] [FROM pos] [LIMIT [offset,] row_count]</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW BINLOG EVENTS IN 'mysql-bin.000607'  limit 1 \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">   Log_name: mysql-bin.000607</span><br><span class="line">        Pos: 4</span><br><span class="line"> Event_type: Format_desc</span><br><span class="line">  Server_id: 132656183</span><br><span class="line">End_log_pos: 120</span><br><span class="line">       Info: Server ver: 5.6.26-log, Binlog ver: 4</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>查看远程服务器上的binlog</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -ubosstest -p -P6183 -hbj.bosstest.w.qiyi.db <span class="comment">--start-datetime='2019-01-15 16:38:00' --stop-datetime='2019-01-15 16:40:00' --read-from-remote-server -vv mysql-bin.000607 &gt; row.sql</span></span><br></pre></td></tr></table></figure>
<p>内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#190115 16:53:34 server id 132656183  end_log_pos 231732483 CRC32 0x2792c369 	Table_map: `autorenew`.`boss_dut_user_new_00` mapped to number 110965745</span></span><br></pre></td></tr></table></figure>
<h3 id="循环复制"><a href="#循环复制" class="headerlink" title="循环复制"></a>循环复制</h3><p>循环复制指的是，双Master架构下，B库重放了主库A的binlog,同时产生了binlog，B库的binlog又被主库A执行的情况。</p>
<p>解决办法如下：</p>
<ol>
<li>binlog中有server_id</li>
<li>每个数据库的server_id都需要设置不同。</li>
<li>当接收到和自己server_id相同的binlog，不执行。</li>
</ol>
<h2 id="25讲-MySQL是如何保证高可用的？"><a href="#25讲-MySQL是如何保证高可用的？" class="headerlink" title="25讲 - MySQL是如何保证高可用的？"></a>25讲 - MySQL是如何保证高可用的？</h2><h3 id="查询主从延迟时间"><a href="#查询主从延迟时间" class="headerlink" title="查询主从延迟时间"></a>查询主从延迟时间</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
<h3 id="主从延迟原因"><a href="#主从延迟原因" class="headerlink" title="主从延迟原因"></a>主从延迟原因</h3><ol>
<li>主从机器配置不对等。</li>
<li>从库压力过大（大量的查询和统计查询）。可以通过多个从库和离线统计解决</li>
<li>大事务。 事务的binlog不能拆分，大事务执行时间长，从库执行大事务耗费同样的时间，由于是单线程，主库最新的更新不能及时同步到从库。</li>
</ol>
<h3 id="主从切换-高可靠"><a href="#主从切换-高可靠" class="headerlink" title="主从切换 - 高可靠"></a>主从切换 - 高可靠</h3><p>因为主从可能存在延迟，所以直接进行切换就会导致数据不一致的情况发生。实践中为了保证数据的一致性，可以使用如下的步骤：</p>
<ol>
<li>判断从库的延迟时间小于一个阈值，例如5s.</li>
<li>把主库改为readonly。</li>
<li>等待2个库数据一致。</li>
<li>从库改为可写。</li>
<li>业务请求切换到新的主库。</li>
</ol>
<h3 id="主从切换-高可用"><a href="#主从切换-高可用" class="headerlink" title="主从切换 - 高可用"></a>主从切换 - 高可用</h3><p>有时候主从的切换不是我们能计划的。例如主库突然down机。此时，为了尽快恢复业务，必须进行切换了。只能事后进行数据一致性恢复操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MySQL的高可用，高度依赖主从的延迟。所以实践中尽力保证主从的延迟一直保持在一个非常小的时间范围内。</p>
<h3 id="课后题-12"><a href="#课后题-12" class="headerlink" title="课后题"></a>课后题</h3><p>什么情况下，备库的主备延迟会表现为一个 45 度的线段？</p>
<p>原因是：备库的同步在这段时间完全被堵住了。</p>
<ul>
<li>一种是大事务（包括大表 DDL、一个事务操作很多行）；</li>
<li>还有一种情况比较隐蔽，就是备库起了一个长事务，比如<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后就不动了。(获取了MDL读锁)</p>
<p>这时候主库对表 t 做了一个加字段操作，即使这个表很小，这个 DDL 在备库应用的时候也会被堵住（获取MDL写锁时被阻塞），也能看到这个现象。</p>
<h2 id="26讲-备库为什么会延迟好几个小时？"><a href="#26讲-备库为什么会延迟好几个小时？" class="headerlink" title="26讲 - 备库为什么会延迟好几个小时？"></a>26讲 - 备库为什么会延迟好几个小时？</h2><p>备库的延迟是机制上导致，主库是并发执行，从库只有一个线程进行重放，延迟可以说是不可避免的。为此各大公司和MySQL官方开发了并行复制功能。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_parall_binlog.png">
<ol>
<li>原来的SQL线程变为协调线程，服务事件的分发。</li>
<li>多个SQL线程进行事件执行。</li>
</ol>
<h3 id="coordinator-分发原则"><a href="#coordinator-分发原则" class="headerlink" title="coordinator 分发原则"></a>coordinator 分发原则</h3><ol>
<li>不能造成更新覆盖。更新同一行的事务必须分发到同一个worker线程。</li>
<li>同一个事务不能被拆开，必须放到同一个worker线程中。 </li>
</ol>
<h3 id="按表分发"><a href="#按表分发" class="headerlink" title="按表分发"></a>按表分发</h3><p>按表分发事务的基本思路是，如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。当然，如果有跨表的事务，还是要把两张表放在一起考虑的。如图 3 所示，就是按表分发的规则。</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_binlog_table.png">
<p>可以看到，每个 worker 线程对应一个 hash 表，用于保存当前正在这个 worker 的“执行队列”里的事务所涉及的表。hash 表的 key 是<code>库名.表名</code>，value 是一个数字，表示队列中有多少个事务修改这个表。</p>
<p>在有事务分配给 worker 时，事务里面涉及的表会被加到对应的 hash 表中。worker 执行完成后，这个表会被从 hash 表中去掉。</p>
<h4 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h4><ol>
<li>由于事务 T 中涉及修改表 t1，而 worker_1 队列中有事务在修改表 t1，事务 T 和队列中的某个事务要修改同一个表的数据，这种情况我们说事务 T 和 worker_1 是冲突的。</li>
<li>按照这个逻辑，顺序判断事务 T 和<code>每个worker</code> 队列的冲突关系，会发现事务 T 跟 worker_2 也冲突。</li>
<li>事务 T 跟多于一个 worker 冲突，coordinator 线程就进入等待。</li>
<li>每个 worker 继续执行，同时修改 hash_table。假设 hash_table_2 里面涉及到修改表 t3 的事务先执行完成，就会从 hash_table_2 中把 db1.t3 这一项去掉。</li>
<li>这样 coordinator 会发现跟事务 T 冲突的 worker 只有 worker_1 了，因此就把它分配给 worker_1。</li>
<li>coordinator 继续读下一个中转日志，继续分配事务。</li>
</ol>
<p>也就是说，每个事务在分发的时候，跟所有 worker 的冲突关系包括以下三种情况：</p>
<ol>
<li>如果跟所有 worker 都不冲突，coordinator 线程就会把这个事务分配给最空闲的 woker;</li>
<li>如果跟多于一个 worker 冲突，coordinator 线程就进入等待状态，直到和这个事务存在冲突关系的 worker 只剩下 1 个；</li>
<li>如果只跟一个 worker 冲突，coordinator 线程就会把这个事务分配给这个存在冲突关系的 worker。</li>
</ol>
<p>这个按表分发的方案，在多个表负载均匀的场景里应用效果很好。但是，如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</p>
<h3 id="按行分发策略"><a href="#按行分发策略" class="headerlink" title="按行分发策略"></a>按行分发策略</h3><p>要解决热点表的并行复制问题，就需要一个按行并行复制的方案。按行复制的核心思路是：<code>如果两个事务没有更新相同的行，它们在备库上可以并行执行</code>。显然，这个模式要求 binlog 格式必须是 row。</p>
<p>这时候，我们判断一个事务 T 和 worker 是否冲突，用的就规则就不是“修改同一个表”，而是“修改同一行”。</p>
<p>按行复制和按表复制的数据结构差不多，也是为每个 worker，分配一个 hash 表。只是要实现按行分发，这时候的 key，就必须是<code>库名 + 表名 + 唯一键的值</code>。</p>
<p>但是，这个“唯一键”只有主键 id 还是不够的，我们还需要考虑下面这种场景，表 t1 中除了主键，还有唯一索引 a：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>假设，接下来我们要在主库执行这两个事务：</p>
<img src="/2018/12/21/geektime-mysql-learn/mysql_para_row_conflict.png">
<p>可以看到，这两个事务要更新的行的主键值不同，但是如果它们被分到不同的 worker，就有可能 session B 的语句先执行。这时候 id=1 的行的 a 的值还是 1，就会报唯一键冲突。</p>
<p>因此，基于行的策略，事务 hash 表中还需要考虑唯一键，即 key 应该是“库名 + 表名 + 索引 a 的名字 +a 的值”。</p>
<p>比如，在上面这个例子中，我要在表 t1 上执行 <code>update t1 set a=1 where id=2</code> 语句，在 binlog 里面记录了整行的数据修改前各个字段的值，和修改后各个字段的值。</p>
<p>因此，coordinator 在解析这个语句的 binlog 的时候，这个事务的 hash 表就有三个项:</p>
<ol>
<li>key=hash_func(db1+t1+“PRIMARY”+2), value=2; 这里 value=2 是因为修改前后的行 id 值不变，出现了两次。</li>
<li>key=hash_func(db1+t1+“a”+2), value=1，表示会影响到这个表 a=2 的行。</li>
<li>key=hash_func(db1+t1+“a”+1), value=1，表示会影响到这个表 a=1 的行。</li>
</ol>
<p>可见<code>相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源</code>。你可能也发现了，这两个方案其实都有一些约束条件：</p>
<ol>
<li>要能够从 binlog 里面解析出表名、主键值和唯一索引的值。也就是说，主库的 binlog 格式必须是 row；</li>
<li>表必须有主键；</li>
<li>不能有外键。表上如果有外键，级联更新的行不会记录在 binlog 中，这样冲突检测就不准确。</li>
</ol>
<p>但，好在这三条约束规则，本来就是 DBA 之前要求业务开发人员必须遵守的线上使用规范，所以这两个并行复制策略在应用上也没有碰到什么麻烦。</p>
<p>对比按表分发和按行分发这两个方案的话，按行分发策略的并行度更高。不过，如果是要操作很多行的大事务的话，按行分发的策略有两个问题：</p>
<ol>
<li>耗费内存。比如一个语句要删除 100 万行数据，这时候 hash 表就要记录 100 万个项。</li>
<li>耗费 CPU。解析 binlog，然后计算 hash 值，对于大事务，这个成本还是很高的。</li>
</ol>
<p>所以，我在实现这个策略的时候会设置一个阈值，单个事务如果超过设置的行数阈值（比如，如果单个事务更新的行数超过 10 万行），就暂时退化为单线程模式，退化过程的逻辑大概是这样的：</p>
<ol>
<li>coordinator 暂时先 hold 住这个事务；</li>
<li>等待所有 worker 都执行完成，变成空队列；</li>
<li>coordinator 直接执行这个事务；</li>
<li>恢复并行模式。</li>
</ol>
<p>读到这里，你可能会感到奇怪，这两个策略又没有被合到官方，我为什么要介绍这么详细呢？其实，介绍这两个策略的目的是抛砖引玉，方便你理解后面要介绍的社区版本策略。</p>
<h3 id="MySQL-5-6-版本的并行复制策略"><a href="#MySQL-5-6-版本的并行复制策略" class="headerlink" title="MySQL 5.6 版本的并行复制策略"></a>MySQL 5.6 版本的并行复制策略</h3><p>官方 MySQL5.6 版本，支持了并行复制，只是支持的粒度是按库并行。理解了上面介绍的按表分发策略和按行分发策略，你就理解了，用于决定分发策略的 hash 表里，key 就是数据库名。</p>
<p>这个策略的并行效果，取决于压力模型。如果在主库上有多个 DB，并且各个 DB 的压力均衡，使用这个策略的效果会很好。</p>
<p>相比于按表和按行分发，这个策略有两个优势：</p>
<ol>
<li>构造 hash 值的时候很快，只需要库名；而且一个实例上 DB 数也不会很多，不会出现需要构造 100 万个项这种情况。</li>
<li>不要求 binlog 的格式。因为 statement 格式的 binlog 也可以很容易拿到库名。</li>
</ol>
<p>但是，如果你的主库上的表都放在同一个 DB 里面，这个策略就没有效果了；或者如果不同 DB 的热点不同，比如一个是业务逻辑库，一个是系统配置库，那也起不到并行的效果。</p>
<p>理论上你可以创建不同的 DB，把相同热度的表均匀分到这些不同的 DB 中，强行使用这个策略。不过据我所知，由于需要特地移动数据，这个策略用得并不多。</p>
<h3 id="MariaDB-的并行复制策略"><a href="#MariaDB-的并行复制策略" class="headerlink" title="MariaDB 的并行复制策略"></a>MariaDB 的并行复制策略</h3><p>在 <a href="https://time.geekbang.org/column/article/76161" target="_blank" rel="noopener">https://time.geekbang.org/column/article/76161</a> 中，我给你介绍了 redo log 组提交 (group commit) 优化， 而 MariaDB 的并行复制策略利用的就是这个特性：</p>
<ol>
<li>能够在同一组里提交的事务，一定不会修改同一行；</li>
<li>主库上可以并行执行的事务，备库上也一定是可以并行执行的。</li>
</ol>
<p>在实现上，MariaDB 是这么做的：</p>
<ol>
<li>在一组里面一起提交的事务，有一个相同的 commit_id，下一组就是 commit_id+1；</li>
<li>commit_id 直接写到 binlog 里面；</li>
<li>传到备库应用的时候，相同 commit_id 的事务分发到多个 worker 执行；</li>
<li>这一组全部执行完成后，coordinator 再去取下一批。</li>
</ol>
<p>当时，这个策略出来的时候是相当惊艳的。因为，之前业界的思路都是在“分析 binlog，并拆分到 worker”上。而 MariaDB 的这个策略，目标是“模拟主库的并行模式”。</p>
<p>但是，这个策略有一个问题，它并没有实现“真正的模拟主库并发度”这个目标。在主库上，一组事务在 commit 的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>如图 5 所示，假设了三组事务在主库的执行情况，你可以看到在 trx1、trx2 和 trx3 提交的时候，trx4、trx5 和 trx6 是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入 commit 状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/8fec5fb48d6095aecc80016826efbfc3.png">
<p>而按照 MariaDB 的并行复制策略，备库上的执行效果如图 6 所示。</p>
<img src="/2018/12/21/geektime-mysql-learn/8ac3799c1ff2f9833619a1624ca3e622.png">
<p>可以看到，在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够。</p>
<p>另外，这个方案很容易被大事务拖后腿。假设 trx2 是一个超大事务，那么在备库应用的时候，trx1 和 trx3 执行完成后，就只能等 trx2 完全执行完成，下一组才能开始执行。这段时间，只有一个 worker 线程在工作，是对资源的浪费。</p>
<p>不过即使如此，这个策略仍然是一个很漂亮的创新。因为，它对原系统的改造非常少，实现也很优雅。</p>
<h3 id="MySQL-5-7-的并行复制策略"><a href="#MySQL-5-7-的并行复制策略" class="headerlink" title="MySQL 5.7 的并行复制策略"></a>MySQL 5.7 的并行复制策略</h3><p>在 MariaDB 并行复制实现之后，官方的 MySQL5.7 版本也提供了类似的功能，由参数 slave-parallel-type 来控制并行复制策略：</p>
<ol>
<li>配置为 DATABASE，表示使用 MySQL 5.6 版本的按库并行策略；</li>
<li>配置为 LOGICAL_CLOCK，表示的就是类似 MariaDB 的策略。不过，MySQL 5.7 这个策略，针对并行度做了优化。这个优化的思路也很有趣儿。</li>
</ol>
<p>你可以先考虑这样一个问题：同时处于“执行状态”的所有事务，是不是可以并行？</p>
<p>答案是，不能。</p>
<p>因为，这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的 worker，就会出现备库跟主库不一致的情况。</p>
<p>而上面提到的 MariaDB 这个策略的核心，是“所有处于 commit”状态的事务可以并行。事务处于 commit 状态，表示已经通过了锁冲突的检验了。</p>
<p>这时候，你可以再回顾一下两阶段提交:</p>
<img src="/2018/12/21/geektime-mysql-learn/5ae7d074c34bc5bd55c82781de670c28.png">
<p>其实，不用等到 commit 阶段，只要能够到达 redo log prepare 阶段，就表示事务已经通过锁冲突的检验了。</p>
<p>因此，MySQL 5.7 并行复制策略的思想是：</p>
<ol>
<li>同时处于 prepare 状态的事务，在备库执行时是可以并行的；</li>
<li>处于 prepare 状态的事务，与处于 commit 状态的事务之间，在备库执行时也是可以并行的。</li>
</ol>
<p>我在第 23 篇文章，讲 binlog 的组提交的时候，介绍过两个参数：</p>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p>这两个参数是用于故意拉长 binlog 从 write 到 fsync 的时间，以此减少 binlog 的写盘次数。在 MySQL 5.7 的并行复制策略里，它们可以用来制造更多的“同时处于 prepare 阶段的事务”。这样就增加了备库复制的并行度。</p>
<p>也就是说，这两个参数，既可以“故意”让主库提交得慢些，又可以让备库执行得快些。在 MySQL 5.7 处理备库延迟的时候，可以考虑调整这两个参数值，来达到提升备库复制并发度的目的。</p>
<h3 id="MySQL-5-7-22-的并行复制策略"><a href="#MySQL-5-7-22-的并行复制策略" class="headerlink" title="MySQL 5.7.22 的并行复制策略"></a>MySQL 5.7.22 的并行复制策略</h3><p>在 2018 年 4 月份发布的 MySQL 5.7.22 版本里，MySQL 增加了一个新的并行复制策略，基于 WRITESET 的并行复制。</p>
<p>相应地，新增了一个参数 <code>binlog-transaction-dependency-tracking</code>，用来控制是否启用这个新策略。这个参数的可选值有以下三种。</p>
<ol>
<li>COMMIT_ORDER，表示的就是前面介绍的，根据同时进入 prepare 和 commit 来判断是否可以并行的策略。</li>
<li>WRITESET，表示的是对于事务涉及更新的每一行，计算出这一行的 hash 值，组成集合 writeset。如果两个事务没有操作相同的行，也就是说它们的 writeset 没有交集，就可以并行。</li>
<li>WRITESET_SESSION，是在 WRITESET 的基础上多了一个约束，即在主库上同一个线程先后执行的两个事务，在备库执行的时候，要保证相同的先后顺序。</li>
</ol>
<p>当然为了唯一标识，这个 hash 值是通过“库名 + 表名 + 索引名 + 值”计算出来的。如果一个表上除了有主键索引外，还有其他唯一索引，那么对于每个唯一索引，insert 语句对应的 writeset 就要多增加一个 hash 值。</p>
<p>你可能看出来了，这跟我们前面介绍的基于 MySQL 5.5 版本的按行分发的策略是差不多的。不过，MySQL 官方的这个实现还是有很大的优势：</p>
<p>因此，MySQL 5.7.22 的并行复制策略在通用性上还是有保证的。</p>
<p>当然，对于“表上没主键”和“外键约束”的场景，WRITESET 策略也是没法并行的，也会暂时退化为单线程模型。</p>
<h3 id="课后题-13"><a href="#课后题-13" class="headerlink" title="课后题"></a>课后题</h3><p>如果主库都是单线程压力模式，在从库追主库的过程中，binlog-transaction-dependency-tracking 应该选用什么参数？</p>
<p>这个问题的答案是，应该将这个参数设置为 WRITESET。</p>
<p>由于主库是单线程压力模式，所以每个事务的 commit_id 都不同，那么设置为 COMMIT_ORDER 模式的话，从库也只能单线程执行。</p>
<p>同样地，由于 WRITESET_SESSION 模式要求在备库应用日志的时候，同一个线程的日志必须与主库上执行的先后顺序相同，也会导致主库单线程压力模式下退化成单线程复制。</p>
<p>所以，应该将 binlog-transaction-dependency-tracking 设置为 WRITESET。</p>
<h2 id="27-主库出问题了，从库怎么办？"><a href="#27-主库出问题了，从库怎么办？" class="headerlink" title="27 - 主库出问题了，从库怎么办？"></a>27 - 主库出问题了，从库怎么办？</h2><p>大多数的互联网应用场景都是读多写少，在发展过程中很可能先会遇到读性能的问题。而在数据库层解决读性能问题的常用架构是：一主多从。</p>
<p>下图是典型的一主多从架构：</p>
<img src="/2018/12/21/geektime-mysql-learn/aadb3b956d1ffc13ac46515a7d619e79.png">
<p>图中，虚线箭头表示的是主备关系，也就是 A 和 A’互为主备， 从库 B、C、D 指向的是主库 A。一主多从的设置，一般用于读写分离，主库负责所有的写入和一部分读，其他的读请求则由从库分担。</p>
<p>如下图所示，就是主库发生故障，主备切换后的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/0014f97423bd75235a9187f492fb2453.png">
<p>相比于一主一备的切换流程，一主多从结构在切换完成后，A’会成为新的主库，从库 B、C、D 也要改接到 A’。正是由于多了从库 B、C、D 重新指向的这个过程，所以主备切换的复杂性也相应增加了。</p>
<h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当我们把节点 B 设置成节点 A’的从库的时候，需要执行一条 change master 命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">MASTER_LOG_FILE=$master_log_name </span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure>
<p>这条命令有这么 6 个参数：</p>
<ol>
<li>MASTER_HOST、MASTER_PORT、MASTER_USER 和 MASTER_PASSWORD 四个参数，分别代表了主库 A’的 IP、端口、用户名和密码。</li>
<li>最后两个参数 MASTER_LOG_FILE 和 MASTER_LOG_POS 表示，要从主库的 master_log_name 文件的 master_log_pos 这个位置的日志继续同步。而这个位置就是我们所说的同步位点，也就是主库对应的文件名和日志偏移量。</li>
</ol>
<p>那么，这里就有一个问题了，节点 B 要设置成 A’的从库，就要执行 change master 命令，就不可避免地要设置位点的这两个参数，但是这两个参数到底应该怎么设置呢？</p>
<p>原来节点 B 是 A 的从库，本地记录的也是 A 的位点。但是相同的日志，<code>A 的位点和 A’的位点是不同的</code>。因此，从库 B 要切换的时候，就需要先经过<code>找同步位点</code>这个逻辑。</p>
<p>这个位点很难精确取到，只能取一个大概位置。为什么这么说呢？</p>
<p>我来和你分析一下看看这个位点一般是怎么获取到的，你就清楚其中不精确的原因了。</p>
<p>考虑到切换过程中不能丢数据，所以我们找位点的时候，总是要找一个<code>稍微往前</code>的，然后再通过判断<code>跳过那些在从库B上已经执行过的事务</code>。</p>
<p>一种取同步位点的方法是这样的：</p>
<ol>
<li>等待新主库 A’把中转日志（relay log）全部同步完成；</li>
<li>在 A’上执行 show master status 命令，得到当前 A’上最新的 File 和 Position；</li>
<li>取原主库 A 故障的时刻 T；</li>
<li>用 mysqlbinlog 工具解析 A’的 File，得到 T 时刻的位点。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/3471dfe4aebcccfaec0523a08cdd0ddd.png">
<p>图中，end_log_pos 后面的值“123”，表示的就是 A’这个实例，在 T 时刻写入新的 binlog 的位置。然后，我们就可以把 123 这个值作为 $master_log_pos ，用在节点 B 的 change master 命令里。</p>
<p>当然这个值并不精确。为什么呢？</p>
<p>你可以设想有这么一种情况，假设在 T 这个时刻，主库 A 已经执行完成了一个 insert 语句插入了一行数据 R，并且已经将 binlog 传给了 A’和 B，然后在传完的瞬间主库 A 的主机就掉电了。</p>
<p>那么，这时候系统的状态是这样的：</p>
<ol>
<li>在从库 B 上，由于同步了 binlog， R 这一行已经存在；</li>
<li>在新主库 A’上， R 这一行也已经存在，日志是写在 123 这个位置之后的；</li>
<li>我们在从库 B 上执行 change master 命令，指向 A’的 File 文件的 123 位置，就会把插入 R 这一行数据的 binlog 又同步到从库 B 去执行。</li>
</ol>
<p>这时候，从库 B 的同步线程就会报告 Duplicate entry ‘id_of_R’ for key ‘PRIMARY’ 错误，提示出现了主键冲突，然后停止同步。</p>
<p>所以：通常情况下，我们在切换任务的时候，要先主动跳过这些错误，有两种常用的方法。</p>
<p>一种做法是，主动跳过一个事务。跳过命令的写法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>因为切换过程中，可能会不止重复执行一个事务，所以我们需要在从库 B 刚开始接到新主库 A’时，持续观察，每次碰到这些错误就停下来，执行一次跳过命令，直到不再出现停下来的情况，以此来跳过可能涉及的所有事务。</p>
<p>另外一种方式是，通过设置 slave_skip_errors 参数，直接设置跳过指定的错误。</p>
<p>在执行主备切换时，有这么两类错误，是经常会遇到的：</p>
<ul>
<li>1062 错误是插入数据时唯一键冲突；</li>
<li>1032 错误是删除数据时找不到行。</li>
</ul>
<p>因此，我们可以把 slave_skip_errors 设置为 “1032,1062”，这样中间碰到这两个错误时就直接跳过。</p>
<p>这里需要注意的是，这种直接跳过指定错误的方法，针对的是主备切换时，由于找不到精确的同步位点，所以只能采用这种方法来创建从库和新主库的主备关系。</p>
<p>这个背景是，我们很清楚在主备切换过程中，直接跳过 1032 和 1062 这两类错误是无损的，所以才可以这么设置 slave_skip_errors 参数。等到主备间的同步关系建立完成，并稳定执行一段时间之后，我们还需要把这个参数设置为空，以免之后真的出现了主从数据不一致，也跳过了。</p>
<p>通过 sql_slave_skip_counter 跳过事务和通过 slave_skip_errors 忽略错误的方法，虽然都最终可以建立从库 B 和新主库 A’的主备关系，但这两种操作都很复杂，而且容易出错。所以，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难。</p>
<p>那么，GTID 到底是什么意思，又是如何解决找同步位点这个问题呢？现在，我就和你简单介绍一下。</p>
<p>GTID 的全称是 Global Transaction Identifier，也就是全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识。它由两部分组成，格式是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=server_uuid:gno</span><br></pre></td></tr></table></figure>
<p>这里我需要和你说明一下，在 MySQL 的官方文档里，GTID 格式是这么定义的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GTID=source_id:transaction_id</span><br></pre></td></tr></table></figure>
<p>这里的 source_id 就是 server_uuid；而后面的这个 transaction_id，我觉得容易造成误导，所以我改成了 gno。为什么说使用 transaction_id 容易造成误解呢？</p>
<p>因为，在 MySQL 里面我们说 transaction_id 就是指事务 id，事务 id 是在事务执行过程中分配的，如果这个事务回滚了，事务 id 也会递增，而 gno 是在事务提交的时候才会分配。</p>
<p>从效果上看，GTID 往往是连续的，因此我们用 gno 来表示更容易理解。</p>
<p>GTID 模式的启动也很简单，我们只需要在启动一个 MySQL 实例的时候，加上参数 gtid_mode=on 和 enforce_gtid_consistency=on 就可以了。</p>
<p>在 GTID 模式下，每个事务都会跟一个 GTID 一一对应。这个 GTID 有两种生成方式，而使用哪种方式取决于 session 变量 gtid_next 的值。</p>
<ol>
<li>如果 gtid_next=automatic，代表使用默认值。这时，MySQL 就会把 server_uuid:gno 分配给这个事务。<br> a. 记录 binlog 的时候，先记录一行 SET @@SESSION.GTID_NEXT=‘server_uuid:gno’;<br> b. 把这个 GTID 加入本实例的 GTID 集合。</li>
<li>如果 gtid_next 是一个指定的 GTID 的值，比如通过 set gtid_next=’current_gtid’指定为 current_gtid，那么就有两种可能：<br>a.  如果 current_gtid 已经存在于实例的 GTID 集合中，接下来执行的这个事务会直接被系统忽略；<br>b.  如果 current_gtid 没有存在于实例的 GTID 集合中，就将这个 current_gtid 分配给接下来要执行的事务，也就是说系统不需要给这个事务生成新的 GTID，因此 gno 也不用加 1。    </li>
</ol>
<p>注意，一个 current_gtid 只能给一个事务使用。这个事务提交后，如果要执行下一个事务，就要执行 set 命令，把 gtid_next 设置成另外一个 gtid 或者 automatic。</p>
<p>这样，每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”。</p>
<p>这样看上去不太容易理解，接下来我就用一个简单的例子，来和你说明 GTID 的基本用法。</p>
<p>我们在实例 X 中创建一个表 t。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img src="/2018/12/21/geektime-mysql-learn/28a5cab0079fb12fd5abecd92b3324c2.png">
<p>可以看到，事务的 BEGIN 之前有一条 SET @@SESSION.GTID_NEXT 命令。这时，如果实例 X 有从库，那么将 CREATE TABLE 和 insert 语句的 binlog 同步过去执行的话，执行事务之前就会先执行这两个 SET 命令， 这样被加入从库的 GTID 集合的，就是图中的这两个 GTID。</p>
<p>假设，现在这个实例 X 是另外一个实例 Y 的从库，并且此时在实例 Y 上执行了下面这条插入语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>并且，这条语句在实例 Y 上的 GTID 是 “aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”。</p>
<p>那么，实例 X 作为 Y 的从库，就要同步这个事务过来执行，显然会出现主键冲突，导致实例 X 的同步线程停止。这时，我们应该怎么处理呢？</p>
<p>处理方法就是，你可以执行下面的这个语句序列：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> gtid_next=<span class="string">'aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
<p>其中，前三条语句的作用，是通过提交一个空事务，把这个 GTID 加到实例 X 的 GTID 集合中。如图 5 所示，就是执行完这个空事务之后的 show master status 的结果。</p>
<img src="/2018/12/21/geektime-mysql-learn/c8d3299ece7d583a3ecd1557851ed157.png">
<p>可以看到实例 X 的 Executed_Gtid_set 里面，已经加入了这个 GTID。</p>
<p>这样，我再执行 start slave 命令让同步线程执行起来的时候，虽然实例 X 上还是会继续执行实例 Y 传过来的事务，但是由于“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”已经存在于实例 X 的 GTID 集合中了，所以实例 X 就会直接跳过这个事务，也就不会再出现主键冲突的错误。</p>
<p>在上面的这个语句序列中，start slave 命令之前还有一句 set gtid_next=automatic。这句话的作用是“恢复 GTID 的默认分配行为”，也就是说如果之后有新的事务再执行，就还是按照原来的分配方式，继续分配 gno=3。</p>
<h3 id="基于-GTID-的主备切换"><a href="#基于-GTID-的主备切换" class="headerlink" title="基于 GTID 的主备切换"></a>基于 GTID 的主备切换</h3><p>现在，我们已经理解 GTID 的概念，再一起来看看基于 GTID 的主备复制的用法。</p>
<p>在 GTID 模式下，备库 B 要设置为新主库 A’的从库的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">MASTER_HOST=$host_name </span><br><span class="line">MASTER_PORT=$port </span><br><span class="line">MASTER_USER=$user_name </span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span> </span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>其中，master_auto_position=1 就表示这个主备关系使用的是 GTID 协议。可以看到，前面让我们头疼不已的 MASTER_LOG_FILE 和 MASTER_LOG_POS 参数，已经不需要指定了。</p>
<p>我们把现在这个时刻，实例 A’的 GTID 集合记为 set_a，实例 B 的 GTID 集合记为 set_b。接下来，我们就看看现在的主备切换逻辑。</p>
<p>我们在实例 B 上执行 start slave 命令，取 binlog 的逻辑是这样的：</p>
<ol>
<li>实例 B 指定主库 A’，基于主备协议建立连接。</li>
<li>实例 B 把 set_b 发给主库 A’。</li>
<li>实例 A’算出 set_a 与 set_b 的差集，也就是所有存在于 set_a，但是不存在于 set_b 的 GITD 的集合，判断 A’本地是否包含了这个差集需要的所有 binlog 事务。<br> a.  如果不包含，表示 A’已经把实例 B 需要的 binlog 给删掉了，直接返回错误；<br> b.  如果确认全部包含，A’从自己的 binlog 文件里面，找出第一个不在 set_b 的事务，发给 B；</li>
<li>之后就从这个事务开始，往后读文件，按顺序取 binlog 发给 B 去执行。    </li>
</ol>
<p>其实，这个逻辑里面包含了一个设计思想：在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A’就拒绝把日志发给 B。</p>
<p>这跟基于位点的主备协议不同。基于位点的协议，是由备库决定的，备库指定哪个位点，主库就发哪个位点，不做日志的完整性判断。</p>
<p>基于上面的介绍，我们再来看看引入 GTID 后，一主多从的切换场景下，主备切换是如何实现的。</p>
<p>由于不需要找位点了，所以从库 B、C、D 只需要分别执行 change master 命令指向实例 A’即可。</p>
<p>其实，严谨地说，主备切换不是不需要找位点了，而是找位点这个工作，在实例 A’内部就已经自动完成了。但由于这个工作是自动的，所以对 HA 系统的开发人员来说，非常友好。</p>
<p>之后这个系统就由新主库 A’写入，主库 A’的自己生成的 binlog 中的 GTID 集合格式是：server_uuid_of_A’:1-M。</p>
<p>如果之前从库 B 的 GTID 集合格式是 server_uuid_of_A:1-N， 那么切换之后 GTID 集合的格式就变成了 server_uuid_of_A:1-N, server_uuid_of_A’:1-M。</p>
<p>当然，主库 A’之前也是 A 的备库，因此主库 A’和从库 B 的 GTID 集合是一样的。这就达到了我们预期。</p>
<h3 id="GTID-和在线-DDL"><a href="#GTID-和在线-DDL" class="headerlink" title="GTID 和在线 DDL"></a>GTID 和在线 DDL</h3><p>在《MySQL 有哪些“饮鸩止渴”提高性能的方法？》中，我和你提到业务高峰期的慢查询性能问题时，分析到如果是由于索引缺失引起的性能问题，我们可以通过在线加索引来解决。但是，考虑到要避免新增索引对主库性能造成的影响，我们可以先在备库加索引，然后再切换。   </p>
<p>当时我说，在双 M 结构下，备库执行的 DDL 语句也会传给主库，为了避免传回后对主库造成影响，要通过 set sql_log_bin=off 关掉 binlog。</p>
<p>评论区有位同学提出了一个问题：这样操作的话，数据库里面是加了索引，但是 binlog 并没有记录下这一个更新，是不是会导致数据和日志不一致？</p>
<p>这个问题提得非常好。当时，我在留言的回复中就引用了 GTID 来说明。今天，我再和你展开说明一下。</p>
<p>假设，这两个互为主备关系的库还是实例 X 和实例 Y，且当前主库是 X，并且都打开了 GTID 模式。这时的主备切换流程可以变成下面这样：</p>
<ol>
<li>在实例 X 上执行 stop slave。</li>
<li>在实例 Y 上执行 DDL 语句。注意，这里并不需要关闭 binlog。</li>
<li>执行完成后，查出这个 DDL 语句对应的 GTID，并记为 server_uuid_of_Y:gno。</li>
<li>到实例 X 上执行以下语句序列：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> GTID_NEXT=<span class="string">"server_uuid_of_Y:gno"</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做的目的在于，既可以让实例 Y 的更新有 binlog 记录，同时也可以确保不会在实例 X 上执行这条更新。 </p>
<ul>
<li>接下来，执行完主备切换，然后照着上述流程再执行一遍即可。</li>
</ul>
<h3 id="课后题-14"><a href="#课后题-14" class="headerlink" title="课后题"></a>课后题</h3><p>你在 GTID 模式下设置主从关系的时候，从库执行 start slave 命令后，主库发现需要的 binlog 已经被删除掉了，导致主备创建不成功。这种情况下，你觉得可以怎么处理呢？</p>
<p>答案如下:</p>
<ol>
<li>如果业务允许主从不一致的情况，那么可以在主库上先执行 show global variables like ‘gtid_purged’，得到主库已经删除的 GTID 集合，假设是 gtid_purged1；然后先在从库上执行 reset master，再执行 set global gtid_purged =‘gtid_purged1’；最后执行 start slave，就会从主库现存的 binlog 开始同步。binlog 缺失的那一部分，数据在从库上就可能会有丢失，造成主从不一致。</li>
<li>如果需要主从数据一致的话，最好还是通过重新搭建从库来做。</li>
<li>如果有其他的从库保留有全量的 binlog 的话，可以把新的从库先接到这个保留了全量 binlog 的从库，追上日志以后，如果有需要，再接回主库。</li>
<li>如果 binlog 有备份的情况，可以先在从库上应用缺失的 binlog，然后再执行 start slave。</li>
</ol>
<h2 id="28讲-读写分离有哪些坑？"><a href="#28讲-读写分离有哪些坑？" class="headerlink" title="28讲 - 读写分离有哪些坑？"></a>28讲 - 读写分离有哪些坑？</h2><p>读写分离主要是为了分担主库的压力。有下面2中场景的架构</p>
<p>客户端直连：</p>
<img src="/2018/12/21/geektime-mysql-learn/1334b9c08b8fd837832fdb2d82e6b0aa.png">
<p>客户端通过proxy进行读写分离</p>
<img src="/2018/12/21/geektime-mysql-learn/065ef246c59019effc8384967d774318.png">
<ol>
<li>客户端直连方案，因为少了一层 proxy 转发，所以查询性能稍微好一点儿，并且整体架构简单，排查问题更方便。但是这种方案，由于要了解后端部署细节，所以在出现主备切换、库迁移等操作的时候，客户端都会感知到，并且需要调整数据库连接信息。你可能会觉得这样客户端也太麻烦了，信息大量冗余，架构很丑。其实也未必，一般采用这样的架构，一定会伴随一个负责管理后端的组件，比如 Zookeeper，尽量让业务端只专注于业务逻辑开发。</li>
<li>带 proxy 的架构，对客户端比较友好。客户端不需要关注后端细节，连接维护、后端信息维护等工作，都是由 proxy 完成的。但这样的话，对后端维护团队的要求会更高。而且，proxy 也需要有高可用架构。因此，带 proxy 架构的整体就相对比较复杂。</li>
</ol>
<p>但是，不论使用哪种架构，你都会碰到我们今天要讨论的问题：由于主从可能存在延迟，客户端执行完一个更新事务后马上发起查询，如果查询选择的是从库的话，就有可能读到刚刚的事务更新之前的状态。</p>
<p>这种“在从库上会读到系统的一个过期状态”的现象，在这篇文章里，我们暂且称之为“过期读”。</p>
<p>前面我们说过了几种可能导致主备延迟的原因，以及对应的优化策略，但是主从延迟还是不能 100% 避免的。</p>
<p>处理过期读的方案汇总</p>
<ul>
<li>强制走主库方案</li>
<li>sleep 方案</li>
<li>判断主备无延迟方案</li>
<li>配合 semi-sync 方案</li>
<li>等主库位点方案</li>
<li>等 GTID 方案</li>
</ul>
<h3 id="强制走主库方案"><a href="#强制走主库方案" class="headerlink" title="强制走主库方案"></a>强制走主库方案</h3><p>强制走主库方案其实就是，将查询请求做分类。通常情况下，我们可以将查询请求分为这么两类：</p>
<ul>
<li>对于必须要拿到最新结果的请求，强制将其发到主库上。比如，在一个交易平台上，卖家发布商品以后，马上要返回主页面，看商品是否发布成功。那么，这个请求需要拿到最新的结果，就必须走主库。</li>
<li>对于可以读到旧数据的请求，才将其发到从库上。在这个交易平台上，买家来逛商铺页面，就算晚几秒看到最新发布的商品，也是可以接受的。那么，这类请求就可以走从库。</li>
</ul>
<h3 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h3><p>主库更新后，读从库之前先 sleep 一下。具体的方案就是，类似于执行一条 select sleep(1) 命令。</p>
<p>这个方案的假设是，大多数情况下主备延迟在 1 秒之内，做一个 sleep 可以有很大概率拿到最新的数据。</p>
<h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>要确保备库无延迟，通常有三种做法。</p>
<h4 id="seconds-behind-master"><a href="#seconds-behind-master" class="headerlink" title="seconds_behind_master"></a>seconds_behind_master</h4><p>我们知道 show slave status 结果里的 seconds_behind_master 参数的值，可以用来衡量主备延迟时间的长短。</p>
<img src="/2018/12/21/geektime-mysql-learn/00110923007513e865d7f43a124887c1.png">
<p>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求。</p>
<p>seconds_behind_master 的单位是秒，如果你觉得精度不够的话，还可以采用对比位点和 GTID 的方法来确保主备无延迟，也就是我们接下来要说的第二和第三种方法。</p>
<h4 id="对比位点确保主备无延迟："><a href="#对比位点确保主备无延迟：" class="headerlink" title="对比位点确保主备无延迟："></a>对比位点确保主备无延迟：</h4><ul>
<li>Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；</li>
<li>Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li>
</ul>
<p>如果 Master_Log_File 和 Relay_Master_Log_File、Read_Master_Log_Pos 和 Exec_Master_Log_Pos 这两组值完全相同，就表示接收到的日志已经同步完成。</p>
<h4 id="对比-GTID-集合确保主备无延迟："><a href="#对比-GTID-集合确保主备无延迟：" class="headerlink" title="对比 GTID 集合确保主备无延迟："></a>对比 GTID 集合确保主备无延迟：</h4><ul>
<li>Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。</li>
<li>Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；</li>
<li>Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li>
</ul>
<p>如果这两个集合相同，也表示备库接收到的日志都已经同步完成。</p>
<p>可见，对比位点和对比 GTID 这两种方法，都要比判断 seconds_behind_master 是否为 0 更准确。    </p>
<p>在执行查询请求之前，先判断从库是否同步完成的方法，相比于 sleep 方案，准确度确实提升了不少，但还是没有达到“精确”的程度。为什么这么说呢？</p>
<p>我们现在一起来回顾下，一个事务的 binlog 在主备库之间的状态：</p>
<ol>
<li>主库执行完成，写入 binlog，并反馈给客户端；</li>
<li>binlog 被从主库发送给备库，备库收到；</li>
<li>在备库执行 binlog 完成。</li>
</ol>
<p>我们上面判断主备无延迟的逻辑，是“备库收到的日志都执行完成了”。但是，从 binlog 在主备之间状态的分析中，不难看出还有一部分日志，处于客户端已经收到提交确认，而备库还没收到日志的状态。</p>
<img src="/2018/12/21/geektime-mysql-learn/557445207b57d6c0f2747509d7d6619e.png">
<p>这时，主库上执行完成了三个事务 trx1、trx2 和 trx3，其中：</p>
<ul>
<li>trx1 和 trx2 已经传到从库，并且已经执行完成了；</li>
<li>trx3 在主库执行完成，并且已经回复给客户端，但是还没有传到从库中。</li>
</ul>
<p>如果这时候你在从库 B 上执行查询请求，按照我们上面的逻辑，从库认为已经没有同步延迟，但还是查不到 trx3 的。严格地说，就是出现了过期读。</p>
<p>那么，这个问题有没有办法解决呢？</p>
<p>配合 semi-sync</p>
<p>要解决这个问题，就要引入半同步复制，也就是 semi-sync replication。</p>
<p>semi-sync 做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把 binlog 发给从库；</li>
<li>从库收到 binlog 以后，发回给主库一个 ack，表示收到了；</li>
<li>主库收到这个 ack 以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>也就是说，如果启用了 semi-sync，就表示所有给客户端发送过确认的事务，都确保了备库已经收到了这个日志。</p>
<p>在 第 25 篇文章 的评论区，有同学问到：如果主库掉电的时候，有些 binlog 还来不及发给从库，会不会导致系统数据丢失？</p>
<p>答案是，如果使用的是普通的异步复制模式，就可能会丢失，但 semi-sync 就可以解决这个问题。</p>
<p>这样，semi-sync 配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是，semi-sync+ 位点判断的方案，只对一主一备的场景是成立的。在一主多从场景中，主库只要等到一个从库的 ack，就开始给客户端返回确认。这时，在从库上执行查询请求，就有两种情况：</p>
<ul>
<li>如果查询是落在这个响应了 ack 的从库上，是能够确保读到最新数据；</li>
<li>但如果是查询落到其他从库上，它们可能还没有收到最新的日志，就会产生过期读的问题。</li>
</ul>
<p>其实，判断同步位点的方案还有另外一个潜在的问题，即：如果在业务更新的高峰期，主库的位点或者 GTID 集合更新很快，那么上面的两个位点等值判断就会一直不成立，很可能出现从库上迟迟无法响应查询请求的情况。</p>
<p>实际上，回到我们最初的业务逻辑里，当发起一个查询请求以后，我们要得到准确的结果，其实并不需要等到“主备完全同步”。</p>
<p>为什么这么说呢？我们来看一下这个时序图。</p>
<img src="/2018/12/21/geektime-mysql-learn/9cf54f3e91dc8f7b8947d7d8e384aa09.png">
<p>图 5 所示，就是等待位点方案的一个 bad case。图中备库 B 下的虚线框，分别表示 relaylog 和 binlog 中的事务。可以看到，图 5 中从状态 1 到状态 4，一直处于延迟一个事务的状态。</p>
<p>备库 B 一直到状态 4 都和主库 A 存在延迟，如果用上面必须等到无延迟才能查询的方案，select 语句直到状态 4 都不能被执行。</p>
<p>但是，其实客户端是在发完 trx1 更新后发起的 select 语句，我们只需要确保 trx1 已经执行完成就可以执行 select 语句了。也就是说，如果在状态 3 执行查询请求，得到的就是预期结果了。</p>
<p>到这里，我们小结一下，semi-sync 配合判断主备无延迟的方案，存在两个问题：</p>
<ul>
<li>一主多从的时候，在某些从库执行查询请求会存在过期读的现象；</li>
<li>在持续延迟的情况下，可能出现过度等待的问题。</li>
</ul>
<p>接下来，我要和你介绍的等主库位点方案，就可以解决这两个问题。</p>
<h3 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h3><p>要理解等主库位点方案，我需要先和你介绍一条命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">master_pos_wait</span>(<span class="keyword">file</span>, pos[, <span class="keyword">timeout</span>]);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑如下：</p>
<ul>
<li>它是在从库执行的；</li>
<li>参数 file 和 pos 指的是主库上的文件名和位置；</li>
<li>timeout 可选，设置为正整数 N 表示这个函数最多等待 N 秒。</li>
</ul>
<p>这个命令正常返回的结果是一个正整数 M，表示从命令开始执行，到应用完 file 和 pos 表示的 binlog 位置，执行了多少事务。</p>
<p>当然，除了正常返回一个正整数 M 外，这条命令还会返回一些其他结果，包括：</p>
<ul>
<li>如果执行期间，备库同步线程发生异常，则返回 NULL；</li>
<li>如果等待超过 N 秒，就返回 -1；</li>
<li>如果刚开始执行的时候，就发现已经执行过这个位置了，则返回 0。</li>
</ul>
<p>对于图 5 中先执行 trx1，再执行一个查询请求的逻辑，要保证能够查到正确的数据，我们可以使用这个逻辑：</p>
<ul>
<li>trx1 事务更新完成后，马上执行 show master status 得到当前主库执行到的 File 和 Position；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select master_pos_wait(File, Position, 1)；</li>
<li>如果返回值是 &gt;=0 的正整数，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<img src="/2018/12/21/geektime-mysql-learn/b20ae91ea46803df1b63ed683e1de357.png">
<p>这里我们假设，这条 select 查询最多在从库上等待 1 秒。那么，如果 1 秒内 master_pos_wait 返回一个大于等于 0 的整数，就确保了从库上执行的这个查询结果一定包含了 trx1 的数据。</p>
<p>步骤 5 到主库执行查询语句，是这类方案常用的退化机制。因为从库的延迟时间不可控，不能无限等待，所以如果等待超时，就应该放弃，然后到主库去查。</p>
<p>你可能会说，如果所有的从库都延迟超过 1 秒了，那查询压力不就都跑到主库上了吗？确实是这样。</p>
<p>但是，按照我们设定不允许过期读的要求，就只有两种选择，一种是超时放弃，一种是转到主库查询。具体怎么选择，就需要业务开发同学做好限流策略了。</p>
<h3 id="GTID-方案"><a href="#GTID-方案" class="headerlink" title="GTID 方案"></a>GTID 方案</h3><p>如果你的数据库开启了 GTID 模式，对应的也有等待 GTID 的方案。</p>
<p>MySQL 中同样提供了一个类似的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wait_for_executed_gtid_set(gtid_set, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这条命令的逻辑是：</p>
<ul>
<li>等待，直到这个库执行的事务中包含传入的 gtid_set，返回 0；</li>
<li>超时返回 1。</li>
</ul>
<p>在前面等位点的方案中，我们执行完事务后，还要主动去主库执行 show master status。而 MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端，这样等 GTID 的方案就可以减少一次查询。</p>
<p>这时，等 GTID 的执行流程就变成了：</p>
<ul>
<li>trx1 事务更新完成后，从返回包直接获取这个事务的 GTID，记为 gtid1；</li>
<li>选定一个从库执行查询语句；</li>
<li>在从库上执行 select wait_for_executed_gtid_set(gtid1, 1)；</li>
<li>如果返回值是 0，则在这个从库执行查询语句；</li>
<li>否则，到主库执行查询语句。</li>
</ul>
<p>跟等主库位点的方案一样，等待超时后是否直接到主库查询，需要业务开发同学来做限流考虑。</p>
<img src="/2018/12/21/geektime-mysql-learn/d521de8017297aff59db2f68170ee739.png">
<p>在上面的第一步中，trx1 事务更新完成后，从返回包直接获取这个事务的 GTID。问题是，怎么能够让 MySQL 在执行事务后，返回包中带上 GTID 呢？</p>
<p>你只需要将参数 session_track_gtids 设置为 OWN_GTID，然后通过 API 接口 mysql_session_track_get_first 从返回包解析出 GTID 的值即可。</p>
<p>在专栏的第一篇文章中，我介绍 mysql_reset_connection 的时候，评论区有同学留言问这类接口应该怎么使用。</p>
<p>这里我再回答一下。其实，MySQL 并没有提供这类接口的 SQL 用法，是提供给程序的 API <a href="https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/c-api-functions.html</a></p>
<p>比如，为了让客户端在事务提交后，返回的 GITD 能够在客户端显示出来，我对 MySQL 客户端代码做了点修改，如下所示：</p>
<img src="/2018/12/21/geektime-mysql-learn/973bdd8741f830acebe005cbf37a7663.png">
<p>这样，就可以看到语句执行完成，显示出 GITD 的值。</p>
<p>当然了，这只是一个例子。你要使用这个方案的时候，还是应该在你的客户端代码中调用 mysql_session_track_get_first 这个函数。</p>
<h3 id="课后题-15"><a href="#课后题-15" class="headerlink" title="课后题"></a>课后题</h3><p>假设你的系统采用了我们文中介绍的最后一个方案，也就是等 GTID 的方案，现在你要对主库的一张大表做 DDL，可能会出现什么情况呢？为了避免这种情况，你会怎么做呢？</p>
<p>答案：如果该DDL语句在主库执行了10min，那么提交后传到备库执行也需要10min。之后主库DDL后提交的事务的GTID，在备库查询时，需要等待10min才会出现，此时，所有的读请求都会路由到主库。</p>
<p>方法1：在业务低峰期进行，确保主库可以满足所有的查询压力，把所有的读请求都路由到主库上。等备库追上主库后切回来。<br>方法2：先在被库执行DDL，再将备库切换主库。</p>
<h2 id="29讲-如何判断一个数据库是不是出问题了？"><a href="#29讲-如何判断一个数据库是不是出问题了？" class="headerlink" title="29讲-如何判断一个数据库是不是出问题了？"></a>29讲-如何判断一个数据库是不是出问题了？</h2><h3 id="主备切换"><a href="#主备切换" class="headerlink" title="主备切换"></a>主备切换</h3><ul>
<li>主动切换</li>
<li>被动切换(HA系统发起)</li>
</ul>
<h3 id="主库健康检查"><a href="#主库健康检查" class="headerlink" title="主库健康检查"></a>主库健康检查</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select 1"></a>select 1</h4><p>只能判断MySQL进程存在</p>
<ul>
<li>innodb_thread_concurrency 控制innodb并发线程上限，超过该值的请求进入等待状态。 默认该值为0，表示不限制。</li>
<li>并发连接 != 并发查询(<code>innodb_thread_concurrency</code>)， show processlist查询的是并发连接</li>
<li>进入锁等待的线程不占用<code>innodb_thread_concurrency</code>的值。</li>
</ul>
<h4 id="查询表判断"><a href="#查询表判断" class="headerlink" title="查询表判断"></a>查询表判断</h4><p>创建一个表<code>health_check</code>，定时检查。</p>
<p>这种方法能检查因并发线程多导致系统不可用的情况。</p>
<h4 id="更新判断"><a href="#更新判断" class="headerlink" title="更新判断"></a>更新判断</h4><p>执行update语句，来判断是否有足够的磁盘来保证系统的正常运行（更新会写binlog和redo log，磁盘空间不足会导致所有的更新都阻塞）。</p>
<p>主备都需要做健康检查：</p>
<p>双M架构下，为了防止主备之间的更新冲突，<code>mysql.health_check</code>表插入多行数据，以<code>server_id</code>作为主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `health_check` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(<span class="keyword">id</span>, t_modified) <span class="keyword">values</span> (@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure>
<h3 id="外部检查的局限性"><a href="#外部检查的局限性" class="headerlink" title="外部检查的局限性"></a>外部检查的局限性</h3><p>上面提到的都是外部检查的实现方案。有一定的缺点：</p>
<ol>
<li>随机性。轮询进行健康检查，不能及时发现问题。</li>
<li>外部健康检查请求需要的资源少，能马上执行，但是其他业务请求不能正常处理。</li>
</ol>
<h3 id="内部检查"><a href="#内部检查" class="headerlink" title="内部检查"></a>内部检查</h3><p><code>performance_schema</code>里面有多个表，可以统计系统的健康状况。</p>
<h2 id="30讲-用动态的观点看加锁"><a href="#30讲-用动态的观点看加锁" class="headerlink" title="30讲 - 用动态的观点看加锁"></a>30讲 - 用动态的观点看加锁</h2><h2 id="31讲-误删数据库处理"><a href="#31讲-误删数据库处理" class="headerlink" title="31讲 - 误删数据库处理"></a>31讲 - 误删数据库处理</h2><h2 id="32讲-为什么还有kill不掉的语句"><a href="#32讲-为什么还有kill不掉的语句" class="headerlink" title="32讲 - 为什么还有kill不掉的语句"></a>32讲 - 为什么还有kill不掉的语句</h2><h2 id="33讲-我查这么多数据会不会把数据库打爆"><a href="#33讲-我查这么多数据会不会把数据库打爆" class="headerlink" title="33讲 - 我查这么多数据会不会把数据库打爆"></a>33讲 - 我查这么多数据会不会把数据库打爆</h2><h2 id="34讲-到底可不可以使用Join"><a href="#34讲-到底可不可以使用Join" class="headerlink" title="34讲 - 到底可不可以使用Join"></a>34讲 - 到底可不可以使用Join</h2><h2 id="35讲-join语句怎么优化"><a href="#35讲-join语句怎么优化" class="headerlink" title="35讲 - join语句怎么优化"></a>35讲 - join语句怎么优化</h2><h2 id="36讲-为什么临时表可以重名"><a href="#36讲-为什么临时表可以重名" class="headerlink" title="36讲 - 为什么临时表可以重名"></a>36讲 - 为什么临时表可以重名</h2><h2 id="37讲-什么时候会使用内部临时表"><a href="#37讲-什么时候会使用内部临时表" class="headerlink" title="37讲 - 什么时候会使用内部临时表"></a>37讲 - 什么时候会使用内部临时表</h2><h3 id="union-执行流程"><a href="#union-执行流程" class="headerlink" title="union 执行流程"></a>union 执行流程</h3><p>初始化数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>意思是取2个子查询结果的并集。</p>
<img src="/2018/12/21/geektime-mysql-learn/402cbdef84eef8f1b42201c6ec4bad4e.png">
<p><code>using temporary</code> 表示使用了临时表。</p>
<p>该语句的执行流程如下：</p>
<ol>
<li>创建一个只有一个整形字段<code>f</code>，且<code>f</code>是主键的临时表。</li>
<li>执行第一个子查询，得到1000这个值，插入到临时表中。</li>
<li>执行第二个子查询，得到1000插入临时表时，违反唯一性约束，失败，然后继续执行。</li>
<li>取第二行999，插入临时表成功。结束。</li>
<li>从临时表获取数据，返回给客户端，并删除临时表。</li>
</ol>
<p>可以看出：临时表使用来<code>暂存</code>数据的。</p>
<p>如果将<code>union</code>改为<code>union all</code>，没有去重语义，这样就依次执行子查询，将结果返回给客户端，不会使用到临时表。</p>
<img src="/2018/12/21/geektime-mysql-learn/c1e90d1d7417b484d566b95720fe3f6d.png">
<h3 id="group-by-执行流程"><a href="#group-by-执行流程" class="headerlink" title="group by 执行流程"></a>group by 执行流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>该语句的逻辑是，将表中的数据按<code>1d%10</code>后的结果进行分组统计，然后按<code>m</code>的结果排序后输出。</p>
<img src="/2018/12/21/geektime-mysql-learn/3d1cb94589b6b3c4bb57b0bdfa385d98.png">
<p>从explain的结果可以知道：</p>
<ol>
<li>Using index, 表示使用了覆盖索引，选择了索引a， 不需要回表。</li>
<li>Using temporary，表示使用了临时表。</li>
<li>Using filesort，表示使用了文件排序。</li>
</ol>
<p>语句执行流程如下：</p>
<ol>
<li>创建一个临时表，包含字段 <code>m</code> 和 <code>c</code>, 主键是<code>m</code>。</li>
<li>扫描索引<code>a</code>，依次取出叶子节点上的id值，计算<code>id%10</code>的结果，记为x。</li>
<li>如果临时表中没有主键为x的行，则插入(x, 1)；如果存在，则对x行的c列加一。</li>
<li>遍历<code>索引a</code>完成后，对临时表按<code>m</code>进行排序，得到的结果输出给客户端。</li>
</ol>
<img src="/2018/12/21/geektime-mysql-learn/0399382169faf50fc1b354099af71954.jpg">
<p>内存临时表的排序如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/b5168d201f5a89de3b424ede2ebf3d68.jpg">
<blockquote>
<p>注意：如果不需要对结果进行排序，可以在语句后面添加<code>order by null</code>来取消排序过程。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>内存临时表的大小由<code>tmp_table_size</code>来设置(默认是16M)，如果数据量很大，不能全部保存在内存临时表中，此时就会使用磁盘临时表。磁盘临时表使用的是Innodb存储引擎。</p>
<h3 id="group-by的优化方法-索引"><a href="#group-by的优化方法-索引" class="headerlink" title="group by的优化方法 - 索引"></a>group by的优化方法 - 索引</h3><p>不论是内存临时表还是磁盘临时表，都需创建一个带有主键的临时表。</p>
<p>group by 的语义逻辑，是统计不同的值出现的个数。但是，由于每一行的 id%100 的结果是无序的，所以我们就需要有一个临时表，来记录并统计结果。</p>
<p>那么，如果扫描过程中可以保证出现的数据是有序的，是不是就简单了呢？</p>
<p>假设，现在有一个类似图 10 的这么一个数据结构，我们来看看 group by 可以怎么做。</p>
<img src="/2018/12/21/geektime-mysql-learn/5c4a581c324c1f6702f9a2c70acddd19.jpg">
<p>可以看到，如果可以确保输入的数据是有序的，那么计算 <code>group by</code> 的时候，就只需要从左到右，顺序扫描，依次累加。</p>
<p>按照这个逻辑执行的话，扫描到整个输入的数据结束，就可以拿到 <code>group by</code> 的结果，不需要临时表，也不需要再额外排序。</p>
<p>InnoDB 的索引，就可以满足这个输入有序的条件。</p>
<p>在 MySQL 5.7 版本支持了 generated column 机制，用来实现列数据的关联更新。你可以用下面的方法创建一个列 z，然后在 z 列上创建一个索引（如果是 MySQL 5.6 及之前的版本，你也可以创建普通列和索引，来解决这个问题）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="built_in">int</span> <span class="keyword">generated</span> <span class="keyword">always</span> <span class="keyword">as</span>(<span class="keyword">id</span> % <span class="number">100</span>), <span class="keyword">add</span> <span class="keyword">index</span>(z);</span><br></pre></td></tr></table></figure>
<p>这样，索引 z 上的数据就是类似图 10 这样有序的了。上面的 group by 语句就可以改成：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> z, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br></pre></td></tr></table></figure>

<h3 id="group-by-优化方法-–-直接排序"><a href="#group-by-优化方法-–-直接排序" class="headerlink" title="group by 优化方法 – 直接排序"></a>group by 优化方法 – 直接排序</h3><p>如果可以通过加索引来完成 group by 逻辑就再好不过了。但是，如果碰上不适合创建索引的场景，我们还是要老老实实做排序的。那么，这时候的 group by 要怎么优化呢？</p>
<p>如果我们明明知道，一个 group by 语句中需要放到临时表上的数据量特别大，却还是要按照“先放到内存临时表，插入一部分数据后，发现内存临时表不够用了再转成磁盘临时表”，看上去就有点儿傻。</p>
<p>在 group by 语句中加入 <code>SQL_BIG_RESULT</code> 这个提示（hint），就可以告诉优化器：这个语句涉及的数据量很大，请直接用磁盘临时表。</p>
<p>MySQL 的优化器一看，磁盘临时表是 B+ 树存储，存储效率不如数组来得高。所以，既然你告诉我数据量很大，那从磁盘空间考虑，还是直接用数组来存吧。</p>
<p>下面语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_BIG_RESULT</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure>
<p>执行流程：</p>
<ul>
<li>初始化 sort_buffer，确定放入一个整型字段，记为 m；    </li>
<li>扫描表 t1 的索引 a，依次取出里面的 id 值, 将 id%100 的值存入 sort_buffer 中；</li>
<li>扫描完成后，对 sort_buffer 的字段 m 做排序（如果 sort_buffer 内存不够用，就会利用磁盘临时文件辅助排序）；</li>
<li>排序完成后，就得到了一个有序数组。</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>基于上面的 union、union all 和 group by 语句的执行过程的分析，我们来回答文章开头的问题：MySQL 什么时候会使用内部临时表？</p>
<ul>
<li>如果语句执行过程可以一边读数据，一边直接得到结果，是不需要额外内存的，否则就需要额外的内存，来保存中间结果；</li>
<li>join_buffer 是无序数组，sort_buffer 是有序数组，临时表是二维表结构；</li>
<li>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。比如我们的例子中，union 需要用到唯一索引约束， group by 还需要用到另外一个字段来存累积计数。</li>
</ul>
<h2 id="38讲-都说InnoDB好，那还要不要使用Memory引擎？"><a href="#38讲-都说InnoDB好，那还要不要使用Memory引擎？" class="headerlink" title="38讲 - 都说InnoDB好，那还要不要使用Memory引擎？"></a>38讲 - 都说InnoDB好，那还要不要使用Memory引擎？</h2><p>Innodb引擎 </p>
<img src="/2018/12/21/geektime-mysql-learn/4e29e4f9db55ace6ab09161c68ad8c8d.jpg">
<p>Memory引擎</p>
<p>与 InnoDB 引擎不同，Memory 引擎的数据和索引是分开的。我们来看一下表 t1 中的数据内容。</p>
<img src="/2018/12/21/geektime-mysql-learn/dde03e92074cecba4154d30cd16a9684.jpg">
<p>可以看到，内存表的<code>数据部分以数组</code>的方式单独存放，而主键 id 索引里，存的是每个<code>数据的位置</code>。主键 id 是 <code>hash</code> 索引，可以看到索引上的 <code>key 并不是有序的</code>。</p>
<ol>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为索引组织表（Index Organizied Table）。</li>
<li>而 Memory 引擎采用的是把数据单独存放，索引上保存<code>数据位置</code>的数据组织形式，我们称之为堆组织表（Heap Organizied Table）。</li>
</ol>
<p>从中我们可以看出，这两个引擎的一些典型不同：</p>
<ol>
<li>InnoDB 表的数据总是有序存放的，而内存表的数据就是按照写入顺序存放的；</li>
<li>当数据文件有空洞的时候，InnoDB 表在插入新数据的时候，为了保证数据有序性，只能在固定的位置写入新值，而内存表找到空位就可以插入新值；</li>
<li>数据位置发生变化的时候，InnoDB 表只需要修改主键索引，而内存表需要修改所有索引；</li>
<li>InnoDB 表用主键索引查询时需要走一次索引查找，用普通索引查询的时候，需要走两次索引查找。而内存表没有这个区别，所有索引的“地位”都是相同的。</li>
<li>InnoDB 支持变长数据类型，不同记录的长度可能不同；内存表不支持 Blob 和 Text 字段，并且即使定义了 varchar(N)，实际也当作 char(N)，也就是固定长度字符串来存储，因此内存表的每行数据长度相同。</li>
</ol>
<p>需要指出的是，表 t1 的这个主键索引是哈希索引，因此如果执行范围查询，比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>&lt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>是用不上主键索引的，需要走全表扫描。</p>
<h3 id="hash-索引和-B-Tree-索引"><a href="#hash-索引和-B-Tree-索引" class="headerlink" title="hash 索引和 B-Tree 索引"></a>hash 索引和 B-Tree 索引</h3><p>实际上，内存表也是支 B-Tree 索引的。在 id 列上创建一个 B-Tree 索引，SQL 语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">index</span> a_btree_index <span class="keyword">using</span> btree (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<p>这时，表 t1 的数据组织形式就变成了这样：</p>
<img src="/2018/12/21/geektime-mysql-learn/1788deca56cb83c114d8353c92e3bde3.jpg">
<p>不建议你在生产环境上使用内存表，原因如下：</p>
<ul>
<li>锁粒度问题；</li>
<li>数据持久化问题。</li>
</ul>
<h3 id="内存表的锁"><a href="#内存表的锁" class="headerlink" title="内存表的锁"></a>内存表的锁</h3><p>内存表不支持行锁，只支持表锁。因此，一张表只要有更新，就会堵住其他所有在这个表上的读写操作。</p>
<h3 id="数据持久性问题"><a href="#数据持久性问题" class="headerlink" title="数据持久性问题"></a>数据持久性问题</h3><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p>
<p>在高可用架构下，稳定性很差，可能发生主从库的数据都被情况的异常。</p>
<p>重启会丢数据，如果一个备库重启，会导致主备同步线程停止；如果主库跟这个备库是双 M 架构，还可能导致主库的内存表数据被删掉。</p>
<blockquote>
<p>建议你把普通内存表都用 InnoDB 表来代替。<br>基于内存表的特性，它的一个适用场景，就是内存临时表。内存表支持 hash 索引，这个特性利用起来，对复杂查询的加速效果还是很不错的。</p>
</blockquote>
<h2 id="自增主键为什么不是连续的"><a href="#自增主键为什么不是连续的" class="headerlink" title="自增主键为什么不是连续的?"></a>自增主键为什么不是连续的?</h2><ol>
<li>不同引擎自增主键的值保存在不同的地方。</li>
<li>Memory 保存在数据文件中</li>
<li>MySQL8.0之前保存在内存中，重启会丢失。8.0开始保存在redo log 中。</li>
</ol>
<h3 id="自增值修改机制"><a href="#自增值修改机制" class="headerlink" title="自增值修改机制"></a>自增值修改机制</h3><ol>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ol>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设，某次要插入的值是 X，当前的自增值是 Y。</p>
<ol>
<li>如果 X&lt;Y，那么这个表的自增值不变；</li>
<li>如果 X≥Y，就需要把当前自增值修改为新的自增值。</li>
</ol>
<p>新的自增值生成算法是：</p>
<blockquote>
<p>从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 X 的值，作为新的自增值。</p>
</blockquote>
<p>其中，auto_increment_offset 和 auto_increment_increment 是两个系统参数，分别用来表示自增的初始值和步长，默认值都是 1。</p>
<blockquote>
<p>备注：在一些场景下，使用的就不全是默认值。比如，双 M 的主备结构里要求双写的时候，我们就可能会设置成 auto_increment_increment=2，让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数，避免两个库生成的主键发生冲突。</p>
</blockquote>
<p>当 auto_increment_offset 和 auto_increment_increment 都是 1 的时候，新的自增值生成逻辑很简单，就是：</p>
<ul>
<li>如果准备插入的值 &gt;= 当前自增值，新的自增值就是“准备插入的值 +1”；</li>
<li>否则，自增值不变。</li>
</ul>
<h3 id="自增值的修改时机"><a href="#自增值的修改时机" class="headerlink" title="自增值的修改时机"></a>自增值的修改时机</h3><p>假设，表 t 里面已经有了 (1,1,1) 这条记录，这时我再执行一条插入数据命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>执行器调用 InnoDB 引擎接口写入一行，传入的这一行的值是 (0,1,1);</li>
<li>InnoDB 发现用户没有指定自增 id 的值，获取表 t 当前的自增值 2；</li>
<li>将传入的行的值改成 (2,1,1);</li>
<li>将表的自增值改成 3；</li>
<li>继续执行插入数据操作，由于已经存在 c=1 的记录，所以报 Duplicate key error，语句返回。</li>
</ol>
<p>可以看到，这个表的自增值改成 3，是在真正执行插入数据的操作之前。这个语句真正执行的时候，因为碰到唯一键 c 冲突，所以 id=2 这一行并没有插入成功，<code>但也没有将自增值再改回去</code>。</p>
<blockquote>
<p>唯一键冲突是导致自增主键 id 不连续的第一种原因。<br>事务回滚也会产生类似的现象，这就是第二种原因。</p>
</blockquote>
<p>你可能会问，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表 t 的自增值改回去呢？如果把表 t 的当前自增值从 3 改回 2，再插入新数据的时候，不就可以生成 id=2 的一行数据了吗？</p>
<p>其实，MySQL 这么设计是为了提升性能。接下来，我就跟你分析一下这个设计思路，看看</p>
<p>假设有两个并行执行的事务，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请。</p>
<ol>
<li>假设事务 A 申请到了 id=2， 事务 B 申请到 id=3，那么这时候表 t 的自增值是 4，之后继续执行。</li>
<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突。</li>
<li>如果允许事务 A 把自增 id 回退，也就是把表 t 的当前自增值改回 2，那么就会出现这样的情况：表里面已经有 id=3 的行，而当前的自增 id 值是 2。</li>
<li>接下来，继续执行的其他事务就会申请到 id=2，然后再申请到 id=3。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id。如果存在，就跳过这个 id。但是，这个方法的成本很高。因为，本来申请 id 是一个很快的操作，现在还要再去主键索引树上判断 id 是否存在。</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id。这个方法的问题，就是锁的粒度太大，系统并发能力大大下降。</li>
</ol>
<p>可见，这两个方法都会导致性能问题。造成这些麻烦的罪魁祸首，就是我们假设的这个“允许自增 id 回退”的前提导致的。</p>
<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>
<h3 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h3><p>可以看到，自增 id 锁并不是一个事务锁，而是每次申请完就马上释放，以便允许别的事务再申请。其实，在 MySQL 5.1 版本之前，并不是这样的。</p>
<p>在 MySQL 5.0 版本的时候，自增锁的范围是语句级别。也就是说，如果一个语句申请了一个表自增锁，这个锁会等语句执行结束以后才释放。显然，这样设计会影响并发度。</p>
<p>MySQL 5.1.22 版本引入了一个新策略，新增参数 innodb_autoinc_lock_mode，默认值是 1。</p>
<ol>
<li>这个参数的值被设置为 0 时，表示采用之前 MySQL 5.0 版本的策略，即语句执行结束后才释放锁；</li>
<li>这个参数的值被设置为 1 时：<ul>
<li>普通 insert 语句，自增锁在申请之后就马上释放；</li>
<li>类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；</li>
</ul>
</li>
<li>这个参数的值被设置为 2 时，所有的申请自增主键的动作都是申请后就释放锁。    </li>
</ol>
<p>为什么默认设置下，insert … select 要使用语句级的锁？为什么这个参数的默认值不是 2？</p>
<p>答案是，这么设计还是为了数据的一致性。</p>
<p>我们一起来看一下这个场景：</p>
<img src="/2018/12/21/geektime-mysql-learn/e0a69e151277de54a8262657e4ec89df.png">
<p>你可以设想一下，如果 session B 是申请了自增值以后马上就释放自增锁，那么就可能出现这样的情况：</p>
<ul>
<li>session B 先插入了两个记录，(1,1,1)、(2,2,2)；</li>
<li>然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；</li>
<li>之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。</li>
</ul>
<p>你可能会说，这也没关系吧，毕竟 session B 的语义本身就没有要求表 t2 的所有行的数据都跟 session A 相同。</p>
<p>是的，从数据逻辑上看是对的。但是，如果我们现在的 binlog_format=statement，你可以设想下，binlog 会怎么记录呢？</p>
<p>由于两个 session 是同时执行插入数据命令的，所以 binlog 里面对表 t2 的更新日志只有两种情况：要么先记 session A 的，要么先记 session B 的。</p>
<p>但不论是哪一种，这个 binlog 拿去从库执行，或者用来恢复临时实例，备库和临时实例里面，session B 这个语句执行出来，生成的结果里面，id 都是连续的。这时，这个库就发生了数据不一致。</p>
<p>原因在于原库 session B 的 insert 语句，生成的 id 不连续。这个不连续的 id，用 statement 格式的 binlog 来串行执行，是执行不出来的。</p>
<p>而要解决这个问题，有两种思路：</p>
<ol>
<li>一种思路是，让原库的批量插入数据语句，固定生成连续的 id 值。所以，自增锁直到语句执行结束才释放，就是为了达到这个目的。</li>
<li>另一种思路是，在 binlog 里面把插入数据的操作都如实记录进来，到备库执行的时候，不再依赖于自增主键去生成。这种情况，其实就是 innodb_autoinc_lock_mode 设置为 2，同时 binlog_format 设置为 row。</li>
</ol>
<p>因此，在生产上，尤其是有 insert … select 这种批量插入数据的场景时，从并发插入数据性能的角度考虑，我建议你这样设置：innodb_autoinc_lock_mode=2 ，并且 binlog_format=row. 这样做，既能提升并发性，又不会出现数据一致性问题。</p>
<p>需要注意的是，我这里说的，批量插入数据，包含的语句类型是 insert … select、replace … select 和 load data 语句。</p>
<p>但是，在普通的 insert 语句里面包含多个 value 值的情况下，即使 innodb_autoinc_lock_mode 设置为 1，也不会等语句执行完成才释放锁。因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>也就是说，批量插入数据的语句，之所以需要这么设置，是因为<code>不知道要预先申请多少个 id</code>。</p>
<p>既然预先不知道要申请多少个自增 id，那么一种直接的想法就是需要一个时申请一个。但如果一个 select … insert 语句要插入 10 万行数据，按照这个逻辑的话就要申请 10 万次。显然，这种申请自增 id 的策略，在大批量插入数据的情况下，不但速度慢，还会影响并发插入的性能。</p>
<p>因此，对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ul>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">5</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>insert…select，实际上往表 t2 中插入了 4 行数据。但是，这四行数据是分三次申请的自增 id，第一次申请到了 id=1，第二次被分配了 id=2 和 id=3， 第三次被分配到 id=4 到 id=7。</p>
<p>由于这条语句实际只用上了 4 个 id，所以 id=5 到 id=7 就被浪费掉了。之后，再执行 insert into t2 values(null, 5,5)，实际上插入的数据就是（8,5,5)。</p>
<blockquote>
<p>这是主键 id 出现自增 id 不连续的第三种原因。</p>
</blockquote>
<h3 id="课后题-16"><a href="#课后题-16" class="headerlink" title="课后题"></a>课后题</h3><p>在最后一个例子中，执行 insert into t2(c,d) select c,d from t; 这个语句的时候，如果隔离级别是可重复读（repeatable read），binlog_format=statement。这个语句会对表 t 的所有记录和间隙加锁。</p>
<p>答案：</p>
<h2 id="40-讲-insert语句的锁为什么这么多？"><a href="#40-讲-insert语句的锁为什么这么多？" class="headerlink" title="40 讲 insert语句的锁为什么这么多？"></a>40 讲 insert语句的锁为什么这么多？</h2><h2 id="41讲-怎么快速复制一张表？"><a href="#41讲-怎么快速复制一张表？" class="headerlink" title="41讲 - 怎么快速复制一张表？"></a>41讲 - 怎么快速复制一张表？</h2><p>如果可以控制对源表的扫描行数和加锁范围很小的话，可以简单的使用<code>insert select</code> 语句实现。</p>
<p>如果需要避免对源表加锁，稳妥的解决办法是将数据保存到临时文件中，然后再写入目标表。此时有两种办法如下：</p>
<p>创建表 db1.t:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></table></figure>
<h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>将db1.t表中的&gt;900的数据导出到文件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">--add-locks --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ol>
<li>–single-transaction 意思是导出数据的是，不需要对db1.t加表锁，而是使用<code>start transaction with consitent snapshot</code>方法。</li>
<li>–add-locks 设置为0，表示在输出的文件中，不增加<code>lock tables t write</code></li>
<li>–no-create-info 表示不要导出表结构</li>
<li>–set-gtid-purged=OFF 表示不要输出和gtid相关的信息</li>
<li>–result-file 指定数据文件的路径，client表示文件位于客户端机器上。</li>
</ol>
<p>输出的文件内存是<code>insert values (...),(...)</code>格式，目的是为了加快执行速度。</p>
<p>可以通过参数<code>--skip-extended-insert</code>变为一个个的insert语句。</p>
<p>通过下面的语句将数据导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"</span><br></pre></td></tr></table></figure>
<h3 id="导出csv文件"><a href="#导出csv文件" class="headerlink" title="导出csv文件"></a>导出csv文件</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ol>
<li>该语句的结果是保存在服务端的。</li>
<li>into outfile指定了文件的位置，这个位置必须受参数<code>secure_file_priv</code>限制。1，设置为empty表示不限制(不安全)。2,如果是一个表示路径的字符串，表示只能保存在这个目录。3,设置为NULL表示禁止执行该操作。</li>
<li>该命令不会帮你覆盖已经存在的文件。</li>
<li>原则上一行数据对应文本中的一行，但是字段值有换行符，文本中也会包含换行符，但是会被转义。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure>
<p>执行流程如下：</p>
<ol>
<li>打开文件，以制表符<code>\t</code>作为字段值得分隔符，以换行符<code>\n</code>作为记录之间的分隔符进行数据读取。</li>
<li>启动事务。</li>
<li>判断每一行的字段数和目标表是否相同，不相同就会报错，事务回滚。相同，构造一行数据，调用存储引擎接口写入表中。</li>
<li>重复步骤3，直到读完整个文件。提交事务。</li>
</ol>
<p>从库：</p>
<ol>
<li>主库执行完成后，将导出的文件<code>/server_tmp/t.csv</code>内容直接写入binlog。</li>
<li>往 binlog 文件中写入语句 load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li>
<li>把这个 binlog 日志传到备库。</li>
<li>备库的 apply 线程在执行这个事务日志时：<br> a. 先将 binlog 中 t.csv 文件的内容读出来，写入到本地临时目录 /tmp/SQL_LOAD_MB-1-0 中；<br> b. 再执行 load data 语句，往备库的 db2.t 表中插入跟主库相同的数据。</li>
</ol>
<p>整个执行流程：</p>
<img src="/2018/12/21/geektime-mysql-learn/3a6790bc933af5ac45a75deba0f52cfd.jpg">
<p>注意，这里备库执行的 load data 语句里面，多了一个“local”。它的意思是“将执行这条命令的客户端所在机器的本地文件 /tmp/SQL_LOAD_MB-1-0 的内容，加载到目标表 db2.t 中”。</p>
<p>也就是说，load data 命令有两种用法</p>
<ul>
<li>不加“local”，是读取服务端的文件，这个文件必须在 secure_file_priv 指定的目录或子目录下；</li>
<li>加上“local”，读取的是客户端的文件，只要 mysql 客户端有访问这个文件的权限即可。这时候，MySQL 客户端会先把本地文件传给服务端，然后执行上述的 load data 流程。</li>
</ul>
<p>另外需要注意的是，select …into outfile 方法不会生成表结构文件, 所以我们导数据时还需要单独的命令得到表结构定义。mysqldump 提供了一个–tab 参数，可以同时导出表结构定义文件和 csv 数据文件。这条命令的使用方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=$secure_file_priv</span></span><br></pre></td></tr></table></figure>
<p>这条命令会在 <code>$secure_file_priv</code> 定义的目录下，创建一个 t.sql 文件保存建表语句，同时创建一个 t.txt 文件保存 CSV 数据。</p>
<h3 id="物理拷贝方法"><a href="#物理拷贝方法" class="headerlink" title="物理拷贝方法"></a>物理拷贝方法</h3><p>前面我们提到的 mysqldump 方法和导出 CSV 文件的方法，都是逻辑导数据的方法，也就是将数据从表 db1.t 中读出来，生成文本，然后再写入目标表 db2.t 中。</p>
<p>你可能会问，有物理导数据的方法吗？比如，直接把 db1.t 表的.frm 文件和.ibd 文件拷贝到 db2 目录下，是否可行呢？</p>
<p>答案是不行的。</p>
<p>因为，一个 InnoDB 表，除了包含这两个物理文件外，还需要在数据字典中注册。直接拷贝这两个文件的话，因为数据字典中没有 db2.t 这个表，系统是不会识别和接受它们的。</p>
<p>不过，在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设我们现在的目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<p>流程如下：</p>
<img src="/2018/12/21/geektime-mysql-learn/2407737651cdc1f5d6ade4d8907e7c05.jpg">
<p>关于拷贝表的这个流程，有以下几个注意点：</p>
<ol>
<li>在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；</li>
<li>在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 t.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是对极客时间专栏&lt;a href=&quot;https://time.geekbang.org/column/139&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL实战45讲&lt;/a&gt; 文章内容和讨论区内容的总结。&lt;/p&gt;
&lt;h2 id=&quot;第一讲-基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;a href=&quot;#第一讲-基础架构：一条SQL查询语句是如何执行的？&quot; class=&quot;headerlink&quot; title=&quot;第一讲 基础架构：一条SQL查询语句是如何执行的？&quot;&gt;&lt;/a&gt;第一讲 基础架构：一条SQL查询语句是如何执行的？&lt;/h2&gt;&lt;h3 id=&quot;mysql-架构&quot;&gt;&lt;a href=&quot;#mysql-架构&quot; class=&quot;headerlink&quot; title=&quot;mysql 架构&quot;&gt;&lt;/a&gt;mysql 架构&lt;/h3&gt;&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/mysql_arch.png&quot;&gt;
&lt;ol&gt;
&lt;li&gt;MySQL 可以分为 Server 层和存储引擎层两部&lt;/li&gt;
&lt;li&gt;Sever 层提供了大多数核心的功能， 例如：连接管理，权限验证，查询缓存，词法分析，语法分析，优化器，执行器等。&lt;/li&gt;
&lt;li&gt;存储引擎负责数据的存储，插件式设计。InnoDB， MyISAM, Memeory, Archive等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;连接器&quot;&gt;&lt;a href=&quot;#连接器&quot; class=&quot;headerlink&quot; title=&quot;连接器&quot;&gt;&lt;/a&gt;连接器&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;负责为何和客户端的TCP连接， 权限获取，验证。&lt;/li&gt;
&lt;li&gt;连接器从权限表里面获取用户对应的权限，验证通过后保存在连接中（会话中）后续的所有操作不在查询权限表。 修改权限不影响已经已经存在的连接。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;show processlits&lt;/code&gt;查看当前所有的连接。&lt;img src=&quot;/2018/12/21/geektime-mysql-learn/show_processlist.png&quot;&gt;&lt;/li&gt;
&lt;li&gt;如果连接在&lt;code&gt;wait_timeout&lt;/code&gt;指定的时间内没有任何操作，则会被关闭。默认是8小时。&lt;/li&gt;
&lt;li&gt;长时间存活的连接会导致MySQL服务内存占用过大，原因是MySQL临时申请的内存保存在连接对象中，直到连接关闭才会释放。&lt;ul&gt;
&lt;li&gt;定时关闭连接 或 执行了大的查询语句后断开连接&lt;/li&gt;
&lt;li&gt;MySQL5.7以后的版本可以通过&lt;code&gt;mysql_reset_connection&lt;/code&gt;重新初始化连接（不会重新验证权限）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>极客时间-算法-学习总结</title>
    <link href="https://leokongwq.github.io/2018/12/17/geektime-algo-summary.html"/>
    <id>https://leokongwq.github.io/2018/12/17/geektime-algo-summary.html</id>
    <published>2018-12-17T01:05:50.000Z</published>
    <updated>2019-03-11T08:27:05.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统高效地学习数据结构与算法"><a href="#系统高效地学习数据结构与算法" class="headerlink" title="系统高效地学习数据结构与算法"></a>系统高效地学习数据结构与算法</h2><h3 id="什么是数据结构？什么是算法"><a href="#什么是数据结构？什么是算法" class="headerlink" title="什么是数据结构？什么是算法?"></a>什么是数据结构？什么是算法?</h3><p>广义定义：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p>
<p>狭义定义：指的就是著名的数据结构和算法实现（大多数相关书籍里面内容），比如数组，队列，栈，链表，快速排序，二分查找等。</p>
<h3 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h3><p>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p>
<a id="more"></a>
<h3 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h3><p>必须掌握一个数据结构与算法中最重要的概念——复杂度分析。</p>
<p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量<code>效率</code>和<code>资源消耗</code>的方法，这就是复杂度分析方法。</p>
<p>数据结构和算法图示：</p>
<img src="/2018/12/17/geektime-algo-summary/algo-summary.jpg">
<p>对于非算法工程师来说，并不需要掌握图里面的所有知识点，要学会找重点来学习。作者总结了如下20个常用的数据结构和算法：</p>
<p>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树。<br>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法，动态规划，字符串匹配算法。</p>
<p>每种数据结构和算法的学习重点：</p>
<ul>
<li>来历</li>
<li>自身的特点</li>
<li>适合解决的问题</li>
<li>实际的应用场景</li>
</ul>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><ul>
<li>边学边练，适度刷题</li>
<li>多问，多思考，多互动</li>
<li>设立目标，贵在坚持</li>
<li>反复迭代，不断沉淀</li>
</ul>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>复杂度分析用来解决算法的执行效率和空间占用情况的，这里的空间占用，指的是内存空间的占用。</p>
<h3 id="为什么需要复杂度分析"><a href="#为什么需要复杂度分析" class="headerlink" title="为什么需要复杂度分析"></a>为什么需要复杂度分析</h3><p>通过统计和监控确实可以分析算法的执行效率和资源消耗。该方法被称为<code>事后分析法</code>，但是它有一定的局限性。</p>
<ol>
<li>测试结果非常依赖测试环境。</li>
<li>测试结果受数据规模的影响较大。</li>
</ol>
<h3 id="大O复杂度分析法"><a href="#大O复杂度分析法" class="headerlink" title="大O复杂度分析法"></a>大O复杂度分析法</h3><blockquote>
<p>T(n) = O(f(n))</p>
</blockquote>
<ul>
<li>n表示数据规模</li>
<li>T(n)表示代码执行时间</li>
<li>f(n)表示每行代码执行时间总和</li>
</ul>
<p>大<code>O</code>时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<code>代码执行时间随数据规模增长的变化趋势</code>， 所以也称为<code>渐进时间复杂度（asymptotic time complexity）</code>。</p>
<p>当数据规模<code>n</code>很大时，公式中的<code>低阶</code>、<code>常量</code>、<code>系数</code>三部分并不左右增长趋势，所以都可以忽略。</p>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol>
<li>只关注循环次数最多的代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li>
</ol>
<h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img src="/2018/12/17/geektime-algo-summary/comon_time_complex.jpg">
<h4 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h4><p><code>O(1)</code>只是常量级时间复杂度的表示，只要算法的执行时间不随着数据规模增加而增加，那么时间复杂度就是<code>O(1)</code>。</p>
<h4 id="O-m-n-和-O-m-n"><a href="#O-m-n-和-O-m-n" class="headerlink" title="O(m + n) 和 O(m * n)"></a>O(m + n) 和 O(m * n)</h4><p><code>O(m + n)</code>表示算法的时间复杂度是由2个数据规模决定的，<code>事前不能确定n和m的大小关系</code>, 所以不能简单的省略其中任何一个（加法法则失效）。但是乘法法则依然起作用。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度表示<code>算法的使用的存储空间随数据规模增长的变化趋势</code>， 所以也称为<code>渐进空间复杂度（asymptotic space complexity）</code>。</p>
<p>常见的空间复杂度有：<code>O(1)</code>, <code>O(n)</code>, <code>O(n2)</code>，像 <code>O(logN)</code>和<code>O(NlogN)</code>比较少见。</p>
<h3 id="最好，最坏时间复杂度"><a href="#最好，最坏时间复杂度" class="headerlink" title="最好，最坏时间复杂度"></a>最好，最坏时间复杂度</h3><p>最好（best case time complexity），最坏（worst case time complexity），平均（average case time complexity）时间复杂度表示算法在不同情况下的执行效率。</p>
<h3 id="平均-情况时间复杂度"><a href="#平均-情况时间复杂度" class="headerlink" title="平均 情况时间复杂度"></a>平均 情况时间复杂度</h3><p><code>加权平均值</code>也称为<code>期望值</code></p>
<p><code>平均情况时间复杂度</code> 也称为：<code>加权平均时间复杂度</code> 或 <code>期望时间复杂度</code></p>
<h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>摊还分析(平摊分析)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;系统高效地学习数据结构与算法&quot;&gt;&lt;a href=&quot;#系统高效地学习数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;系统高效地学习数据结构与算法&quot;&gt;&lt;/a&gt;系统高效地学习数据结构与算法&lt;/h2&gt;&lt;h3 id=&quot;什么是数据结构？什么是算法&quot;&gt;&lt;a href=&quot;#什么是数据结构？什么是算法&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构？什么是算法?&quot;&gt;&lt;/a&gt;什么是数据结构？什么是算法?&lt;/h3&gt;&lt;p&gt;广义定义：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。&lt;/p&gt;
&lt;p&gt;狭义定义：指的就是著名的数据结构和算法实现（大多数相关书籍里面内容），比如数组，队列，栈，链表，快速排序，二分查找等。&lt;/p&gt;
&lt;h3 id=&quot;数据结构和算法的关系&quot;&gt;&lt;a href=&quot;#数据结构和算法的关系&quot; class=&quot;headerlink&quot; title=&quot;数据结构和算法的关系&quot;&gt;&lt;/a&gt;数据结构和算法的关系&lt;/h3&gt;&lt;p&gt;数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。因此，无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://leokongwq.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mockito学习总结</title>
    <link href="https://leokongwq.github.io/2018/12/06/mockito-learn.html"/>
    <id>https://leokongwq.github.io/2018/12/06/mockito-learn.html</id>
    <published>2018-12-06T06:33:01.000Z</published>
    <updated>2018-12-06T09:10:42.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发工作中，单元测试时必不可少的一环。而在编写单元测试代码中，你肯定会遇到依赖的服务，接口和一些运行环境中的对象无法构造的情况。此时你就需要一个功能强大的mock框架，让它来帮你完成这些功能，而<a href="https://site.mockito.org/" target="_blank" rel="noopener">Mockito</a>就是Java开发环境中一个功能强大的Mock框架。类似的还有powermock, easymock等。</p>
<p>本文是对以往工作中使用到Mockito的一些功能做一次总结，方便以后翻看，并帮助需要使用Mockito的人。</p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Mockito不需要安装，根据不同的项目管理工具（maven, gradle）引入Mockito的依赖即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.10.19&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="创建Mock对象"><a href="#创建Mock对象" class="headerlink" title="创建Mock对象"></a>创建Mock对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest  mockedRequest = Mockito.mock(HttpServletRequest.class);</span><br></pre></td></tr></table></figure>
<h3 id="mock对象方法"><a href="#mock对象方法" class="headerlink" title="mock对象方法"></a>mock对象方法</h3><h4 id="mock方法方法返回值"><a href="#mock方法方法返回值" class="headerlink" title="mock方法方法返回值"></a>mock方法方法返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mockito.when(mockedRequest.getHeader(<span class="string">"X-Forwarded-For"</span>)).thenReturn(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">List mockedList = mock(List.class);</span><br><span class="line">when(mockedList.get(anyInt())).thenReturn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="mock方法异常"><a href="#mock方法异常" class="headerlink" title="mock方法异常"></a>mock方法异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">when(mockedList.get(<span class="number">0</span>)).thenReturn();</span><br><span class="line">when(mockedList.get(<span class="number">1</span>)).thenThrow(<span class="keyword">new</span> IndexOutOfBoundsException());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出:0</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//抛异常</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//输出null, 这是因为get(999)没有被mock</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure>
<h3 id="mock对象行为测试。"><a href="#mock对象行为测试。" class="headerlink" title="mock对象行为测试。"></a>mock对象行为测试。</h3><p>Mockito 会追踪 Mock 对象的所用方法调用和调用方法时所传递的参数，可以通过 <code>verify()</code>来测试mock对象行为。例如方法是否被调用，方法被调用的次数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List mockedList = mock(List.class);</span><br><span class="line">mockedList.add(<span class="string">"one"</span>);</span><br><span class="line">mockedList.add(<span class="string">"two"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line">mockedList.add(<span class="string">"three times"</span>);</span><br><span class="line"></span><br><span class="line">when(mockedList.size()).thenReturn(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(mockedList.size(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add("one") 执行被调用一次，否则会抛异常</span></span><br><span class="line">verify(mockedList, atLeastOnce()).add(<span class="string">"one"</span>);</span><br><span class="line"><span class="comment">//add("two") 被调用恰好一次，否则会抛异常</span></span><br><span class="line">verify(mockedList, times(<span class="number">1</span>)).add(<span class="string">"two"</span>);</span><br><span class="line"><span class="comment">//add("three times") 被调用恰好三次，否则会抛异常</span></span><br><span class="line">verify(mockedList, times(<span class="number">3</span>)).add(<span class="string">"three times"</span>);</span><br><span class="line"><span class="comment">//isEmpty 从来没有被调用过</span></span><br><span class="line">verify(mockedList, never()).isEmpty();</span><br></pre></td></tr></table></figure>
<h3 id="方法调用顺序测试"><a href="#方法调用顺序测试" class="headerlink" title="方法调用顺序测试"></a>方法调用顺序测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; firstMock = mock(List.class);</span><br><span class="line">List&lt;String&gt; secondMock = mock(List.class);</span><br><span class="line"></span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">firstMock.add(<span class="string">"was called first"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called second"</span>);</span><br><span class="line">secondMock.add(<span class="string">"was called third"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果mock方法的调用顺序和InOrder中verify的顺序不同，那么测试将执行失败。 */</span></span><br><span class="line"></span><br><span class="line">InOrder inOrder = inOrder(firstMock, secondMock);</span><br><span class="line"><span class="comment">//验证firstMock是否调用了2次add("was called first")，如果把2修改为3则会抛异常</span></span><br><span class="line">inOrder.verify(firstMock, times(<span class="number">2</span>)).add(<span class="string">"was called first"</span>);</span><br><span class="line"><span class="comment">//验证 secondMock是否分别调用add("was called second")，add("was called third")一次</span></span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called second"</span>);</span><br><span class="line">inOrder.verify(secondMock).add(<span class="string">"was called third"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为在secondMock.add("was called third")之后已经没有多余的方法调用了。</span></span><br><span class="line">inOrder.verifyNoMoreInteractions();<span class="comment">// 表示此方法调用后再没有多余的交互</span></span><br></pre></td></tr></table></figure>
<h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><p>Mockito使用<code>equals()</code>方法验证参数值。 当需要更加灵活的验证方式时，可以使用参数匹配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Mockito内置的 anyInt() 参数匹配器</span></span><br><span class="line"> when(mockedList.get(anyInt())).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使用自定义的参数匹配器</span></span><br><span class="line"> when(mockedList.contains(argThat(isValid()))).thenReturn(<span class="string">"element"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//输出：element</span></span><br><span class="line"> System.out.println(mockedList.get(<span class="number">999</span>));</span><br><span class="line"></span><br><span class="line"> <span class="comment">//you can also verify using an argument matcher</span></span><br><span class="line"> verify(mockedList).get(anyInt());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//argument matchers can also be written as Java 8 Lambdas</span></span><br><span class="line"> verify(mockedList).add(argThat(someString -&gt; someString.length() &gt; <span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<h3 id="自定义Answer接口"><a href="#自定义Answer接口" class="headerlink" title="自定义Answer接口"></a>自定义Answer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; mock = mock(List.class);</span><br><span class="line">when(mock.get(<span class="number">4</span>)).thenAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = invocation.getArguments();</span><br><span class="line">        Integer num = (Integer) args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"yes"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(mock.get(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="mock-void-方法"><a href="#mock-void-方法" class="headerlink" title="mock void 方法"></a>mock <code>void</code> 方法</h3><p>doReturn()|doThrow()| doAnswer()|doNothing()|doCallRealMethod()</p>
<h4 id="doThrow"><a href="#doThrow" class="headerlink" title="doThrow"></a>doThrow</h4><p>当需要mock一个返回值是void的方法，调用该方法返回异常的情况，使用doThrow</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doThrow(<span class="keyword">new</span> RuntimeException()).when(mockedList).clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//following throws RuntimeException:</span></span><br><span class="line">mockedList.clear();</span><br></pre></td></tr></table></figure>
<h4 id="doReturn"><a href="#doReturn" class="headerlink" title="doReturn"></a>doReturn</h4><p>有些特殊情况下，不能直接使用<code>when(...).thenReturn</code>，此时只能使用<code>doReturn</code>了。</p>
<h5 id="When-spying-real-objects-and-calling-real-methods-on-a-spy-brings-side-effects"><a href="#When-spying-real-objects-and-calling-real-methods-on-a-spy-brings-side-effects" class="headerlink" title="When spying real objects and calling real methods on a spy brings side effects"></a>When spying real objects and calling real methods on a spy brings side effects</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)</span></span><br><span class="line">when(spy.get(<span class="number">0</span>)).thenReturn(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">"foo"</span>).when(spy).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Overriding-a-previous-exception-stubbing"><a href="#Overriding-a-previous-exception-stubbing" class="headerlink" title="Overriding a previous exception-stubbing:"></a>Overriding a previous exception-stubbing:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">when(mock.foo()).thenThrow(<span class="keyword">new</span> RuntimeException());</span><br><span class="line"></span><br><span class="line"><span class="comment">//Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.</span></span><br><span class="line">when(mock.foo()).thenReturn(<span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//You have to use doReturn() for stubbing:</span></span><br><span class="line">doReturn(<span class="string">"bar"</span>).when(mock).foo();</span><br></pre></td></tr></table></figure>
<h5 id="doAnswer"><a href="#doAnswer" class="headerlink" title="doAnswer"></a>doAnswer</h5><p>Use doAnswer() when you want to stub a void method with generic Answer.<br>Stubbing voids requires different approach from when(Object) because the compiler does not like void methods inside brackets…</p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doAnswer(<span class="keyword">new</span> Answer() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">          Object[] args = invocation.getArguments();</span><br><span class="line">          Mock mock = invocation.getMock();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;&#125;)</span><br><span class="line">  .when(mock).someMethod();</span><br></pre></td></tr></table></figure>
<h5 id="doNothing"><a href="#doNothing" class="headerlink" title="doNothing"></a>doNothing</h5><p>Use doNothing() for setting void methods to do nothing. Beware that void methods on mocks do nothing by default! However, there are rare situations when doNothing() comes handy:</p>
<ul>
<li>Stubbing consecutive calls on a void method:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">doNothing().</span><br><span class="line">doThrow(<span class="keyword">new</span> RuntimeException())</span><br><span class="line">.when(mock).someVoidMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//does nothing the first time:</span></span><br><span class="line">mock.someVoidMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//throws RuntimeException the next time:</span></span><br><span class="line">mock.someVoidMethod();</span><br></pre></td></tr></table></figure>
<ul>
<li>When you spy real objects and you want the void method to do nothing:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//let's make clear() do nothing</span></span><br><span class="line">doNothing().when(spy).clear();</span><br><span class="line"></span><br><span class="line">spy.add(<span class="string">"one"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//clear() does nothing, so the list still contains "one"</span></span><br><span class="line">spy.clear();</span><br></pre></td></tr></table></figure>
<h5 id="doCallRealMethod"><a href="#doCallRealMethod" class="headerlink" title="doCallRealMethod"></a>doCallRealMethod</h5><p>当需要调用真是对象的方法时，使用<code>doCallRealMethod</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callRealMethodTest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    Jerry jerry = mock(Jerry.class);  </span><br><span class="line">  </span><br><span class="line">    doCallRealMethod().when(jerry).goHome();  </span><br><span class="line">    doCallRealMethod().when(jerry).doSomeThingB();  </span><br><span class="line">  </span><br><span class="line">    jerry.goHome();  </span><br><span class="line">  </span><br><span class="line">    verify(jerry).doSomeThingA();  </span><br><span class="line">    verify(jerry).doSomeThingB();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jerry</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        doSomeThingA();  </span><br><span class="line">        doSomeThingB();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// real invoke it.  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingB</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"good day"</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// auto mock method by mockito  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThingA</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"you should not see this message."</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可以看出Jerry是一个mock对象， goHome()和doSomeThingB()是使用了实际调用技术，而doSomeThingA()被mockito执行了默认的answer行为（这里是个void方法，so，什么也不干）。</p>
<h3 id="Mock-简化mock对象的创建"><a href="#Mock-简化mock对象的创建" class="headerlink" title="@Mock 简化mock对象的创建"></a>@Mock 简化mock对象的创建</h3><p>Mockito提供了注解<code>@Mock</code>来简化Mock对象的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleManagerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleCalculator calculator;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> ArticleDatabase database;</span><br><span class="line">    <span class="meta">@Mock</span> <span class="keyword">private</span> UserProvider userProvider;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ArticleManager manager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="comment">// 需要在单元测试方法前执行</span></span><br><span class="line">        MockitoAnnotations.initMocks(testClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spy真实对象"><a href="#spy真实对象" class="headerlink" title="spy真实对象"></a>spy真实对象</h3><p>可以创建真实对象的spy对象。当代用spy对象的方法时，真实对象的方法会被调用（如果被调用的方法没有被mock的话）。</p>
<p>spy对象可以被用在部分mock场景下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">List spy = spy(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以mock部分方法调用</span></span><br><span class="line">when(spy.size()).thenReturn(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//using the spy calls *real* methods</span></span><br><span class="line">spy.add(<span class="string">"one"</span>);</span><br><span class="line">spy.add(<span class="string">"two"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：one</span></span><br><span class="line">System.out.println(spy.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//size() 返回100</span></span><br><span class="line">System.out.println(spy.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//optionally, you can verify</span></span><br><span class="line">verify(spy).add(<span class="string">"one"</span>);</span><br><span class="line">verify(spy).add(<span class="string">"two"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://heipark.iteye.com/blog/1496603" target="_blank" rel="noopener">https://heipark.iteye.com/blog/1496603</a><br><a href="http://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html" target="_blank" rel="noopener">http://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发工作中，单元测试时必不可少的一环。而在编写单元测试代码中，你肯定会遇到依赖的服务，接口和一些运行环境中的对象无法构造的情况。此时你就需要一个功能强大的mock框架，让它来帮你完成这些功能，而&lt;a href=&quot;https://site.mockito.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mockito&lt;/a&gt;就是Java开发环境中一个功能强大的Mock框架。类似的还有powermock, easymock等。&lt;/p&gt;
&lt;p&gt;本文是对以往工作中使用到Mockito的一些功能做一次总结，方便以后翻看，并帮助需要使用Mockito的人。&lt;/p&gt;
    
    </summary>
    
      <category term="测试" scheme="https://leokongwq.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="mockito" scheme="https://leokongwq.github.io/tags/mockito/"/>
    
  </entry>
  
  <entry>
    <title>mysql profile 学习笔记</title>
    <link href="https://leokongwq.github.io/2018/11/24/mysql-show-profile.html"/>
    <id>https://leokongwq.github.io/2018/11/24/mysql-show-profile.html</id>
    <published>2018-11-24T04:55:54.000Z</published>
    <updated>2018-11-24T05:43:42.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql-profile-简介"><a href="#mysql-profile-简介" class="headerlink" title="mysql profile 简介"></a>mysql profile 简介</h3><p><code>show profile</code> 和 <code>show profiles</code>语句，可以用来显示SQL语句执行期间各种资源的使用信息。</p>
<blockquote>
<p>注意：<br>这些语句从版本<code>5.6.7</code>开始就不建议使用了，并且可能在下一个release版本中删除。后续可以通过<code>Performance Schema</code>来替代这些语句。具体可以参考:<a href="https://dev.mysql.com/doc/refman/5.6/en/performance-schema-query-profiling.html" target="_blank" rel="noopener">Profiling Using Performance Schema</a>。</p>
</blockquote>
<h3 id="show-profiles"><a href="#show-profiles" class="headerlink" title="show profiles"></a>show profiles</h3><p><code>show profiles</code> 展示了服务器最近收到的语句列表。 列表的大小可以通过调整<code>profiling_history_size</code>来调整，默认大小是<code>15</code>，最大值是<code>100</code>。如果设置为0，则和关闭profile功能是一样的。</p>
<p>举个例子：</p>
<a id="more"></a>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                     |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line">|        1 | 0.00020000 | <span class="keyword">SET</span> <span class="keyword">global</span> profiling = <span class="number">1</span>                                                  |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00054500</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">|        <span class="number">3</span> | <span class="number">0.00046600</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">|        <span class="number">4</span> | <span class="number">0.00063500</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">'Mary'</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">'%man'</span> |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h3><h4 id="profile-语法"><a href="#profile-语法" class="headerlink" title="profile 语法"></a>profile 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] ... ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>: &#123;</span><br><span class="line">    <span class="keyword">ALL</span></span><br><span class="line">  | <span class="keyword">BLOCK</span> IO</span><br><span class="line">  | <span class="keyword">CONTEXT</span> SWITCHES</span><br><span class="line">  | CPU</span><br><span class="line">  | IPC</span><br><span class="line">  | <span class="keyword">MEMORY</span></span><br><span class="line">  | PAGE FAULTS</span><br><span class="line">  | <span class="keyword">SOURCE</span></span><br><span class="line">  | SWAPS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>show profile</code> 可以显示一个SQL语句的详细信息。如果不带<code>for query n</code>字句，输出的结果是最近一条语句的相关信息。如果包含<code>for query n</code>字句，则<code>show profile</code>显示语句<code>n</code>的相关信息。 这里的<code>n</code>是<code>show profiles</code>数据结果里面<code>Query_ID</code>列的值。</p>
<p>默认情况下<code>show profile</code>只显示<code>Status</code>和<code>Duration</code>列。<code>Status</code>列的值和<code>SHOW PROCESSLIST</code>输出结果里面的列<code>Status</code>的值类似，但有一点小的区别，具体可以查看<a href="https://dev.mysql.com/doc/refman/5.6/en/thread-information.html" target="_blank" rel="noopener">Section 8.14, “Examining Thread Information”</a></p>
<p>可以通过指定<code>type</code>值来获取你关心的信息。</p>
<ul>
<li>ALL 展示所有信息</li>
<li>BLOCK IO 展示阻塞的输入输出操作的个数</li>
<li>CONTEXT SWITCHES 展示主动和被动的上下文切换次数。</li>
<li>CPU 展会用户和系统的CPU使用次数。</li>
<li>IPC 展示消息发送和接收的次数</li>
<li>MEMORY 暂时没有实现</li>
<li>PAGE FAULTS 展示发生缺页错误次数。</li>
<li>SOURCE 展示源代码中的函数名称，以及函数发生的文件的名称和行号</li>
<li>SWAPS 展示发生内存<code>swap</code>的次数。</li>
</ul>
<h3 id="查看并开启profile"><a href="#查看并开启profile" class="headerlink" title="查看并开启profile"></a>查看并开启profile</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| @@profiling |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|           0 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure>
<p>上面的语句执行结果展示了是否开启了profile功能。默认是关闭的。</p>
<h4 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> profiling = <span class="number">1</span>;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> profiling = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>可以通过执行一些sql语句，然后通过profile来查看这些语句的执行情况。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br><span class="line">mysql&gt; SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man';</span><br></pre></td></tr></table></figure>
<p>执行profile分析</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW PROFILE CPU FOR QUERY 7;</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line">| Status         | Duration | CPU_user | CPU_system |</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line">| starting       | 0.003667 | 0.000094 |   0.000977 |</span><br><span class="line">| query <span class="keyword">end</span>      | <span class="number">0.000015</span> | <span class="number">0.000009</span> |   <span class="number">0.000007</span> |</span><br><span class="line">| closing <span class="keyword">tables</span> | <span class="number">0.000007</span> | <span class="number">0.000004</span> |   <span class="number">0.000001</span> |</span><br><span class="line">| freeing items  | <span class="number">0.000019</span> | <span class="number">0.000009</span> |   <span class="number">0.000010</span> |</span><br><span class="line">| cleaning up    | <span class="number">0.000032</span> | <span class="number">0.000020</span> |   <span class="number">0.000013</span> |</span><br><span class="line">+<span class="comment">----------------+----------+----------+------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;mysql-profile-简介&quot;&gt;&lt;a href=&quot;#mysql-profile-简介&quot; class=&quot;headerlink&quot; title=&quot;mysql profile 简介&quot;&gt;&lt;/a&gt;mysql profile 简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;show profile&lt;/code&gt; 和 &lt;code&gt;show profiles&lt;/code&gt;语句，可以用来显示SQL语句执行期间各种资源的使用信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;br&gt;这些语句从版本&lt;code&gt;5.6.7&lt;/code&gt;开始就不建议使用了，并且可能在下一个release版本中删除。后续可以通过&lt;code&gt;Performance Schema&lt;/code&gt;来替代这些语句。具体可以参考:&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/performance-schema-query-profiling.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Profiling Using Performance Schema&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;show-profiles&quot;&gt;&lt;a href=&quot;#show-profiles&quot; class=&quot;headerlink&quot; title=&quot;show profiles&quot;&gt;&lt;/a&gt;show profiles&lt;/h3&gt;&lt;p&gt;&lt;code&gt;show profiles&lt;/code&gt; 展示了服务器最近收到的语句列表。 列表的大小可以通过调整&lt;code&gt;profiling_history_size&lt;/code&gt;来调整，默认大小是&lt;code&gt;15&lt;/code&gt;，最大值是&lt;code&gt;100&lt;/code&gt;。如果设置为0，则和关闭profile功能是一样的。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://leokongwq.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://leokongwq.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate超时引发的血案</title>
    <link href="https://leokongwq.github.io/2018/11/21/springboot-resttempate-timout.html"/>
    <id>https://leokongwq.github.io/2018/11/21/springboot-resttempate-timout.html</id>
    <published>2018-11-21T15:01:05.000Z</published>
    <updated>2018-11-21T15:48:09.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近线上出了一次故障，收银台系统所有服务全部假死。订单量瞬时下降，造成很大损失。</p>
<p>故障总结，导致问题的原因有两方面：</p>
<ol>
<li>数据库慢查询</li>
<li>RestTemplate超时时间设置不生效。</li>
<li>spring-web不同版本设置RestTemplate方式不完全一样。</li>
</ol>
<a id="more"></a>
<h3 id="默认超时设置"><a href="#默认超时设置" class="headerlink" title="默认超时设置"></a>默认超时设置</h3><p>默认情况下是没有超时设置的，此时超时依赖两方面：</p>
<ol>
<li>依赖TCP连接本身的超时时间（tcp空闲连接，超过一定时间，连接会被关闭）。</li>
<li>请求所经过的网络节点的超时时间。e.g. 中间经过nginx, nginx默认读取后端服务的超时时间是60s，所以超时时间在60s左右（日志显示稍微大一点，不会大很多）。</li>
</ol>
<h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><figure class="highlight java"><figcaption><span>例子</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    Map responseObject = restTemplate.getForObject(url, Map.class);</span><br><span class="line">    System.out.println(responseObject);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Assert.assertNotNull(e);</span><br><span class="line">    System.out.println(<span class="string">"timeout = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<p><code>RestTemplate</code> 继承自 <code>HttpAccessor</code>, 默认使用的<code>ClientHttpRequestFactory</code>是<code>SimpleClientHttpRequestFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpAccessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Logger available to subclasses.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">true<span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClientHttpRequestFactory</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CHUNK_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> Proxy proxy;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequestBody = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> chunkSize = DEFAULT_CHUNK_SIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接和读取超时都是 -1, 也就是没有超时设置。</span></span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> connectTimeout = -<span class="number">1</span>;</span><br><span class="line">true<span class="keyword">private</span> <span class="keyword">int</span> readTimeout = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们使用<code>RestTemplate</code>该如何设置超时时间呢？ </p>
<h3 id="RestTemplate超时设置"><a href="#RestTemplate超时设置" class="headerlink" title="RestTemplate超时设置"></a>RestTemplate超时设置</h3><p>由上面的代码我们了解到，超时设置其实应该通过内部的<code>ClientHttpRequestFactory</code>来设置的。</p>
<p>所以就可以通过给<code>RestTemplate</code>设置一个我们自己创建的，设置了超时时间的<code>ClientHttpRequestFactory</code>来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SimpleClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line">clientHttpRequestFactory.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">clientHttpRequestFactory.setReadTimeout(<span class="number">50</span>);</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line">clientHttpRequestFactory.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">clientHttpRequestFactory.setReadTimeout(<span class="number">50</span>);</span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setRequestFactory(clientHttpRequestFactory);</span><br></pre></td></tr></table></figure>
<p>但是要注意的是: <code>HttpComponentsClientHttpRequestFactory</code> 底层使用了apache的<code>HttpClient</code>，超时时间的设置其实是针对它进行设置的。</p>
<figure class="highlight java"><figcaption><span>HttpComponentsClientHttpRequestFactory</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL_CONNECTIONS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CONNECTIONS_PER_ROUTE = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//默认读取超时 60s</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_READ_TIMEOUT_MILLISECONDS = (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the connection timeout for the underlying HttpClient.</span></span><br><span class="line"><span class="comment"> * A timeout value of 0 specifies an infinite timeout.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the timeout value in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">trueAssert.isTrue(timeout &gt;= <span class="number">0</span>, <span class="string">"Timeout must be a non-negative value"</span>);</span><br><span class="line">truegetHttpClient().getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，如果就通过上面提到的方式设置超时时间，那么我们的应用就不用有超时问题，也不会发生故障了。</p>
<p>但问题就发生在，公司内部使用的组件，不是通过<code>HttpComponentsClientHttpRequestFactory</code>设置超时时间，而是通过设置<code>HttpComponentsClientHttpRequestFactory</code>内部的<code>HttpClient</code>设置的超时时间，并且设置了<code>HttpClient</code> 使用的 <code>HttpClientConnectionManager</code>，从而导致了问题的发生。</p>
<h3 id="问题代码-amp-测试"><a href="#问题代码-amp-测试" class="headerlink" title="问题代码&amp;测试"></a>问题代码&amp;测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRestTemplateWithRequestFactoryWithoutTimeOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpComponentsClientHttpRequestFactory requestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.设置超时时间， 设置/不设置ConnectionManager</span></span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">                .setDefaultRequestConfig(getRequestConfig())</span><br><span class="line">                .setDefaultSocketConfig(getSocketConfig())</span><br><span class="line">                .setConnectionManager(<span class="keyword">new</span> PoolingHttpClientConnectionManager(<span class="number">3</span>, TimeUnit.MINUTES))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        requestFactory.setHttpClient(httpClient);</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        restTemplate.setRequestFactory(requestFactory);</span><br><span class="line"></span><br><span class="line">        Map responseObject = restTemplate.getForObject(QUERY_USER_RENEW_URL, Map.class);</span><br><span class="line">        System.out.println(responseObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Assert.assertNotNull(e);</span><br><span class="line">        System.out.println(<span class="string">"timeout = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><h4 id="spring-web-版本-3-2-0"><a href="#spring-web-版本-3-2-0" class="headerlink" title="spring-web 版本 3.2.0"></a>spring-web 版本 3.2.0</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<h4 id="spring-web-版本-4-0-9-RELEASE"><a href="#spring-web-版本-4-0-9-RELEASE" class="headerlink" title="spring-web 版本 4.0.9.RELEASE"></a>spring-web 版本 4.0.9.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时不生效 （qiyue-store 就是这样问题）</li>
</ol>
<h4 id="spring-web-版本-4-3-0-RELEASE"><a href="#spring-web-版本-4-3-0-RELEASE" class="headerlink" title="spring-web 版本 4.3.0.RELEASE"></a>spring-web 版本 4.3.0.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<h4 id="spring-web-版本-4-3-11-RELEASE"><a href="#spring-web-版本-4-3-11-RELEASE" class="headerlink" title="spring-web 版本 4.3.11.RELEASE"></a>spring-web 版本 4.3.11.RELEASE</h4><ol>
<li>默认超时 60s, 因为nginx默认的 proxy_read_timeout 是60s</li>
<li>设置了 HttpClient的超时时间， 不设置 ConnectionManager 超时生效</li>
<li>设置了 HttpClient的超时时间， 设置 ConnectionManager 超时生效</li>
</ol>
<p>其实问题就在与不同的版本中<code>HttpComponentsClientHttpRequestFactory.createRequest</code>方法的实现逻辑不同。如何不同，自己查看。😁</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>超时设置至关重要。外部依赖接口调用可以通过Hystrix进行包装。</li>
<li>任何参数的设置都需要验证是否可以正常工作，可以加入到测试环节中，方便在不同的依赖版本中进行验证。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近线上出了一次故障，收银台系统所有服务全部假死。订单量瞬时下降，造成很大损失。&lt;/p&gt;
&lt;p&gt;故障总结，导致问题的原因有两方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据库慢查询&lt;/li&gt;
&lt;li&gt;RestTemplate超时时间设置不生效。&lt;/li&gt;
&lt;li&gt;spring-web不同版本设置RestTemplate方式不完全一样。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="RestTemplate" scheme="https://leokongwq.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>springboot 之 Servlet3 web组件</title>
    <link href="https://leokongwq.github.io/2018/11/17/springboot-servlet3-component.html"/>
    <id>https://leokongwq.github.io/2018/11/17/springboot-servlet3-component.html</id>
    <published>2018-11-17T03:32:28.000Z</published>
    <updated>2018-11-17T03:44:26.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://jcp.org/en/jsr/detail?id=315" target="_blank" rel="noopener">Servlet3.0</a> 规范新增了很多注解，例如：<code>@WebFilter</code>, <code>@WebServlet</code>, <code>@WebListener</code>, 可以帮助我们简化Web应用的开发，不在使用繁琐的xml配置。</p>
<p>但是在SpringBoot环境和支持Servlet3.0规范的容器下使用有些许的区别。</p>
<a id="more"></a>
<h3 id="springboot环境下使用Servlet3-0注解"><a href="#springboot环境下使用Servlet3-0注解" class="headerlink" title="springboot环境下使用Servlet3.0注解"></a>springboot环境下使用Servlet3.0注解</h3><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"authServlet"</span>, urlPatterns = &#123;<span class="string">"/abc"</span>&#125;, loadOnStartup=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AuthServlet init"</span>);</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resp.getOutputStream().write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : jiexiu</span></span><br><span class="line"><span class="comment"> * DateTime: 2018/3/7 下午10:32</span></span><br><span class="line"><span class="comment"> * Mail:leokongwq@gmail.com   </span></span><br><span class="line"><span class="comment"> * Description: desc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AuthFilter init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(request.getLocalName());</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Application-启动类"><a href="#Application-启动类" class="headerlink" title="Application 启动类"></a>Application 启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiexiu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(BookServiceApplication.class, args);</span><br><span class="line">true&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="@ServletComponentScan"></a>@ServletComponentScan</h3><p><code>@ServletComponentScan</code>这个注解很重要，它告诉SpringBoot从哪里加载Servlet组件。</p>
<p>如果不加该注解，则在SpringBoot内置的Servlet容器中不能正常加载注解指定的组件。</p>
<p>原因参见：<a href="https://github.com/spring-projects/spring-boot/issues/2290" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues/2290</a></p>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p><code>@ServletComponentScan</code>注解是被 <code>ServletComponentRegisteringPostProcessor</code>进行处理的。 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServletComponentRegisteringPostProcessor</span></span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;ServletComponentHandler&gt; HANDLERS;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;ServletComponentHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebServletHandler());</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebFilterHandler());</span><br><span class="line">        handlers.add(<span class="keyword">new</span> WebListenerHandler());</span><br><span class="line">        HANDLERS = Collections.unmodifiableList(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanPackage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ClassPathScanningCandidateComponentProvider componentProvider, </span></span></span><br><span class="line"><span class="function"><span class="params">      String packageToScan)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">for</span> (ServletComponentHandler handler : HANDLERS) &#123;</span><br><span class="line">            handler.handle(((ScannedGenericBeanDefinition) candidate),</span><br><span class="line">              (BeanDefinitionRegistry) <span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://jcp.org/en/jsr/detail?id=315&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Servlet3.0&lt;/a&gt; 规范新增了很多注解，例如：&lt;code&gt;@WebFilter&lt;/code&gt;, &lt;code&gt;@WebServlet&lt;/code&gt;, &lt;code&gt;@WebListener&lt;/code&gt;, 可以帮助我们简化Web应用的开发，不在使用繁琐的xml配置。&lt;/p&gt;
&lt;p&gt;但是在SpringBoot环境和支持Servlet3.0规范的容器下使用有些许的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="servlet3" scheme="https://leokongwq.github.io/tags/servlet3/"/>
    
  </entry>
  
  <entry>
    <title>springboot 之 ConfigurationProperties</title>
    <link href="https://leokongwq.github.io/2018/11/16/springboot-ConfigurationProperties.html"/>
    <id>https://leokongwq.github.io/2018/11/16/springboot-ConfigurationProperties.html</id>
    <published>2018-11-16T14:49:59.000Z</published>
    <updated>2018-11-21T15:01:26.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>ConfigurationProperties</code> 是SpringBoot引入的一个和外部配置文件相关的注解类。它可以帮助我们更好的使用外置的配置文件属性。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"prefix"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreNestedProperties</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exceptionIfInvalid</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="prefix-amp-value"><a href="#prefix-amp-value" class="headerlink" title="prefix &amp; value"></a>prefix &amp; value</h4><p>prefix 属性可以指定配置文件中配置项的前缀，如此，相同前缀的配置项就可以统一解析。</p>
<h4 id="ignoreInvalidFields"><a href="#ignoreInvalidFields" class="headerlink" title="ignoreInvalidFields"></a>ignoreInvalidFields</h4><p>是否忽略不可用的字段，默认为<code>false</code>， 当配置项不能被正确转化为Java类的字段值时，会抛出异常。</p>
<h4 id="ignoreNestedProperties"><a href="#ignoreNestedProperties" class="headerlink" title="ignoreNestedProperties"></a>ignoreNestedProperties</h4><p>是否忽略嵌套属性，默认为<code>false</code>， </p>
<h4 id="ignoreUnknownFields"><a href="#ignoreUnknownFields" class="headerlink" title="ignoreUnknownFields"></a>ignoreUnknownFields</h4><p>是否忽略Java类不存在的字段，默认值为<code>true</code>。</p>
<h4 id="exceptionIfInvalid"><a href="#exceptionIfInvalid" class="headerlink" title="exceptionIfInvalid"></a>exceptionIfInvalid</h4><p>如果Java类加了注解<code>@Validated</code>，并且校验失败了，是否抛出异常。默认<code>true</code></p>
<h3 id="属性注入到Java类"><a href="#属性注入到Java类" class="headerlink" title="属性注入到Java类"></a>属性注入到Java类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:configprops.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigProperties</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Credentials</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Length</span>(max = <span class="number">4</span>, min = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">private</span> String authMethod;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// standard getters and setters</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Min</span>(<span class="number">1025</span>)</span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">65536</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]&#123;2,6&#125;$"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line">    <span class="keyword">private</span> Credentials credentials;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; defaultRecipients;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; additionalHeaders;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// standard getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认属性配置从<code>application.properties</code>文件中获取，也可以通过<code>@PropertySource</code>指定。</p>
<p><code>@Configuration</code>注解不可缺少。</p>
<p>资源文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#Simple properties</span><br><span class="line">mail.host=mailer<span class="meta">@mail</span>.com</span><br><span class="line">mail.port=<span class="number">9000</span></span><br><span class="line">mail.from=mailer<span class="meta">@mail</span>.com</span><br><span class="line"> </span><br><span class="line">#List properties</span><br><span class="line">mail.defaultRecipients[<span class="number">0</span>]=admin<span class="meta">@mail</span>.com</span><br><span class="line">mail.defaultRecipients[<span class="number">1</span>]=owner<span class="meta">@mail</span>.com</span><br><span class="line"> </span><br><span class="line">#Map Properties</span><br><span class="line">mail.additionalHeaders.redelivery=<span class="keyword">true</span></span><br><span class="line">mail.additionalHeaders.secure=<span class="keyword">true</span></span><br><span class="line"> </span><br><span class="line">#Object properties</span><br><span class="line">mail.credentials.username=john</span><br><span class="line">mail.credentials.password=password</span><br><span class="line">mail.credentials.authMethod=SHA1</span><br></pre></td></tr></table></figure>
<h4 id="内嵌类属性"><a href="#内嵌类属性" class="headerlink" title="内嵌类属性"></a>内嵌类属性</h4><p><code>mail.credentials.username</code>可以注入到内嵌属性<code>credentials</code>中</p>
<h4 id="列表字段"><a href="#列表字段" class="headerlink" title="列表字段"></a>列表字段</h4><p><code>mail.defaultRecipients[0]</code> 可以注入到类的列表(数组页可以)属性中。</p>
<h4 id="map字段"><a href="#map字段" class="headerlink" title="map字段"></a>map字段</h4><p><code>mail.additionalHeaders.redelivery</code> 格式的配置项也可以注入到<code>Map</code>类型的属性中。</p>
<h3 id="通过-ConfigurationProperties-Bean注解在配置类的bean定义方法上"><a href="#通过-ConfigurationProperties-Bean注解在配置类的bean定义方法上" class="headerlink" title="通过@ConfigurationProperties + @Bean注解在配置类的bean定义方法上"></a>通过@ConfigurationProperties + @Bean注解在配置类的bean定义方法上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mail"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigProperties <span class="title">mailConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConfigProperties();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConfigurationProperties-EnableConfigurationProperties"><a href="#ConfigurationProperties-EnableConfigurationProperties" class="headerlink" title="@ConfigurationProperties + @EnableConfigurationProperties"></a>@ConfigurationProperties + @EnableConfigurationProperties</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ConfigProperties.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h3><p>可以给属性类上加入<code>javax.validation.constraints.*</code>中的注解，来对配置项进行校验。配合<code>exceptionIfInvalid</code>可以更早的发现问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ConfigurationProperties&lt;/code&gt; 是SpringBoot引入的一个和外部配置文件相关的注解类。它可以帮助我们更好的使用外置的配置文件属性。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink&quot; title=&quot;源码解析&quot;&gt;&lt;/a&gt;源码解析&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(&amp;#123; ElementType.TYPE, ElementType.METHOD &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; ConfigurationProperties &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;prefix&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@AliasFor&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;value&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreInvalidFields&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreNestedProperties&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ignoreUnknownFields&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Deprecated&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exceptionIfInvalid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="springboot" scheme="https://leokongwq.github.io/categories/springboot/"/>
    
    
      <category term="spring" scheme="https://leokongwq.github.io/tags/spring/"/>
    
      <category term="springboot" scheme="https://leokongwq.github.io/tags/springboot/"/>
    
      <category term="译" scheme="https://leokongwq.github.io/tags/%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>JDK8环境下使用struts2</title>
    <link href="https://leokongwq.github.io/2018/11/07/struts2-with-jdk8.html"/>
    <id>https://leokongwq.github.io/2018/11/07/struts2-with-jdk8.html</id>
    <published>2018-11-07T14:07:54.000Z</published>
    <updated>2018-11-07T15:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近将组内项目的部署环境进行了一次升级。将JDK1.7S升级为1.8，Resin替换为Tomcat。在升级替换的过程中遇到了一些问题。特记录再次，希望能帮助有同样需求的朋友。</p>
<a id="more"></a>
<h3 id="Struts2-和-JDK8"><a href="#Struts2-和-JDK8" class="headerlink" title="Struts2 和 JDK8"></a>Struts2 和 JDK8</h3><p>项目中使用的<code>Struts2</code>版本是<code>2.3.35</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Struts2里面依赖<code>xwork-core</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts.xwork<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xwork-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>xwork-core</code>依赖<code>asm-*</code></p>
<p>问题来了!</p>
<p>低版本的<code>ASM</code>不能在JDK1.8环境中使用。如果强行使用，会导致一些奇怪的问题。</p>
<p>例如：</p>
<ol>
<li>只有一部分<code>Action</code>类可以正常被Struts2加载并处理http请求。某些在JDK1.7环境下可以正常工作的<code>Action</code>不能在JDK1.8下使用。原来可以访问的接口，现在是<code>404</code>。</li>
</ol>
<p>具体问题出在：</p>
<figure class="highlight java"><figcaption><span>DefaultClassFinder</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readClassDef</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!className.endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">       className = className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       URL resource = classLoaderInterface.getResource(className);</span><br><span class="line">       <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">           InputStream in = resource.openStream();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ClassReader classReader = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">               classReader.accept(<span class="keyword">new</span> InfoBuildingVisitor(<span class="keyword">this</span>), ClassReader.SKIP_DEBUG);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               in.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> XWorkException(<span class="string">"Could not load "</span> + className);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> XWorkException(<span class="string">"Could not load "</span> + className, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码就因为使用了低版本的<code>ASM</code>导致类解析失败(<code>IndexOutOfBoundsException</code>)。</p>
<h4 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h4><p>最简单方便的解决版本就是升级Struts2的版本到<code>2.5.x</code>。新版本将<code>xwork</code>依赖直接合并到<code>struts2-core</code>中了。而且使用了<code>ASM 5.X</code>版本，支持JDK8。</p>
<h4 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h4><p>使用Struts2官方提供的一个插件。具体用法如下：</p>
<hr>
<p>在项目中加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>struts2-java8-support-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>排除ASM依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.struts.xwork<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xwork-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asm<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>asm-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Struts2-版本升级问题"><a href="#Struts2-版本升级问题" class="headerlink" title="Struts2 版本升级问题"></a>Struts2 版本升级问题</h3><h4 id="标签库不兼容"><a href="#标签库不兼容" class="headerlink" title="标签库不兼容"></a>标签库不兼容</h4><p>众所周知，Struts2框架的安全问题很多，建议升级到最新版本<code>2.5.x</code>。</p>
<p>但是2.5.x版本的Struts2提供的<strong>标签库</strong>和低版本的不兼容。这就会导致原有的<strong>JSP页面不能正常渲染</strong>。</p>
<p>当然了，如果你的项目里面没有使用Struts2替换的标签，这个问题可以忽略了。</p>
<h4 id="核心类拦截器变化"><a href="#核心类拦截器变化" class="headerlink" title="核心类拦截器变化"></a>核心类拦截器变化</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter </span></span><br><span class="line"><span class="comment">之前的核心过滤器全类名会有个ng  ,struts2.5核心过滤器没有这个</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="aspectjweaver"><a href="#aspectjweaver" class="headerlink" title="aspectjweaver"></a>aspectjweaver</h3><p>我们项目使用的版本是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>升级JDK1.8以后，需要同时升级该jar的版本到<code>1.8.13</code>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/gh670011677/article/details/75019003" target="_blank" rel="noopener">Struts2.5配置</a></p>
<p><a href="https://struts.apache.org/plugins/java-8-support/" target="_blank" rel="noopener">Java 8 Support Plugin</a></p>
<p><a href="https://cwiki.apache.org/confluence/display/WW/Struts+2.3+to+2.5+migration" target="_blank" rel="noopener">Struts+2.3+to+2.5+migration</a></p>
<p><a href="https://stackoverflow.com/questions/41307863/what-is-the-difference-between-struts-2-3-x-and-struts-2-5-x" target="_blank" rel="noopener">what-is-the-difference-between-struts-2-3-x-and-struts-2-5-x</a></p>
<p><a href="https://asm.ow2.io/versions.html" target="_blank" rel="noopener">ASM-VERSIONS</a></p>
<p><a href="https://nosec.org/home/detail/1755.html" target="_blank" rel="noopener">Struts2最新RCE漏洞S2-057</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近将组内项目的部署环境进行了一次升级。将JDK1.7S升级为1.8，Resin替换为Tomcat。在升级替换的过程中遇到了一些问题。特记录再次，希望能帮助有同样需求的朋友。&lt;/p&gt;
    
    </summary>
    
    
      <category term="struts2" scheme="https://leokongwq.github.io/tags/struts2/"/>
    
      <category term="JDK8" scheme="https://leokongwq.github.io/tags/JDK8/"/>
    
  </entry>
  
</feed>
